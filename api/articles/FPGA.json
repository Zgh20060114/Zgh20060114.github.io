{"title":"FPGA","uid":"47d8fddcd3299307e9e74bee0c7b2069","slug":"FPGA","date":"2024-04-24T03:03:09.000Z","updated":"2024-04-24T05:24:31.953Z","comments":true,"path":"api/articles/FPGA.json","keywords":null,"cover":[],"content":"<p><code>assign</code> 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在always块中）不同，后者在某种事件或条件发生时才更新值。</p>\n<p>assign temp2 &#x3D; {32{1’b0}}; 是什么意思?</p>\n<p>在Verilog中，<code>assign temp2 = &#123;32&#123;1&#39;b0&#125;&#125;;</code> 这行代码声明了一个连续赋值，将 <code>temp2</code> 这个线网的值设置为一个32位的全0值。</p>\n<p>这里的 <code>&#123;32&#123;1&#39;b0&#125;&#125;</code> 是一个重复拼接操作，含义如下：</p>\n<ul>\n<li><code>1&#39;b0</code> 是一个二进制数，表示一个位宽为1的数值，值为0。</li>\n<li><code>&#123;32&#123;1&#39;b0&#125;&#125;</code> 表示将 <code>1&#39;b0</code> 这个值重复32次。</li>\n</ul>\n<h6 id=\"Verilog-数据类型\"><a href=\"#Verilog-数据类型\" class=\"headerlink\" title=\"Verilog 数据类型\"></a>Verilog 数据类型</h6><p>Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。</p>\n<p><strong>整数（integer）</strong>   reg 型变量为无符号数，而 integer 型变量为有符号数</p>\n<p><strong>实数（real）</strong></p>\n<p>在Verilog中，<code>real</code> 和 <code>integer</code> 是数据类型关键字，分别用于声明实数类型和整数类型的变量。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">real data1;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">integer temp;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">initial begin</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    data1 = 2e3;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    data1 = 3.75;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">end</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">initial begin</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    temp = data1; //temp 值的大小为3</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">end</span></span></code></pre></div><p>这段代码包含两个 <code>initial</code> 块，它们在仿真开始时执行一次。</p>\n<p>第一个 <code>initial</code> 块中：</p>\n<ol>\n<li><code>data1</code> 被初始化为实数类型 <code>real</code>。</li>\n<li><code>data1</code> 被赋值为 <code>2e3</code>，这意味着 <code>data1</code> 现在的值是2000.0。</li>\n<li>随后，<code>data1</code> 被更新为 <code>3.75</code>。</li>\n</ol>\n<p>第二个 <code>initial</code> 块中：</p>\n<ol>\n<li><code>temp</code> 被初始化为整数类型 <code>integer</code>。</li>\n<li><code>temp</code> 被赋值为 <code>data1</code> 的值。由于 <code>data1</code> 当前是 <code>3.75</code>，这个赋值会将实数转换为整数。在Verilog中，实数赋值给整数时，会进行取整操作，保留数值的整数部分，忽略小数部分。因此，<code>temp</code> 的值将是3。</li>\n</ol>\n<p>需要注意的是，您的注释 <code>//temp 值的大小为3</code> 是正确的，因为 <code>data1</code> 的值 <code>3.75</code> 在赋值给 <code>temp</code> 时会被取整为3。</p>\n<p><strong>时间（time）</strong></p>\n<p>Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间。例如：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">time current_time;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">initial begin</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    #100;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    current_time = $time; //current_time 的大小为 100</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">end</span></span></code></pre></div><p>这段代码包含一个 <code>initial</code> 块，它在仿真开始时执行一次。</p>\n<p>在 <code>initial</code> 块中：</p>\n<ol>\n<li><code>current_time</code> 被初始化为时间类型 <code>time</code>。</li>\n<li><code>#100;</code> 是一个延迟语句，它会使仿真暂停100个时间单位。在Verilog中，<code>#</code> 后面跟一个数字表示延迟的时间量。</li>\n</ol>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>存储器</p>\n<h6 id=\"参数-参数用来表示常量，用关键字-parameter-声明，只能赋值一次\"><a href=\"#参数-参数用来表示常量，用关键字-parameter-声明，只能赋值一次\" class=\"headerlink\" title=\"参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次\"></a>参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次</h6><p><strong>parameter</strong>    data_width &#x3D; 10’d32 ;</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。</p>\n<p>字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0  来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”,  需要 14*8bit 的存储单元：</p>\n<p><strong>reg</strong> [0: 14*8-1]    str ;<br> <strong>initial</strong> <strong>begin</strong><br>   str &#x3D; “run.runoob.com”;<br> <strong>end</strong>  </p>\n<p><img src=\"/../images/IMG_20240424_115210.jpg\" alt=\"IMG_20240424_115210\"></p>\n<p><img src=\"/../images/IMG_20240424_115158.jpg\" alt=\"IMG_20240424_115158\"></p>\n<p><img src=\"/../images/IMG_20240424_115542.jpg\" alt=\"IMG_20240424_115542\"></p>\n<p><img src=\"/../images/IMG_20240424_115525.jpg\" alt=\"IMG_20240424_115525\"></p>\n<p><img src=\"/../images/IMG_20240424_115506.jpg\" alt=\"IMG_20240424_115506\"></p>\n<h2 id=\"2-4-Verilog-表达式\"><a href=\"#2-4-Verilog-表达式\" class=\"headerlink\" title=\"2.4 Verilog 表达式\"></a>2.4 Verilog 表达式</h2><p>表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。</p>\n<p> a^b ;      <em>&#x2F;&#x2F;a与b进行异或操作</em><br> address[9:0] + 10’b1 ;  <em>&#x2F;&#x2F;地址累加</em><br> flag1 &amp;&amp; flag2 ;  <em>&#x2F;&#x2F;逻辑与操作</em></p>\n<p><em>always块里赋值对象不能是wire型</em></p>\n<p>同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">//自右向左关联，两种写法等价</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">A+B-C ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">(A+B）-C ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">//自右向左关联，两种写法等价，结果为 B、D 或 F</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">A ? B : C ? D : F ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">A ? B : (C ? D : F) ;</span></span></code></pre></div><p>求幂（**）、取模（%）</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">b = 4&#39;b100x;</span></span></code></pre></div><p><code>x</code> 是一个表示未知或不可确定状态的字符。它用于在仿真中表示一个位的值是未知的，这通常发生在综合过程中，当某些逻辑路径没有被明确赋值时，或者在设计中的某些部分还没有完全定义时。</p>\n<p>无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和</p>\n<p><strong>reg</strong> [3:0]     mula ;<br> <strong>reg</strong> [1:0]     mulb;<br> <strong>reg</strong> [5:0]     res ;<br> mula &#x3D; 4’he  ;<br> mulb &#x3D; 2’h3  ;<br> res  &#x3D; mula * mulb ; <em>&#x2F;&#x2F;结果为res&#x3D;6’h2a, 数据结果没有丢失位数</em></p>\n<p>逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）</p>\n<p>按位操作符包括：取反(<del>)，与（&amp;），或（|），异或（^），同或（</del>^）</p>\n<p>按位操作符对 2 个操作数的每 1bit 数据进行按位操作,如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。</p>\n<h3 id=\"归约操作符\"><a href=\"#归约操作符\" class=\"headerlink\" title=\"归约操作符\"></a>归约操作符</h3><p>归约操作符包括：归约与（&amp;），归约与非（<del>&amp;），归约或（|），归约或非（</del>|），归约异或（^），归约同或（~^）。</p>\n<p>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</p>\n<p>逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">A = 4&#39;b1010 ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&amp;A ;      //结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#39;b0，可用来判断变量A是否全1</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1&#39;b0, 可用来判断变量A是否为全0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1&#39;b0</span></span></code></pre></div><h3 id=\"移位操作符\"><a href=\"#移位操作符\" class=\"headerlink\" title=\"移位操作符\"></a>移位操作符</h3><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p>\n<p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p>\n<p>算术左移和逻辑左移时，右边低位会补 0。</p>\n<p>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>A &#x3D; 4’b1100 ;<br> B &#x3D; 4’b0010 ;<br> A &#x3D; A &gt;&gt; 2 ;     <em>&#x2F;&#x2F;结果为 4’b0011</em><br> A &#x3D; A &lt;&lt; 1;     *&#x2F;&#x2F;结果为 4’b1000*<br> A &#x3D; A &lt;&lt;&lt; 1 ;    *&#x2F;&#x2F;结果为 4’b1000*<br> C &#x3D; B + (A&gt;&gt;&gt;2);   <em>&#x2F;&#x2F;结果为 2 + (-4&#x2F;4) &#x3D; 1, 4’b0001</em></p>\n<h3 id=\"define-undef\"><a href=\"#define-undef\" class=\"headerlink\" title=\"define, undef\"></a><code>define, </code>undef</h3><p>在编译阶段，&#96;define 用于文本替换，类似于 C 语言中的 <strong>#define</strong>。</p>\n<p>&#96;undef 用来取消之前的宏定义</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">`ifdef       MCU51</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    parameter DATA_DW = 8   ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`elsif       WINDOW</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    parameter DATA_DW = 64  ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`else</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    parameter DATA_DW = 32  ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`endif</span></span></code></pre></div><h3 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"&#96;include\"></a>&#96;include</h3><p>使用 &#96;include 可以在编译时将一个 Verilog 文件内嵌到另一个 Verilog 文件中，作用类似于 C 语言中的 #include 结构。</p>\n","feature":true,"text":"assign 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在alw...","permalink":"/post/FPGA","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Verilog-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">Verilog 数据类型</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0-%E5%8F%82%E6%95%B0%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%B8%B8%E9%87%8F%EF%BC%8C%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97-parameter-%E5%A3%B0%E6%98%8E%EF%BC%8C%E5%8F%AA%E8%83%BD%E8%B5%8B%E5%80%BC%E4%B8%80%E6%AC%A1\"><span class=\"toc-text\">参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">字符串</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-Verilog-%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">2.4 Verilog 表达式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%92%E7%BA%A6%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">归约操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">移位操作符</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">实例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#define-undef\"><span class=\"toc-text\">define, undef</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#include\"><span class=\"toc-text\">&#96;include</span></a>","author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Android_Kotlin","uid":"6df1dc6e24cc645f9148dbaf83a17c60","slug":"Android-Kotlin","date":"2024-04-21T12:52:23.000Z","updated":"2024-04-23T15:13:27.293Z","comments":true,"path":"api/articles/Android-Kotlin.json","keywords":null,"cover":[],"text":"txt`class FirstActivity : AppCompatActivity() &#123;` `override fun onCreate(sav...","permalink":"/post/Android-Kotlin","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}