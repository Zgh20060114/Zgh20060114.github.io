{"title":"FPGA","uid":"47d8fddcd3299307e9e74bee0c7b2069","slug":"FPGA","date":"2024-04-24T03:03:09.000Z","updated":"2024-04-26T07:37:34.734Z","comments":true,"path":"api/articles/FPGA.json","keywords":null,"cover":[],"content":"<p><code>assign</code> 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在always块中）不同，后者在某种事件或条件发生时才更新值。</p>\n<p>assign temp2 &#x3D; {32{1’b0}}; 是什么意思?</p>\n<p>在Verilog中，<code>assign temp2 = &#123;32&#123;1&#39;b0&#125;&#125;;</code> 这行代码声明了一个连续赋值，将 <code>temp2</code> 这个线网的值设置为一个32位的全0值。</p>\n<p>这里的 <code>&#123;32&#123;1&#39;b0&#125;&#125;</code> 是一个重复拼接操作，含义如下：</p>\n<ul>\n<li><code>1&#39;b0</code> 是一个二进制数，表示一个位宽为1的数值，值为0。</li>\n<li><code>&#123;32&#123;1&#39;b0&#125;&#125;</code> 表示将 <code>1&#39;b0</code> 这个值重复32次。</li>\n</ul>\n<h6 id=\"Verilog-数据类型\"><a href=\"#Verilog-数据类型\" class=\"headerlink\" title=\"Verilog 数据类型\"></a>Verilog 数据类型</h6><p>Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。</p>\n<p><strong>整数（integer）</strong>   reg 型变量为无符号数，而 integer 型变量为有符号数</p>\n<p><strong>实数（real）</strong></p>\n<p>在Verilog中，<code>real</code> 和 <code>integer</code> 是数据类型关键字，分别用于声明实数类型和整数类型的变量。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">real data1;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">integer temp;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">initial begin</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    data1 = 2e3;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    data1 = 3.75;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">end</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">initial begin</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    temp = data1; //temp 值的大小为3</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">end</span></span></code></pre></div><p>这段代码包含两个 <code>initial</code> 块，它们在仿真开始时执行一次。</p>\n<p>第一个 <code>initial</code> 块中：</p>\n<ol>\n<li><code>data1</code> 被初始化为实数类型 <code>real</code>。</li>\n<li><code>data1</code> 被赋值为 <code>2e3</code>，这意味着 <code>data1</code> 现在的值是2000.0。</li>\n<li>随后，<code>data1</code> 被更新为 <code>3.75</code>。</li>\n</ol>\n<p>第二个 <code>initial</code> 块中：</p>\n<ol>\n<li><code>temp</code> 被初始化为整数类型 <code>integer</code>。</li>\n<li><code>temp</code> 被赋值为 <code>data1</code> 的值。由于 <code>data1</code> 当前是 <code>3.75</code>，这个赋值会将实数转换为整数。在Verilog中，实数赋值给整数时，会进行取整操作，保留数值的整数部分，忽略小数部分。因此，<code>temp</code> 的值将是3。</li>\n</ol>\n<p>需要注意的是，您的注释 <code>//temp 值的大小为3</code> 是正确的，因为 <code>data1</code> 的值 <code>3.75</code> 在赋值给 <code>temp</code> 时会被取整为3。</p>\n<p><strong>时间（time）</strong></p>\n<p>Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间。例如：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">time current_time;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">initial begin</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    #100;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    current_time = $time; //current_time 的大小为 100</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">end</span></span></code></pre></div><p>这段代码包含一个 <code>initial</code> 块，它在仿真开始时执行一次。</p>\n<p>在 <code>initial</code> 块中：</p>\n<ol>\n<li><code>current_time</code> 被初始化为时间类型 <code>time</code>。</li>\n<li><code>#100;</code> 是一个延迟语句，它会使仿真暂停100个时间单位。在Verilog中，<code>#</code> 后面跟一个数字表示延迟的时间量。</li>\n</ol>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>存储器</p>\n<h6 id=\"参数-参数用来表示常量，用关键字-parameter-声明，只能赋值一次\"><a href=\"#参数-参数用来表示常量，用关键字-parameter-声明，只能赋值一次\" class=\"headerlink\" title=\"参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次\"></a>参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次</h6><p><strong>parameter</strong>    data_width &#x3D; 10’d32 ;</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。</p>\n<p>字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0  来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”,  需要 14*8bit 的存储单元：</p>\n<p><strong>reg</strong> [0: 14*8-1]    str ;<br> <strong>initial</strong> <strong>begin</strong><br>   str &#x3D; “run.runoob.com”;<br> <strong>end</strong>  </p>\n<p><img src=\"/../images/IMG_20240424_115210.jpg\" alt=\"IMG_20240424_115210\"></p>\n<p><img src=\"/../images/IMG_20240424_115158.jpg\" alt=\"IMG_20240424_115158\"></p>\n<p><img src=\"/../images/IMG_20240424_115542.jpg\" alt=\"IMG_20240424_115542\"></p>\n<p><img src=\"/../images/IMG_20240424_115525.jpg\" alt=\"IMG_20240424_115525\"></p>\n<p><img src=\"/../images/IMG_20240424_115506.jpg\" alt=\"IMG_20240424_115506\"></p>\n<h2 id=\"2-4-Verilog-表达式\"><a href=\"#2-4-Verilog-表达式\" class=\"headerlink\" title=\"2.4 Verilog 表达式\"></a>2.4 Verilog 表达式</h2><p>表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。</p>\n<p> a^b ;      <em>&#x2F;&#x2F;a与b进行异或操作</em><br> address[9:0] + 10’b1 ;  <em>&#x2F;&#x2F;地址累加</em><br> flag1 &amp;&amp; flag2 ;  <em>&#x2F;&#x2F;逻辑与操作</em></p>\n<p><em>always块里赋值对象不能是wire型</em></p>\n<p>同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">//自右向左关联，两种写法等价</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">A+B-C ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">(A+B）-C ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">//自右向左关联，两种写法等价，结果为 B、D 或 F</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">A ? B : C ? D : F ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">A ? B : (C ? D : F) ;</span></span></code></pre></div><p>求幂（**）、取模（%）</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">b = 4&#39;b100x;</span></span></code></pre></div><p><code>x</code> 是一个表示未知或不可确定状态的字符。它用于在仿真中表示一个位的值是未知的，这通常发生在综合过程中，当某些逻辑路径没有被明确赋值时，或者在设计中的某些部分还没有完全定义时。</p>\n<p>无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和</p>\n<p><strong>reg</strong> [3:0]     mula ;<br> <strong>reg</strong> [1:0]     mulb;<br> <strong>reg</strong> [5:0]     res ;<br> mula &#x3D; 4’he  ;<br> mulb &#x3D; 2’h3  ;<br> res  &#x3D; mula * mulb ; <em>&#x2F;&#x2F;结果为res&#x3D;6’h2a, 数据结果没有丢失位数</em></p>\n<p>逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）</p>\n<p>按位操作符包括：取反(<del>)，与（&amp;），或（|），异或（^），同或（</del>^）</p>\n<p>按位操作符对 2 个操作数的每 1bit 数据进行按位操作,如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。</p>\n<h3 id=\"归约操作符\"><a href=\"#归约操作符\" class=\"headerlink\" title=\"归约操作符\"></a>归约操作符</h3><p>归约操作符包括：归约与（&amp;），归约与非（<del>&amp;），归约或（|），归约或非（</del>|），归约异或（^），归约同或（~^）。</p>\n<p>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</p>\n<p>逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">A = 4&#39;b1010 ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&amp;A ;      //结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#39;b0，可用来判断变量A是否全1</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1&#39;b0, 可用来判断变量A是否为全0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1&#39;b0</span></span></code></pre></div><h3 id=\"移位操作符\"><a href=\"#移位操作符\" class=\"headerlink\" title=\"移位操作符\"></a>移位操作符</h3><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p>\n<p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p>\n<p>算术左移和逻辑左移时，右边低位会补 0。</p>\n<p>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>A &#x3D; 4’b1100 ;<br> B &#x3D; 4’b0010 ;<br> A &#x3D; A &gt;&gt; 2 ;     <em>&#x2F;&#x2F;结果为 4’b0011</em><br> A &#x3D; A &lt;&lt; 1;     *&#x2F;&#x2F;结果为 4’b1000*<br> A &#x3D; A &lt;&lt;&lt; 1 ;    *&#x2F;&#x2F;结果为 4’b1000*<br> C &#x3D; B + (A&gt;&gt;&gt;2);   <em>&#x2F;&#x2F;结果为 2 + (-4&#x2F;4) &#x3D; 1, 4’b0001</em></p>\n<h3 id=\"define-undef\"><a href=\"#define-undef\" class=\"headerlink\" title=\"define, undef\"></a><code>define, </code>undef</h3><p>在编译阶段，&#96;define 用于文本替换，类似于 C 语言中的 <strong>#define</strong>。</p>\n<p>&#96;undef 用来取消之前的宏定义</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">`ifdef       MCU51</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    parameter DATA_DW = 8   ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`elsif       WINDOW</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    parameter DATA_DW = 64  ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`else</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    parameter DATA_DW = 32  ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`endif</span></span></code></pre></div><h3 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"&#96;include\"></a>&#96;include</h3><p>使用 &#96;include 可以在编译时将一个 Verilog 文件内嵌到另一个 Verilog 文件中，作用类似于 C 语言中的 #include 结构。</p>\n<h3 id=\"timescale\"><a href=\"#timescale\" class=\"headerlink\" title=\"timescale\"></a>timescale</h3><p>在 Verilog 模型中，时延有具体的单位时间表述，并用 &#96;timescale 编译指令将时间单位与实际时间相关联。</p>\n<p>该指令用于定义时延、仿真的单位和精度，格式为：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">`timescale      time_unit / time_precision</span></span></code></pre></div><p>time_unit 表示时间单位，time_precision 表示时间精度，它们均是由数字以及单位  s（秒），ms（毫秒），us（微妙），ns（纳秒），ps（皮秒）和  fs（飞秒）组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小，例如下面例子中，输出端 Z 会延迟 5.21ns 输出  A&amp;B 的结果。</p>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p><code>timescale 1ns/100ps   *//时间单位为1ns，精度为100ps，合法*  *//</code>timescale 100ps&#x2F;1ns  &#x2F;&#x2F;不合法*<br> <strong>module</strong> AndFunc(Z, A, B);<br>   <strong>output</strong> Z;<br>   <strong>input</strong> A, B ;<br>   <strong>assign</strong> #5.207 Z &#x3D; A &amp; B<br> <strong>endmodule</strong></p>\n<p>在编译过程中，<code>timescale 指令会影响后面所有模块中的时延值，直至遇到另一个 </code>timescale 指令或 &#96;resetall 指令。 </p>\n<p>由于在 Verilog 中没有默认的 <code>timescale，如果没有指定 </code>timescale，Verilog 模块就有会继承前面编译模块的 &#96;timescale 参数。有可能导致设计出错。</p>\n<p>如果一个设计中的多个模块都带有 &#96;timescale 时，模拟器总是定位在所有模块的最小时延精度上，并且所有时延都相应地换算为最小时延精度</p>\n<h3 id=\"default-nettype\"><a href=\"#default-nettype\" class=\"headerlink\" title=\"&#96;default_nettype\"></a>&#96;default_nettype</h3><p>该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">`default_nettype wand </span></span></code></pre></div><p>该实例定义的缺省的线网为线与类型。因此，如果在此指令后面的任何模块中的连线没有说明，那么该线网被假定为线与类型。  </p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">`default_nettype none</span></span></code></pre></div><p>该实例定义后，将不再自动产生 wire 型变量。</p>\n<h3 id=\"celldefine-endcelldefine\"><a href=\"#celldefine-endcelldefine\" class=\"headerlink\" title=\"celldefine, endcelldefine\"></a><code>celldefine, </code>endcelldefine</h3><p>这两个程序指令用于将模块标记为单元模块，他们包含模块的定义。例如一些与、或、非门，一些 PLL 单元，PAD 模型，以及一些 Analog IP 等。</p>\n<h2 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p><code>celldefine  **module** (    **input**    clk,    **input**    rst,    **output**   clk_pll,    **output**   flag);      ……  **endmodule**  </code>endcelldefine</p>\n<h3 id=\"unconnected-drive-nounconnected-drive\"><a href=\"#unconnected-drive-nounconnected-drive\" class=\"headerlink\" title=\"unconnected_drive, nounconnected_drive\"></a><code>unconnected_drive, </code>nounconnected_drive</h3><p>在模块实例化中，出现在这两个编译指令间的任何未连接的输入端口，为正偏电路状态或者为反偏电路状态。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">assign</span></span></code></pre></div><p>用于对 wire 型变量进行赋值,不对寄存器赋值</p>\n<p>进位输出（Carry  out，通常表示为Co或Cout）是全加器的一个输出，它表示在两个二进制位相加时是否产生了进位。在二进制加法中，当两个加数位（A和B）的和大于或等于2时，就会产生进位，因为二进制中的每一位只能表示0或1。进位输出就是用来表示这个进位的。</p>\n<p><strong>module</strong> full_adder1(<br>   <strong>input</strong>   Ai, Bi, Ci,<br>   <strong>output</strong>  So, Co);</p>\n<p>   <strong>assign</strong> So &#x3D; Ai ^ Bi ^ Ci ;<br>   <strong>assign</strong> Co &#x3D; (Ai &amp; Bi) | (Ci &amp; (Ai | Bi));<br> <strong>endmodule</strong></p>\n<p>更简单的：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">module full_adder1(</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    input Ai, Bi, Ci,</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    output So, Co);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    </span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    assign &#123;Co, So&#125; = Ai + Bi + Ci;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">endmodule</span></span></code></pre></div><p><em>&#x2F;&#x2F;普通时延，A&amp;B计算结果延时10个时间单位赋值给Z</em><br> <strong>wire</strong> Z, A, B ;<br> <strong>assign</strong> #10   Z &#x3D; A &amp; B ;</p>\n<p> <em>&#x2F;&#x2F;隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。</em><br> <strong>wire</strong> A, B;<br> <strong>wire</strong> #10     Z &#x3D; A &amp; B;</p>\n<p> <em>&#x2F;&#x2F;声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。</em><br> <strong>wire</strong> A, B;<br> <strong>wire</strong> #10 Z ;<br> <strong>assign</strong>      Z &#x3D;A &amp; B</p>\n<h2 id=\"Verilog-过程结构\"><a href=\"#Verilog-过程结构\" class=\"headerlink\" title=\"Verilog 过程结构\"></a>Verilog 过程结构</h2><p>过程结构语句有 2 种，initial 与 always 语句</p>\n<p>一个模块中可以包含多个 initial 和 always 语句，但 2 种语句不能嵌套使用。</p>\n<p>但是 initial 语句或 always 语句内部可以理解为是顺序执行的（非阻塞赋值除外）。</p>\n<h3 id=\"initial语句\"><a href=\"#initial语句\" class=\"headerlink\" title=\"initial语句\"></a>initial语句</h3><p>initial 语句从 0 时刻开始执行，只执行一次，多个 initial 块之间是相互独立的。</p>\n<p>如果 initial 块内包含多个语句，需要使用关键字 begin 和 end 组成一个块语句。</p>\n<p>如果 initial 块内只要一条语句，关键字 begin 和 end 可使用也可不使用。</p>\n<p>initial 理论上来讲是不可综合的，多用于初始化、信号检测等。</p>\n<h4 id=\"这些语句在模块间并行执行，与其在模块的前后顺序没有关系\"><a href=\"#这些语句在模块间并行执行，与其在模块的前后顺序没有关系\" class=\"headerlink\" title=\"这些语句在模块间并行执行，与其在模块的前后顺序没有关系\"></a>这些语句在模块间并行执行，与其在模块的前后顺序没有关系</h4><h3 id=\"always-语句\"><a href=\"#always-语句\" class=\"headerlink\" title=\"always 语句\"></a>always 语句</h3><p>与 initial 语句相反，always 语句是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。</p>\n<p>由于循环执行的特点，always 语句多用于仿真时钟的产生，信号行为的检测等。   </p>\n<h6 id=\"parameter-关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。\"><a href=\"#parameter-关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。\" class=\"headerlink\" title=\"parameter 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。\"></a><code>parameter</code> 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。</h6><p>连续性赋值使用assign语句，而过程性赋值使用always块。</p>\n<p>阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。</p>\n<p>阻塞赋值语句使用等号 &#x3D; 作为赋值符。</p>\n<p>非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。</p>\n<p>非阻塞赋值语句使用小于等于号 &lt;&#x3D; 作为赋值符。</p>\n<p>如下所示，2 个 always 块中语句并行执行，赋值操作右端操作数使用的是上一个时钟周期的旧值，此时 a&lt;&#x3D;b 与 b&lt;&#x3D;a 就可以相互不干扰的执行，达到交换寄存器值的目的。</p>\n<h2 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p><strong>always</strong> @(<strong>posedge</strong> clk) <strong>begin</strong><br>   a &lt;&#x3D; b ;<br> <strong>end</strong></p>\n<p> <strong>always</strong> @(<strong>posedge</strong> clk) <strong>begin</strong><br>   b &lt;&#x3D; a;<br> <strong>end</strong></p>\n<h2 id=\"Verilog-时序控制\"><a href=\"#Verilog-时序控制\" class=\"headerlink\" title=\"Verilog 时序控制\"></a>Verilog 时序控制</h2><p>Verilog 提供了 2 大类时序控制方法：时延控制和事件控制。事件控制主要分为边沿触发事件控制与电平敏感事件控制</p>\n<h3 id=\"时延控制-根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。\"><a href=\"#时延控制-根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。\" class=\"headerlink\" title=\"时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。\"></a>时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。</h3><p><strong>常规时延</strong></p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">reg  value_test ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">reg  value_general ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#10  value_general    = value_test ;</span></span></code></pre></div><p>或：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">#10 ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">value_ single         = value_test ;</span></span></code></pre></div><p><strong>内嵌时延</strong></p>\n<p>遇到内嵌延时时，该语句先将计算结果保存，然后等待一定的时间后赋值给目标信号。</p>\n<p>内嵌时延控制加在赋值号之后。例如：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">reg  value_test ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">reg  value_embed ;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">value_embed        = #10 value_test ;</span></span></code></pre></div><p>需要说明的是，这 2 种时延控制方式的效果是有所不同的。</p>\n<p>当延时语句的赋值符号右端是常量时，2 种时延控制都能达到相同的延时赋值效果。</p>\n<p>当延时语句的赋值符号右端是变量时，2 种时延控制可能会产生不同的延时赋值效果。</p>\n<h3 id=\"边沿触发事件控制\"><a href=\"#边沿触发事件控制\" class=\"headerlink\" title=\"边沿触发事件控制\"></a>边沿触发事件控制</h3><p>在 Verilog 中，事件是指某一个 reg 或 wire 型变量发生了值的变化。事件控制用符号 @ 表示。</p>\n<p><strong>设计</strong>：根据需求编写硬件描述语言（如Verilog或VHDL）代码来描述设计的功能和行为</p>\n<p>synthesize综合，合成：综合代码，检查语法是否有错误,将高级的逻辑描述代码转换为逻辑门级别的网表或等效的门级电路</p>\n<p>FloorPlanner 是 FPGA 设计流程中的一个重要工具，用于执行布局（Place）阶段的子任务，即对设计中的逻辑电路进行布局安置。在 FPGA 设计流程中，FloorPlanner 的地位如下：</p>\n<ol>\n<li><strong>布局规划</strong>：FloorPlanner 负责规划 FPGA 芯片上各个逻辑模块的布局位置，以最大程度地满足设计的性能和资源利用率要求。它会考虑逻辑模块之间的布线延迟、信号传输路径长度等因素，以优化整体的布局结构。</li>\n<li><strong>资源分配</strong>：FloorPlanner 还负责将设计中的逻辑模块分配到 FPGA 芯片的不同区域，并且合理利用芯片上的资源（如片上存储器、DSP模块等），以满足设计对资源的需求。</li>\n<li><strong>时序约束</strong>：在布局过程中，FloorPlanner 还会考虑时序约束，确保设计中的时序要求能够得到满足。它会尽可能减少逻辑模块之间的传输延迟，以确保时序性能。</li>\n<li><strong>优化布局</strong>：FloorPlanner 通过对设计进行优化布局，以降低布线延迟、减少时序问题和功耗等方面的优化。这可以提高设计的性能、可靠性和功耗效率。</li>\n</ol>\n<p>在 FPGA 设计流程中，FloorPlanner 位于布局（Place）阶段之前，它为后续的布线（Route）阶段提供了优化的布局结果，从而帮助实现设计的最终映射和部署。</p>\n<p><strong>Place&amp;Route</strong> ：</p>\n<p>开发流程中的 Place &amp; Route 是指在将设计映射到 FPGA 芯片时的一个重要步骤。下面解释一下它的含义和作用：</p>\n<ol>\n<li><strong>Place（放置）</strong>：Place 指的是将设计中的逻辑元素（如逻辑门、寄存器等）放置到 FPGA 芯片的物理位置上。这一步骤考虑了芯片内部的布局和连接资源，以尽可能地优化性能和资源利用率。放置的目标是最小化延迟、最大化时序性能，并且尽量减少芯片内的布线冲突。</li>\n<li><strong>Route（布线）</strong>：Route 是指将设计中的逻辑元素之间的连接关系转化为芯片内部的实际物理连线。这一步骤考虑了芯片内部的连线资源、信号传输延迟等因素，以确保逻辑元素之间的连接能够有效地建立并满足时序要求。布线的目标是尽可能地降低信号传输延迟、最小化信号干扰，同时满足设计的时序约束。</li>\n</ol>\n","feature":true,"text":"assign 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在alw...","permalink":"/post/FPGA","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Verilog-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">Verilog 数据类型</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0-%E5%8F%82%E6%95%B0%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%B8%B8%E9%87%8F%EF%BC%8C%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97-parameter-%E5%A3%B0%E6%98%8E%EF%BC%8C%E5%8F%AA%E8%83%BD%E8%B5%8B%E5%80%BC%E4%B8%80%E6%AC%A1\"><span class=\"toc-text\">参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">字符串</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-Verilog-%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">2.4 Verilog 表达式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%92%E7%BA%A6%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">归约操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">移位操作符</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">实例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#define-undef\"><span class=\"toc-text\">define, undef</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#include\"><span class=\"toc-text\">&#96;include</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#timescale\"><span class=\"toc-text\">timescale</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B-1\"><span class=\"toc-text\">实例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#default-nettype\"><span class=\"toc-text\">&#96;default_nettype</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#celldefine-endcelldefine\"><span class=\"toc-text\">celldefine, endcelldefine</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B-2\"><span class=\"toc-text\">实例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#unconnected-drive-nounconnected-drive\"><span class=\"toc-text\">unconnected_drive, nounconnected_drive</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Verilog-%E8%BF%87%E7%A8%8B%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Verilog 过程结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#initial%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">initial语句</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%BA%9B%E8%AF%AD%E5%8F%A5%E5%9C%A8%E6%A8%A1%E5%9D%97%E9%97%B4%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%B8%8E%E5%85%B6%E5%9C%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%89%8D%E5%90%8E%E9%A1%BA%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">这些语句在模块间并行执行，与其在模块的前后顺序没有关系</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#always-%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">always 语句</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#parameter-%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8F%82%E6%95%B0%E3%80%82%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E7%A7%8D%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%A8%A1%E5%9D%97%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%97%B6%E6%88%96%E5%9C%A8%E6%A8%A1%E5%9D%97%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%BD%86%E4%B8%8D%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9C%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E6%89%80%E6%9C%89%E5%A4%8D%E5%88%B6%E4%B8%AD%E4%BC%A0%E9%80%92%E7%9A%84%E5%B8%B8%E6%95%B0%E3%80%82%E7%AE%80%E5%8D%95%E5%9C%B0%E8%AF%B4%EF%BC%8C%E5%8F%82%E6%95%B0%E7%B1%BB%E4%BC%BC%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%96%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%9C%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%A4%8D%E5%88%B6%E5%93%81%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E3%80%82\"><span class=\"toc-text\">parameter 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B-3\"><span class=\"toc-text\">实例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Verilog-%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">Verilog 时序控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E5%BB%B6%E6%8E%A7%E5%88%B6-%E6%A0%B9%E6%8D%AE%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%B7%AE%E5%BC%82%EF%BC%8C%E6%97%B6%E5%BB%B6%E6%8E%A7%E5%88%B6%E5%8F%88%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%B8%B8%E8%A7%84%E6%97%B6%E5%BB%B6%E4%B8%8E%E5%86%85%E5%B5%8C%E6%97%B6%E5%BB%B6%E3%80%82\"><span class=\"toc-text\">时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">边沿触发事件控制</span></a>","author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Algo","uid":"0104a54ef3539ccc47aaaaa3ebb61ff8","slug":"Algo","date":"2024-04-26T01:35:42.000Z","updated":"2024-04-27T02:17:30.993Z","comments":true,"path":"api/articles/Algo.json","keywords":null,"cover":[],"text":"由于实际测试具有较大的局限性，因此我们考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity anal...","permalink":"/post/Algo","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Android_Kotlin","uid":"6df1dc6e24cc645f9148dbaf83a17c60","slug":"Android-Kotlin","date":"2024-04-21T12:52:23.000Z","updated":"2024-04-25T03:59:07.066Z","comments":true,"path":"api/articles/Android-Kotlin.json","keywords":null,"cover":[],"text":"txt`class FirstActivity : AppCompatActivity() &#123;` `override fun onCreate(sav...","permalink":"/post/Android-Kotlin","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}