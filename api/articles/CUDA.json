{"title":"CUDA","uid":"c694f2b397246a2cd639ff2c5b2c692a","slug":"CUDA","date":"2024-05-14T04:45:58.000Z","updated":"2024-05-24T08:30:33.715Z","comments":true,"path":"api/articles/CUDA.json","keywords":null,"cover":[],"content":"<p><img src=\"/../images/image-20240514124728144.png\" alt=\"image-20240514124728144\"></p>\n<p>PCIe传输速率比较慢</p>\n<p><img src=\"/../images/image-20240514125248067.png\" alt=\"image-20240514125248067\"></p>\n<p><img src=\"/../images/image-20240514134619194.png\" alt=\"image-20240514134619194\"></p>\n<p><img src=\"/../images/image-20240514163840122.png\" alt=\"image-20240514163840122\"></p>\n<p><img src=\"/../images/image-20240514164819180.png\" alt=\"image-20240514164819180\"></p>\n<p>CPU启动核函数之后，由这个核函数在GPU设备里产生的所有的线程构成了一个grid(网格)</p>\n<p>而一个grid又由多个线程块（block）组成，一个线程块里包含一组线程（thread）</p>\n<p>进行CUDA编程时，要做的就是减少计算核心空闲的时间，让计算核心一直处于计算中</p>\n<p>CPU，GPU在进行内存相互访问的时候，会很耗时</p>\n<p><img src=\"/../images/image-20240514170821304.png\" alt=\"image-20240514170821304\"></p>\n<p><img src=\"/../images/image-20240514200242464.png\" alt=\"image-20240514200242464\"></p>\n<p><img src=\"/../images/image-20240514200453776.png\" alt=\"image-20240514200453776\"></p>\n<p>一维：</p>\n<p><img src=\"/../images/image-20240514215215578.png\" alt=\"image-20240514215215578\"></p>\n<p><img src=\"/../images/image-20240514214149999.png\" alt=\"image-20240514214149999\"></p>\n<p>二维：</p>\n<p><img src=\"/../images/image-20240514214513695.png\" alt=\"image-20240514214513695\"></p>\n<p>三维：<br><img src=\"/../images/image-20240515094438706.png\" alt=\"image-20240515094438706\"></p>\n<p><img src=\"/../images/image-20240515094525884.png\" alt=\"image-20240515094525884\"></p>\n<p><img src=\"/../images/image-20240515095616319.png\" alt=\"image-20240515095616319\"></p>\n<p>-arch和-code 都与GPU的兼容性有关，在指定计算能力的时候，GPU的真实架构计算能力一定要大于虚拟架构计算能力的</p>\n<p><img src=\"/../images/image-20240515100052890.png\" alt=\"image-20240515100052890\"></p>\n<p><img src=\"/../images/image-20240515100901251.png\" alt=\"image-20240515100901251\"></p>\n<p><img src=\"/../images/image-20240515101949472.png\" alt=\"image-20240515101949472\"></p>\n<p><img src=\"/../images/image-20240515102254655.png\" alt=\"image-20240515102254655\"></p>\n<p><img src=\"/../images/image-20240515104802323.png\" alt=\"image-20240515104802323\"></p>\n<p>即时编译，增加兼容性：</p>\n<p><img src=\"/../images/image-20240515104350368.png\" alt=\"image-20240515104350368\"></p>\n<p>两个都是compute_XY(虚拟)</p>\n<p><img src=\"/../images/image-20240518093831448.png\" alt=\"image-20240518093831448\"></p>\n<p><img src=\"/../images/image-20240518094156107.png\" alt=\"image-20240518094156107\"></p>\n<p>在C++中，<code>exit(-1)</code> 和 <code>return -1</code> 都可以用来表示程序的异常退出或者返回一个错误码，但它们之间有一些重要的区别：</p>\n<ol>\n<li><code>exit(-1)</code> 是一个系统调用，它会立即终止整个程序的执行，并返回一个指定的退出码给操作系统。这会终止程序的执行并进行清理工作（如关闭文件、释放内存等），然后返回退出码。<code>exit</code> 函数是C标准库中的函数，定义在 <code>&lt;cstdlib&gt;</code> 头文件中。</li>\n<li><code>return -1</code> 通常出现在函数中，用于从当前函数中返回一个指定的值。当函数的返回类型是整型时，<code>return -1</code> 将会将 -1 这个值返回给调用该函数的地方。如果 <code>-1</code> 是 <code>main</code> 函数的返回值，那么它会被返回给操作系统作为程序的退出码。</li>\n</ol>\n<p>因此，<code>exit(-1)</code> 会立即终止整个程序的执行，而 <code>return -1</code> 只是从当前函数中返回一个值。</p>\n<p><img src=\"/../images/image-20240518101534052.png\" alt=\"image-20240518101534052\"></p>\n<p><img src=\"/../images/image-20240518102522434.png\" alt=\"image-20240518102522434\">双指针</p>\n<p><img src=\"/../images/image-20240518102902454.png\" alt=\"image-20240518102902454\"></p>\n<p><img src=\"/../images/image-20240518103123516.png\" alt=\"image-20240518103123516\"></p>\n<p><img src=\"/../images/image-20240518103306357.png\" alt=\"image-20240518103306357\"></p>\n<p><code>cudaDeviceReset()</code>函数用于重置当前设备上的所有状态信息。它会清除当前设备上的所有内存分配和设备端的运行时状态，释放所有CUDA资源，并将设备状态恢复到初始化时的状态。这个函数通常在程序结束前被调用，以确保释放所有CUDA资源并将GPU状态还原到初始状态。</p>\n<p>调用<code>cudaDeviceReset()</code>函数可以帮助确保程序结束时释放了所有CUDA资源，从而避免内存泄漏和其他问题。</p>\n<p>在CUDA中，核函数（kernel function）和设备函数（device function）是两个不同的概念。</p>\n<ol>\n<li>核函数（Kernel Function）：<ul>\n<li>核函数是在GPU上执行的并行函数，由关键字<code>__global__</code>声明。它们可以被从CPU代码调用，并在GPU上并行执行。在CUDA中，核函数通常用于执行大规模数据并行计算。</li>\n</ul>\n</li>\n<li>设备函数（Device Function）：<ul>\n<li>设备函数是在GPU上执行的函数，但它们只能被其他设备函数调用，不能从CPU代码中直接调用。设备函数通常用于封装重复使用的代码逻辑，以便在核函数中进行调用，以提高代码复用性和可读性。</li>\n</ul>\n</li>\n</ol>\n<p>虽然它们都是在GPU上执行的函数，但核函数和设备函数在调用方式、用途和作用域上有明显的区别。核函数是CUDA程序中由CPU代码调用的入口点，而设备函数是为了在核函数内部使用而设计的。</p>\n<p><img src=\"/../images/image-20240518143353274.png\" alt=\"image-20240518143353274\"></p>\n<p><img src=\"/../images/image-20240518145238232.png\" alt=\"image-20240518145238232\"></p>\n<p><img src=\"/../images/image-20240518145441046.png\" alt=\"image-20240518145441046\"></p>\n<p><code>__FILE__</code> 和 <code>__LINE__</code> 是C&#x2F;C++中的预定义宏，它们分别代表当前源文件的文件名和行号</p>\n<p><img src=\"/../images/image-20240518152527144.png\" alt=\"image-20240518152527144\"></p>\n<p><img src=\"/../images/image-20240524144504885.png\" alt=\"image-20240524144504885\"></p>\n<p><code>%g</code> 是 C++ 语言中的格式化输出控制符之一，用于打印浮点数。它根据浮点数的值自动选择 <code>%f</code> 或 <code>%e</code> 中较短的一个输出形式来打印。</p>\n<p>具体来说：</p>\n<ul>\n<li>如果浮点数的绝对值小于 0.0001 或者大于等于 10^6，<code>%g</code> 就会采用 <code>%e</code> 的输出形式，用科学计数法表示浮点数。</li>\n<li>否则，<code>%g</code> 会采用 <code>%f</code> 的输出形式，用普通的小数形式表示浮点数。</li>\n</ul>\n<p>在 CUDA 编程中，<code>cudaEventQuery(start)</code> 表示查询事件 <code>start</code> 的状态。具体来说，它用于检查事件是否已经被记录。如果事件已经被记录，那么 <code>cudaEventQuery</code> 将立即返回。如果事件还没有被记录，那么 <code>cudaEventQuery</code> 将等待事件被记录后才返回。</p>\n<p>在上述代码中，<code>cudaEventQuery(start)</code> 的目的可能是为了确保在记录 <code>stop</code> 事件之前，<code>start</code> 事件已经被成功记录。这样可以确保测量的时间间隔准确，避免了 <code>start</code> 事件尚未记录就立即记录 <code>stop</code> 事件的情况。</p>\n<p><img src=\"/../images/image-20240524163028697.png\" alt=\"image-20240524163028697\"></p>\n","text":" PCIe传输速率比较慢 CPU启动核函数之后，由这个核函数在GPU设备里产生的所有的线程构成了一个grid(网格) 而一个grid又由多个线程块（block）...","permalink":"/post/CUDA","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"OpenGL","uid":"e9d18bf8d4206e6bf0f6f84c71e6472c","slug":"OpenGL","date":"2024-05-17T08:51:10.000Z","updated":"2024-06-08T12:27:38.535Z","comments":true,"path":"api/articles/OpenGL.json","keywords":null,"cover":[],"text":" https://www.cnblogs.com/jiujiubashiyi/p/16429717.html GLFW,GLAD,opengl是什么，有什么联系...","permalink":"/post/OpenGL","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Algo","uid":"0104a54ef3539ccc47aaaaa3ebb61ff8","slug":"Algo","date":"2024-04-26T01:35:42.000Z","updated":"2024-05-06T03:33:16.236Z","comments":true,"path":"api/articles/Algo.json","keywords":null,"cover":[],"text":"由于实际测试具有较大的局限性，因此我们考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity anal...","permalink":"/post/Algo","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}