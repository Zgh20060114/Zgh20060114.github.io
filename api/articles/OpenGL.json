{"title":"OpenGL","uid":"e9d18bf8d4206e6bf0f6f84c71e6472c","slug":"OpenGL","date":"2024-05-17T08:51:10.000Z","updated":"2024-06-11T08:24:07.469Z","comments":true,"path":"api/articles/OpenGL.json","keywords":null,"cover":[],"content":"<p><img src=\"/../images/image-20240517165248939.png\" alt=\"image-20240517165248939\"></p>\n<p><img src=\"/../images/image-20240517165400128.png\" alt=\"image-20240517165400128\"></p>\n<p><a href=\"https://www.cnblogs.com/jiujiubashiyi/p/16429717.html\">https://www.cnblogs.com/jiujiubashiyi/p/16429717.html</a></p>\n<p>GLFW,GLAD,opengl是什么，有什么联系</p>\n<p>GLFW、GLAD和OpenGL是计算机图形学中常用的三个库，它们之间存在着紧密的联系：</p>\n<ol>\n<li><strong>OpenGL</strong>：是一个跨语言、跨平台的编程接口，用于渲染2D、3D向量图形。它是由硅谷图形公司（Silicon Graphics,  SGI）在1992年开发的。OpenGL是图形硬件制造商的标准，也是创作高质量计算机图形的基本工具。OpenGL提供了一个非常灵活的编程接口，让开发者能够利用它来渲染图形。</li>\n<li><strong>GLFW</strong>：是一个跨平台的OpenGL应用程序接口（API）的多线程窗口和输入管理器。简单来说，GLFW用来创建窗口、处理输入事件（如键盘、鼠标点击等），并管理OpenGL上下文。它使得开发者可以比较容易地创建一个OpenGL环境，因为它简化了OpenGL程序中许多繁琐的设置步骤。</li>\n<li><strong>GLAD</strong>：是一个自动生成OpenGL函数指针的库。在OpenGL中，许多操作需要通过指针来调用函数，而在不同的操作系统和硬件平台上，这些函数指针的位置可能会有所不同。GLAD就是用来处理这些函数指针的，它会根据当前的平台和OpenGL的版本自动生成对应的函数指针。这为开发者减少了处理这些底层细节的麻烦。</li>\n</ol>\n<p><strong>它们之间的联系</strong>：</p>\n<ul>\n<li>使用OpenGL之前，需要创建一个OpenGL环境，这个环境包括一个窗口以及一个上下文，这是通过GLFW来完成的。</li>\n<li>GLAD用来确保所有的OpenGL函数调用都能够正确地指向相应的函数，这样开发者就不需要手动查找和设置这些函数指针了。</li>\n<li>通常，一个OpenGL程序的设置流程是这样的：首先初始化GLFW，然后使用GLFW创建一个窗口和OpenGL上下文，接着使用GLAD自动加载OpenGL函数，最后就可以开始使用OpenGL进行绘图了。</li>\n</ul>\n<p>综上，GLFW和GLAD都是帮助开发者更简单、更有效地使用OpenGL的辅助工具。通过它们，开发者可以专注于图形内容的创作，而不必担心底层的细节问题。</p>\n<p>glfwMakeContextCurrent(window);是什么意思</p>\n<p><code>glfwMakeContextCurrent(window);</code> 是一行来自 GLFW（OpenGL Framework）库的代码。GLFW 是一个跨平台的库，用于窗口和输入处理，它使得创建 OpenGL 应用程序变得更加容易。</p>\n<p>这句代码的作用是将 OpenGL 渲染上下文关联到由 <code>window</code> 参数指定的窗口。在 OpenGL 中，渲染上下文是用来进行图形绘制的环境，它定义了一系列可以用来配置和控制渲染行为的设置。</p>\n<p>在创建窗口之后，必须调用 <code>glfwMakeContextCurrent</code> 函数来指定哪个窗口的上下文将被当前的线程使用。只有当前上下文中的 OpenGL 调用才会对指定的窗口产生影响。如果没有激活任何上下文，任何 OpenGL 调用都会导致错误。</p>\n<p>简单来说，当你想要在特定的窗口上绘制图形时，你需要确保该窗口的 OpenGL 上下文被设置为当前上下文。这就是 <code>glfwMakeContextCurrent(window);</code> 这行代码的目的。</p>\n<p>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress) 是什么意思</p>\n<p><code>gladLoadGLLoader</code> 是一个函数，通常在 C 或 C++ 程序中使用，用于初始化 OpenGL 函数指针。OpenGL 是一个用于渲染2D和3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。<code>gladLoadGLLoader</code> 函数是 GLAD 库的一部分，GLAD 是一个小型且易于使用的库，它负责在每次调用 OpenGL 函数之前，动态地加载和绑定正确的 OpenGL 函数指针。</p>\n<p><code>glfwGetProcAddress</code> 是另一个函数，属于 GLFW 库（一个用于创建窗口、输入处理等的前端库，常与OpenGL一起使用）。<code>glfwGetProcAddress</code> 的作用是获取指向特定OpenGL函数的指针，该函数在OpenGL核心或者扩展中定义。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)</span></span></code></pre></div><p>这表示在初始化GLAD库时，它将使用GLFW库提供的函数指针来加载OpenGL函数。这允许应用程序使用OpenGL函数，而不需要关心底层的具体实现细节。</p>\n<p>这种机制的好处是，应用程序只需要链接到一个库（比如GLFW），而GLFW会负责查找和加载正确的OpenGL函数。这样做可以简化应用程序的编写和维护工作，同时也确保了应用程序可以轻松地与不同平台的OpenGL版本兼容。</p>\n<p><strong>双缓冲(Double Buffer)</strong></p>\n<p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p>\n<ul>\n<li>顶点数组对象：Vertex Array Object，VAO</li>\n<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>\n<li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li>\n</ul>\n<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素.3D坐标转为2D坐标的处理过程是由OpenGL的<strong>图形渲染管线</strong>（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。(图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出)</p>\n<p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做<strong>着色器</strong>(Shader)。</p>\n<p><strong>OpenGL着色器</strong>是用OpenGL着色器语言(OpenGL Shading Language, <strong>GLSL</strong>)写成的</p>\n<p><img src=\"/../images/pipeline.png\" alt=\"img\"></p>\n<p>为了让OpenGL知道我们的<strong>坐标和颜色值</strong>构成的到底是什么，OpenGL需要你去指定这些数据所表示的<strong>渲染类型</strong>。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做**图元(Primitive)**，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</p>\n<p><strong>图形渲染管线的第一个部分</strong>—-<strong>顶点着色器</strong></p>\n<p>把3D坐标转为另一种3D坐标</p>\n<p><strong>几何着色器</strong></p>\n<p>一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状</p>\n<p><strong>图元装配</strong></p>\n<p>将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状</p>\n<p><strong>光栅化阶段</strong></p>\n<p>把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的**片段(Fragment)**。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>\n<p>OpenGL中的一个<strong>片段</strong>是OpenGL渲染一个像素所需的所有数据</p>\n<p><strong>片段着色器</strong></p>\n<p>片段着色器的主要目的是计算一个像素的最终颜色</p>\n<p><strong>Alpha测试和混合(Blending)阶段</strong></p>\n<p>这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同</p>\n<p><code>GL_ARRAY_BUFFER</code>目标用于表示顶点属性数据的缓冲区对象</p>\n<p>在OpenGL中，VAO（Vertex Array Object）和VBO（Vertex Buffer Object）是用于管理顶点数据的重要概念，并且它们之间存在一定的关系。</p>\n<ol>\n<li>VAO（Vertex Array Object）：<ul>\n<li>VAO是OpenGL中用于存储顶点属性状态的对象。它包含了多个指向VBO的指针，用于指定顶点属性数据的格式、排列方式等。</li>\n<li>VAO可以看作是对VBO的管理器，它记录了OpenGL如何解释顶点数据，包括顶点的位置、颜色、法线等信息。通过绑定VAO，可以轻松地切换顶点属性的设置，从而简化渲染流程。</li>\n</ul>\n</li>\n<li>VBO（Vertex Buffer Object）：<ul>\n<li>VBO是用于存储顶点数据的缓冲区对象。它可以存储顶点的位置、颜色、纹理坐标等信息。</li>\n<li>通过将顶点数据存储在VBO中，可以有效地管理和传输大量的顶点数据，而不必反复传输到GPU。</li>\n</ul>\n</li>\n</ol>\n<p>关系：</p>\n<ul>\n<li>VBO存储了实际的顶点数据，例如顶点的位置、颜色、纹理坐标等。</li>\n<li>VAO描述了顶点数据的格式和布局，它指明了如何从VBO中读取顶点数据以供渲染使用。</li>\n<li>通常情况下，我们先创建和绑定VAO，然后配置相应的VBO，并将VBO与VAO关联。这样，在渲染时只需绑定相应的VAO即可，OpenGL就会根据VAO中的配置自动获取正确的顶点数据进行渲染。</li>\n</ul>\n<p>总结来说，VAO用于管理顶点属性状态，而VBO用于存储实际的顶点数据。它们共同协作，使得在OpenGL中管理和使用顶点数据变得更加灵活和高效。</p>\n<p>我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）</p>\n<p>着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p>\n<p>Uniform是另一种从我们的应用程序在 CPU 上传递数据到 GPU 上的着色器的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>\n<p>在OpenGL中，VBO（Vertex Buffer Object）和VAO（Vertex Array Object）都是用于管理顶点数据的对象。它们之间的联系和区别如下：</p>\n<p>联系：</p>\n<ul>\n<li>VBO和VAO都是用于管理顶点属性数据的对象。</li>\n<li>它们都可以通过OpenGL API进行创建、绑定、更新和删除等操作。</li>\n<li>VAO可以保存多个VBO的绑定状态，使得我们在绘制时只需绑定VAO即可同时启用多个顶点属性数组。</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>VBO是用于存储和管理顶点数据的缓冲对象，包括顶点位置、法线、颜色、纹理坐标等属性数据。它能够提高渲染效率，因为可以将这些数据上传到显卡内存中，而不需要每次绘制时都从系统内存中获取。</li>\n<li>VAO是用于管理VBO的绑定状态的对象，它记录了VBO的绑定状态以及每个属性在VBO中的偏移量、类型等信息。VAO可以看作是一组VBO的绑定描述符，它规定了如何从VBO中获取顶点属性数据。</li>\n</ul>\n<p>总体来说，VBO和VAO在OpenGL中都扮演着非常重要的角色，它们都可以提高渲染效率，使得开发者可以更加方便地管理和操作顶点属性数据。其中，VBO主要用于存储和管理顶点数据，而VAO则是用于在绘制时快速激活和绑定多个顶点属性数组。</p>\n<p>把两个角度都发送</p>\n<p>试一下发后两个数据，看看是不是数据的问题</p>\n<p>试试发5个</p>\n<p><img src=\"/../images/image-20240603155209855.png\" alt=\"image-20240603155209855\">2024.6.3.15.52Matlab报错，遂改，无用！！！！</p>\n<p>艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节.这样就可以让物体非常精细而不用指定额外的顶点</p>\n<p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p>\n<p>使用 Xlib 来获取窗口大小需要一些底层的操作，但可以通过以下步骤来实现：</p>\n<p>首先，你需要安装 <code>python-xlib</code> 库。你可以使用以下命令在 Ubuntu 上安装：</p>\n<div class=\"language-bash\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">bash</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FFCB6B\">sudo</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">apt-get</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">install</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">python-xlib</span></span></code></pre></div><p>然后，你可以使用下面的代码来获取当前活动窗口的大小：</p>\n<div class=\"language-python\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">python</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #89DDFF; font-style: italic\">from</span><span style=\"color: #BABED8\"> Xlib </span><span style=\"color: #89DDFF; font-style: italic\">import</span><span style=\"color: #BABED8\"> display</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">def</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">get_screen_size</span><span style=\"color: #89DDFF\">():</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    disp </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> display</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">Display</span><span style=\"color: #89DDFF\">()</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    screen </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> disp</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">screen</span><span style=\"color: #89DDFF\">()</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    root_win </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> screen</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #F07178\">root</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    windowID </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> root_win</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">get_full_property</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #82AAFF\">disp</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">intern_atom</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">_NET_ACTIVE_WINDOW</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #89DDFF\">),</span><span style=\"color: #82AAFF\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">).</span><span style=\"color: #F07178\">value</span><span style=\"color: #89DDFF\">[</span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">]</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    window </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> disp</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">create_resource_object</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">window</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #82AAFF\"> windowID</span><span style=\"color: #89DDFF\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    geometry </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> window</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">get_geometry</span><span style=\"color: #89DDFF\">()</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #89DDFF; font-style: italic\">return</span><span style=\"color: #BABED8\"> geometry</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #F07178\">width</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> geometry</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #F07178\">height</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">width</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> height </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">get_screen_size</span><span style=\"color: #89DDFF\">()</span></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">print</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">Window size: </span><span style=\"color: #F78C6C\">&#123;&#125;</span><span style=\"color: #C3E88D\"> x </span><span style=\"color: #F78C6C\">&#123;&#125;</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">format</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #82AAFF\">width</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #82AAFF\"> height</span><span style=\"color: #89DDFF\">))</span></span></code></pre></div><p>这段代码中，我们首先创建了一个 <code>Display</code> 对象，然后获取了当前活动窗口的 ID。接着，我们使用这个窗口 ID 创建了一个 <code>window</code> 对象，并通过这个对象的 <code>get_geometry</code> 方法获取了窗口的宽度和高度。</p>\n<p>请注意，使用 Xlib 需要对 X 窗口系统有一定的了解，因为它是一个底层的库，直接和 X 服务器进行交互。希望这个示例能够帮助你开始使用 Xlib 来获取窗口大小。</p>\n<ul>\n<li><code>layout(location=0)</code>: 这是一个着色器布局限定符（layout qualifier），用于指定顶点属性在输入阶段的位置。在这里，<code>location=0</code> 表示顶点属性的位置索引为 0。这个位置索引将与顶点数组对象（VAO）中的对应属性绑定，以确保正确地将顶点数据传递给顶点着色器。</li>\n<li><code>in</code>: 这是一个输入变量修饰符，用于指示这个变量是从外部传递给顶点着色器的。</li>\n<li><code>vec3</code>: 这是指定变量类型的关键字，表示这个变量是一个三维向量。</li>\n<li><code>in_position</code>: 这是变量的名称，用于在顶点着色器中引用这个输入变量。在这里，<code>in_position</code> 可能表示顶点的位置信息。</li>\n</ul>\n<p>在OpenGL中，<code>gl_Position</code>是一个内置的变量，用于表示顶点着色器（Vertex Shader）输出的顶点位置。它是一个四维向量（<code>vec4</code>），表示顶点的齐次坐标（Homogeneous Coordinates），通常用于表示三维空间中的点。齐次坐标是四维的，其中前三个分量表示点的位置，而第四个分量通常被用于表示点的类型或者进行透视除法（Perspective Division）。在顶点着色器中，对 <code>gl_Position</code> 的设置将影响后续的图元装配（Primitive Assembly）和光栅化（Rasterization）阶段，最终确定绘制的像素位置。因此，正确设置 <code>gl_Position</code> 是绘制正确图形的关键。</p>\n<p>[[ 0.5  0.5  0.   0.   1.   0. ]<br> [-0.5  0.5  0.   1.   0.   0. ]<br> [-0.5 -0.5  0.   0.   0.   1. ]<br> [ 0.5  0.5  0.   0.   1.   0. ]<br> [-0.5 -0.5  0.   0.   0.   1. ]<br> [ 0.5 -0.5  0.   1.   0.   0. ]]</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">layout(location=0) in vec3 in_position;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">layout(location=1) in vec3 in_color;</span></span></code></pre></div><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">self.vbo_format = &#39;3f 3f&#39;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">self.attrs = (&#39;in_position&#39;, &#39;in_color&#39;)</span></span></code></pre></div><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">vertex_data = np.hstack([vertices_array, colors_array])</span></span></code></pre></div><h2 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h2><p><img src=\"/../images/image-20240608192337289.png\" alt=\"image-20240608192337289\"></p>\n<h2 id=\"位移\"><a href=\"#位移\" class=\"headerlink\" title=\"位移\"></a>位移</h2><p><img src=\"/../images/image-20240608192358635.png\" alt=\"image-20240608192358635\"></p>\n<p>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p>\n<ul>\n<li>弧度转角度：<code>角度 = 弧度 * (180.0f / PI)</code></li>\n<li>角度转弧度：<code>弧度 = 角度 * (PI / 180.0f)</code></li>\n</ul>\n<p><img src=\"/../images/image-20240608192525938.png\" alt=\"image-20240608192525938\"></p>\n<p>我这一辈子，抠抠搜搜的花了很多钱，精精明明的上了很多当。骂骂咧咧的干了很多活，小心翼翼的闯了很多祸。精打细算的欠了一屁股帐。认认真真的范了很多错。掏心掏肺的结了很多仇。不明不白的吃了很多亏。窝窝囊囊的活了几十年。</p>\n<ol>\n<li><code>glm::mat4 trans;</code>：首先声明了一个4x4的矩阵trans，用于表示变换矩阵。</li>\n<li><code>trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));</code>：这一行代码对trans进行了旋转变换。使用了glm库中的rotate函数，将trans矩阵绕Z轴旋转90度（使用radians函数将角度转换为弧度），并将结果赋值给trans本身。</li>\n<li><code>trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));</code>：接着对trans进行了缩放变换。使用了glm库中的scale函数，将trans矩阵沿着X、Y、Z三个轴分别缩放0.5倍，并将结果再次赋值给trans本身。</li>\n</ol>\n<ul>\n<li>局部空间(Local Space，或者称为物体空间(Object Space))</li>\n<li>世界空间(World Space)</li>\n<li>观察空间(View Space，或者称为视觉空间(Eye Space))</li>\n<li>裁剪空间(Clip Space)</li>\n<li>屏幕空间(Screen Space)</li>\n</ul>\n<p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕</p>\n<p>坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p>\n<p><img src=\"/../images/coordinate_systems.png\" alt=\"coordinate_systems\"></p>\n<ol>\n<li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li>\n<li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li>\n<li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>\n<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li>\n<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li>\n</ol>\n<p>你可能已经大致了解了每个坐标空间的作用。我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。</p>\n<h2 id=\"局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间-摄像机空间-———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间\"><a href=\"#局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间-摄像机空间-———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间\" class=\"headerlink\" title=\"局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间\"></a>局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间</h2><p><img src=\"/../images/image-20240609164419389.png\" alt=\"image-20240609164419389\"></p>\n<p><img src=\"/../images/image-20240609164929887.png\" alt=\"image-20240609164929887\"></p>\n<p><img src=\"/../images/image-20240609165058873.png\" alt=\"image-20240609165058873\"></p>\n<p><img src=\"/../images/image-20240609211854570.png\" alt=\"image-20240609211854570\"></p>\n<p><img src=\"/../images/image-20240609212927721.png\" alt=\"image-20240609212927721\"></p>\n<p><img src=\"/../images/image-20240609213514370.png\" alt=\"image-20240609213514370\"></p>\n<p>glm::LookAt函数需要一个位置、目标和上向量。它会创建一个观察矩阵。</p>\n<p>为了改变摄像机方向</p>\n<p><img src=\"/../images/image-20240609221012736.png\" alt=\"image-20240609221012736\"></p>\n<p><code>self.m_projection=glm.perspective(V_FOV,ASPECT_RATIO,NEARPLANE,FARPLANE)</code></p>\n<p>使用 GLM 库中的 <code>glm::perspective()</code> 函数创建了一个投影矩阵（projection matrix）.会根据给定的参数创建一个透视投影矩阵，并返回这个矩阵。这个投影矩阵描述了从摄像机位置观察场景时的投影效果，将三维场景转换为二维屏幕空间</p>\n<p><img src=\"/../images/image-20240610000155256.png\" alt=\"image-20240610000155256\"></p>\n<p>对连续时间正弦信号考虑下面表示式：<br>x ( t ) &#x3D; s i n ( 2 π f 0 t + φ )<br>可以按抽样频率 fs&#x3D;1&#x2F;Ts对 x(t)抽样来获得离散时间信号<br>x [ n ] &#x3D; x ( t )|t &#x3D;nTs       &#x3D;  x ( t ) |t&#x3D;n &#x2F; fs &#x3D; s i n ( 2 πf0 &#x2F;fsn + φ ),<br>f0 &#x3D;500Hz， fs 取 100Hz， 绘出 x[n]及其 DTFT</p>\n<p><img src=\"/../images/image-20240611133720092.png\" alt=\"image-20240611133720092\"></p>\n<p><img src=\"/../images/image-20240611133805550.png\" alt=\"image-20240611133805550\"></p>\n<p><img src=\"/../images/image-20240611133838091.png\" alt=\"image-20240611133838091\"></p>\n<p><img src=\"/../images/image-20240611140046801.png\" alt=\"image-20240611140046801\"></p>\n<p>以 5000HZ 和 1000HZ 分别对其采样得到 x1(n)， x2(n)；画出它们的 DTFT 并比较</p>\n<p><img src=\"/../images/image-20240611140651535.png\" alt=\"image-20240611140651535\"></p>\n<p><img src=\"/../images/image-20240611141635271.png\" alt=\"image-20240611141635271\"></p>\n<p>我们可以从第一个方程中直接得到 A 和 φ 的关系：</p>\n<p><img src=\"/../images/image-20240611141659727.png\" alt=\"image-20240611141659727\"></p>\n<p>φ ！&#x3D;π&#x2F;2+kπ</p>\n<p>x(t)&#x3D;2cos(π&#x2F;3 *t)</p>\n<p><img src=\"/../images/image-20240611143342649.png\" alt=\"image-20240611143342649\"></p>\n<p><img src=\"/../images/image-20240611143614094.png\" alt=\"image-20240611143614094\"></p>\n<p><img src=\"/../images/image-20240611144943071.png\" alt=\"image-20240611144943071\"></p>\n<p><img src=\"/../images/image-20240611145404898.png\" alt=\"image-20240611145404898\"></p>\n<p>现实中无法实现理想低通滤波器。然而，可以按下面的方法计算由理想低通滤波器产生的<br>波形：理想低通运算相当于信号频谱与频域的矩形函数相乘，这对应于信号与通过傅里叶逆变<br>换得到的时域 sinc 函数的卷积。当其应用于点样本时，卷积和为 sinc 函数内插：</p>\n<p>xa(t)&#x3D;sum_{n&#x3D;-无穷}^{正无穷} [xa(nt) sin(π(t-nTs)&#x2F;Ts)&#x2F;(π(t-nTs)&#x2F;Ts)]</p>\n<p>(3.18)<br>其中，样本 xa(nt)取自 t&#x3D; nTs处。<br>a. 假设只有有限数量的信号样本是非零值，且只需在有限时间区间上进行信号重建，写出<br>基于(3.18)式的 sinc 内插表示式。</p>\n<p><code>syms t n Ts xa;</code></p>\n<p><code>xa_t = symsum(xa * sin(pi*(t-n*Ts)/Ts)/(pi*(t-n*Ts)/Ts), n, -inf, inf);</code></p>\n<p><img src=\"/../images/image-20240611153315884.png\" alt=\"image-20240611153315884\"></p>\n<p>C：<br><img src=\"/../images/image-20240611155005492.png\" alt=\"image-20240611155005492\"></p>\n<p>根据奈奎斯特采样定理，要求 fs≥2fbfs≥2fb 以避免混叠现象。因此，fb&lt;fs2fb&lt;2fs 是满足采样定理的条件。</p>\n","text":" https://www.cnblogs.com/jiujiubashiyi/p/16429717.html GLFW,GLAD,opengl是什么，有什么联系...","permalink":"/post/OpenGL","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%A9%E6%94%BE\"><span class=\"toc-text\">缩放</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E7%A7%BB\"><span class=\"toc-text\">位移</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94%E2%80%93%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5%E2%80%94%E2%80%94%E2%80%93%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E7%9F%A9%E9%98%B5%E2%80%94%E2%80%94%E2%80%94-%E8%A7%82%E5%AF%9F%E7%A9%BA%E9%97%B4-%E6%91%84%E5%83%8F%E6%9C%BA%E7%A9%BA%E9%97%B4-%E2%80%94%E2%80%94%E2%80%94%E2%80%93%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%93%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%93%E8%A7%86%E5%8F%A3%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间</span></a></li></ol>","author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"openmv","uid":"da768801085088419c591cc57d0a037c","slug":"openmv","date":"2024-05-20T06:46:47.000Z","updated":"2024-05-20T06:50:47.998Z","comments":true,"path":"api/articles/openmv.json","keywords":null,"cover":[],"text":" 安装库libxcb-cursor.so.0， bashsudo apt install libxcb-cursor0","permalink":"/post/openmv","photos":[],"count_time":{"symbolsCount":60,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CUDA","uid":"c694f2b397246a2cd639ff2c5b2c692a","slug":"CUDA","date":"2024-05-14T04:45:58.000Z","updated":"2024-05-24T08:30:33.715Z","comments":true,"path":"api/articles/CUDA.json","keywords":null,"cover":[],"text":" PCIe传输速率比较慢 CPU启动核函数之后，由这个核函数在GPU设备里产生的所有的线程构成了一个grid(网格) 而一个grid又由多个线程块（block）...","permalink":"/post/CUDA","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}