{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"RayTracing","date":"2024-06-05T05:31:11.885Z","updated":"2024-06-06T12:10:06.311Z","comments":true,"path":"api/articles/RayTracing.json","keywords":null,"cover":[],"content":"<p>Contents</p>\n<p><a href=\"#overview\">1 Overview</a><br><a href=\"#outputanimage\">2 Output an Image</a><br> <a href=\"#outputanimage/theppmimageformat\">2.1 The PPM Image Format</a><br> <a href=\"#outputanimage/creatinganimagefile\">2.2 Creating an Image File</a><br> <a href=\"#outputanimage/addingaprogressindicator\">2.3 Adding a Progress Indicator</a><br><a href=\"#thevec3class\">3 The vec3 Class</a><br> <a href=\"#thevec3class/colorutilityfunctions\">3.1 Color Utility Functions</a><br><a href=\"#rays,asimplecamera,andbackground\">4 Rays, a Simple Camera, and Background</a><br> <a href=\"#rays,asimplecamera,andbackground/therayclass\">4.1 The ray Class</a><br> <a href=\"#rays,asimplecamera,andbackground/sendingraysintothescene\">4.2 Sending Rays Into the Scene</a><br><a href=\"#addingasphere\">5 Adding a Sphere</a><br> <a href=\"#addingasphere/ray-sphereintersection\">5.1 Ray-Sphere Intersection</a><br> <a href=\"#addingasphere/creatingourfirstraytracedimage\">5.2 Creating Our First Raytraced Image</a><br><a href=\"#surfacenormalsandmultipleobjects\">6 Surface Normals and Multiple Objects</a><br> <a href=\"#surfacenormalsandmultipleobjects/shadingwithsurfacenormals\">6.1 Shading with Surface Normals</a><br> <a href=\"#surfacenormalsandmultipleobjects/simplifyingtheray-sphereintersectioncode\">6.2 Simplifying the Ray-Sphere Intersection Code</a><br> <a href=\"#surfacenormalsandmultipleobjects/anabstractionforhittableobjects\">6.3 An Abstraction for Hittable Objects</a><br> <a href=\"#surfacenormalsandmultipleobjects/frontfacesversusbackfaces\">6.4 Front Faces Versus Back Faces</a><br> <a href=\"#surfacenormalsandmultipleobjects/alistofhittableobjects\">6.5 A List of Hittable Objects</a><br> <a href=\"#surfacenormalsandmultipleobjects/somenewc++features\">6.6 Some New C++ Features</a><br> <a href=\"#surfacenormalsandmultipleobjects/commonconstantsandutilityfunctions\">6.7 Common Constants and Utility Functions</a><br> <a href=\"#surfacenormalsandmultipleobjects/anintervalclass\">6.8 An Interval Class</a><br><a href=\"#movingcameracodeintoitsownclass\">7 Moving Camera Code Into Its Own Class</a><br><a href=\"#antialiasing\">8 Antialiasing</a><br> <a href=\"#antialiasing/somerandomnumberutilities\">8.1 Some Random Number Utilities</a><br> <a href=\"#antialiasing/generatingpixelswithmultiplesamples\">8.2 Generating Pixels with Multiple Samples</a><br><a href=\"#diffusematerials\">9 Diffuse Materials</a><br> <a href=\"#diffusematerials/asimplediffusematerial\">9.1 A Simple Diffuse Material</a><br> <a href=\"#diffusematerials/limitingthenumberofchildrays\">9.2 Limiting the Number of Child Rays</a><br> <a href=\"#diffusematerials/fixingshadowacne\">9.3 Fixing Shadow Acne</a><br> <a href=\"#diffusematerials/truelambertianreflection\">9.4 True Lambertian Reflection</a><br> <a href=\"#diffusematerials/usinggammacorrectionforaccuratecolorintensity\">9.5 Using Gamma Correction for Accurate Color Intensity</a><br><a href=\"#metal\">10 Metal</a><br> <a href=\"#metal/anabstractclassformaterials\">10.1 An Abstract Class for Materials</a><br> <a href=\"#metal/adatastructuretodescriberay-objectintersections\">10.2 A Data Structure to Describe Ray-Object Intersections</a><br> <a href=\"#metal/modelinglightscatterandreflectance\">10.3 Modeling Light Scatter and Reflectance</a><br> <a href=\"#metal/mirroredlightreflection\">10.4 Mirrored Light Reflection</a><br> <a href=\"#metal/ascenewithmetalspheres\">10.5 A Scene with Metal Spheres</a><br> <a href=\"#metal/fuzzyreflection\">10.6 Fuzzy Reflection</a><br><a href=\"#dielectrics\">11 Dielectrics</a><br> <a href=\"#dielectrics/refraction\">11.1 Refraction</a><br> <a href=\"#dielectrics/snell'slaw\">11.2 Snell’s Law</a><br> <a href=\"#dielectrics/totalinternalreflection\">11.3 Total Internal Reflection</a><br> <a href=\"#dielectrics/schlickapproximation\">11.4 Schlick Approximation</a><br> <a href=\"#dielectrics/modelingahollowglasssphere\">11.5 Modeling a Hollow Glass Sphere</a><br><a href=\"#positionablecamera\">12 Positionable Camera</a><br> <a href=\"#positionablecamera/cameraviewinggeometry\">12.1 Camera Viewing Geometry</a><br> <a href=\"#positionablecamera/positioningandorientingthecamera\">12.2 Positioning and Orienting the Camera</a><br><a href=\"#defocusblur\">13 Defocus Blur</a><br> <a href=\"#defocusblur/athinlensapproximation\">13.1 A Thin Lens Approximation</a><br> <a href=\"#defocusblur/generatingsamplerays\">13.2 Generating Sample Rays</a><br><a href=\"#wherenext?\">14 Where Next?</a><br> <a href=\"#wherenext?/afinalrender\">14.1 A Final Render</a><br> <a href=\"#wherenext?/nextsteps\">14.2 Next Steps</a><br>  <a href=\"#wherenext?/nextsteps/book2:raytracing:thenextweek\">14.2.1 Book 2: <em>Ray Tracing: The Next Week</em></a><br>  <a href=\"#wherenext?/nextsteps/book3:raytracing:therestofyourlife\">14.2.2 Book 3: <em>Ray Tracing: The Rest of Your Life</em></a><br>  <a href=\"#wherenext?/nextsteps/otherdirections\">14.2.3 Other Directions</a><br><a href=\"#acknowledgments\">15 Acknowledgments</a><br><a href=\"#citingthisbook\">16 Citing This Book</a><br> <a href=\"#citingthisbook/basicdata\">16.1 Basic Data</a><br> <a href=\"#citingthisbook/snippets\">16.2 Snippets</a><br>  <a href=\"#citingthisbook/snippets/markdown\">16.2.1 Markdown</a><br>  <a href=\"#citingthisbook/snippets/html\">16.2.2 HTML</a><br>  <a href=\"#citingthisbook/snippets/latexandbibtex\">16.2.3 LaTeX and BibTex</a><br>  <a href=\"#citingthisbook/snippets/biblatex\">16.2.4 BibLaTeX</a><br>  <a href=\"#citingthisbook/snippets/ieee\">16.2.5 IEEE</a><br>  <a href=\"#citingthisbook/snippets/mla:\">16.2.6 MLA:</a></p>\n<h1 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h1><p>I’ve taught many graphics classes over the years. Often I do them in ray tracing, because you are forced to write all the code, but you can still get cool images with no API. I decided to adapt my course notes into a how-to, to get you to a cool program as quickly as possible. It will not be a full-featured ray tracer, but it does have the indirect lighting which has made ray tracing a staple in movies. Follow these steps, and the architecture of the ray tracer you produce will be good for extending to a more extensive ray tracer if you get excited and want to pursue that.</p>\n<p>When somebody says “ray tracing” it could mean many things. What I am going to describe is technically a path tracer, and a fairly general one. While the code will be pretty simple (let the computer do the work!) I think you’ll be very happy with the images you can make.</p>\n<p>I’ll take you through writing a ray tracer in the order I do it, along with some debugging tips. By the end, you will have a ray tracer that produces some great images. You should be able to do this in a weekend. If you take longer, don’t worry about it. I use C++ as the driving language, but you don’t need to. However, I suggest you do, because it’s fast, portable, and most production movie and video game renderers are written in C++. Note that I avoid most “modern features” of C++, but inheritance and operator overloading are too useful for ray tracers to pass on.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>I do not provide the code online, but the code is real and I show all of it except for a few straightforward operators in the <code>vec3</code> class. I am a big believer in typing in code to learn it, but when code is available I use it, so I only practice what I preach when the code is not available. So don’t ask!</p></blockquote>\n<p>I have left that last part in because it is funny what a 180 I have done. Several readers ended up with subtle errors that were helped when we compared code. So please do type in the code, but you can find the finished source for each book in the <a href=\"https://github.com/RayTracing/raytracing.github.io/\">RayTracing project on GitHub</a>.</p>\n<p>A note on the implementing code for these books — our philosophy for the included code prioritizes the following goals:</p>\n<ul>\n<li><p>The code should implement the concepts covered in the books.</p>\n</li>\n<li><p>We use C++, but as simple as possible. Our programming style is very C-like, but we take advantage of modern features where it makes the code easier to use or understand.</p>\n</li>\n<li><p>Our coding style continues the style established from the original books as much as possible, for continuity.</p>\n</li>\n<li><p>Line length is kept to 96 characters per line, to keep lines consistent between the codebase and code listings in the books.</p>\n</li>\n</ul>\n<p>The code thus provides a baseline implementation, with tons of improvements left for the reader to enjoy. There are endless ways one can optimize and modernize the code; we prioritize the simple solution.</p>\n<p>We assume a little bit of familiarity with vectors (like dot product and vector addition). If you don’t know that, do a little review. If you need that review, or to learn it for the first time, check out the online <a href=\"https://graphicscodex.com/\"><em>Graphics Codex</em></a> by Morgan McGuire, <em>Fundamentals of Computer Graphics</em> by Steve Marschner and Peter Shirley, or <em>Computer Graphics: Principles and Practice</em> by J.D. Foley and Andy Van Dam.</p>\n<p>See the <a href=\"../README.md\">project README</a> file for information about this project, the repository on GitHub, directory structure, building &amp; running, and how to make or reference corrections and contributions.</p>\n<p>See <a href=\"https://github.com/RayTracing/raytracing.github.io/wiki/Further-Readings\">our Further Reading wiki page</a> for additional project related resources.</p>\n<p>These books have been formatted to print well directly from your browser. We also include PDFs of each book <a href=\"https://github.com/RayTracing/raytracing.github.io/releases/\">with each release</a>, in the “Assets” section.</p>\n<p>If you want to communicate with us, feel free to send us an email at:</p>\n<ul>\n<li>Peter Shirley, <a href=\"mailto:ptrshrl@gmail.com\">ptrshrl@gmail.com</a></li>\n<li>Steve Hollasch, <a href=\"mailto:steve@hollasch.net\">steve@hollasch.net</a></li>\n<li>Trevor David Black, <a href=\"mailto:trevordblack@trevord.black\">trevordblack@trevord.black</a></li>\n</ul>\n<p>Finally, if you run into problems with your implementation, have general questions, or would like to share your own ideas or work, see <a href=\"https://github.com/RayTracing/raytracing.github.io/discussions/\">the GitHub Discussions forum</a> on the GitHub project.</p>\n<p>Thanks to everyone who lent a hand on this project. You can find them in the <a href=\"#acknowledgments\">acknowledgments</a> section at the end of this book.</p>\n<p>Let’s get on with it!</p>\n<h1 id=\"Output-an-Image\"><a href=\"#Output-an-Image\" class=\"headerlink\" title=\"Output an Image\"></a>Output an Image</h1><h2 id=\"The-PPM-Image-Format\"><a href=\"#The-PPM-Image-Format\" class=\"headerlink\" title=\"The PPM Image Format\"></a>The PPM Image Format</h2><p>Whenever you start a renderer, you need a way to see an image. The most straightforward way is to write it to a file. The catch is, there are so many formats. Many of those are complex. I always start with a plain text ppm file. Here’s a nice description from Wikipedia:</p>\n<p><a href=\"../images/fig-1.01-ppm.jpg\"><img src=\"/../images/fig-1.01-ppm.jpg\" alt=\"img\"></a><em><strong>Figure 1:</strong> PPM Example</em></p>\n<p>Let’s make some C++ code to output such a thing:</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">#include &lt;iostream&gt;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int main() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // Image</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int image_width = 256;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int image_height = 256;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // Render</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    std::cout &lt;&lt; &quot;P3\\n&quot; &lt;&lt; image_width &lt;&lt; &#39; &#39; &lt;&lt; image_height &lt;&lt; &quot;\\n255\\n&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int j = 0; j &lt; image_height; j++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        for (int i = 0; i &lt; image_width; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            auto r = double(i) / (image_width-1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            auto g = double(j) / (image_height-1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            auto b = 0.0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            int ir = int(255.999 * r);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            int ig = int(255.999 * g);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            int ib = int(255.999 * b);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            std::cout &lt;&lt; ir &lt;&lt; &#39; &#39; &lt;&lt; ig &lt;&lt; &#39; &#39; &lt;&lt; ib &lt;&lt; &#39;\\n&#39;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p><strong>Listing 1:</strong> [main.cc] Creating your first image</p>\n<p>There are some things to note in this code:</p>\n<ol>\n<li><p>The pixels are written out in rows.</p>\n</li>\n<li><p>Every row of pixels is written out left to right.</p>\n</li>\n<li><p>These rows are written out from top to bottom.</p>\n</li>\n<li><p>By convention, each of the red&#x2F;green&#x2F;blue components are represented internally by real-valued variables that range from 0.0 to 1.0. These must be scaled to integer values between 0 and 255 before we print them out.</p>\n</li>\n<li><p>Red goes from fully off (black) to fully on (bright red) from left to right, and green goes from fully off at the top (black) to fully on at the bottom (bright green). Adding red and green light together make yellow so we should expect the bottom right corner to be yellow.</p>\n</li>\n</ol>\n<h2 id=\"Creating-an-Image-File\"><a href=\"#Creating-an-Image-File\" class=\"headerlink\" title=\"Creating an Image File\"></a>Creating an Image File</h2><p>Because the file is written to the standard output stream, you’ll need to redirect it to an image file. Typically this is done from the command-line by using the <code>&gt;</code> redirection operator.</p>\n<p>On Windows, you’d get the debug build from CMake running this command:</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">cmake -B build</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">cmake --build build</span></span></code></pre></div><p>Then run your newly-built program like so:</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">build\\Debug\\inOneWeekend.exe &gt; image.ppm</span></span></code></pre></div><p>Later, it will be better to run optimized builds for speed. In that case, you would build like this:</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">cmake --build build --config release</span></span></code></pre></div><p>and would run the optimized program like this:</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">build\\Release\\inOneWeekend.exe &gt; image.ppm</span></span></code></pre></div><p>The examples above assume that you are building with CMake, using the same approach as the <code>CMakeLists.txt</code> file in the included source. Use whatever build environment (and language) you’re most comfortable with.</p>\n<p>On Mac or Linux, release build, you would launch the program like this:</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">build/inOneWeekend &gt; image.ppm</span></span></code></pre></div><p>Complete building and running instructions can be found in the <a href=\"../README.md\">project README</a>.</p>\n<p>Opening the output file (in <code>ToyViewer</code> on my Mac, but try it in your favorite image viewer and Google “ppm viewer” if your viewer doesn’t support it) shows this result:</p>\n<p><a href=\"../images/img-1.01-first-ppm-image.png\"><img src=\"/../images/img-1.01-first-ppm-image.png\" alt=\"img\"></a><em><strong>Image 1:</strong> First PPM image</em></p>\n<p>Hooray! This is the graphics “hello world”. If your image doesn’t look like that, open the output file in a text editor and see what it looks like. It should start something like this:</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">P3</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">256 256</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">255</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">0 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">1 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">2 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">3 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">4 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">5 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">6 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">7 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">8 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">9 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">10 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">11 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">12 0 0</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">...</span></span></code></pre></div><p><strong>Listing 2:</strong> First image output</p>\n<p>If your PPM file doesn’t look like this, then double-check your formatting code. If it <em>does</em> look like this but fails to render, then you may have line-ending differences or something similar that is confusing your image viewer. To help debug this, you can find a file <code>test.ppm</code> in the <code>images</code> directory of the Github project. This should help to ensure that your viewer can handle the PPM format and to use as a comparison against your generated PPM file.</p>\n<p>Some readers have reported problems viewing their generated files on Windows. In this case, the problem is often that the PPM is written out as UTF-16, often from PowerShell. If you run into this problem, see <a href=\"https://github.com/RayTracing/raytracing.github.io/discussions/1114\">Discussion 1114</a> for help with this issue.</p>\n<p>If everything displays correctly, then you’re pretty much done with system and IDE issues — everything in the remainder of this series uses this same simple mechanism for generated rendered images.</p>\n<p>If you want to produce other image formats, I am a fan of <code>stb_image.h</code>, a header-only image library available on GitHub at <a href=\"https://github.com/nothings/stb\">https://github.com/nothings/stb</a>.</p>\n<h2 id=\"Adding-a-Progress-Indicator\"><a href=\"#Adding-a-Progress-Indicator\" class=\"headerlink\" title=\"Adding a Progress Indicator\"></a>Adding a Progress Indicator</h2><p>Before we continue, let’s add a progress indicator to our output. This is a handy way to track the progress of a long render, and also to possibly identify a run that’s stalled out due to an infinite loop or other problem.</p>\n<p>Our program outputs the image to the standard output stream (<code>std::cout</code>), so leave that alone and instead write to the logging output stream (<code>std::clog</code>):</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">    for (int j = 0; j &lt; image_height; ++j) &#123;        std::clog &lt;&lt; &quot;\\rScanlines remaining: &quot; &lt;&lt; (image_height - j) &lt;&lt; &#39; &#39; &lt;&lt; std::flush;        for (int i = 0; i &lt; image_width; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            auto r = double(i) / (image_width-1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            auto g = double(j) / (image_height-1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            auto b = 0.0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            int ir = int(255.999 * r);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            int ig = int(255.999 * g);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            int ib = int(255.999 * b);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">            std::cout &lt;&lt; ir &lt;&lt; &#39; &#39; &lt;&lt; ig &lt;&lt; &#39; &#39; &lt;&lt; ib &lt;&lt; &#39;\\n&#39;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    std::clog &lt;&lt; &quot;\\rDone.                 \\n&quot;;</span></span></code></pre></div><p><strong>Listing 3:</strong> [main.cc] Main render loop with progress reporting</p>\n<p>Now when running, you’ll see a running count of the number of scanlines remaining. Hopefully this runs so fast that you don’t even see it! Don’t worry — you’ll have lots of time in the future to watch a slowly updating progress line as we expand our ray tracer.</p>\n<p><img src=\"/../images/image-20240606194109779.png\" alt=\"image-20240606194109779\"></p>\n<p><img src=\"/../images/image-20240606194519257.png\" alt=\"image-20240606194519257\"><img src=\"/../images/image-20240606200959161.png\" alt=\"image-20240606200959161\"></p>\n","feature":true,"text":"Contents 1 Overview2 Output an Image 2.1 The PPM Image Format 2.2 Creating an Im...","permalink":"/post/RayTracing","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Overview\"><span class=\"toc-text\">Overview</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Output-an-Image\"><span class=\"toc-text\">Output an Image</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#The-PPM-Image-Format\"><span class=\"toc-text\">The PPM Image Format</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Creating-an-Image-File\"><span class=\"toc-text\">Creating an Image File</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Adding-a-Progress-Indicator\"><span class=\"toc-text\">Adding a Progress Indicator</span></a></li></ol></li></ol>","author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"王赫铭","date":"2024-06-03T08:27:57.905Z","updated":"2024-06-06T00:30:55.091Z","comments":true,"path":"api/articles/王赫铭.json","keywords":null,"cover":null,"text":"基础： verilogmodule LED_Shift_Register ( input clk, // 时钟输入 input rst, // 复位信号 inp...","permalink":"/post/王赫铭","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}