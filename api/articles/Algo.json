{"title":"Algo","uid":"0104a54ef3539ccc47aaaaa3ebb61ff8","slug":"Algo","date":"2024-04-26T01:35:42.000Z","updated":"2024-04-27T02:17:30.993Z","comments":true,"path":"api/articles/Algo.json","keywords":null,"cover":[],"content":"<p>由于实际测试具有较大的局限性，因此我们考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p>\n<ul>\n<li>“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。</li>\n<li>“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。</li>\n<li>“时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“<strong>快慢</strong>”。</li>\n</ul>\n<p>迭代（iteration）</p>\n<p>递归（recursion）,通过函数调用自身来解决问题:（“将问题分解为更小子问题”）</p>\n<ol>\n<li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li>\n<li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li>\n</ol>\n<p>而从实现的角度看，递归代码主要包含三个要素。</p>\n<ol>\n<li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li>\n<li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li>\n<li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li>\n</ol>\n<p>虽然从计算角度看，迭代与递归可以得到相同的结果，<strong>但它们代表了两种完全不同的思考和解决问题的范式</strong>。</p>\n<ul>\n<li><strong>迭代</strong>：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。</li>\n<li><strong>递归</strong>：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。</li>\n</ul>\n<p>过深的递归可能导致栈溢出错误</p>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><p>有趣的是，<strong>如果函数在返回前的最后一步才进行递归调用</strong>，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。</p>\n<ul>\n<li><p><strong>普通递归</strong>：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。</p>\n</li>\n<li><p><strong>尾递归</strong>：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。</p>\n<p>例如：</p>\n<p>&#x2F;* 尾递归 *&#x2F;<br>int tailRecur(int n, int res) {<br>&#x2F;&#x2F; 终止条件<br>if (n &#x3D;&#x3D; 0)<br>    return res;<br>&#x2F;&#x2F; 尾递归调用<br>return tailRecur(n - 1, res + n);<br>}</p>\n</li>\n</ul>\n<p><strong>普通递归</strong>：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">python</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">def factorial(n):</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if n == 0:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 1</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    else:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return n * factorial(n - 1)</span></span></code></pre></div><p>在普通递归中，递归调用 <code>factorial(n - 1)</code> 发生在函数的末尾，并且返回值被乘以 <code>n</code> 后再返回。</p>\n<p><strong>尾递归</strong>：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">python</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">def factorial_tail(n, accumulator=1):</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if n == 0:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return accumulator</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    else:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return factorial_tail(n - 1, accumulator * n)</span></span></code></pre></div><p>以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p>\n<p>事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。</p>\n<ol>\n<li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。</li>\n<li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li>\n</ol>\n<p>时间复杂度分析统计的不是算法运行时间，<strong>而是算法运行时间随着数据量变大时的增长趋势</strong>。</p>\n<p><img src=\"/../images/time_complexity_simple_example.png\" alt=\"img\"></p>\n<p><img src=\"/../images/image-20240426102948646.png\" alt=\"image-20240426102948646\"></p>\n<p>在计算机科学中，”渐近上界” 是一种用于分析算法性能的概念，特别是与时间复杂度和空间复杂度相关。在时间复杂度分析中，渐近上界的目的在于确定算法在数据规模趋于无穷大时的最坏性能表现。为了更好地理解这一概念，可以从几个角度来探讨：</p>\n<h3 id=\"1-什么是渐近上界？\"><a href=\"#1-什么是渐近上界？\" class=\"headerlink\" title=\"1. 什么是渐近上界？\"></a>1. 什么是渐近上界？</h3><p>渐近上界指的是某个函数在趋于某个极限（例如，无限大）时，其增长速率的上限。它通常用于描述算法的最坏情况性能，表示随着输入规模增加，算法的运行时间或使用的资源上限。</p>\n<h6 id=\"2-大-O-表示法\"><a href=\"#2-大-O-表示法\" class=\"headerlink\" title=\"2. 大-O 表示法\"></a>2. 大-O 表示法</h6><p>在算法分析中，渐近上界最常用的表示法是大-O 表示法。用 <code>O(f(n))</code> 表示某个算法的时间复杂度，意味着这个算法的运行时间在最坏情况下不会超过某个函数 <code>f(n)</code> 的增长速率。</p>\n<p>例如，若算法的时间复杂度是 <code>O(n^2)</code>，表示无论最坏情况下发生了什么，这个算法的运行时间最多是某个常数与 <code>n^2</code> 的乘积。这里 <code>n</code> 是输入数据的规模。</p>\n<h6 id=\"3-用途\"><a href=\"#3-用途\" class=\"headerlink\" title=\"3. 用途\"></a>3. 用途</h6><p>渐近上界有助于比较不同算法的性能，并帮助工程师选择适当的算法。在设计和优化算法时，了解渐近上界也有助于避免性能陷阱。</p>\n<h6 id=\"4-如何理解渐近上界？\"><a href=\"#4-如何理解渐近上界？\" class=\"headerlink\" title=\"4. 如何理解渐近上界？\"></a>4. 如何理解渐近上界？</h6><p>渐近上界在数学上是严格定义的。函数 <code>T(n)</code> 的渐近上界是 <code>f(n)</code>，如果存在常数 <code>c</code> 和 <code>n_0</code> 使得对于所有 <code>n ≥ n_0</code>，都有 <code>T(n) ≤ c * f(n)</code>。这意味着当 <code>n</code> 足够大时，<code>T(n)</code> 不会超过 <code>c * f(n)</code>，即使在最坏情况下。</p>\n<h6 id=\"5-示例\"><a href=\"#5-示例\" class=\"headerlink\" title=\"5. 示例\"></a>5. 示例</h6><p>考虑一个算法的时间复杂度是 <code>3n^2 + 2n + 7</code>。这个算法的渐近上界是 <code>O(n^2)</code>，因为当 <code>n</code> 足够大时，<code>3n^2</code> 是增长最快的项，其他项的影响可以忽略。</p>\n<p><img src=\"/../images/image-20240426103209429.png\" alt=\"image-20240426103209429\"></p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 指数阶（递归实现） */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int expRecur(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (n == 1)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 1;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return expRecur(n - 1) + expRecur(n - 1) + 1;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/*对数阶*/</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int linearLogRecur(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (n &lt;= 1)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 1;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return count;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 线性对数阶 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int linearLogRecur(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (n &lt;= 1)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 1;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int i = 0; i &lt; n; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        count++;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return count;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p><img src=\"/../images/image-20240426120004603.png\" alt=\"image-20240426120004603\"></p>\n<p>算法在运行过程中使用的内存空间主要包括以下几种。</p>\n<ul>\n<li><strong>输入空间</strong>：用于存储算法的输入数据。</li>\n<li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li>\n<li><strong>输出空间</strong>：用于存储算法的输出数据。</li>\n</ul>\n<p>一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">struct Node &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int val;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    Node *next;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    Node(int x) : val(x), next(nullptr) &#123;&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;;</span></span></code></pre></div><p><code>Node(int x) : val(x), next(nullptr)</code> 是一个构造函数的定义</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">int func() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 执行某些操作</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 循环的空间复杂度为 O(1) */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void loop(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int i = 0; i &lt; n; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        func();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 递归的空间复杂度为 O(n) */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void recur(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (n == 1) return;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return recur(n - 1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 </p>\n<p> ，但空间复杂度不同。</p>\n<ul>\n<li>函数 <code>loop()</code> 在循环中调用了</li>\n</ul>\n<p> 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 </p>\n<p> 。</p>\n<p>递归函数 <code>recur()</code> 在运行过程中会同时存在 </p>\n<p> 个未返回的 <code>recur()</code> ，从而占用  的栈帧空间。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 线性阶 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void linear(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 长度为 n 的数组占用 O(n) 空间</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    vector&lt;int&gt; nums(n);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 长度为 n 的列表占用 O(n) 空间</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    vector&lt;ListNode&gt; nodes;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int i = 0; i &lt; n; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        nodes.push_back(ListNode(i));</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 长度为 n 的哈希表占用 O(n) 空间</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    unordered_map&lt;int, string&gt; map;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int i = 0; i &lt; n; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        map[i] = to_string(i);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 线性阶（递归实现） */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void linearRecur(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    cout &lt;&lt; &quot;递归 n = &quot; &lt;&lt; n &lt;&lt; endl;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (n == 1)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    linearRecur(n - 1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span></code></pre></div><p><strong>Q</strong>：函数和方法这两个术语的区别是什么？</p>\n<p>函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。</p>\n<p>下面以几种常见的编程语言为例来说明。</p>\n<ul>\n<li>C 语言是过程式编程语言，没有面向对象的概念，所以只有函数。但我们可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他编程语言中的方法。</li>\n<li>Java 和 C# 是面向对象的编程语言，代码块（方法）通常作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量。</li>\n<li>C++ 和 Python 既支持过程式编程（函数），也支持面向对象编程（方法）。</li>\n</ul>\n<p>常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。</p>\n<h2 id=\"逻辑结构：线性与非线性\"><a href=\"#逻辑结构：线性与非线性\" class=\"headerlink\" title=\"逻辑结构：线性与非线性\"></a>逻辑结构：线性与非线性</h2><p><strong>逻辑结构揭示了数据元素之间的逻辑关系</strong>。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。</p>\n<p>如图 3-1 所示，逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。</p>\n<ul>\n<li><strong>线性数据结构</strong>：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。</li>\n<li><strong>非线性数据结构</strong>：树、堆、图、哈希表。</li>\n</ul>\n<p>非线性数据结构可以进一步划分为树形结构和网状结构。</p>\n<ul>\n<li><strong>树形结构</strong>：树、堆、哈希表，元素之间是一对多的关系。</li>\n<li><strong>网状结构</strong>：图，元素之间是多对多的关系。</li>\n</ul>\n<p>内存是所有程序的共享资源，当某块内存被某个程序占用时，则无法被其他程序同时使用了。<strong>因此在数据结构与算法的设计中，内存资源是一个重要的考虑因素</strong>。比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。</p>\n<p>如图 3-3 所示，<strong>物理结构反映了数据在计算机内存中的存储方式</strong>，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p>\n<p><img src=\"/../images/classification_phisical_structure.png\" alt=\"连续空间存储与分散空间存储\"></p>\n<p>值得说明的是，<strong>所有数据结构都是基于数组、链表或二者的组合实现的</strong>。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p>\n<p>链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。</p>\n<p><strong>基本数据类型是 CPU 可以直接进行运算的类型</strong>，在算法中直接被使用，主要包括以下几种。</p>\n<ul>\n<li>整数类型 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 。</li>\n<li>浮点数类型 <code>float</code>、<code>double</code> ，用于表示小数。</li>\n<li>字符类型 <code>char</code> ，用于表示各种语言的字母、标点符号甚至表情符号等。</li>\n<li>布尔类型 <code>bool</code> ，用于表示“是”与“否”判断。</li>\n</ul>\n<p><strong>基本数据类型以二进制的形式存储在计算机中</strong>。一个二进制位即为 1比特。在绝大多数现代操作系统中，1字节（byte）由 8比特（bit）组成。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 初始化数组 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 存储在栈上</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int arr[5];</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int nums[5] = &#123; 1, 3, 2, 5, 4 &#125;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 存储在堆上（需要手动释放空间）</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int* arr1 = new int[5];</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int* nums1 = new int[5] &#123; 1, 3, 2, 5, 4 &#125;;</span></span></code></pre></div><p>在C++中，将数据存储在栈上和堆上有以下区别：</p>\n<ol>\n<li><strong>存储位置</strong>：<ul>\n<li><strong>栈上</strong>：栈上的数据存储在程序的栈内存中，它们的分配和释放由编译器自动管理。栈上的数据通常具有较短的生命周期，当函数执行结束时，其内部的局部变量就会被自动释放。</li>\n<li><strong>堆上</strong>：堆上的数据存储在程序的堆内存中，它们的分配和释放通常由程序员手动管理。堆上的数据可以具有较长的生命周期，直到显式释放内存或程序终止时才会被释放。</li>\n</ul>\n</li>\n<li><strong>动态性</strong>：<ul>\n<li><strong>栈上</strong>：栈上的内存分配是静态的，大小在编译时确定，并且通常比较有限。由于栈上的内存分配由编译器管理，所以分配和释放速度较快。</li>\n<li><strong>堆上</strong>：堆上的内存分配是动态的，大小可以在运行时确定，并且可以根据需要动态增长。由于堆上的内存分配由程序员管理，因此可能会产生内存泄漏或内存碎片等问题。</li>\n</ul>\n</li>\n<li><strong>访问方式</strong>：<ul>\n<li><strong>栈上</strong>：栈上的数据访问速度通常比较快，因为它们存储在内存中的连续位置上，并且可以直接通过指针或引用进行访问。</li>\n<li><strong>堆上</strong>：堆上的数据访问速度可能比较慢，因为它们存储在内存中的不同位置上，并且需要通过指针间接访问。</li>\n</ul>\n</li>\n</ol>\n<p>在实际编程中，选择栈上或堆上的存储方式取决于数据的生命周期、大小和访问方式等因素。</p>\n<p>Q:把数组存储在堆，栈上，那堆栈是什么</p>\n<p>A：在计算机科学中，”堆栈”通常指的是”栈”和”堆”这两种不同的内存分配区域，它们用于存储程序运行时所需的数据和内存。这两者虽然名字相似，但是在内存管理和使用方面有着不同的作用和特点：</p>\n<ol>\n<li><strong>栈（Stack）</strong>：<ul>\n<li>栈是一种内存分配区域，用于存储函数调用时的局部变量、函数参数、函数返回地址等信息。</li>\n<li>栈上的内存分配由编译器<strong>自动管理</strong>，通常采用后进先出（LIFO）的方式进行操作。函数调用时，会将局部变量等信息压入栈中，函数返回时则将其弹出。</li>\n<li>栈上的内存分配<strong>速度快</strong>，但是空间有限，通常用于存储函数调用时所需的临时数据。</li>\n</ul>\n</li>\n<li><strong>堆（Heap）</strong>：<ul>\n<li>堆是另一种内存分配区域，用于存储程序运行时动态分配的内存，例如使用<code>new</code>和<code>delete</code>操作符创建和释放的对象。</li>\n<li>堆上的内存分配由程序员<strong>手动管理</strong>，它的大小和生命周期可以动态确定。堆上的内存通常用于存储程序运行时动态产生的数据结构、对象等。</li>\n<li>堆上的内存分配速度<strong>相对较慢</strong>，因为需要进行动态分配和释放，并且可能产生内存碎片等问题。</li>\n</ul>\n</li>\n</ol>\n<p>总的来说，栈和堆是程序运行时两种不同的内存分配区域，它们有着不同的管理方式、分配速度和用途，程序员可以根据需要选择合适的内存分配方式来管理程序的数据和内存。</p>\n<p>Q ：存储在堆上，是要求定义为指针吗</p>\n<p>A : 在C++中，使用<code>new</code>操作符分配内存时，返回的是指向分配内存的指针。因此，存储在堆上的数据需要定义为指针类型，以便程序员能够通过指针来访问和操作这些数据，并在适当的时候手动释放内存空间，以避免内存泄漏。</p>\n<p>以下是一个简单的示例，演示如何声明和使用函数指针：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">cpp</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#include &lt;iostream&gt;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 声明一个接受两个整数参数并返回它们之和的函数</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int add(int a, int b) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return a + b;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 声明一个接受两个整数参数并返回它们之差的函数</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int subtract(int a, int b) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return a - b;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int main() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 声明一个指向函数的指针，该函数接受两个整数参数并返回一个整数</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int (*operation)(int, int);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 将函数 add 的地址赋值给指针变量 operation</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    operation = add;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 使用指针调用函数 add</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int result1 = operation(10, 5);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    std::cout &lt;&lt; &quot;Result of add: &quot; &lt;&lt; result1 &lt;&lt; std::endl;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 将函数 subtract 的地址赋值给指针变量 operation</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    operation = subtract;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 使用指针调用函数 subtract</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int result2 = operation(10, 5);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    std::cout &lt;&lt; &quot;Result of subtract: &quot; &lt;&lt; result2 &lt;&lt; std::endl;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>在这个示例中，<code>int (*operation)(int, int);</code> 声明了一个名为 <code>operation</code> 的函数指针，它指向一个接受两个整数参数并返回一个整数的函数。然后，通过将函数的地址赋值给指针变量 <code>operation</code>，可以使用该指针来调用不同的函数。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 扩展数组长度 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int *extend(int *nums, int size, int enlarge) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 初始化一个扩展长度后的数组</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int *res = new int[size + enlarge];</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 将原数组中的所有元素复制到新数组</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int i = 0; i &lt; size; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        res[i] = nums[i];</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 释放内存</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    delete[] nums;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 返回扩展后的新数组</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return res;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>返回类型为 <code>int *</code>，意味着该函数返回的是一个指向整数类型的指针，即指向数组的指针。</p>\n<h2 id=\"数组的优点与局限性\"><a href=\"#数组的优点与局限性\" class=\"headerlink\" title=\"数组的优点与局限性\"></a>数组的优点与局限性</h2><p>数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。</p>\n<ul>\n<li><p><strong>空间效率高</strong>：数组为数据分配了连续的内存块，无须额外的结构开销。</p>\n</li>\n<li><p><strong>支持随机访问</strong>：数组允许在 </p>\n</li>\n<li><p>时间内访问任何元素。</p>\n</li>\n<li><p><strong>缓存局部性</strong>：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。</p>\n</li>\n</ul>\n<p>连续空间存储是一把双刃剑，其存在以下局限性。</p>\n<ul>\n<li><p><strong>插入与删除效率低</strong>：当数组中元素较多时，插入与删除操作需要移动大量的元素。</p>\n</li>\n<li><p><strong>长度不可变</strong>：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</p>\n</li>\n<li><p><strong>空间浪费</strong>：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</p>\n</li>\n<li><p><code>delete</code> 用于释放通过 <code>new</code> 分配的单个对象的内存。</p>\n</li>\n<li><p><code>delete[]</code> 用于释放通过 <code>new[]</code> 分配的数组的内存。</p>\n</li>\n</ul>\n<h2 id=\"数组典型应用\"><a href=\"#数组典型应用\" class=\"headerlink\" title=\"数组典型应用\"></a>数组典型应用</h2><p>数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。</p>\n<ul>\n<li><strong>随机访问</strong>：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。</li>\n<li><strong>排序和搜索</strong>：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。</li>\n<li><strong>查找表</strong>：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。</li>\n<li><strong>机器学习</strong>：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。</li>\n<li><strong>数据结构实现</strong>：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。</li>\n</ul>\n<p><strong>存储数组的内存空间必须是连续的</strong></p>\n<p>链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。</p>\n<ul>\n<li>链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。</li>\n<li>尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 <code>null</code>、<code>nullptr</code> 和 <code>None</code> 。</li>\n<li>在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。</li>\n</ul>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 链表节点结构体 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">struct ListNode &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int val;         // 节点值</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    ListNode *next;  // 指向下一节点的指针</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;  // 构造函数</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;;</span></span></code></pre></div><p>为什么结构体也有构造函数:</p>\n<p>在C++中，结构体（struct）和类（class）都可以拥有构造函数。构造函数用于初始化对象的数据成员，在创建对象时自动调用。</p>\n<p>单向链表通常用于实现栈、队列、哈希表和图等数据结构。</p>\n<ul>\n<li><strong>栈与队列</strong>：当插入和删除操作都在链表的一端进行时，它表现出先进后出的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。</li>\n<li><strong>哈希表</strong>：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</li>\n<li><strong>图</strong>：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</li>\n</ul>\n<p>双向链表常用于需要快速查找前一个和后一个元素的场景。</p>\n<ul>\n<li><strong>高级数据结构</strong>：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</li>\n<li><strong>浏览器历史</strong>：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</li>\n<li><strong>LRU 算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</li>\n</ul>\n<p>环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。</p>\n<ul>\n<li><strong>时间片轮转调度算法</strong>：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。</li>\n<li><strong>数据缓冲区</strong>：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。</li>\n</ul>\n<p>可以使用动态数组（dynamic array）来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。</p>\n<p>实际上，<strong>许多编程语言中的标准库提供的列表是基于动态数组实现的</strong>，例如 Python 中的 <code>list</code> 、Java 中的 <code>ArrayList</code> 、C++ 中的 <code>vector</code> 和 C# 中的 <code>List</code> 等。接下来，我们将把“列表”和“动态数组”视为等同的概念。</p>\n<h2 id=\"数据结构的缓存效率\"><a href=\"#数据结构的缓存效率\" class=\"headerlink\" title=\"数据结构的缓存效率\"></a>数据结构的缓存效率</h2><p>缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据。</p>\n<p>为了尽可能达到更高的效率，缓存会采取以下数据加载机制。</p>\n<ul>\n<li><strong>缓存行</strong>：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效。</li>\n<li><strong>预取机制</strong>：处理器会尝试预测数据访问模式（例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。</li>\n<li><strong>空间局部性</strong>：如果一个数据被访问，那么它附近的数据可能近期也会被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率。</li>\n<li><strong>时间局部性</strong>：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率。</li>\n</ul>\n<p>栈（stack）是一种遵循先入后出逻辑的线性数据结构。</p>\n<p>如图 5-1 所示，我们把堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫作“入栈”，删除<strong>栈顶元素</strong>的操作叫作“出栈”。因此我们只能在栈顶添加或删除元素,然而，数组和链表都可以在任意位置添加和删除元素，<strong>因此栈可以视为一种受限制的数组或链表</strong>。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">基于数组实现的栈</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">vector&lt;int&gt; stack;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 获取栈的长度 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack.size()</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">入栈</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack.push_back(num);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">出栈</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack.pop_back();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">访问栈顶元素</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack.back();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">back就是栈顶的位置</span></span></code></pre></div><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">有专用的栈方法</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack&lt;int&gt; stack;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 元素入栈 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack.push(1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack.push(3);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack.push(2);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack.push(5);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack.push(4);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 访问栈顶元素 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int top = stack.top();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 元素出栈 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">stack.pop(); // 无返回值</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 获取栈的长度 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int size = stack.size();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 判断是否为空 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">bool empty = stack.empty();</span></span></code></pre></div><p>队列（queue）是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 初始化队列 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">queue&lt;int&gt; queue;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 元素入队 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">queue.push(1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">queue.push(3);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">queue.push(2);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">queue.push(5);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">queue.push(4);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 访问队首元素 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int front = queue.front();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 元素出队 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">queue.pop();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 获取队列的长度 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int size = queue.size();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 判断队列是否为空 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">bool empty = queue.empty();</span></span></code></pre></div><p>添加队尾，删除队首—–先来后到</p>\n<p><strong>双向队列</strong>：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 初始化双向队列 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">deque&lt;int&gt; deque;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 元素入队 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">deque.push_back(2);   // 添加至队尾</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">deque.push_back(5);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">deque.push_back(4);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">deque.push_front(3);  // 添加至队首</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">deque.push_front(1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 访问元素 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int front = deque.front(); // 队首元素</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int back = deque.back();   // 队尾元素</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 元素出队 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">deque.pop_front();  // 队首元素出队</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">deque.pop_back();   // 队尾元素出队</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 获取双向队列的长度 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int size = deque.size();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 判断双向队列是否为空 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">bool empty = deque.empty();</span></span></code></pre></div><p><code>DoublyListNode *pre, *cur = front;</code> 确实是一个比较容易产生误解的地方，但实际上这行代码并不是同时给 <code>pre</code> 和 <code>cur</code> 赋值为 <code>front</code>。这行代码实际上相当于两行分开的声明和初始化：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">cpp</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">DoublyListNode *pre; // 声明一个指向 DoublyListNode 类型的指针 pre</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">DoublyListNode *cur = front; // 声明一个指向 DoublyListNode 类型的指针 cur，并将其初始化为 front</span></span></code></pre></div><p>这里的 <code>pre</code> 只是声明了一个指针，但并没有初始化，所以它的值是未定义的，你需要在后续代码中对其进行初始化。而 <code>cur</code> 在声明时已经被初始化为 <code>front</code>。</p>\n<p>哈希表（hash table），又称散列表，它通过建立键 <code>key</code> 与值 <code>value</code> 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 <code>key</code> ，则可以在  O(1)时间内获取对应的值 <code>value</code> 。</p>\n<p><code>unordered_map</code> 是 C++ 标准库中的一种关联容器（Associative Container），它提供了快速的键值对存储和检索功能。它是通过<strong>哈希表</strong>实现的，因此提供了高效的插入、删除和查找操作。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 初始化哈希表 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">unordered_map&lt;int, string&gt; map;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 添加操作 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 在哈希表中添加键值对 (key, value)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">map[12836] = &quot;小哈&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">map[15937] = &quot;小啰&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">map[16750] = &quot;小算&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">map[13276] = &quot;小法&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">map[10583] = &quot;小鸭&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 查询操作 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 向哈希表中输入键 key ，得到值 value</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">string name = map[15937];</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 删除操作 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 在哈希表中删除键值对 (key, value)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">map.erase(10583);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 遍历哈希表 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 遍历键值对 key-&gt;value</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">for (auto kv: map) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    cout &lt;&lt; kv.first &lt;&lt; &quot; -&gt; &quot; &lt;&lt; kv.second &lt;&lt; endl;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 使用迭代器遍历 key-&gt;value</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">for (auto iter = map.begin(); iter != map.end(); iter++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div>","feature":true,"text":"由于实际测试具有较大的局限性，因此我们考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity anal...","permalink":"/post/Algo","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%BE%E9%80%92%E5%BD%92\"><span class=\"toc-text\">尾递归</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%90%E8%BF%91%E4%B8%8A%E7%95%8C%EF%BC%9F\"><span class=\"toc-text\">1. 什么是渐近上界？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-%E5%A4%A7-O-%E8%A1%A8%E7%A4%BA%E6%B3%95\"><span class=\"toc-text\">2. 大-O 表示法</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3-%E7%94%A8%E9%80%94\"><span class=\"toc-text\">3. 用途</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B8%90%E8%BF%91%E4%B8%8A%E7%95%8C%EF%BC%9F\"><span class=\"toc-text\">4. 如何理解渐近上界？</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#5-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">5. 示例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7\"><span class=\"toc-text\">逻辑结构：线性与非线性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7\"><span class=\"toc-text\">数组的优点与局限性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">数组典型应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%BC%93%E5%AD%98%E6%95%88%E7%8E%87\"><span class=\"toc-text\">数据结构的缓存效率</span></a>","author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"FPGA","uid":"47d8fddcd3299307e9e74bee0c7b2069","slug":"FPGA","date":"2024-04-24T03:03:09.000Z","updated":"2024-04-26T07:37:34.734Z","comments":true,"path":"api/articles/FPGA.json","keywords":null,"cover":[],"text":"assign 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在alw...","permalink":"/post/FPGA","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}