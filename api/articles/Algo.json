{"title":"Algo","uid":"0104a54ef3539ccc47aaaaa3ebb61ff8","slug":"Algo","date":"2024-04-26T01:35:42.000Z","updated":"2024-04-26T08:48:13.055Z","comments":true,"path":"api/articles/Algo.json","keywords":null,"cover":[],"content":"<p>由于实际测试具有较大的局限性，因此我们考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p>\n<ul>\n<li>“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。</li>\n<li>“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。</li>\n<li>“时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“<strong>快慢</strong>”。</li>\n</ul>\n<p>迭代（iteration）</p>\n<p>递归（recursion）,通过函数调用自身来解决问题:（“将问题分解为更小子问题”）</p>\n<ol>\n<li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li>\n<li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li>\n</ol>\n<p>而从实现的角度看，递归代码主要包含三个要素。</p>\n<ol>\n<li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li>\n<li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li>\n<li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li>\n</ol>\n<p>虽然从计算角度看，迭代与递归可以得到相同的结果，<strong>但它们代表了两种完全不同的思考和解决问题的范式</strong>。</p>\n<ul>\n<li><strong>迭代</strong>：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。</li>\n<li><strong>递归</strong>：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。</li>\n</ul>\n<p>过深的递归可能导致栈溢出错误</p>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><p>有趣的是，<strong>如果函数在返回前的最后一步才进行递归调用</strong>，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。</p>\n<ul>\n<li><p><strong>普通递归</strong>：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。</p>\n</li>\n<li><p><strong>尾递归</strong>：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。</p>\n<p>例如：</p>\n<p>&#x2F;* 尾递归 *&#x2F;<br>int tailRecur(int n, int res) {<br>&#x2F;&#x2F; 终止条件<br>if (n &#x3D;&#x3D; 0)<br>    return res;<br>&#x2F;&#x2F; 尾递归调用<br>return tailRecur(n - 1, res + n);<br>}</p>\n</li>\n</ul>\n<p><strong>普通递归</strong>：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">python</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">def factorial(n):</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if n == 0:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 1</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    else:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return n * factorial(n - 1)</span></span></code></pre></div><p>在普通递归中，递归调用 <code>factorial(n - 1)</code> 发生在函数的末尾，并且返回值被乘以 <code>n</code> 后再返回。</p>\n<p><strong>尾递归</strong>：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">python</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">def factorial_tail(n, accumulator=1):</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if n == 0:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return accumulator</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    else:</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return factorial_tail(n - 1, accumulator * n)</span></span></code></pre></div><p>以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p>\n<p>事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。</p>\n<ol>\n<li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。</li>\n<li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li>\n</ol>\n<p>时间复杂度分析统计的不是算法运行时间，<strong>而是算法运行时间随着数据量变大时的增长趋势</strong>。</p>\n<p><img src=\"/../images/time_complexity_simple_example.png\" alt=\"img\"></p>\n<p><img src=\"/../images/image-20240426102948646.png\" alt=\"image-20240426102948646\"></p>\n<p>在计算机科学中，”渐近上界” 是一种用于分析算法性能的概念，特别是与时间复杂度和空间复杂度相关。在时间复杂度分析中，渐近上界的目的在于确定算法在数据规模趋于无穷大时的最坏性能表现。为了更好地理解这一概念，可以从几个角度来探讨：</p>\n<h3 id=\"1-什么是渐近上界？\"><a href=\"#1-什么是渐近上界？\" class=\"headerlink\" title=\"1. 什么是渐近上界？\"></a>1. 什么是渐近上界？</h3><p>渐近上界指的是某个函数在趋于某个极限（例如，无限大）时，其增长速率的上限。它通常用于描述算法的最坏情况性能，表示随着输入规模增加，算法的运行时间或使用的资源上限。</p>\n<h6 id=\"2-大-O-表示法\"><a href=\"#2-大-O-表示法\" class=\"headerlink\" title=\"2. 大-O 表示法\"></a>2. 大-O 表示法</h6><p>在算法分析中，渐近上界最常用的表示法是大-O 表示法。用 <code>O(f(n))</code> 表示某个算法的时间复杂度，意味着这个算法的运行时间在最坏情况下不会超过某个函数 <code>f(n)</code> 的增长速率。</p>\n<p>例如，若算法的时间复杂度是 <code>O(n^2)</code>，表示无论最坏情况下发生了什么，这个算法的运行时间最多是某个常数与 <code>n^2</code> 的乘积。这里 <code>n</code> 是输入数据的规模。</p>\n<h6 id=\"3-用途\"><a href=\"#3-用途\" class=\"headerlink\" title=\"3. 用途\"></a>3. 用途</h6><p>渐近上界有助于比较不同算法的性能，并帮助工程师选择适当的算法。在设计和优化算法时，了解渐近上界也有助于避免性能陷阱。</p>\n<h6 id=\"4-如何理解渐近上界？\"><a href=\"#4-如何理解渐近上界？\" class=\"headerlink\" title=\"4. 如何理解渐近上界？\"></a>4. 如何理解渐近上界？</h6><p>渐近上界在数学上是严格定义的。函数 <code>T(n)</code> 的渐近上界是 <code>f(n)</code>，如果存在常数 <code>c</code> 和 <code>n_0</code> 使得对于所有 <code>n ≥ n_0</code>，都有 <code>T(n) ≤ c * f(n)</code>。这意味着当 <code>n</code> 足够大时，<code>T(n)</code> 不会超过 <code>c * f(n)</code>，即使在最坏情况下。</p>\n<h6 id=\"5-示例\"><a href=\"#5-示例\" class=\"headerlink\" title=\"5. 示例\"></a>5. 示例</h6><p>考虑一个算法的时间复杂度是 <code>3n^2 + 2n + 7</code>。这个算法的渐近上界是 <code>O(n^2)</code>，因为当 <code>n</code> 足够大时，<code>3n^2</code> 是增长最快的项，其他项的影响可以忽略。</p>\n<p><img src=\"/../images/image-20240426103209429.png\" alt=\"image-20240426103209429\"></p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 指数阶（递归实现） */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int expRecur(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (n == 1)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 1;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return expRecur(n - 1) + expRecur(n - 1) + 1;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/*对数阶*/</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int linearLogRecur(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (n &lt;= 1)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 1;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return count;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 线性对数阶 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int linearLogRecur(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (n &lt;= 1)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return 1;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int i = 0; i &lt; n; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        count++;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return count;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p><img src=\"/../images/image-20240426120004603.png\" alt=\"image-20240426120004603\"></p>\n<p>算法在运行过程中使用的内存空间主要包括以下几种。</p>\n<ul>\n<li><strong>输入空间</strong>：用于存储算法的输入数据。</li>\n<li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li>\n<li><strong>输出空间</strong>：用于存储算法的输出数据。</li>\n</ul>\n<p>一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">struct Node &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int val;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    Node *next;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    Node(int x) : val(x), next(nullptr) &#123;&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;;</span></span></code></pre></div><p><code>Node(int x) : val(x), next(nullptr)</code> 是一个构造函数的定义</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">int func() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 执行某些操作</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 循环的空间复杂度为 O(1) */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void loop(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int i = 0; i &lt; n; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        func();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 递归的空间复杂度为 O(n) */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void recur(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (n == 1) return;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return recur(n - 1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 </p>\n<p> ，但空间复杂度不同。</p>\n<ul>\n<li>函数 <code>loop()</code> 在循环中调用了</li>\n</ul>\n<p> 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 </p>\n<p> 。</p>\n<p>递归函数 <code>recur()</code> 在运行过程中会同时存在 </p>\n<p> 个未返回的 <code>recur()</code> ，从而占用  的栈帧空间。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 线性阶 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void linear(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 长度为 n 的数组占用 O(n) 空间</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    vector&lt;int&gt; nums(n);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 长度为 n 的列表占用 O(n) 空间</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    vector&lt;ListNode&gt; nodes;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int i = 0; i &lt; n; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        nodes.push_back(ListNode(i));</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 长度为 n 的哈希表占用 O(n) 空间</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    unordered_map&lt;int, string&gt; map;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int i = 0; i &lt; n; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        map[i] = to_string(i);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 线性阶（递归实现） */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">void linearRecur(int n) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    cout &lt;&lt; &quot;递归 n = &quot; &lt;&lt; n &lt;&lt; endl;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    if (n == 1)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        return;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    linearRecur(n - 1);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span></code></pre></div><p><strong>Q</strong>：函数和方法这两个术语的区别是什么？</p>\n<p>函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。</p>\n<p>下面以几种常见的编程语言为例来说明。</p>\n<ul>\n<li>C 语言是过程式编程语言，没有面向对象的概念，所以只有函数。但我们可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他编程语言中的方法。</li>\n<li>Java 和 C# 是面向对象的编程语言，代码块（方法）通常作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量。</li>\n<li>C++ 和 Python 既支持过程式编程（函数），也支持面向对象编程（方法）。</li>\n</ul>\n<p>常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。</p>\n<h2 id=\"逻辑结构：线性与非线性\"><a href=\"#逻辑结构：线性与非线性\" class=\"headerlink\" title=\"逻辑结构：线性与非线性\"></a>逻辑结构：线性与非线性</h2><p><strong>逻辑结构揭示了数据元素之间的逻辑关系</strong>。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。</p>\n<p>如图 3-1 所示，逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。</p>\n<ul>\n<li><strong>线性数据结构</strong>：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。</li>\n<li><strong>非线性数据结构</strong>：树、堆、图、哈希表。</li>\n</ul>\n<p>非线性数据结构可以进一步划分为树形结构和网状结构。</p>\n<ul>\n<li><strong>树形结构</strong>：树、堆、哈希表，元素之间是一对多的关系。</li>\n<li><strong>网状结构</strong>：图，元素之间是多对多的关系。</li>\n</ul>\n<p>内存是所有程序的共享资源，当某块内存被某个程序占用时，则无法被其他程序同时使用了。<strong>因此在数据结构与算法的设计中，内存资源是一个重要的考虑因素</strong>。比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。</p>\n<p>如图 3-3 所示，<strong>物理结构反映了数据在计算机内存中的存储方式</strong>，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p>\n<p><img src=\"/../images/classification_phisical_structure.png\" alt=\"连续空间存储与分散空间存储\"></p>\n<p>值得说明的是，<strong>所有数据结构都是基于数组、链表或二者的组合实现的</strong>。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p>\n<p>链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。</p>\n<p><strong>基本数据类型是 CPU 可以直接进行运算的类型</strong>，在算法中直接被使用，主要包括以下几种。</p>\n<ul>\n<li>整数类型 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 。</li>\n<li>浮点数类型 <code>float</code>、<code>double</code> ，用于表示小数。</li>\n<li>字符类型 <code>char</code> ，用于表示各种语言的字母、标点符号甚至表情符号等。</li>\n<li>布尔类型 <code>bool</code> ，用于表示“是”与“否”判断。</li>\n</ul>\n<p><strong>基本数据类型以二进制的形式存储在计算机中</strong>。一个二进制位即为 1比特。在绝大多数现代操作系统中，1字节（byte）由 8比特（bit）组成。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/* 初始化数组 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 存储在栈上</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int arr[5];</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int nums[5] = &#123; 1, 3, 2, 5, 4 &#125;;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 存储在堆上（需要手动释放空间）</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int* arr1 = new int[5];</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int* nums1 = new int[5] &#123; 1, 3, 2, 5, 4 &#125;;</span></span></code></pre></div><p>在C++中，将数据存储在栈上和堆上有以下区别：</p>\n<ol>\n<li><strong>存储位置</strong>：<ul>\n<li><strong>栈上</strong>：栈上的数据存储在程序的栈内存中，它们的分配和释放由编译器自动管理。栈上的数据通常具有较短的生命周期，当函数执行结束时，其内部的局部变量就会被自动释放。</li>\n<li><strong>堆上</strong>：堆上的数据存储在程序的堆内存中，它们的分配和释放通常由程序员手动管理。堆上的数据可以具有较长的生命周期，直到显式释放内存或程序终止时才会被释放。</li>\n</ul>\n</li>\n<li><strong>动态性</strong>：<ul>\n<li><strong>栈上</strong>：栈上的内存分配是静态的，大小在编译时确定，并且通常比较有限。由于栈上的内存分配由编译器管理，所以分配和释放速度较快。</li>\n<li><strong>堆上</strong>：堆上的内存分配是动态的，大小可以在运行时确定，并且可以根据需要动态增长。由于堆上的内存分配由程序员管理，因此可能会产生内存泄漏或内存碎片等问题。</li>\n</ul>\n</li>\n<li><strong>访问方式</strong>：<ul>\n<li><strong>栈上</strong>：栈上的数据访问速度通常比较快，因为它们存储在内存中的连续位置上，并且可以直接通过指针或引用进行访问。</li>\n<li><strong>堆上</strong>：堆上的数据访问速度可能比较慢，因为它们存储在内存中的不同位置上，并且需要通过指针间接访问。</li>\n</ul>\n</li>\n</ol>\n<p>在实际编程中，选择栈上或堆上的存储方式取决于数据的生命周期、大小和访问方式等因素。</p>\n<p>Q:把数组存储在堆，栈上，那堆栈是什么</p>\n<p>A：在计算机科学中，”堆栈”通常指的是”栈”和”堆”这两种不同的内存分配区域，它们用于存储程序运行时所需的数据和内存。这两者虽然名字相似，但是在内存管理和使用方面有着不同的作用和特点：</p>\n<ol>\n<li><strong>栈（Stack）</strong>：<ul>\n<li>栈是一种内存分配区域，用于存储函数调用时的局部变量、函数参数、函数返回地址等信息。</li>\n<li>栈上的内存分配由编译器<strong>自动管理</strong>，通常采用后进先出（LIFO）的方式进行操作。函数调用时，会将局部变量等信息压入栈中，函数返回时则将其弹出。</li>\n<li>栈上的内存分配<strong>速度快</strong>，但是空间有限，通常用于存储函数调用时所需的临时数据。</li>\n</ul>\n</li>\n<li><strong>堆（Heap）</strong>：<ul>\n<li>堆是另一种内存分配区域，用于存储程序运行时动态分配的内存，例如使用<code>new</code>和<code>delete</code>操作符创建和释放的对象。</li>\n<li>堆上的内存分配由程序员<strong>手动管理</strong>，它的大小和生命周期可以动态确定。堆上的内存通常用于存储程序运行时动态产生的数据结构、对象等。</li>\n<li>堆上的内存分配速度<strong>相对较慢</strong>，因为需要进行动态分配和释放，并且可能产生内存碎片等问题。</li>\n</ul>\n</li>\n</ol>\n<p>总的来说，栈和堆是程序运行时两种不同的内存分配区域，它们有着不同的管理方式、分配速度和用途，程序员可以根据需要选择合适的内存分配方式来管理程序的数据和内存。</p>\n<p>Q ：存储在堆上，是要求定义为指针吗</p>\n<p>A : 在C++中，使用<code>new</code>操作符分配内存时，返回的是指向分配内存的指针。因此，存储在堆上的数据需要定义为指针类型，以便程序员能够通过指针来访问和操作这些数据，并在适当的时候手动释放内存空间，以避免内存泄漏。</p>\n<p>以下是一个简单的示例，演示如何声明和使用函数指针：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">cpp</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#include &lt;iostream&gt;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 声明一个接受两个整数参数并返回它们之和的函数</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int add(int a, int b) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return a + b;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 声明一个接受两个整数参数并返回它们之差的函数</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int subtract(int a, int b) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return a - b;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int main() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 声明一个指向函数的指针，该函数接受两个整数参数并返回一个整数</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int (*operation)(int, int);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 将函数 add 的地址赋值给指针变量 operation</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    operation = add;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 使用指针调用函数 add</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int result1 = operation(10, 5);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    std::cout &lt;&lt; &quot;Result of add: &quot; &lt;&lt; result1 &lt;&lt; std::endl;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 将函数 subtract 的地址赋值给指针变量 operation</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    operation = subtract;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 使用指针调用函数 subtract</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int result2 = operation(10, 5);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    std::cout &lt;&lt; &quot;Result of subtract: &quot; &lt;&lt; result2 &lt;&lt; std::endl;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return 0;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>在这个示例中，<code>int (*operation)(int, int);</code> 声明了一个名为 <code>operation</code> 的函数指针，它指向一个接受两个整数参数并返回一个整数的函数。然后，通过将函数的地址赋值给指针变量 <code>operation</code>，可以使用该指针来调用不同的函数。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">/* 扩展数组长度 */</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int *extend(int *nums, int size, int enlarge) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 初始化一个扩展长度后的数组</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    int *res = new int[size + enlarge];</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 将原数组中的所有元素复制到新数组</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    for (int i = 0; i &lt; size; i++) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">        res[i] = nums[i];</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 释放内存</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    delete[] nums;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 返回扩展后的新数组</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    return res;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>返回类型为 <code>int *</code>，意味着该函数返回的是一个指向整数类型的指针，即指向数组的指针。</p>\n<h2 id=\"数组的优点与局限性\"><a href=\"#数组的优点与局限性\" class=\"headerlink\" title=\"数组的优点与局限性\"></a>数组的优点与局限性</h2><p>数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。</p>\n<ul>\n<li><p><strong>空间效率高</strong>：数组为数据分配了连续的内存块，无须额外的结构开销。</p>\n</li>\n<li><p><strong>支持随机访问</strong>：数组允许在 </p>\n</li>\n<li><p>时间内访问任何元素。</p>\n</li>\n<li><p><strong>缓存局部性</strong>：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。</p>\n</li>\n</ul>\n<p>连续空间存储是一把双刃剑，其存在以下局限性。</p>\n<ul>\n<li><p><strong>插入与删除效率低</strong>：当数组中元素较多时，插入与删除操作需要移动大量的元素。</p>\n</li>\n<li><p><strong>长度不可变</strong>：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</p>\n</li>\n<li><p><strong>空间浪费</strong>：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</p>\n</li>\n<li><p><code>delete</code> 用于释放通过 <code>new</code> 分配的单个对象的内存。</p>\n</li>\n<li><p><code>delete[]</code> 用于释放通过 <code>new[]</code> 分配的数组的内存。</p>\n</li>\n</ul>\n<h2 id=\"数组典型应用\"><a href=\"#数组典型应用\" class=\"headerlink\" title=\"数组典型应用\"></a>数组典型应用</h2><p>数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。</p>\n<ul>\n<li><strong>随机访问</strong>：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。</li>\n<li><strong>排序和搜索</strong>：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。</li>\n<li><strong>查找表</strong>：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。</li>\n<li><strong>机器学习</strong>：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。</li>\n<li><strong>数据结构实现</strong>：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。</li>\n</ul>\n","feature":true,"text":"由于实际测试具有较大的局限性，因此我们考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity anal...","permalink":"/post/Algo","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%BE%E9%80%92%E5%BD%92\"><span class=\"toc-text\">尾递归</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%90%E8%BF%91%E4%B8%8A%E7%95%8C%EF%BC%9F\"><span class=\"toc-text\">1. 什么是渐近上界？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-%E5%A4%A7-O-%E8%A1%A8%E7%A4%BA%E6%B3%95\"><span class=\"toc-text\">2. 大-O 表示法</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3-%E7%94%A8%E9%80%94\"><span class=\"toc-text\">3. 用途</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B8%90%E8%BF%91%E4%B8%8A%E7%95%8C%EF%BC%9F\"><span class=\"toc-text\">4. 如何理解渐近上界？</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#5-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">5. 示例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7\"><span class=\"toc-text\">逻辑结构：线性与非线性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7\"><span class=\"toc-text\">数组的优点与局限性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">数组典型应用</span></a>","author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"FPGA","uid":"47d8fddcd3299307e9e74bee0c7b2069","slug":"FPGA","date":"2024-04-24T03:03:09.000Z","updated":"2024-04-26T07:37:34.734Z","comments":true,"path":"api/articles/FPGA.json","keywords":null,"cover":[],"text":"assign 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在alw...","permalink":"/post/FPGA","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}