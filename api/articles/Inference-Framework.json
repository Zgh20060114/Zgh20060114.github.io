{"title":"Inference_Framework","uid":"4961e15af02b68ebd599dc1652c0f600","slug":"Inference-Framework","date":"2024-04-13T09:01:40.000Z","updated":"2024-04-13T15:24:54.809Z","comments":true,"path":"api/articles/Inference-Framework.json","keywords":null,"cover":null,"content":"<p>训练完成的模型被放置在：1.模型定义文件；2.权重文件</p>\n<p>编译安装数学库：armadillo（openblas）</p>\n<p>头文件安装在: &#x2F;usr&#x2F;include&#x2F;</p>\n<p>库文件：&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;</p>\n<p>编译安装测试库：Gtest,日志库：Glog</p>\n<p>都</p>\n<p>头文件安装在:&#x2F;usr&#x2F;local&#x2F;include&#x2F;</p>\n<p>库文件：&#x2F;usr&#x2F;local&#x2F;lib&#x2F;</p>\n<ul>\n<li><p>解决gtest库重复定义：${GTEST_BOTH_LIBRARIES}</p>\n</li>\n<li><p><code>std::shared_ptr</code> 是 C++ 标准库提供的一个智能指针类，用于管理动态分配的内存。它提供了共享所有权的能力，即可以被多个指针共同拥有，并在没有任何指针再指向该内存时自动释放。下面是 <code>std::shared_ptr</code> 的一些功能和特性：</p>\n</li>\n</ul>\n<ol>\n<li><strong>共享所有权</strong>：<code>std::shared_ptr</code> 允许多个指针共享同一个对象的所有权。当所有的 <code>shared_ptr</code> 实例都超出作用域或者被显式地置为 <code>nullptr</code> 时，才会释放所管理的对象。</li>\n<li><strong>引用计数</strong>：<code>std::shared_ptr</code> 内部维护一个引用计数器，用来记录有多少个 <code>shared_ptr</code> 实例指向同一个对象。当引用计数变为 0 时，即没有指针指向该对象时，对象被自动销毁。</li>\n<li><strong>线程安全</strong>：<code>std::shared_ptr</code> 的引用计数器是原子操作，因此在多线程环境下使用是安全的。</li>\n<li><strong>自定义删除器</strong>：可以通过构造函数或 <code>std::make_shared</code> 函数提供自定义的删除器，以便在释放资源时执行特定的清理操作。</li>\n<li><strong>弱引用支持</strong>：<code>std::weak_ptr</code> 可以从 <code>std::shared_ptr</code> 创建，它允许引用一个对象但不增加其引用计数，避免循环引用问题。</li>\n</ol>\n<p>使用 <code>std::shared_ptr</code> 能够大大简化动态内存管理，并且能够避免内存泄漏和悬空指针等问题。因此，它是 C++ 中一个非常有用的工具，特别是在需要动态分配内存并且多个对象之间存在所有权关系的情况下。</p>\n<ul>\n<li><p><code>ASSERT_EQ()</code> 是 Google Test（gtest）测试框架中的一种断言宏，用于在测试中验证预期结果与实际结果是否相等。下面是关于 <code>ASSERT_EQ()</code> 的一些说明：</p>\n<ol>\n<li><strong>功能</strong>：<code>ASSERT_EQ()</code> 断言用于比较两个值是否相等。</li>\n<li><strong>使用场景</strong>：通常在编写测试用例时，需要验证某个函数或方法的返回值是否符合预期。<code>ASSERT_EQ()</code> 可以用于检查函数返回值与预期结果是否一致，如果相等，则测试通过；如果不相等，则测试失败。</li>\n<li><strong>语法</strong>：<code>ASSERT_EQ(expected, actual)</code>，其中 <code>expected</code> 是期望值，<code>actual</code> 是实际值。如果两者相等，则测试通过；如果不相等，则测试失败，并输出详细的错误信息。</li>\n<li><strong>示例</strong>：假设有一个名为 <code>add()</code> 的函数用于实现两个数相加的功能，我们可以编写一个测试用例来验证其正确性：</li>\n</ol>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">cpp</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">TEST(AddTest, HandlesPositiveNumbers) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  ASSERT_EQ(5, add(2, 3)); // 预期结果是 5，实际结果是 add(2, 3) 的返回值</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>在上面的示例中，如果 <code>add(2, 3)</code> 返回的值是 5，则测试通过；否则，测试失败，并输出相应的错误信息。</p>\n<ol>\n<li><p>注意事项</p>\n<p>：</p>\n<ul>\n<li><p><code>ASSERT_EQ()</code> 适用于比较基本数据类型（如整数、浮点数、布尔值等）以及支持相等比较的自定义类型。</p>\n</li>\n<li><h5 id=\"对于指针类型，通常使用-ASSERT-EQ-来比较指针的值，而不是比较指针指向的内容。\"><a href=\"#对于指针类型，通常使用-ASSERT-EQ-来比较指针的值，而不是比较指针指向的内容。\" class=\"headerlink\" title=\"对于指针类型，通常使用 ASSERT_EQ() 来比较指针的值，而不是比较指针指向的内容。\"></a>对于指针类型，通常使用 <code>ASSERT_EQ()</code> 来比较指针的值，而不是比较指针指向的内容。</h5></li>\n<li><p>在测试框架中，<code>ASSERT_EQ()</code> 的失败会导致当前测试用例失败，并停止继续执行该用例后面的代码，但不会影响其他测试用例的执行。</p>\n</li>\n<li><p><code>EXPECT_EQ()</code> 和其他断言宏（如 <code>ASSERT_EQ()</code>）的作用类似，但它们的行为在测试失败时略有不同。<code>EXPECT_EQ()</code> 的失败会将测试用例标记为失败，但不会停止继续执行该用例后面的代码，而是会继续执行，直到测试用例结束。</p>\n</li>\n<li><p>在测试框架中，建议优先使用 <code>EXPECT_</code> 系列的断言，除非遇到需要立即停止测试用例执行的情况，才考虑使用 <code>ASSERT_</code> 系列的断言。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p><code>TEST()</code> 是 Google Test（gtest）测试框架中的一个宏，用于定义一个测试用例。下面是关于 <code>TEST()</code> 的一些说明：</p>\n<ol>\n<li><strong>功能</strong>：<code>TEST()</code> 宏用于定义一个测试用例，即一组针对被测试代码的测试操作。</li>\n<li><strong>使用场景</strong>：在进行软件开发时，为了确保代码的质量和功能的正确性，通常需要编写测试用例对代码进行测试。<code>TEST()</code> 宏允许开发者定义测试用例，用于验证被测试代码的行为是否符合预期。</li>\n<li><strong>语法</strong>：<code>TEST(test_case_name, test_name)</code>，其中：<ul>\n<li><code>test_case_name</code> 是测试用例的名称，<strong>用于将多个相关的测试用例组织在一起。</strong></li>\n<li><code>test_name</code> 是<strong>单个测试用例的名称</strong>，用于描述该测试用例验证的具体功能或场景。</li>\n</ul>\n</li>\n<li><strong>示例</strong>：以下是一个简单的示例，演示了如何使用 <code>TEST()</code> 宏定义一个测试用例：</li>\n</ol>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">cpp</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#include &lt;gtest/gtest.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 被测试的函数</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int add(int a, int b) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  return a + b;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// 定义一个测试用例</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">TEST(AddTest, HandlesPositiveNumbers) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  EXPECT_EQ(5, add(2, 3)); // 预期结果是 5，实际结果是 add(2, 3) 的返回值</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">// main 函数</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">int main(int argc, char **argv) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  ::testing::InitGoogleTest(&amp;argc, argv);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">  return RUN_ALL_TESTS();</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>在上面的示例中，<code>TEST()</code> 宏用于定义了一个名为 <code>AddTest</code> 的测试用例，其中包含一个名为 <code>HandlesPositiveNumbers</code> 的测试，用于验证 <code>add()</code> 函数对正数的加法是否正确。如果测试通过，则 <code>add()</code> 函数被认为是正确的。</p>\n<ol>\n<li><p>注意事项</p>\n<p>：</p>\n<ul>\n<li><code>TEST()</code> 宏定义的测试用例必须包含在 <code>main()</code> 函数之外。</li>\n<li>在测试用例中，通常使用各种断言宏（如 <code>ASSERT_EQ()</code>、<code>EXPECT_EQ()</code> 等）来验证代码的行为是否符合预期。</li>\n<li>在运行测试程序时，测试框架会自动发现并执行所有定义的测试用例，并输出测试结果。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">#include &lt;memory&gt;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">#include &lt;vector&gt;</span></span></code></pre></div><ul>\n<li><strong><code>&lt;memory&gt;</code> 头文件</strong>：<ul>\n<li>提供了<strong>智能指针类</strong>（smart pointers），如 <code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>，用于管理动态分配的内存资源，避免内存泄漏和悬空指针等问题。</li>\n<li>包含了一些与内存管理相关的函数，如 <code>std::make_unique</code>、<code>std::make_shared</code> 等，用于方便地创建智能指针对象。</li>\n<li>提供了一些与内存操作相关的工具，如 <code>std::allocator</code>、<code>std::pointer_traits</code> 等。</li>\n</ul>\n</li>\n<li><strong><code>&lt;vector&gt;</code> 头文件</strong>：<ul>\n<li>提供了<strong>向量（vector）容器类模板</strong> <code>std::vector</code>，它是一个<strong>动态数组，可以在运行时动态增长和缩减其大小。</strong></li>\n<li><code>std::vector</code> 允许在其<strong>尾部快速插入和删除元素，同时支持随机访问和迭代器操作。</strong></li>\n<li><strong>提供了一系列成员函数和算法，用于对向量进行元素的访问、插入、删除、排序等操作。</strong></li>\n</ul>\n</li>\n</ul>\n<hr>\n","feature":true,"text":"训练完成的模型被放置在：1.模型定义文件；2.权重文件 编译安装数学库：armadillo（openblas） 头文件安装在: &#x2F;usr&#x2F;i...","permalink":"/post/Inference-Framework","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E4%BA%8E%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8-ASSERT-EQ-%E6%9D%A5%E6%AF%94%E8%BE%83%E6%8C%87%E9%92%88%E7%9A%84%E5%80%BC%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%AF%94%E8%BE%83%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82\"><span class=\"toc-text\">对于指针类型，通常使用 ASSERT_EQ() 来比较指针的值，而不是比较指针指向的内容。</span></a></li></ol>","author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"电路Learning","uid":"9247c802e822e7604ecac76759948ceb","slug":"电路Learning","date":"2024-04-13T02:08:03.000Z","updated":"2024-04-13T02:11:55.787Z","comments":true,"path":"api/articles/电路Learning.json","keywords":null,"cover":[],"text":" 一阶电路三要素法：https://zhuanlan.zhihu.com/p/367671862 ","permalink":"/post/电路Learning","photos":[],"count_time":{"symbolsCount":51,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}