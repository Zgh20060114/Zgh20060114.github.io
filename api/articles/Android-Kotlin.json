{"title":"Android_Kotlin","uid":"6df1dc6e24cc645f9148dbaf83a17c60","slug":"Android-Kotlin","date":"2024-04-21T12:52:23.000Z","updated":"2024-04-25T03:59:07.066Z","comments":true,"path":"api/articles/Android-Kotlin.json","keywords":null,"cover":[],"content":"<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">`class FirstActivity : AppCompatActivity() &#123;`</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`override fun onCreate(savedInstanceState: Bundle?) &#123;`</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`super.onCreate(savedInstanceState)`</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`&#125;`</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`&#125;`</span></span></code></pre></div><p>这段代码是使用 Kotlin 语言编写的 Android 应用程序中的一个活动（Activity）类。让我逐步解释其中的内容：</p>\n<ol>\n<li><code>class FirstActivity : AppCompatActivity()</code>：这是一个类的声明，类名为 <code>FirstActivity</code>，并且继承自 <code>AppCompatActivity</code> 类。<code>AppCompatActivity</code> 是 Android 开发中常用的一个基类，用于支持应用程序在较旧的 Android 版本上提供向后兼容性。</li>\n<li><code>override fun onCreate(savedInstanceState: Bundle?)</code>：这是 <code>FirstActivity</code> 类中的一个方法 <code>onCreate()</code> 的重写。在 Android 中，<code>onCreate()</code> 方法是活动生命周期的一部分，在活动第一次创建时被调用。<code>savedInstanceState</code> 参数是一个 <code>Bundle</code> 对象，其中包含了之前保存的活动状态信息，可以用于在活动重新创建时恢复状态。</li>\n<li><code>super.onCreate(savedInstanceState)</code>：这是调用父类 <code>AppCompatActivity</code> 中的 <code>onCreate()</code> 方法，确保父类中的初始化工作得以执行。</li>\n</ol>\n<p>因此，这段代码定义了一个名为 <code>FirstActivity</code> 的活动类，当该活动第一次创建时，会调用父类的 <code>onCreate()</code> 方法进行初始化。</p>\n<p>在声明 <code>savedInstanceState</code> 参数时，如果在类型后面添加了 <code>?</code>，则表示该参数可以接受 <code>null</code> 值。</p>\n<p>这样做的目的是为了允许 <code>savedInstanceState</code> 参数在某些情况下为 null，例如当活动或片段首次创建时，<code>savedInstanceState</code> 可能为 null，因为此时还没有保存任何状态信息。</p>\n<p>在 Kotlin 中，如果没有使用 <code>?</code>，则表示该参数不接受 null 值，如果在实际使用中传递了 null 值，编译器将会报错。而使用了 <code>?</code> 后，表示该参数可以接受 null 值，编译器将不会报错。</p>\n<p>因此，在 <code>override fun onCreate(savedInstanceState: Bundle?)</code> 中，<code>Bundle?</code> 表示 <code>savedInstanceState</code> 参数可以接受 null 值，即在某些情况下，<code>savedInstanceState</code> 可能为 null。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:orientation=&quot;vertical&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:layout_width=&quot;match_parent&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:layout_height=&quot;match_parent&quot;&gt;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&lt;Button</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:id=&quot;@+id/button1&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:layout_width=&quot;match_parent&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:layout_height=&quot;wrap_content&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:text=&quot;Button 1&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/&gt;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&lt;/LinearLayout&gt;</span></span></code></pre></div><p>这段代码是一个简单的 Android 布局文件，使用 XML 格式描述了一个线性布局（LinearLayout）以及一个按钮（Button）的布局和属性。</p>\n<p>让我解释其中的一些关键部分：</p>\n<ul>\n<li><code>&lt;LinearLayout&gt;</code>：这是一个布局容器，用于在垂直方向排列其子视图（例如按钮）。<code>xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</code> 是 XML 命名空间声明，它使得可以在 XML 文件中使用 Android 提供的属性和元素。</li>\n<li><code>android:orientation=&quot;vertical&quot;</code>：这个属性指定了线性布局的方向，即垂直方向。这意味着其中的子视图（此处为按钮）将会按照垂直方向排列。</li>\n<li><code>android:layout_width=&quot;match_parent&quot;</code> 和 <code>android:layout_height=&quot;match_parent&quot;</code>：这两个属性指定了布局的宽度和高度。<code>match_parent</code> 表示该布局将会填充其父容器的宽度或高度，以占据尽可能多的空间。</li>\n<li><code>&lt;Button&gt;</code>：这是一个按钮视图，在布局中用于响应用户的点击事件。</li>\n<li><code>android:id=&quot;@+id/button1&quot;</code>：这个属性为按钮指定了一个唯一的标识符，可以在 Java 代码中使用这个标识符来查找和操作这个按钮。</li>\n<li><code>wrap_content</code> 属性可以使得布局更加灵活，可以根据内容的大小动态调整视图的尺寸，而不是固定为特定的尺寸。</li>\n<li><code>android:text=&quot;Button 1&quot;</code>：这个属性为按钮设置了显示的文本内容为 “Button 1”。</li>\n</ul>\n<p>因此，这段代码描述了一个垂直排列的线性布局，其中包含一个按钮，按钮显示文本为 “Button 1”。按钮的宽度会填充父容器的宽度，而高度则根据按钮文本的大小动态调整。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">class FirstActivity : AppCompatActivity() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">super.onCreate(savedInstanceState)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">setContentView(R.layout.first_layout)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>首先调用了 <code>super.onCreate(savedInstanceState)</code>，以确保调用了父类的 <code>onCreate()</code> 方法，以便执行必要的初始化操作。</p>\n<p>接着调用了 <code>setContentView(R.layout.first_layout)</code> 方法，这个方法用于设置该活动所使用的布局文件。在这里，<code>first_layout</code> 是指定的布局资源文件的名称，这个布局文件定义了活动的界面布局结构。</p>\n<p>因此，这段代码的作用是在 <code>FirstActivity</code> 中设置了一个布局文件 <code>first_layout</code> 作为活动的界面布局，并在活动创建时加载该布局。</p>\n<p><code>R.layout</code> 是一个自动生成的资源标识符类，它包含了项目中所有布局文件的引用。在 Android 开发中，资源文件（如布局文件、字符串、图像等）都需要通过资源标识符来访问和引用。</p>\n<p>当你在项目中创建布局文件时，每个布局文件都会被编译成一个资源标识符，以便在代码中进行引用。这些资源标识符都会被统一放置在 <code>R</code> 类的内部静态类中，而 <code>R.layout</code> 则是其中用于引用布局文件的子类之一。</p>\n<p>Intent—&gt;用于通信的消息对象</p>\n<p>在 Android 中，Intent 是一种用于在不同组件之间进行通信的对象。它可以用于启动活动（Activity）、启动服务（Service）、发送广播（Broadcast）以及执行其他各种操作。Intent 提供了一种在不同组件之间传递数据和执行操作的机制。</p>\n<p>Intent 本质上是一个消息对象，用于指示想要执行的操作。它可以包含以下信息：</p>\n<ol>\n<li><strong>操作（Action）</strong>：指示要执行的操作，如启动活动、启动服务、发送广播等。常见的操作包括 <code>android.intent.action.VIEW</code>（查看操作）、<code>android.intent.action.SEND</code>（发送操作）、<code>android.intent.action.MAIN</code>（主操作）等。</li>\n<li><strong>数据（Data）</strong>：用于指定操作的数据，可以是 URI、文件路径、文本等。例如，如果要查看网页，可以将网页的 URL 作为数据传递给 Intent。</li>\n<li><strong>类别（Category）</strong>：用于指定操作的类别，如 <code>android.intent.category.LAUNCHER</code>（启动器类别）、<code>android.intent.category.BROWSABLE</code>（可浏览类别）等。</li>\n<li><strong>附加信息（Extras）</strong>：用于传递额外的数据给目标组件。Extras 是键值对的形式，可以包含各种数据类型，如字符串、整数、布尔值等。</li>\n</ol>\n<p>Intent 可以分为两种类型：</p>\n<ul>\n<li><strong>显式 Intent</strong>：明确定义了目标组件的类名，用于启动特定的组件。</li>\n<li><strong>隐式 Intent</strong>：没有明确指定目标组件，而是根据 Intent 的操作、数据等信息由系统来匹配合适的组件。</li>\n</ul>\n<p>通过使用 Intent，Android 应用程序可以实现各种功能，例如启动新的活动、执行后台任务、发送广播等，从而实现各种复杂的交互和功能。</p>\n<p>Kotlin直接可以：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">super.onCreate(savedInstanceState)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">setContentView(R.layout.first_layout)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">button1.setOnClickListener &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">Toast.makeText(this, &quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show()</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>在 Kotlin 中，函数声明的语法是：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">fun 函数名(参数列表): 返回值类型 &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 函数体</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>其中，返回值类型在函数名和参数列表之后，使用冒号 <code>:</code> 来标识。在这个语法中，返回值类型是必须的，但在某些情况下，如果函数没有返回值，可以将返回值类型指定为 <code>Unit</code>，或者省略返回值类型（在这种情况下，编译器会自动推断返回值类型为 <code>Unit</code>）。例如：</p>\n<div class=\"language-kotlin\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">kotlin</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">kotlin</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">fun</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">greet</span><span style=\"color: #BABED8\">(name: </span><span style=\"color: #FFCB6B\">String</span><span style=\"color: #BABED8\">): </span><span style=\"color: #FFCB6B\">Unit</span><span style=\"color: #BABED8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #82AAFF\">println</span><span style=\"color: #BABED8\">(</span><span style=\"color: #C3E88D\">&quot;Hello, </span><span style=\"color: #BABED8\">$name</span><span style=\"color: #C3E88D\">!&quot;</span><span style=\"color: #BABED8\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">// 或者省略返回值类型，编译器会自动推断为 Unit</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">fun</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">greet</span><span style=\"color: #BABED8\">(name: </span><span style=\"color: #FFCB6B\">String</span><span style=\"color: #BABED8\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #82AAFF\">println</span><span style=\"color: #BABED8\">(</span><span style=\"color: #C3E88D\">&quot;Hello, </span><span style=\"color: #BABED8\">$name</span><span style=\"color: #C3E88D\">!&quot;</span><span style=\"color: #BABED8\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">override fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">menuInflater.inflate(R.menu.main, menu)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">return true</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p><code>menuInflater</code> 是 Android 开发中的一个类，用于从 XML 文件中创建菜单对象。在 Android 中，通常使用 XML 文件定义应用程序中的菜单，然后通过 <code>MenuInflater</code> 类将这些 XML 文件中定义的菜单加载到应用程序中的菜单对象中，以供在用户界面中显示和操作。</p>\n<p>具体来说，<code>menuInflater.inflate()</code> 方法用于将一个 XML 文件中定义的菜单资源加载到一个 <code>Menu</code> 对象中，这样就可以在应用程序的用户界面中显示这个菜单。</p>\n<p>在 Android 应用程序中，Activity 和 Fragment 是两种重要的组件，用于构建用户界面和处理用户交互。它们都可以包含用户界面的布局，并且可以响应用户的输入事件（如点击、滑动等）。</p>\n<p>下面是关于 Activity 和 Fragment 的简要介绍：</p>\n<h3 id=\"Activity（活动）\"><a href=\"#Activity（活动）\" class=\"headerlink\" title=\"Activity（活动）\"></a>Activity（活动）</h3><ol>\n<li><strong>定义</strong>：Activity 是 Android 应用中的一个基本组件，代表一个单独的用户界面屏幕，通常是一个窗口、一个对话框或全屏显示的窗口。</li>\n<li><strong>作用</strong>：Activity 主要负责管理用户与应用程序之间的交互，包括接收用户输入、处理用户操作，并在屏幕上显示相应的界面。</li>\n<li><strong>生命周期</strong>：Activity 具有丰富的生命周期方法，如 <code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code> 等，开发者可以根据需要重写这些方法来执行相应的操作。</li>\n<li><strong>布局</strong>：Activity 可以通过设置布局文件（XML 文件）来定义用户界面的外观和行为，也可以通过代码动态地创建和管理用户界面。</li>\n</ol>\n<h3 id=\"Fragment（片段）\"><a href=\"#Fragment（片段）\" class=\"headerlink\" title=\"Fragment（片段）\"></a>Fragment（片段）</h3><ol>\n<li><strong>定义</strong>：Fragment 是 Android 应用中的另一个基本组件，代表了一个可复用的用户界面模块，可以在一个 Activity 中嵌套多个 Fragment。</li>\n<li><strong>作用</strong>：Fragment 主要用于构建灵活的用户界面，允许开发者将应用程序的功能拆分成可重用的模块，并在不同的屏幕尺寸和设备方向下进行适配。</li>\n<li><strong>生命周期</strong>：Fragment 也有自己的生命周期方法，与 Activity 的生命周期方法类似，包括 <code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code> 等。</li>\n<li><strong>布局</strong>：Fragment 可以拥有自己的布局文件（XML 文件），也可以在宿主 Activity 中动态添加到布局中，允许开发者在运行时动态地添加、替换和移除 Fragment。</li>\n</ol>\n<p>总的来说，Activity 通常代表一个完整的屏幕，而 Fragment 则是 Activity 中一个可重用的组成部分，可以在一个 Activity 中组合多个 Fragment 来构建复杂的用户界面。在实际开发中，Activity 和 Fragment 经常一起使用，以实现灵活和高效的用户界面设计。</p>\n<p>在 Kotlin 中，<code>?.</code> 是安全调用运算符，用于在对象为非空时调用其方法或访问其属性。如果对象为 null，则安全调用运算符会短路并返回 null，而不会抛出空指针异常。</p>\n<p>在你提供的代码中，<code>data?.getStringExtra(&quot;data_return&quot;)</code> 的意思是，如果 <code>data</code> 不为 null，则调用 <code>getStringExtra(&quot;data_return&quot;)</code> 方法来获取名为 “data_return” 的额外数据，否则返回 null。这种写法可以避免在 <code>data</code> 为 null 时引发空指针异常。</p>\n<p><code>registerForActivityResult(...)</code>：这是一个用于注册 Activity Result 的函数。它接受一个 <code>ActivityResultContract</code> 对象作为参数，并返回一个 <code>ActivityResultLauncher</code> 对象。<code>ActivityResultContract</code> 是一个接口，用于定义活动启动和结果处理之间的合同。</p>\n<p>Activity类中定义了7个回调方法，覆盖了Activity生命周期的每一个环节:</p>\n<ul>\n<li><p>onCreate() 在Activity第一次被创建时调用</p>\n</li>\n<li><p>onStart() 由不可见到可见时调用</p>\n</li>\n<li><p>onResume()。这个方法在Activity准备好和用户进行交互的时候调用。此时的Activity一</p>\n<p>定位于返回栈的栈顶，并且处于运行状态。</p>\n</li>\n<li><p>onPause()。这个方法在系统准备去启动或者恢复另一个Activity的时候调用。我们通常</p>\n<p>会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执</p>\n<p>行速度一定要快，不然会影响到新的栈顶Activity的使用。</p>\n</li>\n<li><p>onStop()。这个方法在Activity完全不可见的时候调用。它和onPause()方法的主要区</p>\n<p>别在于，如果启动的新Activity是一个对话框式的Activity，那么onPause()方法会得到执行，而onStop()方法并不会执行。</p>\n</li>\n<li><p>onDestroy()。这个方法在Activity被销毁之前调用，之后Activity的状态将变为销毁状态。</p>\n</li>\n<li><p>onRestart()。这个方法在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。</p>\n</li>\n</ul>\n<p><code>onPause()</code> 方法是 Android Activity 生命周期中的一个回调方法，用于指示当前 Activity 正在失去焦点并即将暂停其可见性。当某些事件发生时，系统会调用 <code>onPause()</code> 方法，这些事件包括：</p>\n<ol>\n<li>启动另一个 Activity：当用户启动另一个 Activity 并且当前 Activity 失去焦点时，系统会调用 <code>onPause()</code> 方法。例如，当用户点击应用中的按钮，打开新的 Activity 时，当前 Activity 将暂停。</li>\n<li>打开对话框或弹出窗口：如果当前 Activity 打开了对话框、弹出了一个窗口或者其他部分覆盖了当前 Activity 但不完全遮挡，系统也会调用 <code>onPause()</code> 方法。</li>\n<li>接收到来电或其他中断：当用户接收到来电、收到短信或者其他中断事件时，当前 Activity 也会暂停，系统会调用 <code>onPause()</code> 方法。</li>\n<li>用户按下 Home 键或切换到最近任务列表：当用户按下 Home 键返回桌面或切换到最近任务列表时，当前 Activity 也会暂停，系统会调用 <code>onPause()</code> 方法。</li>\n</ol>\n<p>总之，<code>onPause()</code> 方法的调用情况涵盖了当前 Activity 失去焦点并即将暂停可见性的各种情况。</p>\n<p><code>onStart()</code> 是 Android 活动生命周期中的一个方法，用于指示活动即将变为可见状态。当活动首次启动或从停止状态恢复到活动栈时，系统会调用 <code>onStart()</code> 方法。</p>\n<p>具体情况下，<code>onStart()</code> 方法会在以下几种情况下被调用：</p>\n<ol>\n<li><strong>当活动首次启动</strong>：当用户启动应用程序并打开了包含该活动的界面时，系统会调用活动的 <code>onStart()</code> 方法。此时，活动将从不可见状态转变为可见状态。</li>\n<li><strong>当活动从暂停状态恢复</strong>：如果一个活动从 <code>onPause()</code> 状态恢复到前台状态，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。</li>\n</ol>\n<p>在 <code>onStart()</code> 方法中，通常执行一些与界面相关的初始化操作，比如恢复 UI 状态、注册广播接收器或者启动一些后台任务。需要注意的是，尽管活动已经变为可见状态，但此时活动并未处于用户的焦点下，用户可能无法与其进行交互。</p>\n<p><code>onResume()</code> 是 Android 活动生命周期中的一个方法，用于指示活动即将成为用户焦点并开始与用户进行交互。当活动从不可见状态变为可见状态，并且用户可以开始与其进行交互时，系统会调用 <code>onResume()</code> 方法。</p>\n<p>具体情况下，<code>onResume()</code> 方法会在以下几种情况下被调用：</p>\n<ol>\n<li><strong>当活动首次启动</strong>：当用户首次启动应用程序并打开了包含该活动的界面时，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。此时，活动将从不可见状态转变为可见状态，并且用户可以开始与其进行交互。</li>\n<li><strong>当活动从暂停状态恢复</strong>：如果一个活动从 <code>onPause()</code> 状态恢复到前台状态，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。</li>\n<li><strong>当活动从停止状态恢复</strong>：如果一个活动从 <code>onStop()</code> 状态恢复到前台状态，系统会依次调用 <code>onRestart()</code>、<code>onStart()</code> 和 <code>onResume()</code> 方法。这种情况通常发生在用户按下 Home 键后再次打开应用程序的情况下。</li>\n</ol>\n<p>在 <code>onResume()</code> 方法中，通常执行一些与活动生命周期相关的操作，比如恢复用户的输入状态、启动动画效果或者连接到一些外部服务。需要注意的是，当活动处于 <code>onResume()</code> 状态时，它已经成为了用户焦点下的活动，并且用户可以直接与其进行交互。</p>\n<p><img src=\"/../images/image-20240422135757284.png\" alt=\"image-20240422135757284\"></p>\n<p>当将视图或布局的尺寸设置为 “wrap_content” 时，系统会根据其内容自动调整视图或布局的尺寸，以便刚好容纳其内</p>\n<p>在 Android 的清单文件（AndroidManifest.xml）中声明活动（Activity）时，可以使用两种方式：</p>\n<ol>\n<li><code>&lt;activity&gt;...&lt;/activity&gt;</code>：这是一种传统的 XML 标签方式，用于定义活动的属性和行为。在 <code>&lt;activity&gt;</code> 标签中，可以指定活动的各种属性，例如名称、图标、主题等，并且可以包含其他标签和属性以提供更详细的配置。通常情况下，你可以在 <code>&lt;activity&gt;</code> 标签内部设置更多的属性，包括活动的名称、图标、主题等，以及与活动相关的其他设置。</li>\n<li><code>&lt;activity/&gt;</code>：这是一种自闭合的 XML 标签方式，用于简单地声明一个活动而不指定任何属性或配置。这种方式适用于简单的活动声明，当你不需要指定任何属性或配置时，可以使用这种方式。例如，如果你的活动只需要基本的声明，而不需要指定任何其他属性或配置，你可以使用 <code>&lt;activity/&gt;</code> 标签。</li>\n</ol>\n<p>因此，你应该根据活动的具体需求和配置选择适当的方式。如果需要指定活动的各种属性和配置，可以使用 <code>&lt;activity&gt;...&lt;/activity&gt;</code> 标签；如果活动只需要基本的声明而不需要指定任何其他属性或配置，可以使用 <code>&lt;activity/&gt;</code> 标签。</p>\n<p><code>@style/Theme.AppCompat.Dialog</code> 是指在 Android 应用程序中使用的一个预定义的对话框主题样式。这个样式通常用于创建对话框，即弹出式窗口，以在应用程序中显示临时信息、接受用户输入或执行其他操作。</p>\n<p>这个主题样式基于 AppCompat 库提供的默认对话框主题进行定义，并且与 AppCompat 库中其他主题一样，它提供了跨不同 Android 版本的一致外观和行为。这样，你的应用程序就可以在不同版本的 Android 上保持一致的外观和用户体验。</p>\n<p><code>android:exported=&quot;false&quot;</code> 是 Android 清单文件中 <code>&lt;activity&gt;</code> 元素的一个属性，用于指定该活动是否能够被其他应用程序组件或者系统组件访问。具体含义如下：</p>\n<ul>\n<li>如果 <code>android:exported=&quot;false&quot;</code>，则表示该活动不会被其他应用程序或系统组件调用。这意味着该活动只能被声明它的应用程序内部的组件所访问，其他应用程序或系统组件无法直接启动或与其交互。</li>\n<li>如果 <code>android:exported=&quot;true&quot;</code>，则表示该活动可以被其他应用程序或系统组件调用。这意味着其他应用程序可以使用显式或隐式意图启动该活动，并且与其进行交互。</li>\n</ul>\n<p>在你的示例中，<code>android:exported=&quot;false&quot;</code> 意味着 <code>DialogActivity</code> 这个活动不会被其他应用程序或系统组件访问。它只能被声明它的应用程序内部的组件所访问，其他应用程序无法直接启动或与其交互。这通常用于内部使用的活动，例如只在应用程序内部使用的对话框或者配置界面。</p>\n<p>在 Android 开发中，<code>Intent</code>（意图）是用于在不同组件之间传递数据或执行操作的对象。它是一种在 Android 应用程序中实现组件之间通信的重要机制。</p>\n<p><code>Intent</code> 主要有两种类型：显式 Intent 和隐式 Intent。</p>\n<ol>\n<li><p><strong>显式 Intent</strong>：用于启动应用程序内部的组件，例如启动另一个活动（Activity）、启动服务（Service）等。显式 Intent 通过指定目标组件的类名来明确指示要执行的操作。</p>\n<p>示例：</p>\n</li>\n</ol>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">Intent intent = new Intent(this, AnotherActivity.class);</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">startActivity(intent);</span></span></code></pre></div><p><strong>隐式 Intent</strong>：用于启动应用程序内或其他应用程序中具有特定功能的组件，而不需要指定目标组件的类名。隐式 Intent 根据指定的动作（Action）、数据（Data）等信息来寻找合适的组件执行操作。</p>\n<p>示例：</p>\n<ol>\n<li><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.example.com&quot;));</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">startActivity(intent);</span></span></code></pre></div></li>\n</ol>\n<p><code>Intent</code> 的主要作用包括但不限于：</p>\n<ul>\n<li>启动活动、服务或广播接收器等组件。</li>\n<li>在组件之间传递数据，例如在不同活动之间传递参数。</li>\n<li>执行一些系统级别的操作，例如拨打电话、发送短信、打开网页等。</li>\n</ul>\n<p>总之，<code>Intent</code> 是 Android 应用程序中用于实现组件之间通信和执行操作的重要机制。</p>\n<p>在 Android 中，<code>Bundle</code> 是一个用来存储键值对数据的容器类。它通常被用于在不同的组件（如活动、片段）之间传递数据，或者在组件销毁和重新创建时保存和恢复数据的状态。</p>\n<p>在 <code>onCreate()</code> 方法中，<code>Bundle</code> 参数 <code>savedInstanceState</code> 表示上一个实例状态的数据。当活动被销毁并重新创建时（例如，由于设备旋转或内存紧张），Android 系统会调用 <code>onSaveInstanceState()</code> 方法来保存当前的状态数据，并将其存储在 <code>Bundle</code> 中。然后，在活动重新创建时，系统会将之前保存的状态数据传递给 <code>onCreate()</code> 方法的 <code>savedInstanceState</code> 参数。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">Log.d(&quot;FirstActivity&quot;, this.toString())</span></span></code></pre></div><p><code>this.toString()</code> 是调用当前对象的 <code>toString()</code> 方法。在 Java 中，几乎所有的对象都继承自 <code>Object</code> 类，而 <code>Object</code> 类中有一个 <code>toString()</code> 方法，用于返回对象的字符串表示形式</p>\n<p>当你调用 <code>this.toString()</code> 时，它会返回当前对象的字符串表示形式</p>\n<p>Activity的启动模式:</p>\n<ul>\n<li>standard</li>\n<li>singleTop  单栈顶</li>\n<li>singleTask   单任务</li>\n<li>singleInstance  单实例</li>\n</ul>\n<p>在 Kotlin 中，<code>object</code> 关键字用于定义单例对象。单例对象是指在程序运行期间只有一个实例存在的对象。在给定的作用域内，单例对象只能有一个实例，因此它们非常适合用于管理全局状态或提供全局访问点。</p>\n<p>关闭所有活动并不等同于关闭应用程序的进程。在 Android 应用程序中，当你调用 <code>finish()</code> 方法结束一个活动时，这个活动会被销毁，但应用程序的进程仍然在运行。即使所有活动都被销毁，应用程序的进程仍然存在于系统中。</p>\n<p>为了完全退出应用程序，有时需要调用 <code>System.exit(0)</code> 或者 <code>Process.killProcess(Process.myPid())</code> 这样的方法来结束应用程序的进程。这样做可以确保应用程序的所有组件都被终止，包括活动、服务、广播接收器等，从而实现应用程序的完全退出。</p>\n<p>然而，这种做法通常被视为不推荐的，因为它可能会导致用户体验上的问题，以及系统资源的浪费。通常情况下，Android 系统会自动管理应用程序的进程，并在必要时终止它们，而不需要手动干预。因此，大多数情况下，关闭所有活动即可满足应用程序退出的需求，而无需手动杀死进程。</p>\n<p>在 Kotlin 中，<code>companion object</code>（伴生对象）具有以下作用：</p>\n<ol>\n<li><strong>静态成员访问</strong>：伴生对象中的成员可以直接通过类名访问，就像 Java 中的静态成员一样。这使得可以在不创建类的实例的情况下访问这些成员。</li>\n<li><strong>工厂方法</strong>：可以在伴生对象中定义工厂方法，用于创建类的实例。这种方法通常用于隐藏类的构造函数，提供一种更灵活的方式来创建实例。</li>\n<li><strong>共享代码</strong>：伴生对象可以包含在类的所有实例之间共享的代码或常量。这些代码或常量对于类的所有实例都是相同的，可以方便地通过伴生对象访问。</li>\n<li><strong>扩展方法</strong>：在伴生对象中还可以定义扩展方法，这些方法可以为类添加额外的功能，而无需继承或修改类的源代码。</li>\n</ol>\n<p>总的来说，伴生对象提供了一种在 Kotlin 中实现类级别功能的方式，它可以用于静态成员访问、工厂方法、共享代码和扩展方法等场景。</p>\n<p>StringBuilder是Java中的一个类，用于处理字符串。它允许你在不创建新的String对象的情况下进行字符串的修改和操作，这样可以提高性能并节省内存。</p>\n<p>当你需要对字符串进行频繁的修改时，使用StringBuilder通常比直接使用String更高效。这是因为String是不可变的，每次对String进行修改都会创建一个新的String对象，而StringBuilder允许你在同一个对象上执行多次修改操作。</p>\n<p>你可以使用StringBuilder的append()方法来添加字符串，使用delete()方法来删除字符串，使用insert()方法来在指定位置插入字符串，使用replace()方法来替换字符串等等。最后，你可以使用toString()方法将StringBuilder对象转换为String对象，以便进行进一步的操作或输出。</p>\n<p><code>val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val builder = StringBuilder() builder.append(&quot;Start eating fruits.\\n&quot;) for (fruit in list) &#123; builder.append(fruit).append(&quot;\\n&quot;) &#125; builder.append(&quot;Ate all fruits.&quot;) val result = builder.toString() println(result) 为什么最后要调用builder.toString()</code>，不能直接打印吗</p>\n<p>在上面的代码中，builder是一个StringBuilder对象，而println函数通常接受String类型的参数来进行输出。而builder对象是一个StringBuilder类型的对象，不是String类型的对象，因此无法直接传递给println函数。</p>\n<p>调用builder.toString()方法将StringBuilder对象转换为String类型的对象，这样就可以将其作为参数传递给println函数，从而实现输出。toString()方法会返回StringBuilder对象中包含的所有字符序列作为一个字符串。</p>\n<p>因此，为了能够正确地输出builder对象中的内容，需要先调用toString()方法将其转换为String类型的对象，然后再传递给println函数进行打印。</p>\n<p><code>with</code> 是 Kotlin 的一个标准库函数，它提供了一种简洁的方式来执行针对特定对象的一系列操作，并返回最后一个表达式的结果。</p>\n<p><code>AlertDialog.Builder(this).apply &#123; setTitle(&quot;This is Dialog&quot;) setMessage(&quot;Something important.&quot;) setCancelable(false) setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; &#125; setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; &#125; show()</code> 是什么意思</p>\n<p>这段代码是使用 Kotlin 的标准库函数 <code>apply</code> 来构建一个 <code>AlertDialog</code> 对话框，并设置其标题、消息、按钮等属性。下面是代码的解释：</p>\n<ol>\n<li><code>AlertDialog.Builder(this)</code>：创建了一个 <code>AlertDialog.Builder</code> 的实例，这个实例用于构建一个对话框。</li>\n<li><code>apply &#123; ... &#125;</code>：<code>apply</code> 是一个 Kotlin 标准库函数，它接收一个 lambda 表达式作为参数，并在 lambda 表达式的作用域内执行一系列操作。在这个例子中，<code>apply</code> 函数被调用后，会将调用者对象（即 <code>AlertDialog.Builder</code> 的实例）作为参数传递给 lambda 表达式，并在 lambda 表达式内部执行一系列设置操作。</li>\n<li><code>setTitle(&quot;This is Dialog&quot;)</code>：在 lambda 表达式中调用 <code>setTitle</code> 方法，设置对话框的标题为 “This is Dialog”。</li>\n<li><code>setMessage(&quot;Something important.&quot;)</code>：在 lambda 表达式中调用 <code>setMessage</code> 方法，设置对话框的消息内容为 “Something important.”。</li>\n<li><code>setCancelable(false)</code>：在 lambda 表达式中调用 <code>setCancelable</code> 方法，设置对话框为不可取消状态，即用户点击对话框外部或返回键时不会关闭对话框。</li>\n<li><code>setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; ... &#125;</code>：在 lambda 表达式中调用 <code>setPositiveButton</code> 方法，设置对话框的确定按钮文本为 “OK”，并设置点击事件处理器。在这里，<code>&#123; dialog, which -&gt; ... &#125;</code> 是一个 lambda 表达式，表示当用户点击确定按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。</li>\n<li><code>setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; ... &#125;</code>：在 lambda 表达式中调用 <code>setNegativeButton</code> 方法，设置对话框的取消按钮文本为 “Cancel”，并设置点击事件处理器。同样，<code>&#123; dialog, which -&gt; ... &#125;</code> 是一个 lambda 表达式，表示当用户点击取消按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。</li>\n<li><code>show()</code>：在所有设置完成后，调用 <code>show</code> 方法显示对话框。</li>\n</ol>\n<p>因此，这段代码的作用是创建一个带有标题、消息、确定按钮和取消按钮的对话框，并将其显示在界面上。</p>\n<p>三种基本布局：</p>\n<ul>\n<li>LinearLayout垂直排布</li>\n<li>RelativeLayout相对布局</li>\n<li>FrameLayout帧布局</li>\n</ul>\n<p><img src=\"/../images/image-20240423231325479.png\" alt=\"image-20240423231325479\"></p>\n<p><code>override fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123; val view = LayoutInflater.from(context).inflate(resourceId, parent, false) val fruitImage: ImageView = view.findViewById(R.id.fruitImage) val fruitName: TextView = view.findViewById(R.id.fruitName) val fruit = getItem(position) // 获取当前项的Fruit实例 if (fruit != null) &#123; fruitImage.setImageResource(fruit.imageId) fruitName.text = fruit.name &#125; return view &#125;</code></p>\n<p>其中：val view &#x3D; LayoutInflater.from(context).inflate(resourceId, parent, false)</p>\n<p>作用是从 XML 布局文件中创建一个视图对象，并将其添加到指定的父视图中。</p>\n<p>解释每个参数的含义：</p>\n<ul>\n<li><code>context</code>: 表示当前的上下文环境，通常是一个 Activity 或 Fragment 的实例。</li>\n<li><code>resourceId</code>: 表示要加载的布局文件的资源 ID，即 XML 文件的唯一标识符。</li>\n<li><code>parent</code>: 表示要将创建的视图添加到的父视图，通常是一个 ViewGroup，比如一个 LinearLayout 或者一个 RecyclerView。</li>\n<li><code>false</code>: 表示在加载布局文件时，不将其添加到父视图中。这个参数设置为 <code>false</code> 表示我们会手动将视图添加到父视图中，而不是在加载时自动添加。</li>\n</ul>\n<p>接口在编程中有多种作用，包括但不限于以下几个方面：</p>\n<ol>\n<li><strong>定义约束和契约</strong>：接口定义了一组方法或属性的规范，实现该接口的类必须提供这些方法或属性的具体实现。这种约束和契约使得代码更加清晰，使得不同的类可以共享相同的行为规范。</li>\n<li><strong>实现多态</strong>：通过接口，可以实现多态，即在不同的类中使用相同的方法名，但实际调用的是各自类的具体实现。这样可以提高代码的灵活性和可扩展性。</li>\n<li><strong>代码重用</strong>：接口可以用于定义通用的行为规范，使得多个类可以共享相同的接口定义，从而实现代码的重用。当多个类具有相似的行为或功能时，可以通过接口来统一定义这些行为或功能，避免重复编写代码。</li>\n<li><strong>降低耦合性</strong>：通过接口，类与类之间的耦合度可以降低，因为类之间通过接口进行交互，而不是直接依赖于具体的实现。这样，当一个类的实现发生变化时，只需要修改实现该接口的类，而不需要修改其他使用该类的代码。</li>\n<li><strong>接口委托</strong>：接口支持委托，一个接口可以通过另一个对象来实现其方法，这种方式称为接口委托。这种机制可以进一步提高代码的灵活性和可复用性。</li>\n</ol>\n<p>总的来说，接口是一种重要的编程工具，可以帮助程序员设计出更加灵活、可扩展和易于维护的代码结构。</p>\n","feature":true,"text":"txt`class FirstActivity : AppCompatActivity() &#123;` `override fun onCreate(sav...","permalink":"/post/Android-Kotlin","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Activity%EF%BC%88%E6%B4%BB%E5%8A%A8%EF%BC%89\"><span class=\"toc-text\">Activity（活动）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fragment%EF%BC%88%E7%89%87%E6%AE%B5%EF%BC%89\"><span class=\"toc-text\">Fragment（片段）</span></a></li></ol>","author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"FPGA","uid":"47d8fddcd3299307e9e74bee0c7b2069","slug":"FPGA","date":"2024-04-24T03:03:09.000Z","updated":"2024-04-26T07:37:34.734Z","comments":true,"path":"api/articles/FPGA.json","keywords":null,"cover":[],"text":"assign 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在alw...","permalink":"/post/FPGA","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Inference_Framework","uid":"4961e15af02b68ebd599dc1652c0f600","slug":"Inference-Framework","date":"2024-04-13T09:01:40.000Z","updated":"2024-04-22T02:35:07.827Z","comments":true,"path":"api/articles/Inference-Framework.json","keywords":null,"cover":null,"text":"","permalink":"/post/Inference-Framework","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}