{"title":"Android_Kotlin","uid":"6df1dc6e24cc645f9148dbaf83a17c60","slug":"Android-Kotlin","date":"2024-04-21T12:52:23.000Z","updated":"2024-04-22T02:29:22.063Z","comments":true,"path":"api/articles/Android-Kotlin.json","keywords":null,"cover":null,"content":"<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">`class FirstActivity : AppCompatActivity() &#123;`</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`override fun onCreate(savedInstanceState: Bundle?) &#123;`</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`super.onCreate(savedInstanceState)`</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`&#125;`</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">`&#125;`</span></span></code></pre></div><p>这段代码是使用 Kotlin 语言编写的 Android 应用程序中的一个活动（Activity）类。让我逐步解释其中的内容：</p>\n<ol>\n<li><code>class FirstActivity : AppCompatActivity()</code>：这是一个类的声明，类名为 <code>FirstActivity</code>，并且继承自 <code>AppCompatActivity</code> 类。<code>AppCompatActivity</code> 是 Android 开发中常用的一个基类，用于支持应用程序在较旧的 Android 版本上提供向后兼容性。</li>\n<li><code>override fun onCreate(savedInstanceState: Bundle?)</code>：这是 <code>FirstActivity</code> 类中的一个方法 <code>onCreate()</code> 的重写。在 Android 中，<code>onCreate()</code> 方法是活动生命周期的一部分，在活动第一次创建时被调用。<code>savedInstanceState</code> 参数是一个 <code>Bundle</code> 对象，其中包含了之前保存的活动状态信息，可以用于在活动重新创建时恢复状态。</li>\n<li><code>super.onCreate(savedInstanceState)</code>：这是调用父类 <code>AppCompatActivity</code> 中的 <code>onCreate()</code> 方法，确保父类中的初始化工作得以执行。</li>\n</ol>\n<p>因此，这段代码定义了一个名为 <code>FirstActivity</code> 的活动类，当该活动第一次创建时，会调用父类的 <code>onCreate()</code> 方法进行初始化。</p>\n<p>在声明 <code>savedInstanceState</code> 参数时，如果在类型后面添加了 <code>?</code>，则表示该参数可以接受 <code>null</code> 值。</p>\n<p>这样做的目的是为了允许 <code>savedInstanceState</code> 参数在某些情况下为 null，例如当活动或片段首次创建时，<code>savedInstanceState</code> 可能为 null，因为此时还没有保存任何状态信息。</p>\n<p>在 Kotlin 中，如果没有使用 <code>?</code>，则表示该参数不接受 null 值，如果在实际使用中传递了 null 值，编译器将会报错。而使用了 <code>?</code> 后，表示该参数可以接受 null 值，编译器将不会报错。</p>\n<p>因此，在 <code>override fun onCreate(savedInstanceState: Bundle?)</code> 中，<code>Bundle?</code> 表示 <code>savedInstanceState</code> 参数可以接受 null 值，即在某些情况下，<code>savedInstanceState</code> 可能为 null。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:orientation=&quot;vertical&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:layout_width=&quot;match_parent&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:layout_height=&quot;match_parent&quot;&gt;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&lt;Button</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:id=&quot;@+id/button1&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:layout_width=&quot;match_parent&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:layout_height=&quot;wrap_content&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">android:text=&quot;Button 1&quot;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">/&gt;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&lt;/LinearLayout&gt;</span></span></code></pre></div><p>这段代码是一个简单的 Android 布局文件，使用 XML 格式描述了一个线性布局（LinearLayout）以及一个按钮（Button）的布局和属性。</p>\n<p>让我解释其中的一些关键部分：</p>\n<ul>\n<li><code>&lt;LinearLayout&gt;</code>：这是一个布局容器，用于在垂直方向排列其子视图（例如按钮）。<code>xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</code> 是 XML 命名空间声明，它使得可以在 XML 文件中使用 Android 提供的属性和元素。</li>\n<li><code>android:orientation=&quot;vertical&quot;</code>：这个属性指定了线性布局的方向，即垂直方向。这意味着其中的子视图（此处为按钮）将会按照垂直方向排列。</li>\n<li><code>android:layout_width=&quot;match_parent&quot;</code> 和 <code>android:layout_height=&quot;match_parent&quot;</code>：这两个属性指定了布局的宽度和高度。<code>match_parent</code> 表示该布局将会填充其父容器的宽度或高度，以占据尽可能多的空间。</li>\n<li><code>&lt;Button&gt;</code>：这是一个按钮视图，在布局中用于响应用户的点击事件。</li>\n<li><code>android:id=&quot;@+id/button1&quot;</code>：这个属性为按钮指定了一个唯一的标识符，可以在 Java 代码中使用这个标识符来查找和操作这个按钮。</li>\n<li><code>wrap_content</code> 属性可以使得布局更加灵活，可以根据内容的大小动态调整视图的尺寸，而不是固定为特定的尺寸。</li>\n<li><code>android:text=&quot;Button 1&quot;</code>：这个属性为按钮设置了显示的文本内容为 “Button 1”。</li>\n</ul>\n<p>因此，这段代码描述了一个垂直排列的线性布局，其中包含一个按钮，按钮显示文本为 “Button 1”。按钮的宽度会填充父容器的宽度，而高度则根据按钮文本的大小动态调整。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">class FirstActivity : AppCompatActivity() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">super.onCreate(savedInstanceState)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">setContentView(R.layout.first_layout)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>首先调用了 <code>super.onCreate(savedInstanceState)</code>，以确保调用了父类的 <code>onCreate()</code> 方法，以便执行必要的初始化操作。</p>\n<p>接着调用了 <code>setContentView(R.layout.first_layout)</code> 方法，这个方法用于设置该活动所使用的布局文件。在这里，<code>first_layout</code> 是指定的布局资源文件的名称，这个布局文件定义了活动的界面布局结构。</p>\n<p>因此，这段代码的作用是在 <code>FirstActivity</code> 中设置了一个布局文件 <code>first_layout</code> 作为活动的界面布局，并在活动创建时加载该布局。</p>\n<p><code>R.layout</code> 是一个自动生成的资源标识符类，它包含了项目中所有布局文件的引用。在 Android 开发中，资源文件（如布局文件、字符串、图像等）都需要通过资源标识符来访问和引用。</p>\n<p>当你在项目中创建布局文件时，每个布局文件都会被编译成一个资源标识符，以便在代码中进行引用。这些资源标识符都会被统一放置在 <code>R</code> 类的内部静态类中，而 <code>R.layout</code> 则是其中用于引用布局文件的子类之一。</p>\n<p>Intent—&gt;用于通信的消息对象</p>\n<p>在 Android 中，Intent 是一种用于在不同组件之间进行通信的对象。它可以用于启动活动（Activity）、启动服务（Service）、发送广播（Broadcast）以及执行其他各种操作。Intent 提供了一种在不同组件之间传递数据和执行操作的机制。</p>\n<p>Intent 本质上是一个消息对象，用于指示想要执行的操作。它可以包含以下信息：</p>\n<ol>\n<li><strong>操作（Action）</strong>：指示要执行的操作，如启动活动、启动服务、发送广播等。常见的操作包括 <code>android.intent.action.VIEW</code>（查看操作）、<code>android.intent.action.SEND</code>（发送操作）、<code>android.intent.action.MAIN</code>（主操作）等。</li>\n<li><strong>数据（Data）</strong>：用于指定操作的数据，可以是 URI、文件路径、文本等。例如，如果要查看网页，可以将网页的 URL 作为数据传递给 Intent。</li>\n<li><strong>类别（Category）</strong>：用于指定操作的类别，如 <code>android.intent.category.LAUNCHER</code>（启动器类别）、<code>android.intent.category.BROWSABLE</code>（可浏览类别）等。</li>\n<li><strong>附加信息（Extras）</strong>：用于传递额外的数据给目标组件。Extras 是键值对的形式，可以包含各种数据类型，如字符串、整数、布尔值等。</li>\n</ol>\n<p>Intent 可以分为两种类型：</p>\n<ul>\n<li><strong>显式 Intent</strong>：明确定义了目标组件的类名，用于启动特定的组件。</li>\n<li><strong>隐式 Intent</strong>：没有明确指定目标组件，而是根据 Intent 的操作、数据等信息由系统来匹配合适的组件。</li>\n</ul>\n<p>通过使用 Intent，Android 应用程序可以实现各种功能，例如启动新的活动、执行后台任务、发送广播等，从而实现各种复杂的交互和功能。</p>\n<p>Kotlin直接可以：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">super.onCreate(savedInstanceState)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">setContentView(R.layout.first_layout)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">button1.setOnClickListener &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">Toast.makeText(this, &quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show()</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>在 Kotlin 中，函数声明的语法是：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">fun 函数名(参数列表): 返回值类型 &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">    // 函数体</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p>其中，返回值类型在函数名和参数列表之后，使用冒号 <code>:</code> 来标识。在这个语法中，返回值类型是必须的，但在某些情况下，如果函数没有返回值，可以将返回值类型指定为 <code>Unit</code>，或者省略返回值类型（在这种情况下，编译器会自动推断返回值类型为 <code>Unit</code>）。例如：</p>\n<div class=\"language-kotlin\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">kotlin</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">kotlin</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">fun</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">greet</span><span style=\"color: #BABED8\">(name: </span><span style=\"color: #FFCB6B\">String</span><span style=\"color: #BABED8\">): </span><span style=\"color: #FFCB6B\">Unit</span><span style=\"color: #BABED8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #82AAFF\">println</span><span style=\"color: #BABED8\">(</span><span style=\"color: #C3E88D\">&quot;Hello, </span><span style=\"color: #BABED8\">$name</span><span style=\"color: #C3E88D\">!&quot;</span><span style=\"color: #BABED8\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">// 或者省略返回值类型，编译器会自动推断为 Unit</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">fun</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">greet</span><span style=\"color: #BABED8\">(name: </span><span style=\"color: #FFCB6B\">String</span><span style=\"color: #BABED8\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #82AAFF\">println</span><span style=\"color: #BABED8\">(</span><span style=\"color: #C3E88D\">&quot;Hello, </span><span style=\"color: #BABED8\">$name</span><span style=\"color: #C3E88D\">!&quot;</span><span style=\"color: #BABED8\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">override fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">menuInflater.inflate(R.menu.main, menu)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">return true</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">&#125;</span></span></code></pre></div><p><code>menuInflater</code> 是 Android 开发中的一个类，用于从 XML 文件中创建菜单对象。在 Android 中，通常使用 XML 文件定义应用程序中的菜单，然后通过 <code>MenuInflater</code> 类将这些 XML 文件中定义的菜单加载到应用程序中的菜单对象中，以供在用户界面中显示和操作。</p>\n<p>具体来说，<code>menuInflater.inflate()</code> 方法用于将一个 XML 文件中定义的菜单资源加载到一个 <code>Menu</code> 对象中，这样就可以在应用程序的用户界面中显示这个菜单。</p>\n<p>在 Android 应用程序中，Activity 和 Fragment 是两种重要的组件，用于构建用户界面和处理用户交互。它们都可以包含用户界面的布局，并且可以响应用户的输入事件（如点击、滑动等）。</p>\n<p>下面是关于 Activity 和 Fragment 的简要介绍：</p>\n<h3 id=\"Activity（活动）\"><a href=\"#Activity（活动）\" class=\"headerlink\" title=\"Activity（活动）\"></a>Activity（活动）</h3><ol>\n<li><strong>定义</strong>：Activity 是 Android 应用中的一个基本组件，代表一个单独的用户界面屏幕，通常是一个窗口、一个对话框或全屏显示的窗口。</li>\n<li><strong>作用</strong>：Activity 主要负责管理用户与应用程序之间的交互，包括接收用户输入、处理用户操作，并在屏幕上显示相应的界面。</li>\n<li><strong>生命周期</strong>：Activity 具有丰富的生命周期方法，如 <code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code> 等，开发者可以根据需要重写这些方法来执行相应的操作。</li>\n<li><strong>布局</strong>：Activity 可以通过设置布局文件（XML 文件）来定义用户界面的外观和行为，也可以通过代码动态地创建和管理用户界面。</li>\n</ol>\n<h3 id=\"Fragment（片段）\"><a href=\"#Fragment（片段）\" class=\"headerlink\" title=\"Fragment（片段）\"></a>Fragment（片段）</h3><ol>\n<li><strong>定义</strong>：Fragment 是 Android 应用中的另一个基本组件，代表了一个可复用的用户界面模块，可以在一个 Activity 中嵌套多个 Fragment。</li>\n<li><strong>作用</strong>：Fragment 主要用于构建灵活的用户界面，允许开发者将应用程序的功能拆分成可重用的模块，并在不同的屏幕尺寸和设备方向下进行适配。</li>\n<li><strong>生命周期</strong>：Fragment 也有自己的生命周期方法，与 Activity 的生命周期方法类似，包括 <code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code> 等。</li>\n<li><strong>布局</strong>：Fragment 可以拥有自己的布局文件（XML 文件），也可以在宿主 Activity 中动态添加到布局中，允许开发者在运行时动态地添加、替换和移除 Fragment。</li>\n</ol>\n<p>总的来说，Activity 通常代表一个完整的屏幕，而 Fragment 则是 Activity 中一个可重用的组成部分，可以在一个 Activity 中组合多个 Fragment 来构建复杂的用户界面。在实际开发中，Activity 和 Fragment 经常一起使用，以实现灵活和高效的用户界面设计。</p>\n<p>在 Kotlin 中，<code>?.</code> 是安全调用运算符，用于在对象为非空时调用其方法或访问其属性。如果对象为 null，则安全调用运算符会短路并返回 null，而不会抛出空指针异常。</p>\n<p>在你提供的代码中，<code>data?.getStringExtra(&quot;data_return&quot;)</code> 的意思是，如果 <code>data</code> 不为 null，则调用 <code>getStringExtra(&quot;data_return&quot;)</code> 方法来获取名为 “data_return” 的额外数据，否则返回 null。这种写法可以避免在 <code>data</code> 为 null 时引发空指针异常。</p>\n","feature":true,"text":"txt`class FirstActivity : AppCompatActivity() &#123;` `override fun onCreate(sav...","permalink":"/post/Android-Kotlin","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Activity%EF%BC%88%E6%B4%BB%E5%8A%A8%EF%BC%89\"><span class=\"toc-text\">Activity（活动）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fragment%EF%BC%88%E7%89%87%E6%AE%B5%EF%BC%89\"><span class=\"toc-text\">Fragment（片段）</span></a></li></ol>","author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Inference_Framework","uid":"4961e15af02b68ebd599dc1652c0f600","slug":"Inference-Framework","date":"2024-04-13T09:01:40.000Z","updated":"2024-04-14T12:08:54.498Z","comments":true,"path":"api/articles/Inference-Framework.json","keywords":null,"cover":null,"text":"","permalink":"/post/Inference-Framework","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"IF","slug":"IF","count":1,"path":"api/tags/IF.json"}],"author":{"name":"Zgh","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}