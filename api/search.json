[{"id":"6423712d5b034a9ffa873eac01a6fcae","title":"raytracing","content":"","slug":"raytracing","date":"2024-06-12T08:08:14.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"基础：\nverilogmodule LED_Shift_Register (\n    input clk,       // 时钟输入\n    input rst,       // 复位信号\n    input [7:0] sw,  // 拨码开关输入\n    output reg [15:0] leds // LED输出\n);\n\nreg [3:0] counter; // 计数器\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter &lt;= 4&#39;b0000; // 复位计数器\n    end else begin\n        if (sw[7]) begin // 如果启停开关为1\n            if (counter == 4&#39;b1111) begin\n                counter &lt;= 4&#39;b0000; // 当计数器到达最大值时，重置计数器\n            end else begin\n                counter &lt;= counter + 1; // 否则递增计数器\n            end\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (sw[7]) begin // 如果启停开关为1\n        if (sw[0]) begin // 如果SW0为1，从左向右\n            leds &lt;= &#123;counter, 12&#39;b0&#125;; // 将计数器值作为LED输出\n        end else begin // 如果SW0为0，从右向左\n            leds &lt;= &#123;12&#39;b0, counter&#125;; // 将计数器值作为LED输出\n        end\n    end else begin\n        leds &lt;= 16&#39;b0; // 否则关闭LED\n    end\nend\n\nendmodule自动换向：\nverilogmodule LED_Shift_Register_AutoDirection (\n    input clk,       // 时钟输入\n    input rst,       // 复位信号\n    output reg [15:0] leds // LED输出\n);\n\nreg [3:0] counter; // 计数器\nreg direction; // 方向信号，0表示向左，1表示向右\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter &lt;= 4&#39;b0000; // 复位计数器\n        direction &lt;= 1&#39;b0; // 初始方向为向左\n    end else begin\n        if (counter == 4&#39;b1111) begin\n            counter &lt;= 4&#39;b0000; // 当计数器到达最大值时，重置计数器\n            direction &lt;= ~direction; // 切换方向\n        end else begin\n            counter &lt;= counter + 1; // 递增计数器\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (direction) begin // 如果方向为1，从右向左\n        leds &lt;= &#123;12&#39;b0, counter&#125;; // 将计数器值作为LED输出\n    end else begin // 如果方向为0，从左向右\n        leds &lt;= &#123;counter, 12&#39;b0&#125;; // 将计数器值作为LED输出\n    end\nend\n\nendmodule进阶：\nverilogmodule LED_Shift_Register_AutoDirection_SpeedControl (\n    input clk,       // 时钟输入\n    input rst,       // 复位信号\n    input sw0,       // 开关0，用于调节速度\n    output reg [15:0] leds // LED输出\n);\n\nreg [3:0] counter; // 计数器\nreg direction; // 方向信号，0表示向左，1表示向右\nreg [3:0] speed; // 速度调节器\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter &lt;= 4&#39;b0000; // 复位计数器\n        direction &lt;= 1&#39;b0; // 初始方向为向左\n        speed &lt;= 4&#39;b0000; // 初始速度为最慢\n    end else begin\n        if (counter == speed) begin\n            counter &lt;= 4&#39;b0000; // 当计数器计数达到速度值时，重置计数器\n            if (sw0) begin // 如果SW0为1，增加速度\n                if (speed &lt; 4&#39;b1111) begin\n                    speed &lt;= speed + 1; // 递增速度\n                end\n            end else begin // 如果SW0为0，减小速度\n                if (speed &gt; 4&#39;b0000) begin\n                    speed &lt;= speed - 1; // 递减速度\n                end\n            end\n            if (direction) begin // 如果方向为1，从右向左\n                if (leds != 16&#39;b0000000000000001) begin\n                    leds &lt;= &#123;leds[13:0], 2&#39;b00&#125; // 向右移动\n                end else begin\n                    direction &lt;= ~direction; // 切换方向\n                end\n            end else begin // 如果方向为0，从左向右\n                if (leds != 16&#39;b1000000000000000) begin\n                    leds &lt;= &#123;2&#39;b00, leds[15:2]&#125;; // 向左移动\n                end else begin\n                    direction &lt;= ~direction; // 切换方向\n                end\n            end\n        end else begin\n            counter &lt;= counter + 1; // 递增计数器\n        end\n    end\nend\n\nendmodule使用Vulkan对Xe显卡加速后能够达到50-60fps的速度，\n","slug":"王赫铭","date":"2024-06-03T08:27:57.905Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"5ed8025b2d97b0226e087fa7327026b0","title":"FOC","content":"可以看出，我们只需要像步进电机那样不断的重复这六部换向就可以让BLDC转动起来，甚至会产生一种错觉，是不是我们换向越快电机转的越快呢？答案是:否，这里我们一定要认识到，是当转子处于特定位置时才去触发换向操作，换向是被动换向，想要提高转速一定是要提高电流，让定子产生的磁场更强，让转子更快的达到目标点然后触发换向\n如何获得转子角度？我们已经知道了要先检测角度再去换向，那么如何检测当前角度呢？，有以下三种方式。1.通过安装编码器来计算出当前角度。2.通过安装霍尔元件计算当前角度。3.通过检测电流来计算当前角度\n编码器方式获取电机当前角度编码器方式分为两种，增量式编码器和绝对式编码器。增量式编码器：每次启动之气都需要做一次校准，而且为了防止单片机性能问题导致脉冲丢失，还需要对编码器每圈校准一次。因此经常使用ABZ三轴编码器，AB输出正交信号，Z轴输出中断。绝对式编码器：只需要在出厂之前做一次校准，之后如果没有拆机便不需要校准，通讯方式一般是SPI和IIC,需要考虑通讯时间对系统的影响。为什么要对编码器进行校准？因为我们无法保证在安装的时候让编码器的0°（机械角度）刚好对应电机绕组的0°（电气角度）\n\n伸开左手，使拇指与其他四指垂直且在一个平面内，让磁感线从手心流入，四指指向电流方向，大拇指指向的就是安培力方向（即导体受力方向）\n\n右手平展，使大拇指与其余四指垂直，并且都跟手掌在一个平面内。把右手放入磁场中，让磁感线从掌心进入（当磁感线为直线时，相当于手心面向N极），大拇指指向导线运动方向，则四指所指方向为导线中感应电流（动生电动势）的方向。\n\n根据想得到的电流矢量到u1,u2,u3上投影的正负，来判断在哪个扇区里，u1,u2,u3可由u_alpha,u_beta表示出\n\n\n\n\n\n\n从定子来计算\n可以计算出反电动势，进而计算转子的速度和位置（无感)\n当变压器的初级绕组通电后，线圈所产生的磁通在铁心流动，因为铁心本身也是导体（由硅钢片制成），在垂直于磁力线的平面上就会感应电势，这个电势在铁心的断面上形成闭合回路并产生电流，好象一个旋涡所以称为“涡流”。这个“涡流”使变压器的损耗增加，并且使变压器的铁心发热变压器的温升增加。由“涡流”所产生的损耗我们称为“铁损”。另外要绕制变压器需要用大量的铜线，这些铜导线存在着电阻，电流流过时这电阻会消耗一定的功率，这部分损耗往往变成热量而消耗，我们称这种损耗为“铜损”。铁损等于铜损时，变压器效率最高。大概就是变压器额定负荷的0.65倍左右。\n从绕组来计算（d,q,轴的电压方程）\n\n由于定子自感的属性，电流会滞后电压90度\n\n\n要等幅变换，所以要乘（2&#x2F;3）\n如果遇到乘(根号下2&#x2F;3),是等功率变换\n\n\n\n反帕克变换就是对帕克变换旋转矩阵求逆\nMOS管是电压驱动型，三极管是电流驱动型\n\n\n电角度&#x3D;极对数（或者级数&#x2F;2）*机械角度\n\n","slug":"FOC","date":"2024-05-28T23:30:54.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"da768801085088419c591cc57d0a037c","title":"openmv","content":"\n\n安装库libxcb-cursor.so.0，\nbashsudo apt install libxcb-cursor0","slug":"openmv","date":"2024-05-20T06:46:47.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"e9d18bf8d4206e6bf0f6f84c71e6472c","title":"OpenGL","content":"\n\nhttps://www.cnblogs.com/jiujiubashiyi/p/16429717.html\nGLFW,GLAD,opengl是什么，有什么联系\nGLFW、GLAD和OpenGL是计算机图形学中常用的三个库，它们之间存在着紧密的联系：\n\nOpenGL：是一个跨语言、跨平台的编程接口，用于渲染2D、3D向量图形。它是由硅谷图形公司（Silicon Graphics,  SGI）在1992年开发的。OpenGL是图形硬件制造商的标准，也是创作高质量计算机图形的基本工具。OpenGL提供了一个非常灵活的编程接口，让开发者能够利用它来渲染图形。\nGLFW：是一个跨平台的OpenGL应用程序接口（API）的多线程窗口和输入管理器。简单来说，GLFW用来创建窗口、处理输入事件（如键盘、鼠标点击等），并管理OpenGL上下文。它使得开发者可以比较容易地创建一个OpenGL环境，因为它简化了OpenGL程序中许多繁琐的设置步骤。\nGLAD：是一个自动生成OpenGL函数指针的库。在OpenGL中，许多操作需要通过指针来调用函数，而在不同的操作系统和硬件平台上，这些函数指针的位置可能会有所不同。GLAD就是用来处理这些函数指针的，它会根据当前的平台和OpenGL的版本自动生成对应的函数指针。这为开发者减少了处理这些底层细节的麻烦。\n\n它们之间的联系：\n\n使用OpenGL之前，需要创建一个OpenGL环境，这个环境包括一个窗口以及一个上下文，这是通过GLFW来完成的。\nGLAD用来确保所有的OpenGL函数调用都能够正确地指向相应的函数，这样开发者就不需要手动查找和设置这些函数指针了。\n通常，一个OpenGL程序的设置流程是这样的：首先初始化GLFW，然后使用GLFW创建一个窗口和OpenGL上下文，接着使用GLAD自动加载OpenGL函数，最后就可以开始使用OpenGL进行绘图了。\n\n综上，GLFW和GLAD都是帮助开发者更简单、更有效地使用OpenGL的辅助工具。通过它们，开发者可以专注于图形内容的创作，而不必担心底层的细节问题。\nglfwMakeContextCurrent(window);是什么意思\nglfwMakeContextCurrent(window); 是一行来自 GLFW（OpenGL Framework）库的代码。GLFW 是一个跨平台的库，用于窗口和输入处理，它使得创建 OpenGL 应用程序变得更加容易。\n这句代码的作用是将 OpenGL 渲染上下文关联到由 window 参数指定的窗口。在 OpenGL 中，渲染上下文是用来进行图形绘制的环境，它定义了一系列可以用来配置和控制渲染行为的设置。\n在创建窗口之后，必须调用 glfwMakeContextCurrent 函数来指定哪个窗口的上下文将被当前的线程使用。只有当前上下文中的 OpenGL 调用才会对指定的窗口产生影响。如果没有激活任何上下文，任何 OpenGL 调用都会导致错误。\n简单来说，当你想要在特定的窗口上绘制图形时，你需要确保该窗口的 OpenGL 上下文被设置为当前上下文。这就是 glfwMakeContextCurrent(window); 这行代码的目的。\ngladLoadGLLoader((GLADloadproc)glfwGetProcAddress) 是什么意思\ngladLoadGLLoader 是一个函数，通常在 C 或 C++ 程序中使用，用于初始化 OpenGL 函数指针。OpenGL 是一个用于渲染2D和3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。gladLoadGLLoader 函数是 GLAD 库的一部分，GLAD 是一个小型且易于使用的库，它负责在每次调用 OpenGL 函数之前，动态地加载和绑定正确的 OpenGL 函数指针。\nglfwGetProcAddress 是另一个函数，属于 GLFW 库（一个用于创建窗口、输入处理等的前端库，常与OpenGL一起使用）。glfwGetProcAddress 的作用是获取指向特定OpenGL函数的指针，该函数在OpenGL核心或者扩展中定义。\ntxtgladLoadGLLoader((GLADloadproc)glfwGetProcAddress)这表示在初始化GLAD库时，它将使用GLFW库提供的函数指针来加载OpenGL函数。这允许应用程序使用OpenGL函数，而不需要关心底层的具体实现细节。\n这种机制的好处是，应用程序只需要链接到一个库（比如GLFW），而GLFW会负责查找和加载正确的OpenGL函数。这样做可以简化应用程序的编写和维护工作，同时也确保了应用程序可以轻松地与不同平台的OpenGL版本兼容。\n双缓冲(Double Buffer)\n应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。\n\n顶点数组对象：Vertex Array Object，VAO\n顶点缓冲对象：Vertex Buffer Object，VBO\n元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO\n\n在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素.3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。(图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出)\n图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。\nOpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的\n\n为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做**图元(Primitive)**，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。\n图形渲染管线的第一个部分—-顶点着色器\n把3D坐标转为另一种3D坐标\n几何着色器\n一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状\n图元装配\n将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状\n光栅化阶段\n把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的**片段(Fragment)**。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。\nOpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据\n片段着色器\n片段着色器的主要目的是计算一个像素的最终颜色\nAlpha测试和混合(Blending)阶段\n这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同\nGL_ARRAY_BUFFER目标用于表示顶点属性数据的缓冲区对象\n在OpenGL中，VAO（Vertex Array Object）和VBO（Vertex Buffer Object）是用于管理顶点数据的重要概念，并且它们之间存在一定的关系。\n\nVAO（Vertex Array Object）：\nVAO是OpenGL中用于存储顶点属性状态的对象。它包含了多个指向VBO的指针，用于指定顶点属性数据的格式、排列方式等。\nVAO可以看作是对VBO的管理器，它记录了OpenGL如何解释顶点数据，包括顶点的位置、颜色、法线等信息。通过绑定VAO，可以轻松地切换顶点属性的设置，从而简化渲染流程。\n\n\nVBO（Vertex Buffer Object）：\nVBO是用于存储顶点数据的缓冲区对象。它可以存储顶点的位置、颜色、纹理坐标等信息。\n通过将顶点数据存储在VBO中，可以有效地管理和传输大量的顶点数据，而不必反复传输到GPU。\n\n\n\n关系：\n\nVBO存储了实际的顶点数据，例如顶点的位置、颜色、纹理坐标等。\nVAO描述了顶点数据的格式和布局，它指明了如何从VBO中读取顶点数据以供渲染使用。\n通常情况下，我们先创建和绑定VAO，然后配置相应的VBO，并将VBO与VAO关联。这样，在渲染时只需绑定相应的VAO即可，OpenGL就会根据VAO中的配置自动获取正确的顶点数据进行渲染。\n\n总结来说，VAO用于管理顶点属性状态，而VBO用于存储实际的顶点数据。它们共同协作，使得在OpenGL中管理和使用顶点数据变得更加灵活和高效。\n我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）\n着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。\nUniform是另一种从我们的应用程序在 CPU 上传递数据到 GPU 上的着色器的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。\n在OpenGL中，VBO（Vertex Buffer Object）和VAO（Vertex Array Object）都是用于管理顶点数据的对象。它们之间的联系和区别如下：\n联系：\n\nVBO和VAO都是用于管理顶点属性数据的对象。\n它们都可以通过OpenGL API进行创建、绑定、更新和删除等操作。\nVAO可以保存多个VBO的绑定状态，使得我们在绘制时只需绑定VAO即可同时启用多个顶点属性数组。\n\n区别：\n\nVBO是用于存储和管理顶点数据的缓冲对象，包括顶点位置、法线、颜色、纹理坐标等属性数据。它能够提高渲染效率，因为可以将这些数据上传到显卡内存中，而不需要每次绘制时都从系统内存中获取。\nVAO是用于管理VBO的绑定状态的对象，它记录了VBO的绑定状态以及每个属性在VBO中的偏移量、类型等信息。VAO可以看作是一组VBO的绑定描述符，它规定了如何从VBO中获取顶点属性数据。\n\n总体来说，VBO和VAO在OpenGL中都扮演着非常重要的角色，它们都可以提高渲染效率，使得开发者可以更加方便地管理和操作顶点属性数据。其中，VBO主要用于存储和管理顶点数据，而VAO则是用于在绘制时快速激活和绑定多个顶点属性数组。\n把两个角度都发送\n试一下发后两个数据，看看是不是数据的问题\n试试发5个\n2024.6.3.15.52Matlab报错，遂改，无用！！！！\n艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节.这样就可以让物体非常精细而不用指定额外的顶点\n为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。\n使用 Xlib 来获取窗口大小需要一些底层的操作，但可以通过以下步骤来实现：\n首先，你需要安装 python-xlib 库。你可以使用以下命令在 Ubuntu 上安装：\nbashsudo apt-get install python-xlib然后，你可以使用下面的代码来获取当前活动窗口的大小：\npythonfrom Xlib import display\n\ndef get_screen_size():\n    disp = display.Display()\n    screen = disp.screen()\n    root_win = screen.root\n    windowID = root_win.get_full_property(disp.intern_atom(&#39;_NET_ACTIVE_WINDOW&#39;), 0).value[0]\n    window = disp.create_resource_object(&#39;window&#39;, windowID)\n    geometry = window.get_geometry()\n    return geometry.width, geometry.height\n\nwidth, height = get_screen_size()\nprint(&quot;Window size: &#123;&#125; x &#123;&#125;&quot;.format(width, height))这段代码中，我们首先创建了一个 Display 对象，然后获取了当前活动窗口的 ID。接着，我们使用这个窗口 ID 创建了一个 window 对象，并通过这个对象的 get_geometry 方法获取了窗口的宽度和高度。\n请注意，使用 Xlib 需要对 X 窗口系统有一定的了解，因为它是一个底层的库，直接和 X 服务器进行交互。希望这个示例能够帮助你开始使用 Xlib 来获取窗口大小。\n\nlayout(location=0): 这是一个着色器布局限定符（layout qualifier），用于指定顶点属性在输入阶段的位置。在这里，location=0 表示顶点属性的位置索引为 0。这个位置索引将与顶点数组对象（VAO）中的对应属性绑定，以确保正确地将顶点数据传递给顶点着色器。\nin: 这是一个输入变量修饰符，用于指示这个变量是从外部传递给顶点着色器的。\nvec3: 这是指定变量类型的关键字，表示这个变量是一个三维向量。\nin_position: 这是变量的名称，用于在顶点着色器中引用这个输入变量。在这里，in_position 可能表示顶点的位置信息。\n\n在OpenGL中，gl_Position是一个内置的变量，用于表示顶点着色器（Vertex Shader）输出的顶点位置。它是一个四维向量（vec4），表示顶点的齐次坐标（Homogeneous Coordinates），通常用于表示三维空间中的点。齐次坐标是四维的，其中前三个分量表示点的位置，而第四个分量通常被用于表示点的类型或者进行透视除法（Perspective Division）。在顶点着色器中，对 gl_Position 的设置将影响后续的图元装配（Primitive Assembly）和光栅化（Rasterization）阶段，最终确定绘制的像素位置。因此，正确设置 gl_Position 是绘制正确图形的关键。\n[[ 0.5  0.5  0.   0.   1.   0. ] [-0.5  0.5  0.   1.   0.   0. ] [-0.5 -0.5  0.   0.   0.   1. ] [ 0.5  0.5  0.   0.   1.   0. ] [-0.5 -0.5  0.   0.   0.   1. ] [ 0.5 -0.5  0.   1.   0.   0. ]]\ntxtlayout(location=0) in vec3 in_position;\nlayout(location=1) in vec3 in_color;txtself.vbo_format = &#39;3f 3f&#39;\nself.attrs = (&#39;in_position&#39;, &#39;in_color&#39;)txtvertex_data = np.hstack([vertices_array, colors_array])缩放\n位移\n大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：\n\n弧度转角度：角度 = 弧度 * (180.0f / PI)\n角度转弧度：弧度 = 角度 * (PI / 180.0f)\n\n\n我这一辈子，抠抠搜搜的花了很多钱，精精明明的上了很多当。骂骂咧咧的干了很多活，小心翼翼的闯了很多祸。精打细算的欠了一屁股帐。认认真真的范了很多错。掏心掏肺的结了很多仇。不明不白的吃了很多亏。窝窝囊囊的活了几十年。\n\nglm::mat4 trans;：首先声明了一个4x4的矩阵trans，用于表示变换矩阵。\ntrans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));：这一行代码对trans进行了旋转变换。使用了glm库中的rotate函数，将trans矩阵绕Z轴旋转90度（使用radians函数将角度转换为弧度），并将结果赋值给trans本身。\ntrans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));：接着对trans进行了缩放变换。使用了glm库中的scale函数，将trans矩阵沿着X、Y、Z三个轴分别缩放0.5倍，并将结果再次赋值给trans本身。\n\n\n局部空间(Local Space，或者称为物体空间(Object Space))\n世界空间(World Space)\n观察空间(View Space，或者称为视觉空间(Eye Space))\n裁剪空间(Clip Space)\n屏幕空间(Screen Space)\n\n为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕\n坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：\n\n\n局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。\n下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。\n接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。\n坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。\n最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。\n\n你可能已经大致了解了每个坐标空间的作用。我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。\n局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间\n\n\n\n\n\nglm::LookAt函数需要一个位置、目标和上向量。它会创建一个观察矩阵。\n为了改变摄像机方向\n\nself.m_projection=glm.perspective(V_FOV,ASPECT_RATIO,NEARPLANE,FARPLANE)\n使用 GLM 库中的 glm::perspective() 函数创建了一个投影矩阵（projection matrix）.会根据给定的参数创建一个透视投影矩阵，并返回这个矩阵。这个投影矩阵描述了从摄像机位置观察场景时的投影效果，将三维场景转换为二维屏幕空间\n\n对连续时间正弦信号考虑下面表示式：x ( t ) &#x3D; s i n ( 2 π f 0 t + φ )可以按抽样频率 fs&#x3D;1&#x2F;Ts对 x(t)抽样来获得离散时间信号x [ n ] &#x3D; x ( t )|t &#x3D;nTs       &#x3D;  x ( t ) |t&#x3D;n &#x2F; fs &#x3D; s i n ( 2 πf0 &#x2F;fsn + φ ),f0 &#x3D;500Hz， fs 取 100Hz， 绘出 x[n]及其 DTFT\n\n\n\n\n以 5000HZ 和 1000HZ 分别对其采样得到 x1(n)， x2(n)；画出它们的 DTFT 并比较\n\n\n我们可以从第一个方程中直接得到 A 和 φ 的关系：\n\nφ ！&#x3D;π&#x2F;2+kπ\nx(t)&#x3D;2cos(π&#x2F;3 *t)\n\n\n\n\n现实中无法实现理想低通滤波器。然而，可以按下面的方法计算由理想低通滤波器产生的波形：理想低通运算相当于信号频谱与频域的矩形函数相乘，这对应于信号与通过傅里叶逆变换得到的时域 sinc 函数的卷积。当其应用于点样本时，卷积和为 sinc 函数内插：\nxa(t)&#x3D;sum_{n&#x3D;-无穷}^{正无穷} [xa(nt) sin(π(t-nTs)&#x2F;Ts)&#x2F;(π(t-nTs)&#x2F;Ts)]\n(3.18)其中，样本 xa(nt)取自 t&#x3D; nTs处。a. 假设只有有限数量的信号样本是非零值，且只需在有限时间区间上进行信号重建，写出基于(3.18)式的 sinc 内插表示式。\nsyms t n Ts xa;\nxa_t = symsum(xa * sin(pi*(t-n*Ts)/Ts)/(pi*(t-n*Ts)/Ts), n, -inf, inf);\n\nC：\n根据奈奎斯特采样定理，要求 fs≥2fbfs≥2fb 以避免混叠现象。因此，fb&lt;fs2fb&lt;2fs 是满足采样定理的条件。\n","slug":"OpenGL","date":"2024-05-17T08:51:10.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"c694f2b397246a2cd639ff2c5b2c692a","title":"CUDA","content":"\nPCIe传输速率比较慢\n\n\n\n\nCPU启动核函数之后，由这个核函数在GPU设备里产生的所有的线程构成了一个grid(网格)\n而一个grid又由多个线程块（block）组成，一个线程块里包含一组线程（thread）\n进行CUDA编程时，要做的就是减少计算核心空闲的时间，让计算核心一直处于计算中\nCPU，GPU在进行内存相互访问的时候，会很耗时\n\n\n\n一维：\n\n\n二维：\n\n三维：\n\n\n-arch和-code 都与GPU的兼容性有关，在指定计算能力的时候，GPU的真实架构计算能力一定要大于虚拟架构计算能力的\n\n\n\n\n\n即时编译，增加兼容性：\n\n两个都是compute_XY(虚拟)\n\n\n在C++中，exit(-1) 和 return -1 都可以用来表示程序的异常退出或者返回一个错误码，但它们之间有一些重要的区别：\n\nexit(-1) 是一个系统调用，它会立即终止整个程序的执行，并返回一个指定的退出码给操作系统。这会终止程序的执行并进行清理工作（如关闭文件、释放内存等），然后返回退出码。exit 函数是C标准库中的函数，定义在 &lt;cstdlib&gt; 头文件中。\nreturn -1 通常出现在函数中，用于从当前函数中返回一个指定的值。当函数的返回类型是整型时，return -1 将会将 -1 这个值返回给调用该函数的地方。如果 -1 是 main 函数的返回值，那么它会被返回给操作系统作为程序的退出码。\n\n因此，exit(-1) 会立即终止整个程序的执行，而 return -1 只是从当前函数中返回一个值。\n\n双指针\n\n\n\ncudaDeviceReset()函数用于重置当前设备上的所有状态信息。它会清除当前设备上的所有内存分配和设备端的运行时状态，释放所有CUDA资源，并将设备状态恢复到初始化时的状态。这个函数通常在程序结束前被调用，以确保释放所有CUDA资源并将GPU状态还原到初始状态。\n调用cudaDeviceReset()函数可以帮助确保程序结束时释放了所有CUDA资源，从而避免内存泄漏和其他问题。\n在CUDA中，核函数（kernel function）和设备函数（device function）是两个不同的概念。\n\n核函数（Kernel Function）：\n核函数是在GPU上执行的并行函数，由关键字__global__声明。它们可以被从CPU代码调用，并在GPU上并行执行。在CUDA中，核函数通常用于执行大规模数据并行计算。\n\n\n设备函数（Device Function）：\n设备函数是在GPU上执行的函数，但它们只能被其他设备函数调用，不能从CPU代码中直接调用。设备函数通常用于封装重复使用的代码逻辑，以便在核函数中进行调用，以提高代码复用性和可读性。\n\n\n\n虽然它们都是在GPU上执行的函数，但核函数和设备函数在调用方式、用途和作用域上有明显的区别。核函数是CUDA程序中由CPU代码调用的入口点，而设备函数是为了在核函数内部使用而设计的。\n\n\n\n__FILE__ 和 __LINE__ 是C&#x2F;C++中的预定义宏，它们分别代表当前源文件的文件名和行号\n\n\n%g 是 C++ 语言中的格式化输出控制符之一，用于打印浮点数。它根据浮点数的值自动选择 %f 或 %e 中较短的一个输出形式来打印。\n具体来说：\n\n如果浮点数的绝对值小于 0.0001 或者大于等于 10^6，%g 就会采用 %e 的输出形式，用科学计数法表示浮点数。\n否则，%g 会采用 %f 的输出形式，用普通的小数形式表示浮点数。\n\n在 CUDA 编程中，cudaEventQuery(start) 表示查询事件 start 的状态。具体来说，它用于检查事件是否已经被记录。如果事件已经被记录，那么 cudaEventQuery 将立即返回。如果事件还没有被记录，那么 cudaEventQuery 将等待事件被记录后才返回。\n在上述代码中，cudaEventQuery(start) 的目的可能是为了确保在记录 stop 事件之前，start 事件已经被成功记录。这样可以确保测量的时间间隔准确，避免了 start 事件尚未记录就立即记录 stop 事件的情况。\n\n","slug":"CUDA","date":"2024-05-14T04:45:58.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"0104a54ef3539ccc47aaaaa3ebb61ff8","title":"Algo","content":"由于实际测试具有较大的局限性，因此我们考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。\n\n“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。\n“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。\n“时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。\n\n迭代（iteration）\n递归（recursion）,通过函数调用自身来解决问题:（“将问题分解为更小子问题”）\n\n递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。\n归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。\n\n而从实现的角度看，递归代码主要包含三个要素。\n\n终止条件：用于决定什么时候由“递”转“归”。\n递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。\n返回结果：对应“归”，将当前递归层级的结果返回至上一层。\n\n虽然从计算角度看，迭代与递归可以得到相同的结果，但它们代表了两种完全不同的思考和解决问题的范式。\n\n迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。\n递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。\n\n过深的递归可能导致栈溢出错误\n尾递归有趣的是，如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。\n\n普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。\n\n尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。\n例如：\n&#x2F;* 尾递归 *&#x2F;int tailRecur(int n, int res) {&#x2F;&#x2F; 终止条件if (n &#x3D;&#x3D; 0)    return res;&#x2F;&#x2F; 尾递归调用return tailRecur(n - 1, res + n);}\n\n\n普通递归：\ntxtpython\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)在普通递归中，递归调用 factorial(n - 1) 发生在函数的末尾，并且返回值被乘以 n 后再返回。\n尾递归：\ntxtpython\ndef factorial_tail(n, accumulator=1):\n    if n == 0:\n        return accumulator\n    else:\n        return factorial_tail(n - 1, accumulator * n)以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，这种工作机制与栈的“先入后出”原则异曲同工。\n事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。\n\n递：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。\n归：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。\n\n时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势。\n\n\n在计算机科学中，”渐近上界” 是一种用于分析算法性能的概念，特别是与时间复杂度和空间复杂度相关。在时间复杂度分析中，渐近上界的目的在于确定算法在数据规模趋于无穷大时的最坏性能表现。为了更好地理解这一概念，可以从几个角度来探讨：\n1. 什么是渐近上界？渐近上界指的是某个函数在趋于某个极限（例如，无限大）时，其增长速率的上限。它通常用于描述算法的最坏情况性能，表示随着输入规模增加，算法的运行时间或使用的资源上限。\n2. 大-O 表示法在算法分析中，渐近上界最常用的表示法是大-O 表示法。用 O(f(n)) 表示某个算法的时间复杂度，意味着这个算法的运行时间在最坏情况下不会超过某个函数 f(n) 的增长速率。\n例如，若算法的时间复杂度是 O(n^2)，表示无论最坏情况下发生了什么，这个算法的运行时间最多是某个常数与 n^2 的乘积。这里 n 是输入数据的规模。\n3. 用途渐近上界有助于比较不同算法的性能，并帮助工程师选择适当的算法。在设计和优化算法时，了解渐近上界也有助于避免性能陷阱。\n4. 如何理解渐近上界？渐近上界在数学上是严格定义的。函数 T(n) 的渐近上界是 f(n)，如果存在常数 c 和 n_0 使得对于所有 n ≥ n_0，都有 T(n) ≤ c * f(n)。这意味着当 n 足够大时，T(n) 不会超过 c * f(n)，即使在最坏情况下。\n5. 示例考虑一个算法的时间复杂度是 3n^2 + 2n + 7。这个算法的渐近上界是 O(n^2)，因为当 n 足够大时，3n^2 是增长最快的项，其他项的影响可以忽略。\n\ntxt/* 指数阶（递归实现） */\nint expRecur(int n) &#123;\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n&#125;txt/*对数阶*/\nint linearLogRecur(int n) &#123;\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n\n    return count;\n&#125;txt/* 线性对数阶 */\nint linearLogRecur(int n) &#123;\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) &#123;\n        count++;\n    &#125;\n    return count;\n&#125;\n算法在运行过程中使用的内存空间主要包括以下几种。\n\n输入空间：用于存储算法的输入数据。\n暂存空间：用于存储算法在运行过程中的变量、对象、函数上下文等数据。\n输出空间：用于存储算法的输出数据。\n\n一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。\ntxtstruct Node &#123;\n    int val;\n    Node *next;\n    Node(int x) : val(x), next(nullptr) &#123;&#125;\n&#125;;Node(int x) : val(x), next(nullptr) 是一个构造函数的定义\ntxtint func() &#123;\n    // 执行某些操作\n    return 0;\n&#125;\n/* 循环的空间复杂度为 O(1) */\nvoid loop(int n) &#123;\n    for (int i = 0; i &lt; n; i++) &#123;\n        func();\n    &#125;\n&#125;\n/* 递归的空间复杂度为 O(n) */\nvoid recur(int n) &#123;\n    if (n == 1) return;\n    return recur(n - 1);\n&#125;函数 loop() 和 recur() 的时间复杂度都为 \n ，但空间复杂度不同。\n\n函数 loop() 在循环中调用了\n\n 次 function() ，每轮中的 function() 都返回并释放了栈帧空间，因此空间复杂度仍为 \n 。\n递归函数 recur() 在运行过程中会同时存在 \n 个未返回的 recur() ，从而占用  的栈帧空间。\ntxt/* 线性阶 */\nvoid linear(int n) &#123;\n    // 长度为 n 的数组占用 O(n) 空间\n    vector&lt;int&gt; nums(n);\n    // 长度为 n 的列表占用 O(n) 空间\n    vector&lt;ListNode&gt; nodes;\n    for (int i = 0; i &lt; n; i++) &#123;\n        nodes.push_back(ListNode(i));\n    &#125;\n    // 长度为 n 的哈希表占用 O(n) 空间\n    unordered_map&lt;int, string&gt; map;\n    for (int i = 0; i &lt; n; i++) &#123;\n        map[i] = to_string(i);\n    &#125;\n&#125;\n\n/* 线性阶（递归实现） */\nvoid linearRecur(int n) &#123;\n    cout &lt;&lt; &quot;递归 n = &quot; &lt;&lt; n &lt;&lt; endl;\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n&#125;\nQ：函数和方法这两个术语的区别是什么？\n函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。\n下面以几种常见的编程语言为例来说明。\n\nC 语言是过程式编程语言，没有面向对象的概念，所以只有函数。但我们可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他编程语言中的方法。\nJava 和 C# 是面向对象的编程语言，代码块（方法）通常作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量。\nC++ 和 Python 既支持过程式编程（函数），也支持面向对象编程（方法）。\n\n常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。\n逻辑结构：线性与非线性逻辑结构揭示了数据元素之间的逻辑关系。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。\n如图 3-1 所示，逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。\n\n线性数据结构：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。\n非线性数据结构：树、堆、图、哈希表。\n\n非线性数据结构可以进一步划分为树形结构和网状结构。\n\n树形结构：树、堆、哈希表，元素之间是一对多的关系。\n网状结构：图，元素之间是多对多的关系。\n\n内存是所有程序的共享资源，当某块内存被某个程序占用时，则无法被其他程序同时使用了。因此在数据结构与算法的设计中，内存资源是一个重要的考虑因素。比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。\n如图 3-3 所示，物理结构反映了数据在计算机内存中的存储方式，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。\n\n值得说明的是，所有数据结构都是基于数组、链表或二者的组合实现的。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。\n链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。\n基本数据类型是 CPU 可以直接进行运算的类型，在算法中直接被使用，主要包括以下几种。\n\n整数类型 byte、short、int、long 。\n浮点数类型 float、double ，用于表示小数。\n字符类型 char ，用于表示各种语言的字母、标点符号甚至表情符号等。\n布尔类型 bool ，用于表示“是”与“否”判断。\n\n基本数据类型以二进制的形式存储在计算机中。一个二进制位即为 1比特。在绝大多数现代操作系统中，1字节（byte）由 8比特（bit）组成。\ntxt\n/* 初始化数组 */\n// 存储在栈上\nint arr[5];\nint nums[5] = &#123; 1, 3, 2, 5, 4 &#125;;\n// 存储在堆上（需要手动释放空间）\nint* arr1 = new int[5];\nint* nums1 = new int[5] &#123; 1, 3, 2, 5, 4 &#125;;在C++中，将数据存储在栈上和堆上有以下区别：\n\n存储位置：\n栈上：栈上的数据存储在程序的栈内存中，它们的分配和释放由编译器自动管理。栈上的数据通常具有较短的生命周期，当函数执行结束时，其内部的局部变量就会被自动释放。\n堆上：堆上的数据存储在程序的堆内存中，它们的分配和释放通常由程序员手动管理。堆上的数据可以具有较长的生命周期，直到显式释放内存或程序终止时才会被释放。\n\n\n动态性：\n栈上：栈上的内存分配是静态的，大小在编译时确定，并且通常比较有限。由于栈上的内存分配由编译器管理，所以分配和释放速度较快。\n堆上：堆上的内存分配是动态的，大小可以在运行时确定，并且可以根据需要动态增长。由于堆上的内存分配由程序员管理，因此可能会产生内存泄漏或内存碎片等问题。\n\n\n访问方式：\n栈上：栈上的数据访问速度通常比较快，因为它们存储在内存中的连续位置上，并且可以直接通过指针或引用进行访问。\n堆上：堆上的数据访问速度可能比较慢，因为它们存储在内存中的不同位置上，并且需要通过指针间接访问。\n\n\n\n在实际编程中，选择栈上或堆上的存储方式取决于数据的生命周期、大小和访问方式等因素。\nQ:把数组存储在堆，栈上，那堆栈是什么\nA：在计算机科学中，”堆栈”通常指的是”栈”和”堆”这两种不同的内存分配区域，它们用于存储程序运行时所需的数据和内存。这两者虽然名字相似，但是在内存管理和使用方面有着不同的作用和特点：\n\n栈（Stack）：\n栈是一种内存分配区域，用于存储函数调用时的局部变量、函数参数、函数返回地址等信息。\n栈上的内存分配由编译器自动管理，通常采用后进先出（LIFO）的方式进行操作。函数调用时，会将局部变量等信息压入栈中，函数返回时则将其弹出。\n栈上的内存分配速度快，但是空间有限，通常用于存储函数调用时所需的临时数据。\n\n\n堆（Heap）：\n堆是另一种内存分配区域，用于存储程序运行时动态分配的内存，例如使用new和delete操作符创建和释放的对象。\n堆上的内存分配由程序员手动管理，它的大小和生命周期可以动态确定。堆上的内存通常用于存储程序运行时动态产生的数据结构、对象等。\n堆上的内存分配速度相对较慢，因为需要进行动态分配和释放，并且可能产生内存碎片等问题。\n\n\n\n总的来说，栈和堆是程序运行时两种不同的内存分配区域，它们有着不同的管理方式、分配速度和用途，程序员可以根据需要选择合适的内存分配方式来管理程序的数据和内存。\nQ ：存储在堆上，是要求定义为指针吗\nA : 在C++中，使用new操作符分配内存时，返回的是指向分配内存的指针。因此，存储在堆上的数据需要定义为指针类型，以便程序员能够通过指针来访问和操作这些数据，并在适当的时候手动释放内存空间，以避免内存泄漏。\n以下是一个简单的示例，演示如何声明和使用函数指针：\ntxtcpp\n#include &lt;iostream&gt;\n\n// 声明一个接受两个整数参数并返回它们之和的函数\nint add(int a, int b) &#123;\n    return a + b;\n&#125;\n\n// 声明一个接受两个整数参数并返回它们之差的函数\nint subtract(int a, int b) &#123;\n    return a - b;\n&#125;\n\nint main() &#123;\n    // 声明一个指向函数的指针，该函数接受两个整数参数并返回一个整数\n    int (*operation)(int, int);\n\n    // 将函数 add 的地址赋值给指针变量 operation\n    operation = add;\n\n    // 使用指针调用函数 add\n    int result1 = operation(10, 5);\n    std::cout &lt;&lt; &quot;Result of add: &quot; &lt;&lt; result1 &lt;&lt; std::endl;\n\n    // 将函数 subtract 的地址赋值给指针变量 operation\n    operation = subtract;\n\n    // 使用指针调用函数 subtract\n    int result2 = operation(10, 5);\n    std::cout &lt;&lt; &quot;Result of subtract: &quot; &lt;&lt; result2 &lt;&lt; std::endl;\n\n    return 0;\n&#125;在这个示例中，int (*operation)(int, int); 声明了一个名为 operation 的函数指针，它指向一个接受两个整数参数并返回一个整数的函数。然后，通过将函数的地址赋值给指针变量 operation，可以使用该指针来调用不同的函数。\ntxt/* 扩展数组长度 */\nint *extend(int *nums, int size, int enlarge) &#123;\n    // 初始化一个扩展长度后的数组\n    int *res = new int[size + enlarge];\n    // 将原数组中的所有元素复制到新数组\n    for (int i = 0; i &lt; size; i++) &#123;\n        res[i] = nums[i];\n    &#125;\n    // 释放内存\n    delete[] nums;\n    // 返回扩展后的新数组\n    return res;\n&#125;返回类型为 int *，意味着该函数返回的是一个指向整数类型的指针，即指向数组的指针。\n数组的优点与局限性数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。\n\n空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。\n\n支持随机访问：数组允许在 \n\n时间内访问任何元素。\n\n缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。\n\n\n连续空间存储是一把双刃剑，其存在以下局限性。\n\n插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。\n\n长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。\n\n空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。\n\ndelete 用于释放通过 new 分配的单个对象的内存。\n\ndelete[] 用于释放通过 new[] 分配的数组的内存。\n\n\n数组典型应用数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。\n\n随机访问：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。\n排序和搜索：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。\n查找表：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。\n机器学习：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。\n数据结构实现：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。\n\n存储数组的内存空间必须是连续的\n链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。\n\n链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。\n尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None 。\n在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。\n\ntxt/* 链表节点结构体 */\nstruct ListNode &#123;\n    int val;         // 节点值\n    ListNode *next;  // 指向下一节点的指针\n    ListNode(int x) : val(x), next(nullptr) &#123;&#125;  // 构造函数\n&#125;;为什么结构体也有构造函数:\n在C++中，结构体（struct）和类（class）都可以拥有构造函数。构造函数用于初始化对象的数据成员，在创建对象时自动调用。\n单向链表通常用于实现栈、队列、哈希表和图等数据结构。\n\n栈与队列：当插入和删除操作都在链表的一端进行时，它表现出先进后出的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。\n哈希表：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。\n图：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。\n\n双向链表常用于需要快速查找前一个和后一个元素的场景。\n\n高级数据结构：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。\n浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。\nLRU 算法：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。\n\n环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。\n\n时间片轮转调度算法：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。\n数据缓冲区：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。\n\n可以使用动态数组（dynamic array）来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。\n实际上，许多编程语言中的标准库提供的列表是基于动态数组实现的，例如 Python 中的 list 、Java 中的 ArrayList 、C++ 中的 vector 和 C# 中的 List 等。接下来，我们将把“列表”和“动态数组”视为等同的概念。\n数据结构的缓存效率缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据。\n为了尽可能达到更高的效率，缓存会采取以下数据加载机制。\n\n缓存行：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效。\n预取机制：处理器会尝试预测数据访问模式（例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。\n空间局部性：如果一个数据被访问，那么它附近的数据可能近期也会被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率。\n时间局部性：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率。\n\n栈（stack）是一种遵循先入后出逻辑的线性数据结构。\n如图 5-1 所示，我们把堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫作“入栈”，删除栈顶元素的操作叫作“出栈”。因此我们只能在栈顶添加或删除元素,然而，数组和链表都可以在任意位置添加和删除元素，因此栈可以视为一种受限制的数组或链表。\ntxt基于数组实现的栈\nvector&lt;int&gt; stack;\n/* 获取栈的长度 */\nstack.size()\n入栈\nstack.push_back(num);\n出栈\nstack.pop_back();\n访问栈顶元素\nstack.back();\n\nback就是栈顶的位置txt有专用的栈方法\nstack&lt;int&gt; stack;\n\n/* 元素入栈 */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* 访问栈顶元素 */\nint top = stack.top();\n\n/* 元素出栈 */\nstack.pop(); // 无返回值\n\n/* 获取栈的长度 */\nint size = stack.size();\n\n/* 判断是否为空 */\nbool empty = stack.empty();队列（queue）是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。\ntxt/* 初始化队列 */\nqueue&lt;int&gt; queue;\n\n/* 元素入队 */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* 访问队首元素 */\nint front = queue.front();\n\n/* 元素出队 */\nqueue.pop();\n\n/* 获取队列的长度 */\nint size = queue.size();\n\n/* 判断队列是否为空 */\nbool empty = queue.empty();添加队尾，删除队首—–先来后到\n双向队列：\ntxt/* 初始化双向队列 */\ndeque&lt;int&gt; deque;\n\n/* 元素入队 */\ndeque.push_back(2);   // 添加至队尾\ndeque.push_back(5);\ndeque.push_back(4);\ndeque.push_front(3);  // 添加至队首\ndeque.push_front(1);\n\n/* 访问元素 */\nint front = deque.front(); // 队首元素\nint back = deque.back();   // 队尾元素\n\n/* 元素出队 */\ndeque.pop_front();  // 队首元素出队\ndeque.pop_back();   // 队尾元素出队\n\n/* 获取双向队列的长度 */\nint size = deque.size();\n\n/* 判断双向队列是否为空 */\nbool empty = deque.empty();DoublyListNode *pre, *cur = front; 确实是一个比较容易产生误解的地方，但实际上这行代码并不是同时给 pre 和 cur 赋值为 front。这行代码实际上相当于两行分开的声明和初始化：\ntxtcpp\nDoublyListNode *pre; // 声明一个指向 DoublyListNode 类型的指针 pre\nDoublyListNode *cur = front; // 声明一个指向 DoublyListNode 类型的指针 cur，并将其初始化为 front这里的 pre 只是声明了一个指针，但并没有初始化，所以它的值是未定义的，你需要在后续代码中对其进行初始化。而 cur 在声明时已经被初始化为 front。\n哈希表（hash table），又称散列表，它通过建立键 key 与值 value 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 key ，则可以在  O(1)时间内获取对应的值 value 。\nunordered_map 是 C++ 标准库中的一种关联容器（Associative Container），它提供了快速的键值对存储和检索功能。它是通过哈希表实现的，因此提供了高效的插入、删除和查找操作。\ntxt/* 初始化哈希表 */\nunordered_map&lt;int, string&gt; map;\n\n/* 添加操作 */\n// 在哈希表中添加键值对 (key, value)\nmap[12836] = &quot;小哈&quot;;\nmap[15937] = &quot;小啰&quot;;\nmap[16750] = &quot;小算&quot;;\nmap[13276] = &quot;小法&quot;;\nmap[10583] = &quot;小鸭&quot;;\n\n/* 查询操作 */\n// 向哈希表中输入键 key ，得到值 value\nstring name = map[15937];\n\n/* 删除操作 */\n// 在哈希表中删除键值对 (key, value)\nmap.erase(10583);\n\n/* 遍历哈希表 */\n// 遍历键值对 key-&gt;value\nfor (auto kv: map) &#123;\n    cout &lt;&lt; kv.first &lt;&lt; &quot; -&gt; &quot; &lt;&lt; kv.second &lt;&lt; endl;\n&#125;\n// 使用迭代器遍历 key-&gt;value\nfor (auto iter = map.begin(); iter != map.end(); iter++) &#123;\n    cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;\n&#125;我们先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将数组中的每个空位称为桶（bucket），每个桶可存储一个键值对。因此，查询操作就是找到 key 对应的桶，并在桶中获取 value 。\n那么，如何基于 key 定位对应的桶呢？这是通过哈希函数（hash function）实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 key ，输出空间是所有桶（数组索引）。换句话说，输入一个 key ，我们可以通过哈希函数得到该 key 对应的键值对在数组中的存储位置。\n输入一个 key ，哈希函数的计算过程分为以下两步。\n\n通过某种哈希算法 hash() 计算得到哈希值。\n将哈希值对桶数量（数组长度）capacity 取模，从而获取该 key 对应的数组索引 index 。\n\ntxtindex = hash(key) % capacity&lt;Pair *&gt; 表示这个 vector 存储的是指向 Pair 类型对象的指针。\nvector&lt;Pair *&gt; 创建了一个存储指向 Pair 结构的指针的动态数组，即每个元素都是指向 Pair 结构的指针。\n我们将多个输入对应同一输出的情况称为哈希冲突（hash collision）。\n我们可以通过扩容哈希表来减少哈希冲突。类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 capacity 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。\n负载因子（load factor）是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，也常作为哈希表扩容的触发条件。例如在 Java 中，当负载因子超过  时，系统会将哈希表扩容至原先的 2倍。\n但此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。\n\n改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。\n仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。\n\n哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。\n链式地址在原始哈希表中，每个桶仅能存储一个键值对。链式地址（separate chaining）将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。图 6-5 展示了一个链式地址哈希表的例子。\n\n 图 6-5  链式地址哈希表 \n基于链式地址实现的哈希表的操作方法发生了以下变化。\n\n查询元素：输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 key 以查找目标键值对。\n添加元素：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。\n删除元素：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。\n\n链式地址存在以下局限性。\n\n占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间。\n查询效率降低：因为需要线性遍历链表来查找对应元素。\n\n开放寻址开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。\n线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。\n\n插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 \n\n），直至找到空桶，将元素插入其中。\n\n查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。\n\n\n图 6-6 展示了开放寻址（线性探测）哈希表的键值对分布。根据此哈希函数，最后两位相同的 key 都会被映射到相同的桶。而通过线性探测，它们被依次存储在该桶以及之下的桶中。\n\n 值得注意的是，我们不能在开放寻址哈希表中直接删除元素。这是因为删除元素会在数组内产生一个空桶 None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在\n为了解决该问题，我们可以采用懒删除（lazy deletion）机制：它不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。在该机制下，None 和 TOMBSTONE 都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。\n然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着 TOMBSTONE 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 TOMBSTONE 才能找到目标元素。\n为此，考虑在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。\n平方探测平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 \n 步。\n平方探测主要具有以下优势。\n\n平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。\n平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。\n\n然而，平方探测并不是完美的。\n\n仍然存在聚集现象，即某些位置比其他位置更容易被占用。\n由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。\n\n\n二叉树的常用术语如图所示。\n\n根节点（root node）：位于二叉树顶层的节点，没有父节点。\n叶节点（leaf node）：没有子节点的节点，其两个指针均指向 None 。\n边（edge）：连接两个节点的线段，即节点引用（指针）。\n节点所在的层（level）：从顶至底递增，根节点所在层为 1 。\n节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。\n二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。\n节点的深度（depth）：从根节点到该节点所经过的边的数量。\n节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量。\n\n\n常见二叉树类型完美二叉树所有层的节点都被完全填满。\n\n完全二叉树只有最底层的节点未被填满，且最底层节点尽量靠左填充。\n\n完满二叉树除了叶节点之外，其余所有节点都有两个子节点。\n\n平衡二叉树任意节点的左子树和右子树的高度之差的绝对值不超过 1 。\n[\n理想结构与退化结构\n二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。\n完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。\n链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n)\n\n二叉树遍历从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现。\n二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和后序遍历等。\n层序遍历\n从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。\n层序遍历本质上属于广度优先遍历（breadth-first traversal），也称广度优先搜索（breadth-first search, BFS），它体现了一种“一圈一圈向外扩展”的逐层遍历方式。\n\n广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。\ntxt/* 层序遍历 */\nvector&lt;int&gt; levelOrder(TreeNode *root) &#123;\n    // 初始化队列，加入根节点\n    queue&lt;TreeNode *&gt; queue;\n    queue.push(root);\n    // 初始化一个列表，用于保存遍历序列\n    vector&lt;int&gt; vec;\n    while (!queue.empty()) &#123;\n        TreeNode *node = queue.front();\n        queue.pop();              // 队列出队\n        vec.push_back(node-&gt;val); // 保存节点值\n        if (node-&gt;left != nullptr)\n            queue.push(node-&gt;left); // 左子节点入队\n        if (node-&gt;right != nullptr)\n            queue.push(node-&gt;right); // 右子节点入队\n    &#125;\n    return vec;\n&#125;\n前序、中序和后序遍历都属于深度优先遍历（depth-first traversal），也称深度优先搜索（depth-first search, DFS），它体现了一种“先走到尽头，再回溯继续”的遍历方式。\n\n前序、中序和后序遍历是针对二叉树的三种不同的遍历方式，它们的区别在于遍历节点的顺序：\n\n前序遍历（Preorder Traversal）：\n遍历顺序：根节点 -&gt; 左子树 -&gt; 右子树\n具体操作：先访问根节点，然后递归地对左子树进行前序遍历，最后递归地对右子树进行前序遍历。\n\n\n中序遍历（Inorder Traversal）：\n遍历顺序：左子树 -&gt; 根节点 -&gt; 右子树\n具体操作：先递归地对左子树进行中序遍历，然后访问根节点，最后递归地对右子树进行中序遍历。\n\n\n后序遍历（Postorder Traversal）：\n遍历顺序：左子树 -&gt; 右子树 -&gt; 根节点\n具体操作：先递归地对左子树进行后序遍历，然后递归地对右子树进行后序遍历，最后访问根节点。\n\n\n\n总的来说，这三种遍历方式主要区别在于根节点的访问顺序与左右子树的递归顺序。\n深度优先搜索通常基于递归实现：\ntxt/* 前序遍历 */\nvoid preOrder(TreeNode *root) &#123;\n    if (root == nullptr)\n        return;\n    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树\n    vec.push_back(root-&gt;val);\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n&#125;\n\n/* 中序遍历 */\nvoid inOrder(TreeNode *root) &#123;\n    if (root == nullptr)\n        return;\n    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树\n    inOrder(root-&gt;left);\n    vec.push_back(root-&gt;val);\n    inOrder(root-&gt;right);\n&#125;\n\n/* 后序遍历 */\nvoid postOrder(TreeNode *root) &#123;\n    if (root == nullptr)\n        return;\n    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点\n    postOrder(root-&gt;left);\n    postOrder(root-&gt;right);\n    vec.push_back(root-&gt;val);\n&#125;\n“递”表示开启新方法，程序在此过程中访问下一个节点。\n“归”表示函数返回，代表当前节点已经访问完毕。\n\n\n二叉树数组表示用数组来表示二叉树\n表示完美二叉树给定一棵完美二叉树，我们将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一的数组索引。\n根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：若某节点的索引为i  ，则该节点的左子节点索引为2i+1  ，右子节点索引为2i+2 \n映射公式的角色相当于链表中的节点引用（指针）。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的左（右)子节点。\n表示任意二叉树完美二叉树是一个特例，在二叉树的中间层通常存在许多 None 。由于层序遍历序列并不包含这些 None ，因此我们无法仅凭该序列来推测 None 的数量和分布位置。这意味着存在多种二叉树结构都符合该层序遍历序列。\n\n为了解决此问题，我们可以考虑在层序遍历序列中显式地写出所有 None 。如图 7-14 所示，这样处理后，层序遍历序列就可以唯一表示二叉树了\ntxt/* 二叉树的数组表示 */\n// 使用 int 最大值 INT_MAX 标记空位\nvector&lt;int&gt; tree = &#123;1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15&#125;;\n完全二叉树:只有最底层的节点未被填满，且最底层节点尽量靠左填充。\n完全二叉树非常适合使用数组来表示。回顾完全二叉树的定义，None 只出现在最底层且靠右的位置，因此所有 None 一定出现在层序遍历序列的末尾。这意味着使用数组表示完全二叉树时，可以省略存储所有 None ，非常方便.\n\n优点与局限性二叉树的数组表示主要有以下优点。\n\n数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。\n不需要存储指针，比较节省空间。\n允许随机访问节点。\n\n然而，数组表示也存在一些局限性。\n\n数组存储需要连续内存空间，因此不适合存储数据量过大的树。\n增删节点需要通过数组插入与删除操作实现，效率较低。\n当二叉树中存在大量 None 时，数组中包含的节点数据比重较低，空间利用率较低。\n\n二叉搜索树二叉搜索树（binary search tree）满足以下条件:\n1.对于根节点，左子树中所有节点的值&lt;根节点的值&lt;右子树中所有节点的值。\n2,任意节点的左、右子树也是二叉搜索树，即同样满足条件 1. 。\n\n插入节点给定一个待插入元素 num ，为了保持二叉搜索树“左子树 &lt; 根节点 &lt; 右子树”的性质,\n\n查找插入位置：与查找操作相似，从根节点出发，根据当前节点值和 num 的大小关系循环向下搜索，直到越过叶节点（遍历至 None ）时跳出循环。\n在该位置插入节点：初始化节点 num ，将该节点置于 None 的位置。\n\n\n只能插在NONE节点处,即*pre &#x3D; nullptr\n\n二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。\n为了实现插入节点，我们需要借助节点 pre 保存上一轮循环的节点。这样在遍历至 None 时，我们可以获取到其父节点，从而完成节点插入操作。\n\n删除节点\n当待删除节点的度为2时，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左子树 &lt;根节点 &lt;右子树”的性质，因此这个节点可以是右子树的最小节点或左子树的最大节点。\n\n找到待删除节点在“中序遍历序列”中的下一个节点，记为 tmp 。\n用 tmp 的值覆盖待删除节点的值，并在树中递归删除节点 tmp 。\n\n\n\n\n二叉树的中序遍历遵循“左  根  右”的遍历顺序，而二叉搜索树满足“左子节点  根节点  右子节点”的大小关系。\n这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：二叉搜索树的中序遍历序列是升序的。\n利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需O(n)时间，无须进行额外的排序操作，非常高效。\n\nint val&#123;&#125;; 是C++中的变量声明语句，其中 int 表示变量的类型为整数类型，val 是变量名，&#123;&#125; 表示进行了值初始化。\n在C++11及其之后的标准中，使用 &#123;&#125; 进行初始化被称为列表初始化或者统一初始化。对于内置类型（如 int、float、double 等），使用 &#123;&#125; 进行初始化时，如果未提供初始值，则会将变量初始化为零值，即 0。这种初始化方式也可以保证初始化的一致性，并且在某些情况下可以避免隐式类型转换带来的问题。\nAVL 树在多次插入和删除操作后，二叉搜索树可能退化为链表。在这种情况下，所有操作的时间复杂度将从\nO(log  n)劣化成O(n)\nAVL 树既是二叉搜索树，也是平衡二叉树，同时满足这两类二叉树的所有性质，因此是一种平衡二叉搜索树（balanced binary search tree）。\n节点的平衡因子（balance factor）定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为0  。\nAVL 树旋转\nAVL 树的特点在于“旋转”操作，它能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”。\n我们将平衡因子绝对值&gt;1的节点称为“失衡节点”。根据节点失衡情况的不同，旋转操作分为四种：右旋、左旋、先右旋后左旋、先左旋后右旋。\n1.  右旋\n\n当节点 child 有右子节点（记为 grand_child ）时，需要在右旋中添加一步：将 grand_child 作为 node 的左子节点。\n\n右旋和左旋操作在逻辑上是镜像对称的，它们分别解决的两种失衡情况也是对称的。基于对称性，我们只需将右旋的实现代码中的所有的 left 替换为 right ，将所有的 right 替换为 left ，即可得到左旋的实现代码\n先左旋后右旋\n先右旋后左旋\n\nDFS（深度优先搜索）遍历二叉树是一种遍历或搜索算法，用来访问二叉树中的所有节点，其目的是尽可能深地访问树的分支。DFS在二叉树中常用的有三种遍历方式：前序遍历（Pre-order）、中序遍历（In-order）和后序遍历（Post-order）。下面详细解释这三种遍历方式：\n\n前序遍历（Pre-order Traversal）：\n访问顺序：先访问根节点，然后递归地进行前序遍历左子树，接着递归地进行前序遍历右子树。\n应用：前序遍历常用于打印树的结构，复制树结构。\n\n\n中序遍历（In-order Traversal）：\n访问顺序：先递归地进行中序遍历左子树，然后访问根节点，最后递归地进行中序遍历右子树。\n应用：对于二叉搜索树（BST），中序遍历可以得到一个有序的数据序列。\n\n\n后序遍历（Post-order Traversal）：\n访问顺序：先递归地进行后序遍历左子树，然后递归地进行后序遍历右子树，最后访问根节点。\n应用：后序遍历常用于访问节点后再执行操作的场景，如计算一个文件夹的总大小时。\n\n\n\nDFS 遍历的核心在于使用递归（或显式使用栈）来实现持续深入每个分支直到达到叶子节点或满足某些条件后回溯到上一节点。这种方式非常适合处理具有层级关系的数据，如文件系统的目录结构、组织结构等。在二叉树的上下文中，DFS遍历可以帮助理解和操作树的结构。\ntxtvisited.count(adjVet)count 是 unordered_set 提供的的一个成员函数，它返回集合中指定元素的数量。如果 adjVet 是指向图中的一个顶点的指针，并且这个顶点已经被添加到 visited 集合中，那么 visited.count(adjVet) 将返回 1，表示该顶点已经被访问过。如果 adjVet 不在 visited 集合中，那么返回 0，表示该顶点还没有被访问过。\ntxtvisited.emplace(adjVet);emplace 是一个函数，它用于在容器中直接构造并插入元素，而不需要创建元素的副本\n","slug":"Algo","date":"2024-04-26T01:35:42.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"47d8fddcd3299307e9e74bee0c7b2069","title":"FPGA","content":"assign 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在always块中）不同，后者在某种事件或条件发生时才更新值。\nassign temp2 &#x3D; {32{1’b0}}; 是什么意思?\n在Verilog中，assign temp2 = &#123;32&#123;1&#39;b0&#125;&#125;; 这行代码声明了一个连续赋值，将 temp2 这个线网的值设置为一个32位的全0值。\n这里的 &#123;32&#123;1&#39;b0&#125;&#125; 是一个重复拼接操作，含义如下：\n\n1&#39;b0 是一个二进制数，表示一个位宽为1的数值，值为0。\n&#123;32&#123;1&#39;b0&#125;&#125; 表示将 1&#39;b0 这个值重复32次。\n\nVerilog 数据类型Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。\n整数（integer）   reg 型变量为无符号数，而 integer 型变量为有符号数\n实数（real）\n在Verilog中，real 和 integer 是数据类型关键字，分别用于声明实数类型和整数类型的变量。\ntxtreal data1;\ninteger temp;\ninitial begin\n    data1 = 2e3;\n    data1 = 3.75;\nend\n\ninitial begin\n    temp = data1; //temp 值的大小为3\nend这段代码包含两个 initial 块，它们在仿真开始时执行一次。\n第一个 initial 块中：\n\ndata1 被初始化为实数类型 real。\ndata1 被赋值为 2e3，这意味着 data1 现在的值是2000.0。\n随后，data1 被更新为 3.75。\n\n第二个 initial 块中：\n\ntemp 被初始化为整数类型 integer。\ntemp 被赋值为 data1 的值。由于 data1 当前是 3.75，这个赋值会将实数转换为整数。在Verilog中，实数赋值给整数时，会进行取整操作，保留数值的整数部分，忽略小数部分。因此，temp 的值将是3。\n\n需要注意的是，您的注释 //temp 值的大小为3 是正确的，因为 data1 的值 3.75 在赋值给 temp 时会被取整为3。\n时间（time）\nVerilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间。例如：\ntxttime current_time;\ninitial begin\n    #100;\n    current_time = $time; //current_time 的大小为 100\nend这段代码包含一个 initial 块，它在仿真开始时执行一次。\n在 initial 块中：\n\ncurrent_time 被初始化为时间类型 time。\n#100; 是一个延迟语句，它会使仿真暂停100个时间单位。在Verilog中，# 后面跟一个数字表示延迟的时间量。\n\n数组存储器\n参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次parameter    data_width &#x3D; 10’d32 ;\n字符串字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。\n字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0  来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”,  需要 14*8bit 的存储单元：\nreg [0: 14*8-1]    str ; initial begin   str &#x3D; “run.runoob.com”; end  \n\n\n\n\n\n2.4 Verilog 表达式表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。\n a^b ;      &#x2F;&#x2F;a与b进行异或操作 address[9:0] + 10’b1 ;  &#x2F;&#x2F;地址累加 flag1 &amp;&amp; flag2 ;  &#x2F;&#x2F;逻辑与操作\nalways块里赋值对象不能是wire型\n同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行\ntxt//自右向左关联，两种写法等价\nA+B-C ;\n(A+B）-C ;\n\n//自右向左关联，两种写法等价，结果为 B、D 或 F\nA ? B : C ? D : F ;\nA ? B : (C ? D : F) ;求幂（**）、取模（%）\ntxtb = 4&#39;b100x;x 是一个表示未知或不可确定状态的字符。它用于在仿真中表示一个位的值是未知的，这通常发生在综合过程中，当某些逻辑路径没有被明确赋值时，或者在设计中的某些部分还没有完全定义时。\n无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和\nreg [3:0]     mula ; reg [1:0]     mulb; reg [5:0]     res ; mula &#x3D; 4’he  ; mulb &#x3D; 2’h3  ; res  &#x3D; mula * mulb ; &#x2F;&#x2F;结果为res&#x3D;6’h2a, 数据结果没有丢失位数\n逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）\n按位操作符包括：取反()，与（&amp;），或（|），异或（^），同或（^）\n按位操作符对 2 个操作数的每 1bit 数据进行按位操作,如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。\n归约操作符归约操作符包括：归约与（&amp;），归约与非（&amp;），归约或（|），归约或非（|），归约异或（^），归约同或（~^）。\n归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。\n逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。\ntxtA = 4&#39;b1010 ;\n&amp;A ;      //结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#39;b0，可用来判断变量A是否全1\n~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1&#39;b0, 可用来判断变量A是否为全0\n^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1&#39;b0移位操作符移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。\n移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。\n算术左移和逻辑左移时，右边低位会补 0。\n逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。\n实例A &#x3D; 4’b1100 ; B &#x3D; 4’b0010 ; A &#x3D; A &gt;&gt; 2 ;     &#x2F;&#x2F;结果为 4’b0011 A &#x3D; A &lt;&lt; 1;     *&#x2F;&#x2F;结果为 4’b1000* A &#x3D; A &lt;&lt;&lt; 1 ;    *&#x2F;&#x2F;结果为 4’b1000* C &#x3D; B + (A&gt;&gt;&gt;2);   &#x2F;&#x2F;结果为 2 + (-4&#x2F;4) &#x3D; 1, 4’b0001\ndefine, undef在编译阶段，&#96;define 用于文本替换，类似于 C 语言中的 #define。\n&#96;undef 用来取消之前的宏定义\ntxt`ifdef       MCU51\n    parameter DATA_DW = 8   ;\n`elsif       WINDOW\n    parameter DATA_DW = 64  ;\n`else\n    parameter DATA_DW = 32  ;\n`endif&#96;include使用 &#96;include 可以在编译时将一个 Verilog 文件内嵌到另一个 Verilog 文件中，作用类似于 C 语言中的 #include 结构。\ntimescale在 Verilog 模型中，时延有具体的单位时间表述，并用 &#96;timescale 编译指令将时间单位与实际时间相关联。\n该指令用于定义时延、仿真的单位和精度，格式为：\ntxt`timescale      time_unit / time_precisiontime_unit 表示时间单位，time_precision 表示时间精度，它们均是由数字以及单位  s（秒），ms（毫秒），us（微妙），ns（纳秒），ps（皮秒）和  fs（飞秒）组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小，例如下面例子中，输出端 Z 会延迟 5.21ns 输出  A&amp;B 的结果。\n实例timescale 1ns/100ps   *//时间单位为1ns，精度为100ps，合法*  *//timescale 100ps&#x2F;1ns  &#x2F;&#x2F;不合法* module AndFunc(Z, A, B);   output Z;   input A, B ;   assign #5.207 Z &#x3D; A &amp; B endmodule\n在编译过程中，timescale 指令会影响后面所有模块中的时延值，直至遇到另一个 timescale 指令或 &#96;resetall 指令。 \n由于在 Verilog 中没有默认的 timescale，如果没有指定 timescale，Verilog 模块就有会继承前面编译模块的 &#96;timescale 参数。有可能导致设计出错。\n如果一个设计中的多个模块都带有 &#96;timescale 时，模拟器总是定位在所有模块的最小时延精度上，并且所有时延都相应地换算为最小时延精度\n&#96;default_nettype该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型。\ntxt`default_nettype wand 该实例定义的缺省的线网为线与类型。因此，如果在此指令后面的任何模块中的连线没有说明，那么该线网被假定为线与类型。  \ntxt`default_nettype none该实例定义后，将不再自动产生 wire 型变量。\ncelldefine, endcelldefine这两个程序指令用于将模块标记为单元模块，他们包含模块的定义。例如一些与、或、非门，一些 PLL 单元，PAD 模型，以及一些 Analog IP 等。\n实例celldefine  **module** (    **input**    clk,    **input**    rst,    **output**   clk_pll,    **output**   flag);      ……  **endmodule**  endcelldefine\nunconnected_drive, nounconnected_drive在模块实例化中，出现在这两个编译指令间的任何未连接的输入端口，为正偏电路状态或者为反偏电路状态。\ntxtassign用于对 wire 型变量进行赋值,不对寄存器赋值\n进位输出（Carry  out，通常表示为Co或Cout）是全加器的一个输出，它表示在两个二进制位相加时是否产生了进位。在二进制加法中，当两个加数位（A和B）的和大于或等于2时，就会产生进位，因为二进制中的每一位只能表示0或1。进位输出就是用来表示这个进位的。\nmodule full_adder1(   input   Ai, Bi, Ci,   output  So, Co);\n   assign So &#x3D; Ai ^ Bi ^ Ci ;   assign Co &#x3D; (Ai &amp; Bi) | (Ci &amp; (Ai | Bi)); endmodule\n更简单的：\ntxtmodule full_adder1(\n    input Ai, Bi, Ci,\n    output So, Co);\n    \n    assign &#123;Co, So&#125; = Ai + Bi + Ci;\nendmodule&#x2F;&#x2F;普通时延，A&amp;B计算结果延时10个时间单位赋值给Z wire Z, A, B ; assign #10   Z &#x3D; A &amp; B ;\n &#x2F;&#x2F;隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。 wire A, B; wire #10     Z &#x3D; A &amp; B;\n &#x2F;&#x2F;声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。 wire A, B; wire #10 Z ; assign      Z &#x3D;A &amp; B\nVerilog 过程结构过程结构语句有 2 种，initial 与 always 语句\n一个模块中可以包含多个 initial 和 always 语句，但 2 种语句不能嵌套使用。\n但是 initial 语句或 always 语句内部可以理解为是顺序执行的（非阻塞赋值除外）。\ninitial语句initial 语句从 0 时刻开始执行，只执行一次，多个 initial 块之间是相互独立的。\n如果 initial 块内包含多个语句，需要使用关键字 begin 和 end 组成一个块语句。\n如果 initial 块内只要一条语句，关键字 begin 和 end 可使用也可不使用。\ninitial 理论上来讲是不可综合的，多用于初始化、信号检测等。\n这些语句在模块间并行执行，与其在模块的前后顺序没有关系always 语句与 initial 语句相反，always 语句是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。\n由于循环执行的特点，always 语句多用于仿真时钟的产生，信号行为的检测等。   \nparameter 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。连续性赋值使用assign语句，而过程性赋值使用always块。\n阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。\n阻塞赋值语句使用等号 &#x3D; 作为赋值符。\n非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。\n非阻塞赋值语句使用小于等于号 &lt;&#x3D; 作为赋值符。\n如下所示，2 个 always 块中语句并行执行，赋值操作右端操作数使用的是上一个时钟周期的旧值，此时 a&lt;&#x3D;b 与 b&lt;&#x3D;a 就可以相互不干扰的执行，达到交换寄存器值的目的。\n实例always @(posedge clk) begin   a &lt;&#x3D; b ; end\n always @(posedge clk) begin   b &lt;&#x3D; a; end\nVerilog 时序控制Verilog 提供了 2 大类时序控制方法：时延控制和事件控制。事件控制主要分为边沿触发事件控制与电平敏感事件控制\n时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。常规时延\ntxtreg  value_test ;\nreg  value_general ;\n#10  value_general    = value_test ;或：\ntxt#10 ;\nvalue_ single         = value_test ;内嵌时延\n遇到内嵌延时时，该语句先将计算结果保存，然后等待一定的时间后赋值给目标信号。\n内嵌时延控制加在赋值号之后。例如：\ntxtreg  value_test ;\nreg  value_embed ;\nvalue_embed        = #10 value_test ;需要说明的是，这 2 种时延控制方式的效果是有所不同的。\n当延时语句的赋值符号右端是常量时，2 种时延控制都能达到相同的延时赋值效果。\n当延时语句的赋值符号右端是变量时，2 种时延控制可能会产生不同的延时赋值效果。\n边沿触发事件控制在 Verilog 中，事件是指某一个 reg 或 wire 型变量发生了值的变化。事件控制用符号 @ 表示。\n设计：根据需求编写硬件描述语言（如Verilog或VHDL）代码来描述设计的功能和行为\nsynthesize综合，合成：综合代码，检查语法是否有错误,将高级的逻辑描述代码转换为逻辑门级别的网表或等效的门级电路\nFloorPlanner 是 FPGA 设计流程中的一个重要工具，用于执行布局（Place）阶段的子任务，即对设计中的逻辑电路进行布局安置。在 FPGA 设计流程中，FloorPlanner 的地位如下：\n\n布局规划：FloorPlanner 负责规划 FPGA 芯片上各个逻辑模块的布局位置，以最大程度地满足设计的性能和资源利用率要求。它会考虑逻辑模块之间的布线延迟、信号传输路径长度等因素，以优化整体的布局结构。\n资源分配：FloorPlanner 还负责将设计中的逻辑模块分配到 FPGA 芯片的不同区域，并且合理利用芯片上的资源（如片上存储器、DSP模块等），以满足设计对资源的需求。\n时序约束：在布局过程中，FloorPlanner 还会考虑时序约束，确保设计中的时序要求能够得到满足。它会尽可能减少逻辑模块之间的传输延迟，以确保时序性能。\n优化布局：FloorPlanner 通过对设计进行优化布局，以降低布线延迟、减少时序问题和功耗等方面的优化。这可以提高设计的性能、可靠性和功耗效率。\n\n在 FPGA 设计流程中，FloorPlanner 位于布局（Place）阶段之前，它为后续的布线（Route）阶段提供了优化的布局结果，从而帮助实现设计的最终映射和部署。\nPlace&amp;Route ：\n开发流程中的 Place &amp; Route 是指在将设计映射到 FPGA 芯片时的一个重要步骤。下面解释一下它的含义和作用：\n\nPlace（放置）：Place 指的是将设计中的逻辑元素（如逻辑门、寄存器等）放置到 FPGA 芯片的物理位置上。这一步骤考虑了芯片内部的布局和连接资源，以尽可能地优化性能和资源利用率。放置的目标是最小化延迟、最大化时序性能，并且尽量减少芯片内的布线冲突。\nRoute（布线）：Route 是指将设计中的逻辑元素之间的连接关系转化为芯片内部的实际物理连线。这一步骤考虑了芯片内部的连线资源、信号传输延迟等因素，以确保逻辑元素之间的连接能够有效地建立并满足时序要求。布线的目标是尽可能地降低信号传输延迟、最小化信号干扰，同时满足设计的时序约束。\n\n在 Verilog 中，reg 类型通常用于表示存储元素（如寄存器），而不是直接连接到模块的输出端口。输出端口通常使用 output 或 inout 声明，并且通常需要与 wire 类型一起使用。\nreg 类型在 Verilog 中表示的是寄存器类型，它在 always 块中使用，存储状态或信号。而 output 端口应该使用 wire 类型来表示，因为它们不会存储状态，只是将信号传递给其他部件。\n因此，你在模块顶层中使用 output reg 是不符合常规的 Verilog 设计习惯的，通常应该使用 output wire。\n\n半加器（Half Adder）和全加器（Full Adder）是数字电路中用于执行二进制加法的基本组件。它们的主要区别在于它们处理的输入数量和功能。\n半加器： 半加器是一个组合逻辑电路，它接受两个二进制位作为输入，并产生两个输出：和（Sum）和进位（Carry）。半加器只处理两个输入位的加法，不考虑来自较低位的进位。半加器的输出进位只能表示当前两个输入位相加是否产生了进位。\n半加器的逻辑可以表示为：\n\n•\n和（Sum） &#x3D; A XOR B\n\n•\n进位（Carry） &#x3D; A AND B\n\n\n其中，A和B是两个输入位，XOR表示异或门，AND表示与门。\n全加器： 全加器也是一个组合逻辑电路，它接受三个二进制位作为输入，并产生两个输出：和（Sum）和进位（Carry）。全加器的三个输入包括两个加数位（A和B）以及来自较低位的进位（Carry-in）。全加器能够处理包括进位在内的三个位的加法。\n全加器的逻辑可以表示为：\n\n•\n和（Sum） &#x3D; (A XOR B) XOR Carry-in\n\n•\n进位（Carry） &#x3D; (A AND B) OR (Carry-in AND (A XOR B))\n\n\n其中，Carry-in是来自较低位的进位，OR表示或门。\n区别：\n\n\n\n\n\n\n  输入数量：半加器有两个输入，全加器有三个输入。\n\n\n\n\n\n\n  功能：半加器只计算两个输入位的和和进位，而全加器计算三个输入位（包括来自较低位的进位）的和和进位。\n\n\n\n\n\n\n  应用：半加器通常用于构建更复杂的加法器电路，如全加器。全加器则用于实现多位二进制数的加法，因为它能够处理进位。\n在实际的数字电路设计中，全加器更为常用，因为它可以级联（Cascade）起来构成多位加法器，如4位、8位、16位等，从而实现更复杂的算术运算。\n在Verilog中，parameter是一个关键字，用于定义模块（module）的参数\nparameter定义的值在模块的整个实例化过程中都是固定的，不能被重新赋值。这意味着一旦定义了parameter，它的值在整个模块中都是不变的。\nAssignment 赋值\nSP代表single port单端口模式，即同一时钟控制读写，同一时间只能写或者度\n在您提供的 Verilog 代码片段中，ram_inst 是一个实例化语句，用于创建一个 RAM 模块的实例。这个实例使用了多个引脚（pins），这些引脚定义了模块的输入和输出接口。下面是每个引脚的详细解释：\n\n•\n.dout(dout_o)：这是 RAM 模块的输出引脚，名为 dout，它是一个 8 位宽度的输出信号。在这个实例中，它被连接到了一个名为 dout_o 的信号。\n\n•\n.clk(clk)：这是 RAM 模块的时钟输入引脚，用于同步数据写入和读取操作。它被连接到了一个名为 clk 的信号。\n\n•\n.oce(oce_i)：这是 RAM 模块的输出使能输入引脚，用于控制 dout 信号是否输出数据。它被连接到了一个名为 oce_i 的信号。\n\n•\n.ce(ce_i)：这是 RAM 模块的芯片使能输入引脚，用于控制 RAM 是否可以进行读写操作。它被连接到了一个名为 ce_i 的信号。\n\n•\n.reset(reset_i)：这是 RAM 模块的复位输入引脚，用于将 RAM 恢复到初始状态。它被连接到了一个名为 reset_i 的信号。\n\n•\n.wre(wre_i)：这是 RAM 模块的写使能输入引脚，用于控制是否可以写入数据到 RAM。它被连接到了一个名为 wre_i 的信号。\n\n•\n.ad(addr)：这是 RAM 模块的地址输入引脚，用于指定要读取或写入的 RAM 单元的地址。它被连接到了一个名为 addr 的信号，该信号是 11 位宽度的。\n\n•\n.din(data_i)：这是 RAM 模块的数据输入引脚，用于写入数据到 RAM。它被连接到了一个名为 data_i 的信号，该信号是 8 位宽度的。\n\n\n每个引脚都是 RAM 模块与其外部接口之间的连接点，它们定义了模块如何与外部信号交互。在实际的设计中，您需要确保这些引脚被正确地连接到相应的信号，并且信号的类型和宽度与 RAM 模块的要求相匹配。\nFPGA中BRAM和DRAM的区别\nFPGA（现场可编程门阵列）中的BRAM（块RAM）和DRAM（动态RAM）是两种不同类型的存储器，它们在设计和使用上有着显著的区别：\n\n类型和用途：\n\n\nBRAM：是静态RAM（SRAM）的一种形式，通常集成在FPGA芯片内部。它提供快速的存储解决方案，适用于需要高速、小容量存储的应用，如缓存、缓冲区或FPGA内部的数据存储。\nDRAM：是一种动态RAM，与FPGA芯片外部连接。它具有更高的存储密度，但速度较BRAM慢。DRAM适用于需要大容量存储的应用，如图像处理、视频缓冲和大量数据存储。\n\n\n存储机制：\n\n\nBRAM：作为静态RAM，它不需要刷新电路来维持数据。每个存储单元都使用六晶体管（6T）的SRAM细胞结构，这意味着它可以无限期地保持数据，直到被写入新数据。\nDRAM：作为动态RAM，它需要定期刷新来维持数据。每个存储单元通常由一个电容器和一个晶体管组成，因此它的密度可以更高，但速度较慢，并且需要更复杂的控制逻辑。\n\n\n性能特点：\n\n\nBRAM：提供单周期访问时间，这意味着访问数据几乎立即完成，适用于要求严格实时性能的应用。\nDRAM：由于其刷新要求，访问速度较慢，通常需要多个时钟周期来访问数据。\n\n\n集成度：\n\n\nBRAM：在FPGA芯片内部，与逻辑元素紧密集成，可以提供非常低的延迟访问。\nDRAM：通常作为外部组件连接到FPGA，通过内存接口（如DDR）进行通信。\n\n\n功耗：\n\n\nBRAM：由于其简单性和快速访问能力，通常功耗较低。\nDRAM：由于需要刷新和复杂的控制逻辑，功耗通常更高。\n\n在选择使用BRAM还是DRAM时，设计者需要根据应用需求、性能要求、成本考虑和功耗限制来做出决策。对于需要高速、小容量存储的应用，BRAM通常是更好的选择；而对于需要大容量存储的应用，DRAM可能是更合适的选择。\n在FPGA中，BRAM（块RAM）可以被配置为单端口模式或双端口模式，这两种模式在数据访问方式上有所不同：\n\n单端口模式：\n\n\n在单端口模式下，BRAM有一个数据访问端口，即地址和数据线是共用的。\n在任何给定的时间，单端口BRAM只能进行一次读操作或写操作。如果在一个时钟周期内同时尝试进行读和写操作，通常会发生冲突，除非特定的FPGA具有特殊的管理机制。\n单端口模式适用于那些不需要同时进行读写操作的应用场景，或者那些可以接受顺序访问的应用场景。\n\n\n双端口模式：\n\n\n双端口模式允许BRAM同时通过两个独立的端口进行访问，每个端口都有自己的地址线、数据线和控制线。\n这意味着双端口BRAM可以在同一时钟周期内进行一次读操作和一次写操作，或者同时进行两次读操作，访问不同的地址。\n双端口模式适用于需要同时或并行访问存储器中不同位置的应用场景，如图像处理、缓存和乒乓缓冲等。\n\n在某些FPGA中，BRAM还可以配置为更高级的端口模式，如四端口模式，这允许更多的并行访问。设计者根据具体应用的需求来选择最合适的端口模式，以优化性能和资源利用。\n十六进制数系统中的每个数字代表4位二进制数\n在Verilog中，defparam是一个编译器指令，用于在模块实例化时重定义参数的值。这条指令可以用来改变模块实例化时参数的默认值。\n在Verilog中，localparam关键字用于声明一个模块内部的参数，这个参数在模块的整个作用域内都是常量。localparam声明的参数是不可变的，它们的值在编译时就已经确定了。\n","slug":"FPGA","date":"2024-04-24T03:03:09.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"6df1dc6e24cc645f9148dbaf83a17c60","title":"Android_Kotlin","content":"txt`class FirstActivity : AppCompatActivity() &#123;`\n`override fun onCreate(savedInstanceState: Bundle?) &#123;`\n`super.onCreate(savedInstanceState)`\n`&#125;`\n`&#125;`这段代码是使用 Kotlin 语言编写的 Android 应用程序中的一个活动（Activity）类。让我逐步解释其中的内容：\n\nclass FirstActivity : AppCompatActivity()：这是一个类的声明，类名为 FirstActivity，并且继承自 AppCompatActivity 类。AppCompatActivity 是 Android 开发中常用的一个基类，用于支持应用程序在较旧的 Android 版本上提供向后兼容性。\noverride fun onCreate(savedInstanceState: Bundle?)：这是 FirstActivity 类中的一个方法 onCreate() 的重写。在 Android 中，onCreate() 方法是活动生命周期的一部分，在活动第一次创建时被调用。savedInstanceState 参数是一个 Bundle 对象，其中包含了之前保存的活动状态信息，可以用于在活动重新创建时恢复状态。\nsuper.onCreate(savedInstanceState)：这是调用父类 AppCompatActivity 中的 onCreate() 方法，确保父类中的初始化工作得以执行。\n\n因此，这段代码定义了一个名为 FirstActivity 的活动类，当该活动第一次创建时，会调用父类的 onCreate() 方法进行初始化。\n在声明 savedInstanceState 参数时，如果在类型后面添加了 ?，则表示该参数可以接受 null 值。\n这样做的目的是为了允许 savedInstanceState 参数在某些情况下为 null，例如当活动或片段首次创建时，savedInstanceState 可能为 null，因为此时还没有保存任何状态信息。\n在 Kotlin 中，如果没有使用 ?，则表示该参数不接受 null 值，如果在实际使用中传递了 null 值，编译器将会报错。而使用了 ? 后，表示该参数可以接受 null 值，编译器将不会报错。\n因此，在 override fun onCreate(savedInstanceState: Bundle?) 中，Bundle? 表示 savedInstanceState 参数可以接受 null 值，即在某些情况下，savedInstanceState 可能为 null。\ntxt&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\nandroid:orientation=&quot;vertical&quot;\nandroid:layout_width=&quot;match_parent&quot;\nandroid:layout_height=&quot;match_parent&quot;&gt;\n&lt;Button\nandroid:id=&quot;@+id/button1&quot;\nandroid:layout_width=&quot;match_parent&quot;\nandroid:layout_height=&quot;wrap_content&quot;\nandroid:text=&quot;Button 1&quot;\n/&gt;\n&lt;/LinearLayout&gt;这段代码是一个简单的 Android 布局文件，使用 XML 格式描述了一个线性布局（LinearLayout）以及一个按钮（Button）的布局和属性。\n让我解释其中的一些关键部分：\n\n&lt;LinearLayout&gt;：这是一个布局容器，用于在垂直方向排列其子视图（例如按钮）。xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; 是 XML 命名空间声明，它使得可以在 XML 文件中使用 Android 提供的属性和元素。\nandroid:orientation=&quot;vertical&quot;：这个属性指定了线性布局的方向，即垂直方向。这意味着其中的子视图（此处为按钮）将会按照垂直方向排列。\nandroid:layout_width=&quot;match_parent&quot; 和 android:layout_height=&quot;match_parent&quot;：这两个属性指定了布局的宽度和高度。match_parent 表示该布局将会填充其父容器的宽度或高度，以占据尽可能多的空间。\n&lt;Button&gt;：这是一个按钮视图，在布局中用于响应用户的点击事件。\nandroid:id=&quot;@+id/button1&quot;：这个属性为按钮指定了一个唯一的标识符，可以在 Java 代码中使用这个标识符来查找和操作这个按钮。\nwrap_content 属性可以使得布局更加灵活，可以根据内容的大小动态调整视图的尺寸，而不是固定为特定的尺寸。\nandroid:text=&quot;Button 1&quot;：这个属性为按钮设置了显示的文本内容为 “Button 1”。\n\n因此，这段代码描述了一个垂直排列的线性布局，其中包含一个按钮，按钮显示文本为 “Button 1”。按钮的宽度会填充父容器的宽度，而高度则根据按钮文本的大小动态调整。\ntxtclass FirstActivity : AppCompatActivity() &#123;\noverride fun onCreate(savedInstanceState: Bundle?) &#123;\nsuper.onCreate(savedInstanceState)\nsetContentView(R.layout.first_layout)\n&#125;\n&#125;首先调用了 super.onCreate(savedInstanceState)，以确保调用了父类的 onCreate() 方法，以便执行必要的初始化操作。\n接着调用了 setContentView(R.layout.first_layout) 方法，这个方法用于设置该活动所使用的布局文件。在这里，first_layout 是指定的布局资源文件的名称，这个布局文件定义了活动的界面布局结构。\n因此，这段代码的作用是在 FirstActivity 中设置了一个布局文件 first_layout 作为活动的界面布局，并在活动创建时加载该布局。\nR.layout 是一个自动生成的资源标识符类，它包含了项目中所有布局文件的引用。在 Android 开发中，资源文件（如布局文件、字符串、图像等）都需要通过资源标识符来访问和引用。\n当你在项目中创建布局文件时，每个布局文件都会被编译成一个资源标识符，以便在代码中进行引用。这些资源标识符都会被统一放置在 R 类的内部静态类中，而 R.layout 则是其中用于引用布局文件的子类之一。\nIntent—&gt;用于通信的消息对象\n在 Android 中，Intent 是一种用于在不同组件之间进行通信的对象。它可以用于启动活动（Activity）、启动服务（Service）、发送广播（Broadcast）以及执行其他各种操作。Intent 提供了一种在不同组件之间传递数据和执行操作的机制。\nIntent 本质上是一个消息对象，用于指示想要执行的操作。它可以包含以下信息：\n\n操作（Action）：指示要执行的操作，如启动活动、启动服务、发送广播等。常见的操作包括 android.intent.action.VIEW（查看操作）、android.intent.action.SEND（发送操作）、android.intent.action.MAIN（主操作）等。\n数据（Data）：用于指定操作的数据，可以是 URI、文件路径、文本等。例如，如果要查看网页，可以将网页的 URL 作为数据传递给 Intent。\n类别（Category）：用于指定操作的类别，如 android.intent.category.LAUNCHER（启动器类别）、android.intent.category.BROWSABLE（可浏览类别）等。\n附加信息（Extras）：用于传递额外的数据给目标组件。Extras 是键值对的形式，可以包含各种数据类型，如字符串、整数、布尔值等。\n\nIntent 可以分为两种类型：\n\n显式 Intent：明确定义了目标组件的类名，用于启动特定的组件。\n隐式 Intent：没有明确指定目标组件，而是根据 Intent 的操作、数据等信息由系统来匹配合适的组件。\n\n通过使用 Intent，Android 应用程序可以实现各种功能，例如启动新的活动、执行后台任务、发送广播等，从而实现各种复杂的交互和功能。\nKotlin直接可以：\ntxtoverride fun onCreate(savedInstanceState: Bundle?) &#123;\nsuper.onCreate(savedInstanceState)\nsetContentView(R.layout.first_layout)\nbutton1.setOnClickListener &#123;\nToast.makeText(this, &quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show()\n&#125;\n&#125;在 Kotlin 中，函数声明的语法是：\ntxtfun 函数名(参数列表): 返回值类型 &#123;\n    // 函数体\n&#125;其中，返回值类型在函数名和参数列表之后，使用冒号 : 来标识。在这个语法中，返回值类型是必须的，但在某些情况下，如果函数没有返回值，可以将返回值类型指定为 Unit，或者省略返回值类型（在这种情况下，编译器会自动推断返回值类型为 Unit）。例如：\nkotlinkotlin\nfun greet(name: String): Unit &#123;\n    println(&quot;Hello, $name!&quot;)\n&#125;\n\n// 或者省略返回值类型，编译器会自动推断为 Unit\nfun greet(name: String) &#123;\n    println(&quot;Hello, $name!&quot;)\n&#125;txtoverride fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;\nmenuInflater.inflate(R.menu.main, menu)\nreturn true\n&#125;menuInflater 是 Android 开发中的一个类，用于从 XML 文件中创建菜单对象。在 Android 中，通常使用 XML 文件定义应用程序中的菜单，然后通过 MenuInflater 类将这些 XML 文件中定义的菜单加载到应用程序中的菜单对象中，以供在用户界面中显示和操作。\n具体来说，menuInflater.inflate() 方法用于将一个 XML 文件中定义的菜单资源加载到一个 Menu 对象中，这样就可以在应用程序的用户界面中显示这个菜单。\n在 Android 应用程序中，Activity 和 Fragment 是两种重要的组件，用于构建用户界面和处理用户交互。它们都可以包含用户界面的布局，并且可以响应用户的输入事件（如点击、滑动等）。\n下面是关于 Activity 和 Fragment 的简要介绍：\nActivity（活动）\n定义：Activity 是 Android 应用中的一个基本组件，代表一个单独的用户界面屏幕，通常是一个窗口、一个对话框或全屏显示的窗口。\n作用：Activity 主要负责管理用户与应用程序之间的交互，包括接收用户输入、处理用户操作，并在屏幕上显示相应的界面。\n生命周期：Activity 具有丰富的生命周期方法，如 onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy() 等，开发者可以根据需要重写这些方法来执行相应的操作。\n布局：Activity 可以通过设置布局文件（XML 文件）来定义用户界面的外观和行为，也可以通过代码动态地创建和管理用户界面。\n\nFragment（片段）\n定义：Fragment 是 Android 应用中的另一个基本组件，代表了一个可复用的用户界面模块，可以在一个 Activity 中嵌套多个 Fragment。\n作用：Fragment 主要用于构建灵活的用户界面，允许开发者将应用程序的功能拆分成可重用的模块，并在不同的屏幕尺寸和设备方向下进行适配。\n生命周期：Fragment 也有自己的生命周期方法，与 Activity 的生命周期方法类似，包括 onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy() 等。\n布局：Fragment 可以拥有自己的布局文件（XML 文件），也可以在宿主 Activity 中动态添加到布局中，允许开发者在运行时动态地添加、替换和移除 Fragment。\n\n总的来说，Activity 通常代表一个完整的屏幕，而 Fragment 则是 Activity 中一个可重用的组成部分，可以在一个 Activity 中组合多个 Fragment 来构建复杂的用户界面。在实际开发中，Activity 和 Fragment 经常一起使用，以实现灵活和高效的用户界面设计。\n在 Kotlin 中，?. 是安全调用运算符，用于在对象为非空时调用其方法或访问其属性。如果对象为 null，则安全调用运算符会短路并返回 null，而不会抛出空指针异常。\n在你提供的代码中，data?.getStringExtra(&quot;data_return&quot;) 的意思是，如果 data 不为 null，则调用 getStringExtra(&quot;data_return&quot;) 方法来获取名为 “data_return” 的额外数据，否则返回 null。这种写法可以避免在 data 为 null 时引发空指针异常。\nregisterForActivityResult(...)：这是一个用于注册 Activity Result 的函数。它接受一个 ActivityResultContract 对象作为参数，并返回一个 ActivityResultLauncher 对象。ActivityResultContract 是一个接口，用于定义活动启动和结果处理之间的合同。\nActivity类中定义了7个回调方法，覆盖了Activity生命周期的每一个环节:\n\nonCreate() 在Activity第一次被创建时调用\n\nonStart() 由不可见到可见时调用\n\nonResume()。这个方法在Activity准备好和用户进行交互的时候调用。此时的Activity一\n定位于返回栈的栈顶，并且处于运行状态。\n\nonPause()。这个方法在系统准备去启动或者恢复另一个Activity的时候调用。我们通常\n会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执\n行速度一定要快，不然会影响到新的栈顶Activity的使用。\n\nonStop()。这个方法在Activity完全不可见的时候调用。它和onPause()方法的主要区\n别在于，如果启动的新Activity是一个对话框式的Activity，那么onPause()方法会得到执行，而onStop()方法并不会执行。\n\nonDestroy()。这个方法在Activity被销毁之前调用，之后Activity的状态将变为销毁状态。\n\nonRestart()。这个方法在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。\n\n\nonPause() 方法是 Android Activity 生命周期中的一个回调方法，用于指示当前 Activity 正在失去焦点并即将暂停其可见性。当某些事件发生时，系统会调用 onPause() 方法，这些事件包括：\n\n启动另一个 Activity：当用户启动另一个 Activity 并且当前 Activity 失去焦点时，系统会调用 onPause() 方法。例如，当用户点击应用中的按钮，打开新的 Activity 时，当前 Activity 将暂停。\n打开对话框或弹出窗口：如果当前 Activity 打开了对话框、弹出了一个窗口或者其他部分覆盖了当前 Activity 但不完全遮挡，系统也会调用 onPause() 方法。\n接收到来电或其他中断：当用户接收到来电、收到短信或者其他中断事件时，当前 Activity 也会暂停，系统会调用 onPause() 方法。\n用户按下 Home 键或切换到最近任务列表：当用户按下 Home 键返回桌面或切换到最近任务列表时，当前 Activity 也会暂停，系统会调用 onPause() 方法。\n\n总之，onPause() 方法的调用情况涵盖了当前 Activity 失去焦点并即将暂停可见性的各种情况。\nonStart() 是 Android 活动生命周期中的一个方法，用于指示活动即将变为可见状态。当活动首次启动或从停止状态恢复到活动栈时，系统会调用 onStart() 方法。\n具体情况下，onStart() 方法会在以下几种情况下被调用：\n\n当活动首次启动：当用户启动应用程序并打开了包含该活动的界面时，系统会调用活动的 onStart() 方法。此时，活动将从不可见状态转变为可见状态。\n当活动从暂停状态恢复：如果一个活动从 onPause() 状态恢复到前台状态，系统会先调用 onStart() 方法，然后调用 onResume() 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。\n\n在 onStart() 方法中，通常执行一些与界面相关的初始化操作，比如恢复 UI 状态、注册广播接收器或者启动一些后台任务。需要注意的是，尽管活动已经变为可见状态，但此时活动并未处于用户的焦点下，用户可能无法与其进行交互。\nonResume() 是 Android 活动生命周期中的一个方法，用于指示活动即将成为用户焦点并开始与用户进行交互。当活动从不可见状态变为可见状态，并且用户可以开始与其进行交互时，系统会调用 onResume() 方法。\n具体情况下，onResume() 方法会在以下几种情况下被调用：\n\n当活动首次启动：当用户首次启动应用程序并打开了包含该活动的界面时，系统会先调用 onStart() 方法，然后调用 onResume() 方法。此时，活动将从不可见状态转变为可见状态，并且用户可以开始与其进行交互。\n当活动从暂停状态恢复：如果一个活动从 onPause() 状态恢复到前台状态，系统会先调用 onStart() 方法，然后调用 onResume() 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。\n当活动从停止状态恢复：如果一个活动从 onStop() 状态恢复到前台状态，系统会依次调用 onRestart()、onStart() 和 onResume() 方法。这种情况通常发生在用户按下 Home 键后再次打开应用程序的情况下。\n\n在 onResume() 方法中，通常执行一些与活动生命周期相关的操作，比如恢复用户的输入状态、启动动画效果或者连接到一些外部服务。需要注意的是，当活动处于 onResume() 状态时，它已经成为了用户焦点下的活动，并且用户可以直接与其进行交互。\n\n当将视图或布局的尺寸设置为 “wrap_content” 时，系统会根据其内容自动调整视图或布局的尺寸，以便刚好容纳其内\n在 Android 的清单文件（AndroidManifest.xml）中声明活动（Activity）时，可以使用两种方式：\n\n&lt;activity&gt;...&lt;/activity&gt;：这是一种传统的 XML 标签方式，用于定义活动的属性和行为。在 &lt;activity&gt; 标签中，可以指定活动的各种属性，例如名称、图标、主题等，并且可以包含其他标签和属性以提供更详细的配置。通常情况下，你可以在 &lt;activity&gt; 标签内部设置更多的属性，包括活动的名称、图标、主题等，以及与活动相关的其他设置。\n&lt;activity/&gt;：这是一种自闭合的 XML 标签方式，用于简单地声明一个活动而不指定任何属性或配置。这种方式适用于简单的活动声明，当你不需要指定任何属性或配置时，可以使用这种方式。例如，如果你的活动只需要基本的声明，而不需要指定任何其他属性或配置，你可以使用 &lt;activity/&gt; 标签。\n\n因此，你应该根据活动的具体需求和配置选择适当的方式。如果需要指定活动的各种属性和配置，可以使用 &lt;activity&gt;...&lt;/activity&gt; 标签；如果活动只需要基本的声明而不需要指定任何其他属性或配置，可以使用 &lt;activity/&gt; 标签。\n@style/Theme.AppCompat.Dialog 是指在 Android 应用程序中使用的一个预定义的对话框主题样式。这个样式通常用于创建对话框，即弹出式窗口，以在应用程序中显示临时信息、接受用户输入或执行其他操作。\n这个主题样式基于 AppCompat 库提供的默认对话框主题进行定义，并且与 AppCompat 库中其他主题一样，它提供了跨不同 Android 版本的一致外观和行为。这样，你的应用程序就可以在不同版本的 Android 上保持一致的外观和用户体验。\nandroid:exported=&quot;false&quot; 是 Android 清单文件中 &lt;activity&gt; 元素的一个属性，用于指定该活动是否能够被其他应用程序组件或者系统组件访问。具体含义如下：\n\n如果 android:exported=&quot;false&quot;，则表示该活动不会被其他应用程序或系统组件调用。这意味着该活动只能被声明它的应用程序内部的组件所访问，其他应用程序或系统组件无法直接启动或与其交互。\n如果 android:exported=&quot;true&quot;，则表示该活动可以被其他应用程序或系统组件调用。这意味着其他应用程序可以使用显式或隐式意图启动该活动，并且与其进行交互。\n\n在你的示例中，android:exported=&quot;false&quot; 意味着 DialogActivity 这个活动不会被其他应用程序或系统组件访问。它只能被声明它的应用程序内部的组件所访问，其他应用程序无法直接启动或与其交互。这通常用于内部使用的活动，例如只在应用程序内部使用的对话框或者配置界面。\n在 Android 开发中，Intent（意图）是用于在不同组件之间传递数据或执行操作的对象。它是一种在 Android 应用程序中实现组件之间通信的重要机制。\nIntent 主要有两种类型：显式 Intent 和隐式 Intent。\n\n显式 Intent：用于启动应用程序内部的组件，例如启动另一个活动（Activity）、启动服务（Service）等。显式 Intent 通过指定目标组件的类名来明确指示要执行的操作。\n示例：\n\n\ntxtIntent intent = new Intent(this, AnotherActivity.class);\nstartActivity(intent);隐式 Intent：用于启动应用程序内或其他应用程序中具有特定功能的组件，而不需要指定目标组件的类名。隐式 Intent 根据指定的动作（Action）、数据（Data）等信息来寻找合适的组件执行操作。\n示例：\n\ntxtIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.example.com&quot;));\nstartActivity(intent);\n\nIntent 的主要作用包括但不限于：\n\n启动活动、服务或广播接收器等组件。\n在组件之间传递数据，例如在不同活动之间传递参数。\n执行一些系统级别的操作，例如拨打电话、发送短信、打开网页等。\n\n总之，Intent 是 Android 应用程序中用于实现组件之间通信和执行操作的重要机制。\n在 Android 中，Bundle 是一个用来存储键值对数据的容器类。它通常被用于在不同的组件（如活动、片段）之间传递数据，或者在组件销毁和重新创建时保存和恢复数据的状态。\n在 onCreate() 方法中，Bundle 参数 savedInstanceState 表示上一个实例状态的数据。当活动被销毁并重新创建时（例如，由于设备旋转或内存紧张），Android 系统会调用 onSaveInstanceState() 方法来保存当前的状态数据，并将其存储在 Bundle 中。然后，在活动重新创建时，系统会将之前保存的状态数据传递给 onCreate() 方法的 savedInstanceState 参数。\ntxtLog.d(&quot;FirstActivity&quot;, this.toString())this.toString() 是调用当前对象的 toString() 方法。在 Java 中，几乎所有的对象都继承自 Object 类，而 Object 类中有一个 toString() 方法，用于返回对象的字符串表示形式\n当你调用 this.toString() 时，它会返回当前对象的字符串表示形式\nActivity的启动模式:\n\nstandard\nsingleTop  单栈顶\nsingleTask   单任务\nsingleInstance  单实例\n\n在 Kotlin 中，object 关键字用于定义单例对象。单例对象是指在程序运行期间只有一个实例存在的对象。在给定的作用域内，单例对象只能有一个实例，因此它们非常适合用于管理全局状态或提供全局访问点。\n关闭所有活动并不等同于关闭应用程序的进程。在 Android 应用程序中，当你调用 finish() 方法结束一个活动时，这个活动会被销毁，但应用程序的进程仍然在运行。即使所有活动都被销毁，应用程序的进程仍然存在于系统中。\n为了完全退出应用程序，有时需要调用 System.exit(0) 或者 Process.killProcess(Process.myPid()) 这样的方法来结束应用程序的进程。这样做可以确保应用程序的所有组件都被终止，包括活动、服务、广播接收器等，从而实现应用程序的完全退出。\n然而，这种做法通常被视为不推荐的，因为它可能会导致用户体验上的问题，以及系统资源的浪费。通常情况下，Android 系统会自动管理应用程序的进程，并在必要时终止它们，而不需要手动干预。因此，大多数情况下，关闭所有活动即可满足应用程序退出的需求，而无需手动杀死进程。\n在 Kotlin 中，companion object（伴生对象）具有以下作用：\n\n静态成员访问：伴生对象中的成员可以直接通过类名访问，就像 Java 中的静态成员一样。这使得可以在不创建类的实例的情况下访问这些成员。\n工厂方法：可以在伴生对象中定义工厂方法，用于创建类的实例。这种方法通常用于隐藏类的构造函数，提供一种更灵活的方式来创建实例。\n共享代码：伴生对象可以包含在类的所有实例之间共享的代码或常量。这些代码或常量对于类的所有实例都是相同的，可以方便地通过伴生对象访问。\n扩展方法：在伴生对象中还可以定义扩展方法，这些方法可以为类添加额外的功能，而无需继承或修改类的源代码。\n\n总的来说，伴生对象提供了一种在 Kotlin 中实现类级别功能的方式，它可以用于静态成员访问、工厂方法、共享代码和扩展方法等场景。\nStringBuilder是Java中的一个类，用于处理字符串。它允许你在不创建新的String对象的情况下进行字符串的修改和操作，这样可以提高性能并节省内存。\n当你需要对字符串进行频繁的修改时，使用StringBuilder通常比直接使用String更高效。这是因为String是不可变的，每次对String进行修改都会创建一个新的String对象，而StringBuilder允许你在同一个对象上执行多次修改操作。\n你可以使用StringBuilder的append()方法来添加字符串，使用delete()方法来删除字符串，使用insert()方法来在指定位置插入字符串，使用replace()方法来替换字符串等等。最后，你可以使用toString()方法将StringBuilder对象转换为String对象，以便进行进一步的操作或输出。\nval list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val builder = StringBuilder() builder.append(&quot;Start eating fruits.\\n&quot;) for (fruit in list) &#123; builder.append(fruit).append(&quot;\\n&quot;) &#125; builder.append(&quot;Ate all fruits.&quot;) val result = builder.toString() println(result) 为什么最后要调用builder.toString()，不能直接打印吗\n在上面的代码中，builder是一个StringBuilder对象，而println函数通常接受String类型的参数来进行输出。而builder对象是一个StringBuilder类型的对象，不是String类型的对象，因此无法直接传递给println函数。\n调用builder.toString()方法将StringBuilder对象转换为String类型的对象，这样就可以将其作为参数传递给println函数，从而实现输出。toString()方法会返回StringBuilder对象中包含的所有字符序列作为一个字符串。\n因此，为了能够正确地输出builder对象中的内容，需要先调用toString()方法将其转换为String类型的对象，然后再传递给println函数进行打印。\nwith 是 Kotlin 的一个标准库函数，它提供了一种简洁的方式来执行针对特定对象的一系列操作，并返回最后一个表达式的结果。\nAlertDialog.Builder(this).apply &#123; setTitle(&quot;This is Dialog&quot;) setMessage(&quot;Something important.&quot;) setCancelable(false) setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; &#125; setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; &#125; show() 是什么意思\n这段代码是使用 Kotlin 的标准库函数 apply 来构建一个 AlertDialog 对话框，并设置其标题、消息、按钮等属性。下面是代码的解释：\n\nAlertDialog.Builder(this)：创建了一个 AlertDialog.Builder 的实例，这个实例用于构建一个对话框。\napply &#123; ... &#125;：apply 是一个 Kotlin 标准库函数，它接收一个 lambda 表达式作为参数，并在 lambda 表达式的作用域内执行一系列操作。在这个例子中，apply 函数被调用后，会将调用者对象（即 AlertDialog.Builder 的实例）作为参数传递给 lambda 表达式，并在 lambda 表达式内部执行一系列设置操作。\nsetTitle(&quot;This is Dialog&quot;)：在 lambda 表达式中调用 setTitle 方法，设置对话框的标题为 “This is Dialog”。\nsetMessage(&quot;Something important.&quot;)：在 lambda 表达式中调用 setMessage 方法，设置对话框的消息内容为 “Something important.”。\nsetCancelable(false)：在 lambda 表达式中调用 setCancelable 方法，设置对话框为不可取消状态，即用户点击对话框外部或返回键时不会关闭对话框。\nsetPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; ... &#125;：在 lambda 表达式中调用 setPositiveButton 方法，设置对话框的确定按钮文本为 “OK”，并设置点击事件处理器。在这里，&#123; dialog, which -&gt; ... &#125; 是一个 lambda 表达式，表示当用户点击确定按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。\nsetNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; ... &#125;：在 lambda 表达式中调用 setNegativeButton 方法，设置对话框的取消按钮文本为 “Cancel”，并设置点击事件处理器。同样，&#123; dialog, which -&gt; ... &#125; 是一个 lambda 表达式，表示当用户点击取消按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。\nshow()：在所有设置完成后，调用 show 方法显示对话框。\n\n因此，这段代码的作用是创建一个带有标题、消息、确定按钮和取消按钮的对话框，并将其显示在界面上。\n三种基本布局：\n\nLinearLayout垂直排布\nRelativeLayout相对布局\nFrameLayout帧布局\n\n\noverride fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123; val view = LayoutInflater.from(context).inflate(resourceId, parent, false) val fruitImage: ImageView = view.findViewById(R.id.fruitImage) val fruitName: TextView = view.findViewById(R.id.fruitName) val fruit = getItem(position) // 获取当前项的Fruit实例 if (fruit != null) &#123; fruitImage.setImageResource(fruit.imageId) fruitName.text = fruit.name &#125; return view &#125;\n其中：val view &#x3D; LayoutInflater.from(context).inflate(resourceId, parent, false)\n作用是从 XML 布局文件中创建一个视图对象，并将其添加到指定的父视图中。\n解释每个参数的含义：\n\ncontext: 表示当前的上下文环境，通常是一个 Activity 或 Fragment 的实例。\nresourceId: 表示要加载的布局文件的资源 ID，即 XML 文件的唯一标识符。\nparent: 表示要将创建的视图添加到的父视图，通常是一个 ViewGroup，比如一个 LinearLayout 或者一个 RecyclerView。\nfalse: 表示在加载布局文件时，不将其添加到父视图中。这个参数设置为 false 表示我们会手动将视图添加到父视图中，而不是在加载时自动添加。\n\n接口在编程中有多种作用，包括但不限于以下几个方面：\n\n定义约束和契约：接口定义了一组方法或属性的规范，实现该接口的类必须提供这些方法或属性的具体实现。这种约束和契约使得代码更加清晰，使得不同的类可以共享相同的行为规范。\n实现多态：通过接口，可以实现多态，即在不同的类中使用相同的方法名，但实际调用的是各自类的具体实现。这样可以提高代码的灵活性和可扩展性。\n代码重用：接口可以用于定义通用的行为规范，使得多个类可以共享相同的接口定义，从而实现代码的重用。当多个类具有相似的行为或功能时，可以通过接口来统一定义这些行为或功能，避免重复编写代码。\n降低耦合性：通过接口，类与类之间的耦合度可以降低，因为类之间通过接口进行交互，而不是直接依赖于具体的实现。这样，当一个类的实现发生变化时，只需要修改实现该接口的类，而不需要修改其他使用该类的代码。\n接口委托：接口支持委托，一个接口可以通过另一个对象来实现其方法，这种方式称为接口委托。这种机制可以进一步提高代码的灵活性和可复用性。\n\n总的来说，接口是一种重要的编程工具，可以帮助程序员设计出更加灵活、可扩展和易于维护的代码结构。\ninterface接口\nsealed class密封类\n\ncompanion object 是 Kotlin 中的一个关键字，它用于创建一个伴随对象。伴随对象是类中的一个单例对象，可以通过类名直接访问其中的属性和方法\nnews_content_frag.xml——–&gt;NewsContentFragment类———–&gt;NewsContentActivity\nnews_item.xml——–&gt;news_title_frag.xml———&gt;NewsTitleFragment类———-&gt;\nlayout&#x2F;activity_main.xml——-&gt;单页模式;\nNewsTitleFragment类————&gt;\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\tlayout-sw600dp&#x2F;activity_main.xml——–&gt;双页模式;\nNewsContentFragment类——-&gt;\n在NewsTitleFragment类中通过RecyclerView将新闻列表展示出来\n在 Kotlin 中，open 关键字用于声明一个类、方法或属性是可以被继承或覆盖的。具体来说：\n\n类（Class）：在类声明前加上 open 关键字，表示这个类是可以被其他类继承的。如果不加 open 关键字，则默认情况下类是 final 的，不能被继承。\n\ntxtkotlin\nopen class BaseActivity : AppCompatActivity() &#123;\n    // 可以被继承的类\n&#125;\n方法（Method）：在方法声明前加上 open 关键字，表示这个方法是可以被子类覆盖（重写）的。如果不加 open 关键字，则默认情况下方法是 final 的，不能被子类覆盖。\n\ntxtkotlin\nopen fun someMethod() &#123;\n    // 可以被子类重写的方法\n&#125;\n属性（Property）：在属性声明前加上 open 关键字，表示这个属性是可以被子类覆盖的。如果不加 open 关键字，则默认情况下属性是 final 的，不能被子类覆盖。\n\ntxtkotlin\nopen val someProperty: Int = 0使用 open 关键字可以让类的设计更加灵活，允许其他类继承并重写其中的方法，或者覆盖属性的行为。\nval square: (Int) -&gt; Int = &#123; x: Int -&gt; x * x &#125;\nsquare是(Int) -&gt; Int函数类型的变量，表示接受一个 Int 类型的参数，并返回一个 Int 类型的结果。\nLambda 表达式 &#123; x: Int -&gt; x * x &#125; 被赋给了这个变量\nfun save(inputText: String) &#123;try &#123;val output = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE)val writer = BufferedWriter(OutputStreamWriter(output))writer.use &#123;it.write(inputText)&#125;&#125; catch (e: IOException) &#123;e.printStackTrace()&#125;&#125;\n这段代码定义了一个名为 save 的函数，它接受一个 inputText 参数，类型为 String。函数的作用是将输入的文本内容保存到文件中。让我解释一下代码的逻辑：\n\nopenFileOutput(&quot;data&quot;, Context.MODE_PRIVATE): 这行代码打开一个名为 “data” 的文件，并返回一个 FileOutputStream 对象。这个文件将会存储在应用的内部存储空间中，因为使用了 Context.MODE_PRIVATE 参数，表示只有当前应用可以访问这个文件，并且会覆盖掉同名的文件（如果存在）。\nval writer = BufferedWriter(OutputStreamWriter(output)): 这行代码创建了一个 BufferedWriter 对象，并将其包装在一个 OutputStreamWriter 中，以便将文本写入到 output 中。\nwriter.use &#123; it.write(inputText) &#125;: 这行代码使用 Kotlin 的 use 函数，确保在使用结束后正确关闭 writer，以释放资源。在 use 函数的 lambda 表达式中，调用了 write 方法，将 inputText 写入到文件中。\ncatch (e: IOException) &#123; e.printStackTrace() &#125;: 这是一个异常处理块，如果在保存文件时发生了 IOException 异常，程序将会打印异常的堆栈信息。\n\n将委托功能分为了两种：类委托和委托属性\n","slug":"Android-Kotlin","date":"2024-04-21T12:52:23.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"4961e15af02b68ebd599dc1652c0f600","title":"Inference_Framework","content":"PNNXPNNX项目 PyTorch Neural Network eXchange（PNNX）是PyTorch模型互操作性的开放标准。PNNX为PyTorch提供了一种开源的模型格式，它定义了与Pytorch相匹配的数据流图和运算图，我们的框架在PNNX之上封装了一层更加易用和简单的计算图格式。pytorch训练好一个模型之后，然后模型需要转换到pnnx格式，然后pnnx格式我们再去读取，形成计算图.\npytorch到我们计算图？\nPNNX帮我做了很多的图优化、算子融合的工作，所以底层的用它PNNX的话，我们可以吸收图优化的结果，后面推理更快.\n但是不直接在项目中用PNNX，因为别人的工作和自己推理框架开发思路总是有不同的。所以在这上面封装，又快速又好用方便，符合自己的使用习惯。\n我们只是去读取PNNX产物，然后构建自己一种易用的计算图结构。\n产物：resnet18.pnnx.param PNNX graph definition 结构定义\nresnet18.pnnx.bin PNNX model weight 权重\nPNNX的格式定义:\nPNNX由操作数operand(运算数)和operator(运算符号)，PNNX::Graph用来管理和操作这两者。\n操作数(operand)，也可以通过操作数来方向访问到这个数字的产生者和使用者Customer\nOperand有以下几个部分组成:\nProducer: 类型是operator, 表示产生了这个操作数的运算符(operator). 也就是说这个操作数(operand)是Producer的输出. Producer这个操作符号产生了当前的OperandCustomer:类型是operator, 表示需要这个操作数下一个操作的的运算符(operator)，也就是说这个操作数(operand)作为Customer的输入存在.\nName: 类型是std::string, 表示这个操作数的名称.ValuesShape: 类型是std::vector , 用来表示操作数的大小,\nthis：指针，指向当前对象的地址。在类的成员函数中，this关键字指向当前对象。\n-&gt;：成员访问运算符，用来访问类的成员变量或成员函数。\n在 C++11 中，使用 new 创建动态分配的对象并不安全，因为需要手动管理资源的释放，容易出现内存泄漏或者忘记释放资源导致的内存泄漏。为了更加安全和方便地管理动态分配的对象，C++11 引入了智能指针，其中 std::unique_ptr 是一种独占所有权的智能指针，它负责在对象不再需要时释放所占用的内存。\n图（graph） 节点（vertex）  边（edge）\n","slug":"Inference-Framework","date":"2024-04-13T09:01:40.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"9247c802e822e7604ecac76759948ceb","title":"电路Learning","content":"\n\n\n一阶电路三要素法：https://zhuanlan.zhihu.com/p/367671862\n续流二极管的作用：当输入电压由变+VCC为0V时，三极管由饱和变为截止，这样继电器电感线圈中的电流突然失去了流通通路，若无续流二极管D将在线圈两端产生较大的反向电动势，极性为下正上负，电压值可达一百多伏，这个电压加上电源电压作用在三极管的集电极上足以损坏三极管。故续流二极管D的作用是将这个反向电动势通过图中箭头所指方向放电，使三极管集电极对地的电压最高不超过+VCC +0.7V。\n\n桥式全波整流电路\n\n\n\n\n衰减电阻网络需要搭配上电容来进行补偿是什么意思\n在电子电路中，衰减电阻网络通常是指由电阻组成的网络，用于降低信号的电压或电流。而提到衰减电阻网络需要搭配电容来进行补偿，这通常是指在某些电路设计中，为了改善电路的性能，需要在不改变电路基本功能的前提下，通过添加电容元件来修正或改善电路的某些特性。补偿电容的作用可能包括：\n\n改善频率响应：在某些电路中，电阻网络可能会引入一定的相位偏移，导致电路在高频工作时性能变差。添加电容可以补偿这种相位偏移，从而改善电路的带宽和频率响应。\n减少噪声：电容可以起到滤波的作用，减少电路中的噪声成分，使输出信号更干净。\n改善稳定性：在某些电路中，电容可以用来改善系统的稳定性，例如在反馈电路中，适当的电容值可以帮助电路更快地稳定在工作点。\n消除振荡：如果电路中存在不需要的振荡，适当的电容值可以用来消除这些振荡。\n定时作用：在某些振荡电路中，电容与电阻配合使用，可以决定振荡频率。补偿电容的值和位置需要根据具体的电路设计和所需的性能来确定。通常，电路设计者会根据电路的频率特性、相位特性以及所需的带宽等因素来选择合适的电容类型和值。\n\n为什么添加电容可以补偿这种相位偏移\n在电路中，电阻和电容都会引入相位偏移。电阻器的相位偏移通常与频率成正比，而电容器则与频率成反比.为了补偿这种相位偏移，电路设计者会在电路中添加电容器，以便在高频应用中提供额外的相位移动，从而抵消电阻引起的相位偏移。通过这种方式，电路可以在整个频率范围内保持稳定的相位响应，从而提高电路的整体性能。\n","slug":"电路Learning","date":"2024-04-13T02:08:03.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"a92cda69d94e66650e74496352232332","title":"pcl","content":"&#96;&#96;c make -DCMAKE_BUILD_TYPE&#x3D;None `      -DCMAKE_INSTALL_PREFIX=/home/zgh/pcl_1.9.1_compile \\      -DBUILD_GPU=ON \\      -DBUILD_apps=ON \\      -DBUILD_examples=ON\n-DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-12.2 \\\n-DCUDA_ARCH_BIN=8.6 \\\n-DCUDA_ARCH_PTX=8.6 ..\ncmake  if(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;10.0&quot;)\n    set(__cuda_arch_bin &quot;3.0 3.5 5.0 5.2 5.3 6.0 6.1 7.0 7.2 7.5&quot;)\n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;9.1&quot;)\n    set(__cuda_arch_bin &quot;3.0 3.5 5.0 5.2 5.3 6.0 6.1 7.0 7.2&quot;)\n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;9.0&quot;)\n    set(__cuda_arch_bin &quot;3.0 3.5 5.0 5.2 5.3 6.0 6.1 7.0&quot;)  \n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;8.0&quot;)\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0) 3.0 3.5 5.0 5.2 5.3 6.0 6.1&quot;)\n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;6.5&quot;)\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0) 3.0 3.5 5.0 5.2&quot;)\n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;6.0&quot;)\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0) 3.0 3.5 5.0&quot;)\n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;5.0&quot;)\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0) 3.0 3.5&quot;)\n  elseif($&#123;CUDA_VERSION_STRING&#125; VERSION_GREATER &quot;4.1&quot;)\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0) 3.0&quot;)\n  else()\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0)&quot;)\n  endif()NXHAY2OW76-eyJsaWNlbnNlSWQiOiJOWEhBWTJPVzc2IiwibGljZW5zZWVOYW1lIjoiSHVuYW4gSW5zdGl0dXRlIG9mIFNjaWVuY2UgYW5kIFRlY2hub2xvZ3kiLCJsaWNlbnNlZVR5cGUiOiJDTEFTU1JPT00iLCJhc3NpZ25lZU5hbWUiOiJ0bXUgaXRtYW5hZ2VyIiwiYXNzaWduZWVFbWFpbCI6InRtdWl0bWFuYWdlckBvdXRsb29rLmNvbSIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU0MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRTIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNWIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQU0kiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUENXTVAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiRFAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjMxMTA5TFBBQTAwOTAwNyIsImhhc2giOiI0MjU0OTY3OS8xMzU2NTA1OTotNDU5NTIyNTciLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwidHJpYWwiOmZhbHNlLCJhaUFsbG93ZWQiOnRydWV9-t3Mcnh+cc&#x2F;DF5z54xXxQ1wh2DTHULDDp0xl9P1s3jRugff7MKaHhYu8MFuKB8smfDaUysLfs94WjunQJeCc4L&#x2F;gMi024G9o&#x2F;O2yBx4&#x2F;Ho9yU7SeYOvnuMqPwwpczR&#x2F;U2JcIZAhH9YPdOo5E7CEtPEW5cq774wN7MrXnHK+LPN6uE4asZ&#x2F;Qk3g3TyqpD3R7ubTmtkAx8JF6iWrezyLNngezgq3NkSE+3LZFuOLep6EKsOJeuaPCKD1uSFJZK7yzUkcLq+H&#x2F;AZDOPZ+Gk9ZTl+P8TlRw3DIA1WDMORmycx5Q4mG+y2cNJoj9r0gfZPiw8OcmcQI8icyF2yTLnWOopRUg&#x3D;&#x3D;-MIIETDCCAjSgAwIBAgIBDzANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMTAxMDE2MDU0NFoXDTI0MTAxMTE2MDU0NFowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMjEwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC&#x2F;W3uCpU5M2y48rUR&#x2F;3fFR6y4xj1nOm3rIuGp2brELVGzdgK2BezjnDXpAxVDw5657hBkAUMoyByiDs2MgmVi9IcqdAwpk988&#x2F;Daaajq9xuU1of59jH9eQ9c3BmsEtdA4boN3VpenYKATwmpKYkJKVc07ZKoXL6kSyZuF7Jq7HoQZcclChbF75QJPGbri3cw9vDk&#x2F;e46kuzfwpGftvl6+vKibpInO6Dv0ocwImDbOutyZC7E+BwpEm1TJZW4XovMBegHhWC04cJvpH1u98xoR94ichw0jKhdppywARe43rGU96163RckIuFmFDQKZV9SMUrwpQFu4Z2D5yTNqnlLRfAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQU5FZqQ4gnVc+inIeZF+o3ID+VhcEwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBANLG1anEKid4W87vQkqWaQTkRtFKJ2GFtBeMhvLhIyM6Cg3FdQnMZr0qr9mlV0w289pf&#x2F;+M14J7S7SgsfwxMJvFbw9gZlwHvhBl24N349GuthshGO9P9eKmNPgyTJzTtw6FedXrrHV99nC7spaY84e+DqfHGYOzMJDrg8xHDYLLHk5Q2z5TlrztXMbtLhjPKrc2+ZajFFshgE5eowfkutSYxeX8uA5czFNT1ZxmDwX1KIelbqhh6XkMQFJui8v8Eo396&#x2F;sN3RAQSfvBd7Syhch2vlaMP4FAB11AlMKO2x&#x2F;1hoKiHBU3oU3OKRTfoUTfy1uH3T+t03k1Qkr0dqgHLxiv6QU5WrarR9tx&#x2F;dapqbsSmrYapmJ7S5+ghc4FTWxXJB1cjJRh3X+gwJIHjOVW+5ZVqXTG2s2Jwi2daDt6XYeigxgL2SlQpeL5kvXNCcuSJurJVcRZFYUkzVv85XfDauqGxYqaehPcK2TzmcXOUWPfxQxLJd2TrqSiO+mseqqkNTb3ZDiYS&#x2F;ZqdQoGYIUwJqXo+EDgqlmuWUhkWwCkyo4rtTZeAj+nP00v3n8JmXtO30Fip+lxpfsVR3tO1hk4Vi2kmVjXyRkW2G7D7WAVt+91ahFoSeRWlKyb4KcvGvwUaa43fWLem2hyI4di2pZdr3fcYJ3xvL5ejL3m14bKsfoOv\npcl::PointCloud 和 pcl::PCLPointCloud2 是 PCL 中两种不同的点云数据结构，它们之间的主要区别在于数据的组织形式和灵活性：\n\npcl::PointCloud：\npcl::PointCloud 是 PCL 中用于表示点云的模板类。\n它是一种比较高级的数据结构，已经预定义了点云中每个点的字段（如坐标、法向量等）以及数据类型（如PointXYZ、Normal等）。\n使用 pcl::PointCloud 可以更方便地访问和处理点云数据，因为它提供了成员函数来操作点云中的点，如添加、删除、修改等操作。\n\n\npcl::PCLPointCloud2：\npcl::PCLPointCloud2 是 PCL 中用于表示点云的更底层、更通用的数据结构。\n它是一种更灵活的数据结构，可以容纳任意类型和数量的字段，适合表示各种形式的点云数据。\n使用 pcl::PCLPointCloud2 需要通过字段的偏移量和数据类型来手动解析和访问点云数据，相对复杂一些。\n\n\n\n总的来说，pcl::PointCloud 更适合处理已知结构和类型的点云数据，而 pcl::PCLPointCloud2 则更适合处理未知结构或需要更大灵活性的点云数据。在实际应用中，根据具体需求选择合适的数据结构进行点云数据的处理和操作。\nstd::cerr 通常用于输出程序运行时的错误信息、警告信息等\n","slug":"pcl","date":"2024-01-31T02:04:42.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"a844e8402236c25b1a86bfe3611488cf","title":"Embedded","content":"为什么原理图里的stm32f4的VCAP1引脚要接一个4.7微法的电容，再接地呢\n2023&#x2F;12&#x2F;25 08:23:32\nSTM32F4芯片的VCAP1引脚是芯片内部电容的引出端，用于连接外部电容以提供给芯片内部振荡电路使用。在使用高速外设时，由于这些外设需要非常稳定的电源供应，因此需要在VCAP1引脚与地之间连接一个电容来提高芯片的稳定性。\n具体来说，连接4.7微法的电容可以起到平滑电压、提高电源噪声抑制能力等作用，从而提高芯片的工作稳定性和可靠性。此外，需要注意电容的选型要符合芯片手册的要求，不能超出规定的范围。\n2023&#x2F;12&#x2F;25 08:26:15芯片内部还有电容吗\n2023&#x2F;12&#x2F;25 08:26:20\n是的，芯片内部通常会包含一些电容。这些内部电容主要用于稳定芯片的电源供应和进行滤波。它们的作用包括：\ntxt电源滤波：在芯片内部集成了一些小型电容器，用于过滤电源中的噪声和干扰，确保芯片正常运行所需的电源干净和稳定。\n\n芯片电源稳定：芯片内部可能还包含一些供电相关的电容，用于提供瞬态响应和电源稳定性，以确保芯片在各种工作条件下都能正常工作。这些内部电容一般由芯片制造商在设计阶段根据具体需求添加，并在芯片手册或参考设计中进行了详细说明。在使用芯片时，我们不需要特别处理这些内部电容，只需按照芯片手册的要求合理连接外部电容即可。\n2023&#x2F;12&#x2F;25 08:26:41那为什么还要连接外部电容\n2023&#x2F;12&#x2F;25 08:26:48\n连接外部电容主要是为了进一步提高芯片的电源稳定性和抑制电磁干扰。虽然芯片内部已经包含了一些电容，但这些电容的容值较小且位置相对固定，可能无法满足某些特殊应用或高要求的电源稳定性。\n通过在VCAP1引脚与地之间连接外部电容，可以实现以下效果：\ntxt改善电源噪声抑制能力：外部电容可以提供更大的容值，能够更好地滤除电源中的高频噪声和纹波，从而提供更稳定的电源供应。\n\n提供额外的瞬态响应：外部电容能够快速响应芯片工作状态的变化，提供更好的瞬态响应能力，尤其在高速外设工作时，可以提供更稳定的电源给这些外设。\n\n抑制电磁干扰：外部电容能够帮助减少电源线上的电磁辐射和接收到的外界干扰信号，提高系统的抗干扰能力，保证芯片的正常运行。需要注意的是，具体的外部电容选型和连接方式应根据芯片厂商提供的参考设计或芯片手册的建议进行，以确保电路的稳定性和可靠性。\n\n\n配置通道    具有检测正反插…..等\n\n边带使用实现…..\n\n\n\n\n\nOSC32IN引脚，用于连接外部低速晶体振荡器（32.768 kHz）。这种振荡器通常用于实时时钟（RTC)的时基。\nOSC_IN引脚，用于连接外部高速晶体振荡器（通常在4 MHz到26 MHz之间）。这种振荡器通常用于系统时钟（SYSCLK）的时基。\nVBAT代表电池供电引脚（Voltage Battery）。VBAT引脚用于连接外部备用电池，通常是一个小型电池，以提供芯片的备份电源。\nVCAP1是指STM32系列芯片上的一个电容滤波器引脚，用于为芯片内部提供稳定的电源环境,用于去除芯片电源中的高频噪声和波动。\n\n在电路设计中，加入0欧电阻（也称为短接电阻）有以下几个常见的目的：\n\n电路连接：0欧电阻可以作为电路的连接点，将不同信号线或电源线连接在一起。它可以提供良好的电气连接，并保持信号或电流的连续性。\n信号分配：在复杂的电路板上，使用0欧电阻可以方便地将信号线分配到不同的位置。通过添加或移除0欧电阻，可以改变信号路径，以满足电路的布局要求。\n调试和测试：在调试和测试电路时，加入0欧电阻可以方便地连接测试仪器或测量点。它可以用作测试点或测量点的连接线，以便在需要时轻松接入测试设备。\n阻抗匹配：在高频电路设计中，0欧电阻可以用于阻抗匹配。通过选择适当的阻值，可以使电路中的阻抗更好地匹配，以最大限度地传输信号或功率。\n\n需要注意的是，加入0欧电阻并不会引入电阻本身的阻尼效应。它的主要作用是提供连接和分配功能，而不会对电路的整体电性能产生实质性的影响。\n\nTPS3823-33DBVR的MR引脚是干什么的\n1&#x2F;3&#x2F;2024, 5:11:40 PM\nTPS3823-33DBVR是一款超低功耗、微型化的复位监测器。MR引脚是器件的主复位引脚，用于手动地对器件进行复位操作。\n当MR引脚被拉低时，TPS3823-33DBVR会立即进行复位操作，并将RST引脚拉低，使被监测的系统或芯片得到重新启动。此外，当MR引脚保持低电平时，TPS3823-33DBVR将始终保持在复位状态，直到MR引脚上升到高电平。\n需要注意的是，MR引脚应该在正常工作时保持高电平，并通过一个合适的电阻接到正电源。当需要手动复位时，可以通过连接一个按钮或开关来将MR引脚拉低，从而触发复位操作。\n总之，TPS3823-33DBVR的MR引脚是用于手动复位操作的引脚，当MR引脚被拉低时，TPS3823-33DBVR会进行复位操作，从而实现对被监测系统或芯片的重新启动。\n1&#x2F;3&#x2F;2024, 5:12:51 PM\nTPS3823-33DBVR的WDI引脚是干什么的\n1&#x2F;3&#x2F;2024, 5:13:13 PM\nTPS3823-33DBVR的WDI引脚是用于喂狗定时器（Watchdog Timer）的输入引脚。\n喂狗定时器是一种用于监控系统运行状态的计时器。它需要周期性地接收一个喂狗脉冲来防止系统出现故障或死锁。如果在一定的时间内没有接收到喂狗脉冲，喂狗定时器会触发复位操作，使被监控的系统重新启动。\n在TPS3823-33DBVR中，WDI引脚用于接收外部喂狗脉冲。当WDI引脚接收到一个高电平脉冲时，喂狗定时器会被重置，系统继续正常运行。如果在一定时间内未接收到喂狗脉冲，喂狗定时器将超时，并触发复位操作。\n通过连接一个外部的喂狗脉冲源（例如微处理器的GPIO引脚），可以周期性地向TPS3823-33DBVR的WDI引脚提供喂狗脉冲。这样可以确保系统持续运行，并在出现故障或死锁时进行自动复位，提高系统的可靠性和稳定性。\n总之，TPS3823-33DBVR的WDI引脚用于接收外部喂狗脉冲，用于喂狗定时器的重置操作，以确保系统正常运行并防止故障或死锁。\nMPU6050https://blog.csdn.net/qq_52251819/article/details/134957492\n\nAHT21\n\nVdd_IO和Vdd是两个不同的电源引脚，常见于集成电路或芯片中。\n\nVdd（也称为Vcc）是供电引脚，用于提供主要的电源电压给芯片或集成电路的内部电路。它通常连接到正电源（例如+3.3V或+5V），以供应芯片内部的数字和模拟电路。\nVdd_IO（也称为Vcc_IO或VddIO）是IO供电引脚，用于提供给输入输出（IO）电路的电源电压。它通常连接到较低的电压（例如+1.8V或+3.3V），用于驱动芯片的输入和输出引脚。\n\n区别：\n\n功能：Vdd提供整个芯片的电源，包括内部逻辑、处理器核心等。Vdd_IO则专门提供给IO电路使用。\n电压级别：Vdd通常连接到较高的电压，而Vdd_IO连接到较低的电压。这是为了在现代集成电路中实现低功耗设计和电压兼容性。\n\n在 STM32 HAL 库中，xx_MspInit() 和 xx_Init() 函数是针对特定外设的初始化函数。\n\nxx_MspInit() 函数：该函数是外设的底层初始化函数，用于配置外设的时钟、引脚、中断等底层硬件资源。”xx” 是指特定外设的前缀，例如 GPIO、USART、SPI 等。xx_MspInit() 通常在应用程序初始化之前调用，主要目的是配置外设所需的底层硬件资源。\nxx_Init() 函数：该函数是外设的高层初始化函数，用于配置外设的工作模式、时钟频率、中断优先级等高层参数。它会调用底层的 xx_MspInit() 函数来初始化底层硬件资源，并进行一些高层配置。xx_Init() 通常在应用程序初始化阶段调用，用于配置外设的工作模式和参数。\n\nHAL_ADC_ConfigChannel()是ADC常规通道配置，一次配置一个通道\nHAL_ADC_PollForConversion()是轮询方式等待ADC常规通道转换完成\nHAL_ADC_GetValue()读取常规通道转换结果寄存器的数据\nHAL_ADC_Start（）以软件方式启动ADC常规转换的通道，然后调用HAL_ADC_PollForConversion()来查询转换是否完成，如果转换完成，使用HAL_ADC_GetValue()读出常规结果寄存器的32位数据\nstm32是32位的，所以指针总是32位的\n\n![(..&#x2F;images&#x2F;image-20240322125751723.png)\n\n\n工作模式：\n\n低功耗模式：\n\n\nstm32的SPI的Clock Phase(CPHA)设置为2 Edge是什么意思\n2024&#x2F;3&#x2F;23 14:29:32\n在 STM32 微控制器的 SPI（Serial Peripheral Interface）模块中，Clock Phase（时钟相位，通常用 CPHA 表示）参数用于定义数据采样的时机。当设置为 2 Edge 时，表示数据采样会在时钟的第二个边缘上进行。\n在 SPI 通信中，数据传输的时机是由时钟信号决定的。CPHA 参数定义了数据采样的时机相对于时钟信号的边缘。具体来说，CPHA 可以设置为 0 或 1，分别表示：\n\nCPHA &#x3D; 0：数据在时钟信号的第一个边缘上进行采样。也就是说，在时钟信号的上升沿或下降沿（取决于时钟极性）开始时采样数据。\nCPHA &#x3D; 1：数据在时钟信号的第二个边缘上进行采样。也就是说，在时钟信号的另一个沿（与上升沿或下降沿相反的沿）上采样数据。\n\n因此，当将 SPI 的 CPHA 参数设置为 2 Edge 时，表示数据采样会在时钟的第二个边缘上进行，这种设置通常用于特定的 SPI 设备或者通信协议要求，确保数据的正确采样和传输。在实际应用中，需要根据外设设备的要求和通信协议的规范来选择合适的 CPHA 设置，以确保 SPI 数据传输的准确性和稳定性。\n\n\n不使用预装载，设置的新ARR的值立即生效\n使用，会在下一个UEV事件生效\nPWM波：\n\n\ncHAL_TIM_IC_CaptureCallback(htim);\nHAL_TIM_OC_DelayElapsedCallback(htim);\nHAL_TIM_PWM_PulseFinishedCallback(htim);\nHAL_TIM_PeriodElapsedCallback(htim);\nHAL_TIM_TriggerCallback(htim);\nHAL_TIMEx_CommutCallback(htim);\n\nmpu_prototypes.h\nmpu_wrappers.h内存保护单元 ,内存保护单元(memory protection unit)，简称：MPU,使用MPU可以设置不同存储区域的存储访问特性（如只支持特权访问或全访问）和存储器属性（如可缓存、可共享），从而提高嵌入式系统的健壮性，使系统更加安全。优先执行mpu_prototypes.h,mpu_wrappers.h里的函数\n\n\n\n\nMPU：内存保护单元\nFPU：浮点数单元\n钩子函数类似于回调函数\n\n\n\n  \n\n\nfreertos中任何时候都要有一个任务占用CPU，所以就有了空闲任务\nsystick只有定时中断功能，1ms中断一次\nsystick定时器不仅可以产生滴答信号，还可以产生任务切换申请\n\n\n所以：Freertos的任务优先级总是低于系统中断的优先级\n\n\nxTaskCreate()创建一个任务，以动态方式来分配内存\nxTaskCreateStatic()\nvTaskDelete()可以删除当前任务或者另一个任务\nvTaskSuspend()可以挂起当前任务或者另一个任务\nvTaskResume()恢复另一个挂起的任务的运行\n调度器管理的函数：vTaskStartScheduler()开启任务调度器\nvTaskSuspendAll()挂起任务调度器，但是不禁用中断，调度器被挂起后，不再进行上下文切换\nvTaskResumeAll()恢复调度器的执行，但是不会恢复vTaskSuspend()单独挂起的任务\n延时和调度的函数：\n中央对齐模式下：\ntxtRCR = 0，更新事件没有延迟；\nRCR = 1，更新事件延后了半个PWM周期；\nRCR = 2, 更新事件延后了一个PWM周期；\nRCR = 3，更新事件延后了 3 2 \\cfrac&#123;3&#125;&#123;2&#125; 23个PWM周期；","slug":"Embedded","date":"2023-12-25T00:29:56.000Z","categories_index":"","tags_index":"Embedded","author_index":"Zgh"},{"id":"2da31e9118a69e38c27812cfeb6f1fe9","title":"Esp32","content":"\n","slug":"Esp32","date":"2023-12-20T08:57:19.000Z","categories_index":"","tags_index":"esp32","author_index":"Zgh"},{"id":"f0da541dcd6df6287dc7b7bcefa5bded","title":"yolov5","content":"\n\nIOU —-交并比\nLou为1意味着预测边界框和地面真实边界框完全重叠。您可以为LOU设置阈值，以确定对象检测是否有效。假设您将LOU设置为0.5，在这种情况下。·如果LOU≥为0.5，则将目标检测归类为真阳性(TP)。如果LOU&lt;0.5，则为错误检测，并将其归类为假阳性(FP)。当图像中存在地面真实且模型未能检测到目标时，分类。作为假阴性(FN)。真负片(TN)：TN是我们没有预测到物体的图像的每一部分。度量对于目标检测没有用处，因此我们忽略TN。\n\nAP,MAP\n\n\n   \n \n网络架构和组件单阶段检测器：\n\nyolov5：（没有划出专门的颈部Neck）\n\ngit clone https://github.moeyy.xyz/https://github.com/ultralytics/yolov5.git\n\n\nnc: 80：这个参数表示模型分类数量（number of classes），默认为 80，对应着 COCO 数据集。\ndepth_multiple: 0.33：这个参数表示模型深度相对于基础版本的倍数。在 YOLOv5 中，有 S、M、L 和 X 四个版本，其中 S 为基础版本，即 depth_multiple: 1.0，而 M、L 和 X 版本为在此基础上分别加深了一定的层数。而 depth_multiple: 0.33 表示在 S 版本的基础上，深度缩小了 3 倍，即变成了 depth_multiple: 0.33 × 3 &#x3D; 0.99。\nwidth_multiple: 0.50：这个参数表示模型通道宽度相对于基础版本的倍数。与 depth_multiple 类似，S 版本的 width_multiple 是 1.0，而 M、L 和 X 版本则在此基础上分别扩大了一定的倍数。\nanchors：这是一个锚点数组，用于定义不同尺度下的 anchor boxes。YOLOv5 中使用了三个不同的尺度，每个尺度使用三个不同的 anchor boxes。这些锚点大小是相对于输入图像的，因此不同尺度下的大小会有所差别。\nbackbone：这一部分定义了模型的骨干网络（backbone），包括卷积层、批归一化层和激活函数等。YOLOv5 使用了 CSPDarknet53 这个网络作为基础骨干网络，并在此基础上进行改进。具体而言，YOLOv5 增加了空间注意力机制和SPP模块，以增强特征表达能力。\nhead：这一部分定义了模型的检测头（detection head），包括检测网络和分类网络。YOLOv5 中的检测网络采用了YOLOv3中的FPN结构，并在此基础上加入了PANet模块和SAM模块，以提高检测性能。\n\n序列数据的不同采样方法（随机采样和顺序分区）会导致隐状态初始化的差异，原因如下：\n\n随机采样： 在随机采样中，我们从序列数据中随机选择一个序列作为训练样本。这意味着每次训练时，我们都使用不同的序列作为输入。由于每个序列可能具有不同的上下文和语义信息，模型在每次训练时都需要重新适应不同的序列特征。因此，随机采样会导致隐状态的初始化与之前的训练批次存在一定差异。\n顺序分区： 在顺序分区中，我们按顺序依次读取序列数据进行训练。这意味着模型在每个训练批次中都会接收到相邻的序列数据。由于相邻的序列通常具有相似的上下文和语义信息，模型可以利用之前批次的隐藏状态来帮助理解当前批次的序列。因此，顺序分区会导致隐状态的初始化与之前的训练批次存在一定的相关性。\n\n不同的隐状态初始化差异可能会对模型的训练和预测产生影响。随机采样可以增加数据的多样性，帮助模型更好地适应不同的序列特征。然而，随机采样可能也会引入一些噪声，导致训练过程更加不稳定。顺序分区可以利用相邻序列之间的相关性，帮助模型更好地捕捉到序列的上下文信息。然而，顺序分区可能会限制模型对不同序列特征的适应能力。\n困惑度（perplexity）是自然语言处理中常用的一个评价指标，主要用于衡量语言模型的预测性能。困惑度越低，表示模型的预测能力越好。\n在自然语言处理中，我们通常使用语言模型来计算文本序列的概率。给定一个文本序列 $W&#x3D;w_1,w_2,…,w_n$，其概率可以表示为：\n$$P(W)&#x3D;P(w_1)\\times P(w_2|w_1) \\times … \\times P(w_n|w_1,w_2,…,w_{n-1})$$\n其中，$P(w_i|w_1,w_2,…,w_{i-1})$ 表示在已知前面 $i-1$ 个词的情况下，第 $i$ 个词的概率。语言模型的目标就是学习这种条件概率分布。在模型训练过程中，我们通常会使用最大似然估计法来估计模型参数。\n困惑度是一个数值指标，表示用当前语言模型对一个测试集进行预测时所得到的困惑程度。具体而言，如果测试集包含 $N$ 个词，我们可以计算出每个词的概率 $P(w_i)$，然后将这些概率求倒数并取对数，即：\n$$\\log \\frac{1}{P(w_1)}+\\log \\frac{1}{P(w_2|w_1)}+…+\\log \\frac{1}{P(w_N|w_1,w_2,…,w_{N-1})}$$\n然后，我们可以将上述结果除以测试集中的词数 $N$，得到平均困惑度。具体而言，平均困惑度的计算公式如下：\n$$\\text{Perplexity}&#x3D;exp\\left(-\\frac{1}{N}\\sum_{i&#x3D;1}^{N}\\log P(w_i)\\right)$$\n例如，如果我们有一个包含100个句子的测试集，其中总共包含1000个词，我们可以使用语言模型来预测每个词的概率，并计算出平均困惑度。假设我们的模型预测准确率较高，平均每个词的概率为0.9，则平均困惑度为：\n$$exp\\left(-\\frac{1}{1000}\\sum_{i&#x3D;1}^{1000}\\log 0.9\\right) \\approx 2.15$$\n这表示我们的模型对测试集中的文本序列进行预测时，每个词的平均困惑度为2.15。如果我们使用一个更好的语言模型，其困惑度可能会更低。\n用困惑度来评价模型确保了不同长度的序列具有可比性\n路径聚合网络模块\nFocus处理模块\n空间金字塔池化模块\n跨阶段局部网络模块\n\n​\t\n     IoU、GIoU、DIoU、CIoU损失函数         IoU、GIoU、DIoU、CIoU损失函数\n目标检测任务的损失函数由Classificition Loss和Bounding Box Regeression Loss两部分构成。目标检测任务中近几年来Bounding Box Regression Loss Function的演进过程，其演进路线是一、IOU(Intersection over Union)1. 特性(优点)\nIoU就是我们所说的交并比，是目标检测中最常用的指标，在anchor-based的方法。作用不仅用来确定正样本和负样本，还可以用来评价输出框（predict box）和ground-truth的距离。\n \n \\1. 可以说它可以反映预测检测框与真实检测框的检测效果。\n \\2. 还有一个很好的特性就是尺度不变性，也就是对尺度不敏感（scale invariant）， 在regression任务中，判断predict box和gt的距离最直接的指标就是IoU。**(**满足非负性；同一性；对称性；三角不等性)\n\n 2. 作为损失函数会出现的问题(缺点)\n\\1. 如果两个框没有相交，根据定义，IoU&#x3D;0，不能反映两者的距离大小（重合度）。同时因为loss&#x3D;0，没有梯度回传，无法进行学习训练。\n \\2. IoU无法精确的反映两者的重合度大小。如下图所示，三种情况IoU都相等，但看得出来他们的重合度是不一样的，左边的图回归的效果最好，右边的最差。\n \n 二、GIOU(Generalized Intersection over Union)\n1****、来源\n在CVPR2019中，论文\n《Generalized Intersection over Union: A Metric and A Loss for Bounding Box Regression》 https:arxiv.org&#x2F;abs&#x2F;1902.09630\n提出了GIoU的思想。由于IoU是比值的概念，对目标物体的scale是不敏感的。然而检测任务中的BBox的回归损失(MSE loss, l1-smooth loss等）优化和IoU优化不是完全等价的，而且 Ln 范数对物体的scale也比较敏感，IoU无法直接优化没有重叠的部分。\n \n 这篇论文提出可以直接把IoU设为回归的loss。\n \n 上面公式的意思是：先计算两个框的最小闭包区域面积_ _(通俗理解：同时包含了预测框和真实框的最小框的面积)，再计算出IoU，再计算闭包区域中不属于两个框的区域占闭包区域的比重，最后用IoU减去这个比重得到GIoU。\n 附：https://github.com/generalized-iou/g-darknet\n2****、 特性[1]\n与IoU相似，GIoU也是一种距离度量，作为损失函数的话， ,满足损失函数的基本要求\nGIoU对scale不敏感\nGIoU是IoU的下界，在两个框无线重合的情况下，IoU&#x3D;GIoU\nIoU取值[0,1]，但GIoU有对称区间，取值范围[-1,1]。在两者重合的时候取最大值1，在两者无交集且无限远的时候取最小值-1，因此GIoU是一个非常好的距离度量指标。\n与IoU只关注重叠区域不同，GIoU****不仅关注重叠区域，还关注其他的非重合区域，能更好的反映两者的重合度。\n \n \n 三、DIoU(Distance-IoU)[2]\n**1,**来源\nDIoU要比GIou更加符合目标框回归的机制，将目标与anchor之间的距离，重叠率以及尺度都考虑进去，使得目标框回归变得更加稳定，不会像IoU和GIoU一样出现训练过程中发散等问题。论文中\nDistance-IoU https://arxiv.org/pdf/1911.08287.pdf\n基于IoU和GIoU存在的问题，作者提出了两个问题： \\1. 直接最小化anchor框与目标框之间的归一化距离是否可行，以达到更快的收敛速度？ \\2. 如何使回归在与目标框有重叠甚至包含时更准确、更快？\n \n 其中，分别代表了预测框和真实框的中心点，且代表的是计算两个中心点间的欧式距离。c代表的是能够同时包含预测框和真实框的最小闭包区域的对角线距离。\n \n \n DIoU中对anchor框和目标框之间的归一化距离进行了建模\n附：\nYOLOV3 DIoU GitHub项目地址 https&#x2F;&#x2F;github.com&#x2F;Zzh-tju&#x2F;DIoU-darknet\n2****、优点\n与GIoU loss类似，DIoU loss（ ）在与目标框不重叠时，仍然可以为边界框提供移动方向。\nDIoU loss可以直接最小化两个目标框的距离，因此比GIoU loss收敛快得多。\n对于包含两个框在水平方向和垂直方向上这种情况，DIoU损失可以使回归非常快，而GIoU损失几乎退化为IoU损失。\nDIoU还可以替换普通的IoU评价策略，应用于NMS中，使得NMS得到的结果更加合理和有效。\n实现代码：[3]\n \n \n 四、CIoU(Complete-IoU)\n论文考虑到bbox回归三要素中的长宽比还没被考虑到计算中，因此，进一步在DIoU的基础上提出了CIoU。其惩罚项如下面公式：\n \n 实现代码：[5] \n \n \n \n\n\nL(IoU)&#x3D;1-IoU,L(GIoU)&#x3D;1-GIoU\n\npenalty item 惩罚项\n\n\n\n用1替换\n\n\nYOLO训练技巧\n1.\n\n2.\n余弦退火学习率调整的原理是根据余弦函数的形状动态地调整学习率。它通过将学习率从一个较大的初始值逐渐减小到一个较小的最小值来控制训练过程中的学习率变化。\n具体实现步骤如下：\n\n设置一个最大学习率和最小学习率的范围。\n定义一个周期数（通常是训练的总迭代次数）。\n对于每个训练迭代，计算当前周期数与总周期数之间的比例。\n使用余弦函数来动态计算学习率，公式如下：\n\ntxtlr = lr_min + 0.5 * (lr_max - lr_min) * (1 + cos(epoch / T_total * pi))其中，lr表示当前学习率，epoch表示当前周期数，T_total表示总周期数，lr_max表示最大学习率，lr_min表示最小学习率。\n\n将计算得到的学习率应用于优化器中进行权重更新。\n\n使用余弦退火学习率调整可以在训练初期使用较大的学习率来快速收敛，然后逐渐减小学习率以细化模型的优化过程。这种方法在训练中期能够跳出局部最优解并找到更好的全局最优解，有助于提高模型的泛化性能和训练效果。\n3.\n4.\n5.遗传算法\n6.AMP\n7.\n激活函数\n\n\n\n\n优点：激活区域可以更多样\n因此，引入了各种方法来压缩神经网络，以使大型模型可以在边缘设备上部署。模型压缩方法可以分为3类：剪枝、量化和知识蒸馏。在剪枝中，移除模型中不重要的冗余参数，以获得稀疏&#x2F;紧凑的模型结构。量化涉及使用低精度数据类型表示模型的激活和权重。最后，知识蒸馏是指利用大型准确模型作为教师来训练一个小型模型，使用教师模型提供的软标签来进行训练。cmake_minimum_required(VERSION 3.10) project(yolov5) add_definitions(-std&#x3D;c++11) add_definitions(-DAPI_EXPORTS) option(CUDA_USE_STATIC_CUDA_RUNTIME OFF) set(CMAKE_CXX_STANDARD 11) set(CMAKE_BUILD_TYPE Debug) # TODO(Call for PR): make cmake compatible with Windows set(CMAKE_CUDA_COMPILER &#x2F;usr&#x2F;local&#x2F;cuda-12.2&#x2F;bin&#x2F;nvcc) enable_language(CUDA) # include and link dirs of cuda and tensorrt, you need adapt them if yours are different # cuda include_directories(&#x2F;usr&#x2F;local&#x2F;cuda-12.2&#x2F;include) link_directories(&#x2F;usr&#x2F;local&#x2F;cuda-12.2&#x2F;lib64) # tensorrt # TODO(Call for PR): make TRT path configurable from command line include_directories(&#x2F;home&#x2F;nvidia&#x2F;TensorRT-8.2.5.1&#x2F;include&#x2F;) link_directories(&#x2F;home&#x2F;nvidia&#x2F;TensorRT-8.2.5.1&#x2F;lib&#x2F;) include_directories(${PROJECT_SOURCE_DIR}&#x2F;src&#x2F;) include_directories(${PROJECT_SOURCE_DIR}&#x2F;plugin&#x2F;) file(GLOB_RECURSE SRCS ${PROJECT_SOURCE_DIR}&#x2F;src&#x2F;.cpp ${PROJECT_SOURCE_DIR}&#x2F;src&#x2F;.cu) file(GLOB_RECURSE PLUGIN_SRCS ${PROJECT_SOURCE_DIR}&#x2F;plugin&#x2F;*.cu) add_library(myplugins SHARED ${PLUGIN_SRCS}) target_link_libraries(myplugins nvinfer cudart) find_package(OpenCV) include_directories(${OpenCV_INCLUDE_DIRS}) add_executable(yolov5_det yolov5_det.cpp ${SRCS}) target_link_libraries(yolov5_det nvinfer) target_link_libraries(yolov5_det cudart) target_link_libraries(yolov5_det myplugins) target_link_libraries(yolov5_det ${OpenCV_LIBS}) add_executable(yolov5_cls yolov5_cls.cpp ${SRCS}) target_link_libraries(yolov5_cls nvinfer) target_link_libraries(yolov5_cls cudart) target_link_libraries(yolov5_cls myplugins) target_link_libraries(yolov5_cls ${OpenCV_LIBS}) add_executable(yolov5_seg yolov5_seg.cpp ${SRCS}) target_link_libraries(yolov5_seg nvinfer) target_link_libraries(yolov5_seg cudart) target_link_libraries(yolov5_seg myplugins) target_link_libraries(yolov5_seg ${OpenCV_LIBS}) 这是cmakeLists.txt文件 cmake .. 报错： zgh@zgh-Legion-Y7000P-IAH7:~&#x2F;tensorrtx&#x2F;yolov5&#x2F;build$ cmake .. CMake Error at &#x2F;usr&#x2F;local&#x2F;share&#x2F;cmake-3.27&#x2F;Modules&#x2F;CMakeDetermineCUDACompiler.cmake:277 (message):  CMAKE_CUDA_ARCHITECTURES must be non-empty if set. Call Stack (most recent call first):  CMakeLists.txt:13 (enable_language)  – Configuring incomplete, errors occurred!\n2024&#x2F;1&#x2F;20 11:33:33\n该错误提示是由于没有指定 CMAKE_CUDA_ARCHITECTURES 变量，需要在 CMakeLists.txt 中添加以下语句：\ntxt\nset(CMAKE_CUDA_ARCHITECTURES &quot;60;61;70;75&quot;)其中，CMAKE_CUDA_ARCHITECTURES 指定了支持的 CUDA 架构版本号，这里的值可以根据你的 GPU 型号进行调整。\n在添加上述语句后，再次运行 cmake .. 命令即可。\ntxtcmake_minimum_required(VERSION 3.5)\nproject(Ball_Det)\nset(CMAKE_CXX_STANDARD 11)\nset(Cudart_LIBS &quot;/usr/local/cuda-12.2/targets/x86_64-linux/lib/libcudart.so&quot;)\nset(CMAKE_CUDA_COMPILER /usr/local/cuda-12.2/bin/nvcc)\nset(CMAKE_CUDA_ARCHITECTURES &quot;80&quot;)\ninclude_directories(/usr/local/cuda-12.2/include)\nlink_directories(/usr/local/cuda-12.2/lib64)\nenable_language(CUDA)\nfind_package(CUDA REQUIRED)\nfind_package(k4a REQUIRED)\nfind_package(OpenCV REQUIRED)\ninclude_directories(\n       Yolo\n        $&#123;OpenCV_INCLUDE_DIRS&#125;\n       /usr/local/cuda12.2/include\n       $&#123;CMAKE_CURRENT_LIST_DIR&#125;\n)\nadd_library(\n       Yolo\n       Yolo/yolov5.cpp\n)\n\ncuda_add_library(myplugins SHARED ./Yolo/yololayer.cu)\n\n\nadd_executable(Ball_Det\n       Mask_Detection.cpp\n       Yolo/yolov5.cpp\n       main.cpp\n       Ball_Detection.cpp\n       Yolo/calibrator.cpp\n)\ntarget_link_libraries(\n       Ball_Det\n       nvinfer\n       cudart\n       myplugins\n       /usr/local/cuda12.2/lib64\n       $&#123;Cudart_LIBS&#125;\n       $&#123;OpenCV_LIBS&#125;\n       libk4a.so\n        )","slug":"yolov5","date":"2023-12-16T12:04:59.000Z","categories_index":"","tags_index":"yolo","author_index":"Zgh"},{"id":"2dd54cd4b432aa48fbfa03c6312b571a","title":"deeplearning","content":"在 Pandas 中，.apply() 是用于对 DataFrame 或 Series 中的元素应用指定函数的方法。\n对于 DataFrame，.apply() 可以在行或列方向上应用函数。语法如下：\ntxtDataFrame.apply(func, axis=0)\nfunc 是要应用的函数，可以是一个已定义的函数，也可以是一个匿名函数（如 lambda 函数）。\naxis 是指定应用函数的方向，默认为 0，表示按列应用函数；设置为 1 则表示按行应用函数。\n\n对于 Series，.apply() 仅能在元素级别上应用函数，无需指定应用方向。语法如下：\ntxtSeries.apply(func)\nfunc 是要应用的函数，可以是一个已定义的函数，也可以是一个匿名函数（如 lambda 函数）。\n\n在上述代码中，.apply(lambda x: (x - x.mean()) / (x.std())) 就是将匿名函数 lambda x: (x - x.mean()) / (x.std()) 应用到 DataFrame 或 Series 中的每个元素上。结果是对 DataFrame 或 Series 中的每个元素进行标准化计算，并返回处理后的结果\n\n​                                                                                                         右–按照时间线展开图\n\n查询（自主提示）和键（非自主提示）之间的交互形成了注意力汇聚；注意力汇聚有选择地聚合了值（感官输入）以生成最终的输出。torch.repeat_interleave() 函数是 PyTorch 中的一个张量操作函数，用于生成一个重复值的张量。它的详细解释如下：\ntxt\ntorch.repeat_interleave(input, repeats, dim=None)参数说明：\n\ninput：输入张量。\nrepeats：重复次数，可以是一个整数、一个一维张量或一个与 input 张量形状相匹配的张量。\ndim（可选）：指定重复操作的维度。\n\n函数功能：\n\ntorch.repeat_interleave() 函数将输入张量 input 按指定的重复次数 repeats 进行重复，并生成一个新的张量。\n\ntxthttps://zhuanlan.zhihu.com/p/659067322\n\nsk-QxaDRZHsiyhtTFpB3JXHMkQ5fiK0AnEQZgM27mbiEIaIkF0G","slug":"deeplearning","date":"2023-12-16T02:57:26.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"61251d8b73997ae6479adce2ddc93d34","title":"Pytorch","content":"在 Python 中，lambda 是用来创建匿名函数的关键字。所谓匿名函数，即没有显式定义函数名的函数，通常用于需要临时定义简单函数的场景。\nlambda 函数的语法如下：\ntxtlambda arguments: expression其中：\n\narguments 是函数的参数，可以有多个参数，用逗号隔开。\nexpression 是函数的返回值计算表达式。\n\nlambda 函数通常用于需要一个函数，但是又不想正式定义一个函数的场景，比如作为其他函数的参数传递进去，或者在一些函数式编程的场景中使用。\nparams &#x3D; [W_xh, W_hh, b_h, W_hq, b_q]for param in params:        param.requires_grad_(True)\n目的是告诉 PyTorch 在模型训练过程中需要计算这些参数的梯度，并且在反向传播时对其进行更新。\nXt*Wxh + Ht−1*Whh=cat(Xt,Ht−1)*cat(Wxh,Whh)\ntorch.matmul(X, W_xh) + torch.matmul(H, W_hh)\ntorch.matmul(torch.cat((X, H), 1), torch.cat((W_xh, W_hh), 0))\n当一个类实现了 __call__ 方法时，它的实例对象可以像函数一样进行调用。这意味着你可以使用实例对象作为函数来调用，就好像调用一个函数一样。\n例如，假设有一个类 MyClass，并且实现了 __call__ 方法：\ntxtpython\nclass MyClass:\n    def __call__(self, x):\n        print(&quot;Calling MyClass with argument:&quot;, x)现在，你可以创建一个 MyClass 的实例，并将其作为函数进行调用：\ntxtpython\nobj = MyClass()\nobj(10)输出结果将是：\ntxt\nCalling MyClass with argument: 10所以class RNNModelScratch: #@save&quot;&quot;&quot;从零开始实现的循环神经网络模型&quot;&quot;&quot;def __init__(self, vocab_size, num_hiddens, device,get_params, init_state, forward_fn):self.vocab_size, self.num_hiddens = vocab_size, num_hiddensself.params = get_params(vocab_size, num_hiddens, device)self.init_state, self.forward_fn = init_state, forward_fndef __call__(self, X, state):X = F.one_hot(X.T, self.vocab_size).type(torch.float32)return self.forward_fn(X, state, self.params)\n可以这样调用：\nnet = RNNModelScratch(len(vocab), num_hiddens, d2l.try_gpu(), get_params,init_rnn_state, rnn)\nY, new_state = net(X.to(d2l.try_gpu()), state)\n**kwargs 是 Python 中的一种特殊语法，用于接收任意数量的关键字参数（keyword arguments）。在函数或方法的定义中，**kwargs 会将传递给函数的未命名关键字参数收集到一个字典中，其中字典的键是参数名，值是参数值。\n在这段代码中，**kwargs 被用作 NWKernelRegression 类的初始化方法 __init__ 的参数。通过使用 **kwargs，可以接收任意数量的关键字参数，并将它们存储为类的属性。这样做可以使代码更加灵活，允许用户在创建 NWKernelRegression 实例时传递额外的参数。\n例如，如果你创建了一个 NWKernelRegression 实例时传递了额外的参数，比如 model = NWKernelRegression(param1=10, param2=&#39;abc&#39;)，那么这些额外的参数会被收集到 kwargs 字典中，字典的键是参数名，值是参数值。你可以根据需要在 __init__ 方法中使用这些参数。\n总而言之，**kwargs 允许在函数或方法定义中接收任意数量的关键字参数，并将它们保存为字典以供后续使用。\n","slug":"Pytorch","date":"2023-12-15T14:50:19.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deployMore info: Deployment\n","slug":"hello-world","date":"2023-12-15T14:27:11.801Z","categories_index":"","tags_index":"","author_index":"Zgh"}]