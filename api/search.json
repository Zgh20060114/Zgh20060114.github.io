[{"id":"0104a54ef3539ccc47aaaaa3ebb61ff8","title":"Algo","content":"由于实际测试具有较大的局限性，因此我们考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。\n\n“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。\n“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。\n“时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。\n\n迭代（iteration）\n递归（recursion）,通过函数调用自身来解决问题:（“将问题分解为更小子问题”）\n\n递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。\n归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。\n\n而从实现的角度看，递归代码主要包含三个要素。\n\n终止条件：用于决定什么时候由“递”转“归”。\n递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。\n返回结果：对应“归”，将当前递归层级的结果返回至上一层。\n\n虽然从计算角度看，迭代与递归可以得到相同的结果，但它们代表了两种完全不同的思考和解决问题的范式。\n\n迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。\n递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。\n\n过深的递归可能导致栈溢出错误\n尾递归有趣的是，如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。\n\n普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。\n\n尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。\n例如：\n&#x2F;* 尾递归 *&#x2F;int tailRecur(int n, int res) {&#x2F;&#x2F; 终止条件if (n &#x3D;&#x3D; 0)    return res;&#x2F;&#x2F; 尾递归调用return tailRecur(n - 1, res + n);}\n\n\n普通递归：\ntxtpython\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)在普通递归中，递归调用 factorial(n - 1) 发生在函数的末尾，并且返回值被乘以 n 后再返回。\n尾递归：\ntxtpython\ndef factorial_tail(n, accumulator=1):\n    if n == 0:\n        return accumulator\n    else:\n        return factorial_tail(n - 1, accumulator * n)以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，这种工作机制与栈的“先入后出”原则异曲同工。\n事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。\n\n递：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。\n归：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。\n\n时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势。\n\n\n在计算机科学中，”渐近上界” 是一种用于分析算法性能的概念，特别是与时间复杂度和空间复杂度相关。在时间复杂度分析中，渐近上界的目的在于确定算法在数据规模趋于无穷大时的最坏性能表现。为了更好地理解这一概念，可以从几个角度来探讨：\n1. 什么是渐近上界？渐近上界指的是某个函数在趋于某个极限（例如，无限大）时，其增长速率的上限。它通常用于描述算法的最坏情况性能，表示随着输入规模增加，算法的运行时间或使用的资源上限。\n2. 大-O 表示法在算法分析中，渐近上界最常用的表示法是大-O 表示法。用 O(f(n)) 表示某个算法的时间复杂度，意味着这个算法的运行时间在最坏情况下不会超过某个函数 f(n) 的增长速率。\n例如，若算法的时间复杂度是 O(n^2)，表示无论最坏情况下发生了什么，这个算法的运行时间最多是某个常数与 n^2 的乘积。这里 n 是输入数据的规模。\n3. 用途渐近上界有助于比较不同算法的性能，并帮助工程师选择适当的算法。在设计和优化算法时，了解渐近上界也有助于避免性能陷阱。\n4. 如何理解渐近上界？渐近上界在数学上是严格定义的。函数 T(n) 的渐近上界是 f(n)，如果存在常数 c 和 n_0 使得对于所有 n ≥ n_0，都有 T(n) ≤ c * f(n)。这意味着当 n 足够大时，T(n) 不会超过 c * f(n)，即使在最坏情况下。\n5. 示例考虑一个算法的时间复杂度是 3n^2 + 2n + 7。这个算法的渐近上界是 O(n^2)，因为当 n 足够大时，3n^2 是增长最快的项，其他项的影响可以忽略。\n\ntxt/* 指数阶（递归实现） */\nint expRecur(int n) &#123;\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n&#125;txt/*对数阶*/\nint linearLogRecur(int n) &#123;\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n\n    return count;\n&#125;txt/* 线性对数阶 */\nint linearLogRecur(int n) &#123;\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) &#123;\n        count++;\n    &#125;\n    return count;\n&#125;\n算法在运行过程中使用的内存空间主要包括以下几种。\n\n输入空间：用于存储算法的输入数据。\n暂存空间：用于存储算法在运行过程中的变量、对象、函数上下文等数据。\n输出空间：用于存储算法的输出数据。\n\n一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。\ntxtstruct Node &#123;\n    int val;\n    Node *next;\n    Node(int x) : val(x), next(nullptr) &#123;&#125;\n&#125;;Node(int x) : val(x), next(nullptr) 是一个构造函数的定义\ntxtint func() &#123;\n    // 执行某些操作\n    return 0;\n&#125;\n/* 循环的空间复杂度为 O(1) */\nvoid loop(int n) &#123;\n    for (int i = 0; i &lt; n; i++) &#123;\n        func();\n    &#125;\n&#125;\n/* 递归的空间复杂度为 O(n) */\nvoid recur(int n) &#123;\n    if (n == 1) return;\n    return recur(n - 1);\n&#125;函数 loop() 和 recur() 的时间复杂度都为 \n ，但空间复杂度不同。\n\n函数 loop() 在循环中调用了\n\n 次 function() ，每轮中的 function() 都返回并释放了栈帧空间，因此空间复杂度仍为 \n 。\n递归函数 recur() 在运行过程中会同时存在 \n 个未返回的 recur() ，从而占用  的栈帧空间。\ntxt/* 线性阶 */\nvoid linear(int n) &#123;\n    // 长度为 n 的数组占用 O(n) 空间\n    vector&lt;int&gt; nums(n);\n    // 长度为 n 的列表占用 O(n) 空间\n    vector&lt;ListNode&gt; nodes;\n    for (int i = 0; i &lt; n; i++) &#123;\n        nodes.push_back(ListNode(i));\n    &#125;\n    // 长度为 n 的哈希表占用 O(n) 空间\n    unordered_map&lt;int, string&gt; map;\n    for (int i = 0; i &lt; n; i++) &#123;\n        map[i] = to_string(i);\n    &#125;\n&#125;\n\n/* 线性阶（递归实现） */\nvoid linearRecur(int n) &#123;\n    cout &lt;&lt; &quot;递归 n = &quot; &lt;&lt; n &lt;&lt; endl;\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n&#125;\nQ：函数和方法这两个术语的区别是什么？\n函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。\n下面以几种常见的编程语言为例来说明。\n\nC 语言是过程式编程语言，没有面向对象的概念，所以只有函数。但我们可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他编程语言中的方法。\nJava 和 C# 是面向对象的编程语言，代码块（方法）通常作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量。\nC++ 和 Python 既支持过程式编程（函数），也支持面向对象编程（方法）。\n\n常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。\n逻辑结构：线性与非线性逻辑结构揭示了数据元素之间的逻辑关系。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。\n如图 3-1 所示，逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。\n\n线性数据结构：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。\n非线性数据结构：树、堆、图、哈希表。\n\n非线性数据结构可以进一步划分为树形结构和网状结构。\n\n树形结构：树、堆、哈希表，元素之间是一对多的关系。\n网状结构：图，元素之间是多对多的关系。\n\n内存是所有程序的共享资源，当某块内存被某个程序占用时，则无法被其他程序同时使用了。因此在数据结构与算法的设计中，内存资源是一个重要的考虑因素。比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。\n如图 3-3 所示，物理结构反映了数据在计算机内存中的存储方式，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。\n\n值得说明的是，所有数据结构都是基于数组、链表或二者的组合实现的。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。\n链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。\n基本数据类型是 CPU 可以直接进行运算的类型，在算法中直接被使用，主要包括以下几种。\n\n整数类型 byte、short、int、long 。\n浮点数类型 float、double ，用于表示小数。\n字符类型 char ，用于表示各种语言的字母、标点符号甚至表情符号等。\n布尔类型 bool ，用于表示“是”与“否”判断。\n\n基本数据类型以二进制的形式存储在计算机中。一个二进制位即为 1比特。在绝大多数现代操作系统中，1字节（byte）由 8比特（bit）组成。\ntxt\n/* 初始化数组 */\n// 存储在栈上\nint arr[5];\nint nums[5] = &#123; 1, 3, 2, 5, 4 &#125;;\n// 存储在堆上（需要手动释放空间）\nint* arr1 = new int[5];\nint* nums1 = new int[5] &#123; 1, 3, 2, 5, 4 &#125;;在C++中，将数据存储在栈上和堆上有以下区别：\n\n存储位置：\n栈上：栈上的数据存储在程序的栈内存中，它们的分配和释放由编译器自动管理。栈上的数据通常具有较短的生命周期，当函数执行结束时，其内部的局部变量就会被自动释放。\n堆上：堆上的数据存储在程序的堆内存中，它们的分配和释放通常由程序员手动管理。堆上的数据可以具有较长的生命周期，直到显式释放内存或程序终止时才会被释放。\n\n\n动态性：\n栈上：栈上的内存分配是静态的，大小在编译时确定，并且通常比较有限。由于栈上的内存分配由编译器管理，所以分配和释放速度较快。\n堆上：堆上的内存分配是动态的，大小可以在运行时确定，并且可以根据需要动态增长。由于堆上的内存分配由程序员管理，因此可能会产生内存泄漏或内存碎片等问题。\n\n\n访问方式：\n栈上：栈上的数据访问速度通常比较快，因为它们存储在内存中的连续位置上，并且可以直接通过指针或引用进行访问。\n堆上：堆上的数据访问速度可能比较慢，因为它们存储在内存中的不同位置上，并且需要通过指针间接访问。\n\n\n\n在实际编程中，选择栈上或堆上的存储方式取决于数据的生命周期、大小和访问方式等因素。\nQ:把数组存储在堆，栈上，那堆栈是什么\nA：在计算机科学中，”堆栈”通常指的是”栈”和”堆”这两种不同的内存分配区域，它们用于存储程序运行时所需的数据和内存。这两者虽然名字相似，但是在内存管理和使用方面有着不同的作用和特点：\n\n栈（Stack）：\n栈是一种内存分配区域，用于存储函数调用时的局部变量、函数参数、函数返回地址等信息。\n栈上的内存分配由编译器自动管理，通常采用后进先出（LIFO）的方式进行操作。函数调用时，会将局部变量等信息压入栈中，函数返回时则将其弹出。\n栈上的内存分配速度快，但是空间有限，通常用于存储函数调用时所需的临时数据。\n\n\n堆（Heap）：\n堆是另一种内存分配区域，用于存储程序运行时动态分配的内存，例如使用new和delete操作符创建和释放的对象。\n堆上的内存分配由程序员手动管理，它的大小和生命周期可以动态确定。堆上的内存通常用于存储程序运行时动态产生的数据结构、对象等。\n堆上的内存分配速度相对较慢，因为需要进行动态分配和释放，并且可能产生内存碎片等问题。\n\n\n\n总的来说，栈和堆是程序运行时两种不同的内存分配区域，它们有着不同的管理方式、分配速度和用途，程序员可以根据需要选择合适的内存分配方式来管理程序的数据和内存。\nQ ：存储在堆上，是要求定义为指针吗\nA : 在C++中，使用new操作符分配内存时，返回的是指向分配内存的指针。因此，存储在堆上的数据需要定义为指针类型，以便程序员能够通过指针来访问和操作这些数据，并在适当的时候手动释放内存空间，以避免内存泄漏。\n以下是一个简单的示例，演示如何声明和使用函数指针：\ntxtcpp\n#include &lt;iostream&gt;\n\n// 声明一个接受两个整数参数并返回它们之和的函数\nint add(int a, int b) &#123;\n    return a + b;\n&#125;\n\n// 声明一个接受两个整数参数并返回它们之差的函数\nint subtract(int a, int b) &#123;\n    return a - b;\n&#125;\n\nint main() &#123;\n    // 声明一个指向函数的指针，该函数接受两个整数参数并返回一个整数\n    int (*operation)(int, int);\n\n    // 将函数 add 的地址赋值给指针变量 operation\n    operation = add;\n\n    // 使用指针调用函数 add\n    int result1 = operation(10, 5);\n    std::cout &lt;&lt; &quot;Result of add: &quot; &lt;&lt; result1 &lt;&lt; std::endl;\n\n    // 将函数 subtract 的地址赋值给指针变量 operation\n    operation = subtract;\n\n    // 使用指针调用函数 subtract\n    int result2 = operation(10, 5);\n    std::cout &lt;&lt; &quot;Result of subtract: &quot; &lt;&lt; result2 &lt;&lt; std::endl;\n\n    return 0;\n&#125;在这个示例中，int (*operation)(int, int); 声明了一个名为 operation 的函数指针，它指向一个接受两个整数参数并返回一个整数的函数。然后，通过将函数的地址赋值给指针变量 operation，可以使用该指针来调用不同的函数。\ntxt/* 扩展数组长度 */\nint *extend(int *nums, int size, int enlarge) &#123;\n    // 初始化一个扩展长度后的数组\n    int *res = new int[size + enlarge];\n    // 将原数组中的所有元素复制到新数组\n    for (int i = 0; i &lt; size; i++) &#123;\n        res[i] = nums[i];\n    &#125;\n    // 释放内存\n    delete[] nums;\n    // 返回扩展后的新数组\n    return res;\n&#125;返回类型为 int *，意味着该函数返回的是一个指向整数类型的指针，即指向数组的指针。\n数组的优点与局限性数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。\n\n空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。\n\n支持随机访问：数组允许在 \n\n时间内访问任何元素。\n\n缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。\n\n\n连续空间存储是一把双刃剑，其存在以下局限性。\n\n插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。\n\n长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。\n\n空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。\n\ndelete 用于释放通过 new 分配的单个对象的内存。\n\ndelete[] 用于释放通过 new[] 分配的数组的内存。\n\n\n数组典型应用数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。\n\n随机访问：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。\n排序和搜索：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。\n查找表：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。\n机器学习：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。\n数据结构实现：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。\n\n存储数组的内存空间必须是连续的\n链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。\n\n链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。\n尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None 。\n在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。\n\ntxt/* 链表节点结构体 */\nstruct ListNode &#123;\n    int val;         // 节点值\n    ListNode *next;  // 指向下一节点的指针\n    ListNode(int x) : val(x), next(nullptr) &#123;&#125;  // 构造函数\n&#125;;为什么结构体也有构造函数:\n在C++中，结构体（struct）和类（class）都可以拥有构造函数。构造函数用于初始化对象的数据成员，在创建对象时自动调用。\n单向链表通常用于实现栈、队列、哈希表和图等数据结构。\n\n栈与队列：当插入和删除操作都在链表的一端进行时，它表现出先进后出的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。\n哈希表：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。\n图：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。\n\n双向链表常用于需要快速查找前一个和后一个元素的场景。\n\n高级数据结构：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。\n浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。\nLRU 算法：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。\n\n环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。\n\n时间片轮转调度算法：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。\n数据缓冲区：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。\n\n可以使用动态数组（dynamic array）来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。\n实际上，许多编程语言中的标准库提供的列表是基于动态数组实现的，例如 Python 中的 list 、Java 中的 ArrayList 、C++ 中的 vector 和 C# 中的 List 等。接下来，我们将把“列表”和“动态数组”视为等同的概念。\n数据结构的缓存效率缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据。\n为了尽可能达到更高的效率，缓存会采取以下数据加载机制。\n\n缓存行：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效。\n预取机制：处理器会尝试预测数据访问模式（例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。\n空间局部性：如果一个数据被访问，那么它附近的数据可能近期也会被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率。\n时间局部性：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率。\n\n栈（stack）是一种遵循先入后出逻辑的线性数据结构。\n如图 5-1 所示，我们把堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫作“入栈”，删除栈顶元素的操作叫作“出栈”。因此我们只能在栈顶添加或删除元素,然而，数组和链表都可以在任意位置添加和删除元素，因此栈可以视为一种受限制的数组或链表。\ntxt基于数组实现的栈\nvector&lt;int&gt; stack;\n/* 获取栈的长度 */\nstack.size()\n入栈\nstack.push_back(num);\n出栈\nstack.pop_back();\n访问栈顶元素\nstack.back();\n\nback就是栈顶的位置txt有专用的栈方法\nstack&lt;int&gt; stack;\n\n/* 元素入栈 */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* 访问栈顶元素 */\nint top = stack.top();\n\n/* 元素出栈 */\nstack.pop(); // 无返回值\n\n/* 获取栈的长度 */\nint size = stack.size();\n\n/* 判断是否为空 */\nbool empty = stack.empty();队列（queue）是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。\ntxt/* 初始化队列 */\nqueue&lt;int&gt; queue;\n\n/* 元素入队 */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* 访问队首元素 */\nint front = queue.front();\n\n/* 元素出队 */\nqueue.pop();\n\n/* 获取队列的长度 */\nint size = queue.size();\n\n/* 判断队列是否为空 */\nbool empty = queue.empty();添加队尾，删除队首—–先来后到\n双向队列：\ntxt/* 初始化双向队列 */\ndeque&lt;int&gt; deque;\n\n/* 元素入队 */\ndeque.push_back(2);   // 添加至队尾\ndeque.push_back(5);\ndeque.push_back(4);\ndeque.push_front(3);  // 添加至队首\ndeque.push_front(1);\n\n/* 访问元素 */\nint front = deque.front(); // 队首元素\nint back = deque.back();   // 队尾元素\n\n/* 元素出队 */\ndeque.pop_front();  // 队首元素出队\ndeque.pop_back();   // 队尾元素出队\n\n/* 获取双向队列的长度 */\nint size = deque.size();\n\n/* 判断双向队列是否为空 */\nbool empty = deque.empty();DoublyListNode *pre, *cur = front; 确实是一个比较容易产生误解的地方，但实际上这行代码并不是同时给 pre 和 cur 赋值为 front。这行代码实际上相当于两行分开的声明和初始化：\ntxtcpp\nDoublyListNode *pre; // 声明一个指向 DoublyListNode 类型的指针 pre\nDoublyListNode *cur = front; // 声明一个指向 DoublyListNode 类型的指针 cur，并将其初始化为 front这里的 pre 只是声明了一个指针，但并没有初始化，所以它的值是未定义的，你需要在后续代码中对其进行初始化。而 cur 在声明时已经被初始化为 front。\n哈希表（hash table），又称散列表，它通过建立键 key 与值 value 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 key ，则可以在  O(1)时间内获取对应的值 value 。\nunordered_map 是 C++ 标准库中的一种关联容器（Associative Container），它提供了快速的键值对存储和检索功能。它是通过哈希表实现的，因此提供了高效的插入、删除和查找操作。\ntxt/* 初始化哈希表 */\nunordered_map&lt;int, string&gt; map;\n\n/* 添加操作 */\n// 在哈希表中添加键值对 (key, value)\nmap[12836] = &quot;小哈&quot;;\nmap[15937] = &quot;小啰&quot;;\nmap[16750] = &quot;小算&quot;;\nmap[13276] = &quot;小法&quot;;\nmap[10583] = &quot;小鸭&quot;;\n\n/* 查询操作 */\n// 向哈希表中输入键 key ，得到值 value\nstring name = map[15937];\n\n/* 删除操作 */\n// 在哈希表中删除键值对 (key, value)\nmap.erase(10583);\n\n/* 遍历哈希表 */\n// 遍历键值对 key-&gt;value\nfor (auto kv: map) &#123;\n    cout &lt;&lt; kv.first &lt;&lt; &quot; -&gt; &quot; &lt;&lt; kv.second &lt;&lt; endl;\n&#125;\n// 使用迭代器遍历 key-&gt;value\nfor (auto iter = map.begin(); iter != map.end(); iter++) &#123;\n    cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;\n&#125;我们先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将数组中的每个空位称为桶（bucket），每个桶可存储一个键值对。因此，查询操作就是找到 key 对应的桶，并在桶中获取 value 。\n那么，如何基于 key 定位对应的桶呢？这是通过哈希函数（hash function）实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 key ，输出空间是所有桶（数组索引）。换句话说，输入一个 key ，我们可以通过哈希函数得到该 key 对应的键值对在数组中的存储位置。\n输入一个 key ，哈希函数的计算过程分为以下两步。\n\n通过某种哈希算法 hash() 计算得到哈希值。\n将哈希值对桶数量（数组长度）capacity 取模，从而获取该 key 对应的数组索引 index 。\n\ntxtindex = hash(key) % capacity&lt;Pair *&gt; 表示这个 vector 存储的是指向 Pair 类型对象的指针。\nvector&lt;Pair *&gt; 创建了一个存储指向 Pair 结构的指针的动态数组，即每个元素都是指向 Pair 结构的指针。\n我们将多个输入对应同一输出的情况称为哈希冲突（hash collision）。\n我们可以通过扩容哈希表来减少哈希冲突。类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 capacity 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。\n负载因子（load factor）是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，也常作为哈希表扩容的触发条件。例如在 Java 中，当负载因子超过  时，系统会将哈希表扩容至原先的 2倍。\n但此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。\n\n改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。\n仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。\n\n哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。\n链式地址在原始哈希表中，每个桶仅能存储一个键值对。链式地址（separate chaining）将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。图 6-5 展示了一个链式地址哈希表的例子。\n\n 图 6-5  链式地址哈希表 \n基于链式地址实现的哈希表的操作方法发生了以下变化。\n\n查询元素：输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 key 以查找目标键值对。\n添加元素：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。\n删除元素：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。\n\n链式地址存在以下局限性。\n\n占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间。\n查询效率降低：因为需要线性遍历链表来查找对应元素。\n\n开放寻址开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。\n线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。\n\n插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 \n\n），直至找到空桶，将元素插入其中。\n\n查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None 。\n\n\n图 6-6 展示了开放寻址（线性探测）哈希表的键值对分布。根据此哈希函数，最后两位相同的 key 都会被映射到相同的桶。而通过线性探测，它们被依次存储在该桶以及之下的桶中。\n\n 值得注意的是，我们不能在开放寻址哈希表中直接删除元素。这是因为删除元素会在数组内产生一个空桶 None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在\n为了解决该问题，我们可以采用懒删除（lazy deletion）机制：它不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。在该机制下，None 和 TOMBSTONE 都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。\n然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着 TOMBSTONE 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 TOMBSTONE 才能找到目标元素。\n为此，考虑在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。\n平方探测平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 \n 步。\n平方探测主要具有以下优势。\n\n平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。\n平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。\n\n然而，平方探测并不是完美的。\n\n仍然存在聚集现象，即某些位置比其他位置更容易被占用。\n由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。\n\n\n二叉树的常用术语如图所示。\n\n根节点（root node）：位于二叉树顶层的节点，没有父节点。\n叶节点（leaf node）：没有子节点的节点，其两个指针均指向 None 。\n边（edge）：连接两个节点的线段，即节点引用（指针）。\n节点所在的层（level）：从顶至底递增，根节点所在层为 1 。\n节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。\n二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。\n节点的深度（depth）：从根节点到该节点所经过的边的数量。\n节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量。\n\n\n常见二叉树类型完美二叉树所有层的节点都被完全填满。\n\n完全二叉树只有最底层的节点未被填满，且最底层节点尽量靠左填充。\n\n完满二叉树除了叶节点之外，其余所有节点都有两个子节点。\n\n平衡二叉树任意节点的左子树和右子树的高度之差的绝对值不超过 1 。\n[\n理想结构与退化结构\n二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。\n完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。\n链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n)\n\n二叉树遍历从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现。\n二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和后序遍历等。\n层序遍历\n从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。\n层序遍历本质上属于广度优先遍历（breadth-first traversal），也称广度优先搜索（breadth-first search, BFS），它体现了一种“一圈一圈向外扩展”的逐层遍历方式。\n\n广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。\ntxt/* 层序遍历 */\nvector&lt;int&gt; levelOrder(TreeNode *root) &#123;\n    // 初始化队列，加入根节点\n    queue&lt;TreeNode *&gt; queue;\n    queue.push(root);\n    // 初始化一个列表，用于保存遍历序列\n    vector&lt;int&gt; vec;\n    while (!queue.empty()) &#123;\n        TreeNode *node = queue.front();\n        queue.pop();              // 队列出队\n        vec.push_back(node-&gt;val); // 保存节点值\n        if (node-&gt;left != nullptr)\n            queue.push(node-&gt;left); // 左子节点入队\n        if (node-&gt;right != nullptr)\n            queue.push(node-&gt;right); // 右子节点入队\n    &#125;\n    return vec;\n&#125;\n前序、中序和后序遍历都属于深度优先遍历（depth-first traversal），也称深度优先搜索（depth-first search, DFS），它体现了一种“先走到尽头，再回溯继续”的遍历方式。\n\n前序、中序和后序遍历是针对二叉树的三种不同的遍历方式，它们的区别在于遍历节点的顺序：\n\n前序遍历（Preorder Traversal）：\n遍历顺序：根节点 -&gt; 左子树 -&gt; 右子树\n具体操作：先访问根节点，然后递归地对左子树进行前序遍历，最后递归地对右子树进行前序遍历。\n\n\n中序遍历（Inorder Traversal）：\n遍历顺序：左子树 -&gt; 根节点 -&gt; 右子树\n具体操作：先递归地对左子树进行中序遍历，然后访问根节点，最后递归地对右子树进行中序遍历。\n\n\n后序遍历（Postorder Traversal）：\n遍历顺序：左子树 -&gt; 右子树 -&gt; 根节点\n具体操作：先递归地对左子树进行后序遍历，然后递归地对右子树进行后序遍历，最后访问根节点。\n\n\n\n总的来说，这三种遍历方式主要区别在于根节点的访问顺序与左右子树的递归顺序。\n深度优先搜索通常基于递归实现：\ntxt/* 前序遍历 */\nvoid preOrder(TreeNode *root) &#123;\n    if (root == nullptr)\n        return;\n    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树\n    vec.push_back(root-&gt;val);\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n&#125;\n\n/* 中序遍历 */\nvoid inOrder(TreeNode *root) &#123;\n    if (root == nullptr)\n        return;\n    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树\n    inOrder(root-&gt;left);\n    vec.push_back(root-&gt;val);\n    inOrder(root-&gt;right);\n&#125;\n\n/* 后序遍历 */\nvoid postOrder(TreeNode *root) &#123;\n    if (root == nullptr)\n        return;\n    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点\n    postOrder(root-&gt;left);\n    postOrder(root-&gt;right);\n    vec.push_back(root-&gt;val);\n&#125;\n“递”表示开启新方法，程序在此过程中访问下一个节点。\n“归”表示函数返回，代表当前节点已经访问完毕。\n\n\n二叉树数组表示用数组来表示二叉树\n表示完美二叉树给定一棵完美二叉树，我们将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一的数组索引。\n根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：若某节点的索引为i  ，则该节点的左子节点索引为2i+1  ，右子节点索引为2i+2 \n映射公式的角色相当于链表中的节点引用（指针）。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的左（右)子节点。\n表示任意二叉树完美二叉树是一个特例，在二叉树的中间层通常存在许多 None 。由于层序遍历序列并不包含这些 None ，因此我们无法仅凭该序列来推测 None 的数量和分布位置。这意味着存在多种二叉树结构都符合该层序遍历序列。\n\n为了解决此问题，我们可以考虑在层序遍历序列中显式地写出所有 None 。如图 7-14 所示，这样处理后，层序遍历序列就可以唯一表示二叉树了\ntxt/* 二叉树的数组表示 */\n// 使用 int 最大值 INT_MAX 标记空位\nvector&lt;int&gt; tree = &#123;1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15&#125;;\n","slug":"Algo","date":"2024-04-26T01:35:42.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"47d8fddcd3299307e9e74bee0c7b2069","title":"FPGA","content":"assign 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在always块中）不同，后者在某种事件或条件发生时才更新值。\nassign temp2 &#x3D; {32{1’b0}}; 是什么意思?\n在Verilog中，assign temp2 = &#123;32&#123;1&#39;b0&#125;&#125;; 这行代码声明了一个连续赋值，将 temp2 这个线网的值设置为一个32位的全0值。\n这里的 &#123;32&#123;1&#39;b0&#125;&#125; 是一个重复拼接操作，含义如下：\n\n1&#39;b0 是一个二进制数，表示一个位宽为1的数值，值为0。\n&#123;32&#123;1&#39;b0&#125;&#125; 表示将 1&#39;b0 这个值重复32次。\n\nVerilog 数据类型Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。\n整数（integer）   reg 型变量为无符号数，而 integer 型变量为有符号数\n实数（real）\n在Verilog中，real 和 integer 是数据类型关键字，分别用于声明实数类型和整数类型的变量。\ntxtreal data1;\ninteger temp;\ninitial begin\n    data1 = 2e3;\n    data1 = 3.75;\nend\n\ninitial begin\n    temp = data1; //temp 值的大小为3\nend这段代码包含两个 initial 块，它们在仿真开始时执行一次。\n第一个 initial 块中：\n\ndata1 被初始化为实数类型 real。\ndata1 被赋值为 2e3，这意味着 data1 现在的值是2000.0。\n随后，data1 被更新为 3.75。\n\n第二个 initial 块中：\n\ntemp 被初始化为整数类型 integer。\ntemp 被赋值为 data1 的值。由于 data1 当前是 3.75，这个赋值会将实数转换为整数。在Verilog中，实数赋值给整数时，会进行取整操作，保留数值的整数部分，忽略小数部分。因此，temp 的值将是3。\n\n需要注意的是，您的注释 //temp 值的大小为3 是正确的，因为 data1 的值 3.75 在赋值给 temp 时会被取整为3。\n时间（time）\nVerilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间。例如：\ntxttime current_time;\ninitial begin\n    #100;\n    current_time = $time; //current_time 的大小为 100\nend这段代码包含一个 initial 块，它在仿真开始时执行一次。\n在 initial 块中：\n\ncurrent_time 被初始化为时间类型 time。\n#100; 是一个延迟语句，它会使仿真暂停100个时间单位。在Verilog中，# 后面跟一个数字表示延迟的时间量。\n\n数组存储器\n参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次parameter    data_width &#x3D; 10’d32 ;\n字符串字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。\n字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0  来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”,  需要 14*8bit 的存储单元：\nreg [0: 14*8-1]    str ; initial begin   str &#x3D; “run.runoob.com”; end  \n\n\n\n\n\n2.4 Verilog 表达式表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。\n a^b ;      &#x2F;&#x2F;a与b进行异或操作 address[9:0] + 10’b1 ;  &#x2F;&#x2F;地址累加 flag1 &amp;&amp; flag2 ;  &#x2F;&#x2F;逻辑与操作\nalways块里赋值对象不能是wire型\n同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行\ntxt//自右向左关联，两种写法等价\nA+B-C ;\n(A+B）-C ;\n\n//自右向左关联，两种写法等价，结果为 B、D 或 F\nA ? B : C ? D : F ;\nA ? B : (C ? D : F) ;求幂（**）、取模（%）\ntxtb = 4&#39;b100x;x 是一个表示未知或不可确定状态的字符。它用于在仿真中表示一个位的值是未知的，这通常发生在综合过程中，当某些逻辑路径没有被明确赋值时，或者在设计中的某些部分还没有完全定义时。\n无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和\nreg [3:0]     mula ; reg [1:0]     mulb; reg [5:0]     res ; mula &#x3D; 4’he  ; mulb &#x3D; 2’h3  ; res  &#x3D; mula * mulb ; &#x2F;&#x2F;结果为res&#x3D;6’h2a, 数据结果没有丢失位数\n逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）\n按位操作符包括：取反()，与（&amp;），或（|），异或（^），同或（^）\n按位操作符对 2 个操作数的每 1bit 数据进行按位操作,如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。\n归约操作符归约操作符包括：归约与（&amp;），归约与非（&amp;），归约或（|），归约或非（|），归约异或（^），归约同或（~^）。\n归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。\n逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。\ntxtA = 4&#39;b1010 ;\n&amp;A ;      //结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#39;b0，可用来判断变量A是否全1\n~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1&#39;b0, 可用来判断变量A是否为全0\n^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1&#39;b0移位操作符移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。\n移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。\n算术左移和逻辑左移时，右边低位会补 0。\n逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。\n实例A &#x3D; 4’b1100 ; B &#x3D; 4’b0010 ; A &#x3D; A &gt;&gt; 2 ;     &#x2F;&#x2F;结果为 4’b0011 A &#x3D; A &lt;&lt; 1;     *&#x2F;&#x2F;结果为 4’b1000* A &#x3D; A &lt;&lt;&lt; 1 ;    *&#x2F;&#x2F;结果为 4’b1000* C &#x3D; B + (A&gt;&gt;&gt;2);   &#x2F;&#x2F;结果为 2 + (-4&#x2F;4) &#x3D; 1, 4’b0001\ndefine, undef在编译阶段，&#96;define 用于文本替换，类似于 C 语言中的 #define。\n&#96;undef 用来取消之前的宏定义\ntxt`ifdef       MCU51\n    parameter DATA_DW = 8   ;\n`elsif       WINDOW\n    parameter DATA_DW = 64  ;\n`else\n    parameter DATA_DW = 32  ;\n`endif&#96;include使用 &#96;include 可以在编译时将一个 Verilog 文件内嵌到另一个 Verilog 文件中，作用类似于 C 语言中的 #include 结构。\ntimescale在 Verilog 模型中，时延有具体的单位时间表述，并用 &#96;timescale 编译指令将时间单位与实际时间相关联。\n该指令用于定义时延、仿真的单位和精度，格式为：\ntxt`timescale      time_unit / time_precisiontime_unit 表示时间单位，time_precision 表示时间精度，它们均是由数字以及单位  s（秒），ms（毫秒），us（微妙），ns（纳秒），ps（皮秒）和  fs（飞秒）组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小，例如下面例子中，输出端 Z 会延迟 5.21ns 输出  A&amp;B 的结果。\n实例timescale 1ns/100ps   *//时间单位为1ns，精度为100ps，合法*  *//timescale 100ps&#x2F;1ns  &#x2F;&#x2F;不合法* module AndFunc(Z, A, B);   output Z;   input A, B ;   assign #5.207 Z &#x3D; A &amp; B endmodule\n在编译过程中，timescale 指令会影响后面所有模块中的时延值，直至遇到另一个 timescale 指令或 &#96;resetall 指令。 \n由于在 Verilog 中没有默认的 timescale，如果没有指定 timescale，Verilog 模块就有会继承前面编译模块的 &#96;timescale 参数。有可能导致设计出错。\n如果一个设计中的多个模块都带有 &#96;timescale 时，模拟器总是定位在所有模块的最小时延精度上，并且所有时延都相应地换算为最小时延精度\n&#96;default_nettype该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型。\ntxt`default_nettype wand 该实例定义的缺省的线网为线与类型。因此，如果在此指令后面的任何模块中的连线没有说明，那么该线网被假定为线与类型。  \ntxt`default_nettype none该实例定义后，将不再自动产生 wire 型变量。\ncelldefine, endcelldefine这两个程序指令用于将模块标记为单元模块，他们包含模块的定义。例如一些与、或、非门，一些 PLL 单元，PAD 模型，以及一些 Analog IP 等。\n实例celldefine  **module** (    **input**    clk,    **input**    rst,    **output**   clk_pll,    **output**   flag);      ……  **endmodule**  endcelldefine\nunconnected_drive, nounconnected_drive在模块实例化中，出现在这两个编译指令间的任何未连接的输入端口，为正偏电路状态或者为反偏电路状态。\ntxtassign用于对 wire 型变量进行赋值,不对寄存器赋值\n进位输出（Carry  out，通常表示为Co或Cout）是全加器的一个输出，它表示在两个二进制位相加时是否产生了进位。在二进制加法中，当两个加数位（A和B）的和大于或等于2时，就会产生进位，因为二进制中的每一位只能表示0或1。进位输出就是用来表示这个进位的。\nmodule full_adder1(   input   Ai, Bi, Ci,   output  So, Co);\n   assign So &#x3D; Ai ^ Bi ^ Ci ;   assign Co &#x3D; (Ai &amp; Bi) | (Ci &amp; (Ai | Bi)); endmodule\n更简单的：\ntxtmodule full_adder1(\n    input Ai, Bi, Ci,\n    output So, Co);\n    \n    assign &#123;Co, So&#125; = Ai + Bi + Ci;\nendmodule&#x2F;&#x2F;普通时延，A&amp;B计算结果延时10个时间单位赋值给Z wire Z, A, B ; assign #10   Z &#x3D; A &amp; B ;\n &#x2F;&#x2F;隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。 wire A, B; wire #10     Z &#x3D; A &amp; B;\n &#x2F;&#x2F;声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。 wire A, B; wire #10 Z ; assign      Z &#x3D;A &amp; B\nVerilog 过程结构过程结构语句有 2 种，initial 与 always 语句\n一个模块中可以包含多个 initial 和 always 语句，但 2 种语句不能嵌套使用。\n但是 initial 语句或 always 语句内部可以理解为是顺序执行的（非阻塞赋值除外）。\ninitial语句initial 语句从 0 时刻开始执行，只执行一次，多个 initial 块之间是相互独立的。\n如果 initial 块内包含多个语句，需要使用关键字 begin 和 end 组成一个块语句。\n如果 initial 块内只要一条语句，关键字 begin 和 end 可使用也可不使用。\ninitial 理论上来讲是不可综合的，多用于初始化、信号检测等。\n这些语句在模块间并行执行，与其在模块的前后顺序没有关系always 语句与 initial 语句相反，always 语句是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。\n由于循环执行的特点，always 语句多用于仿真时钟的产生，信号行为的检测等。   \nparameter 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。连续性赋值使用assign语句，而过程性赋值使用always块。\n阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。\n阻塞赋值语句使用等号 &#x3D; 作为赋值符。\n非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。\n非阻塞赋值语句使用小于等于号 &lt;&#x3D; 作为赋值符。\n如下所示，2 个 always 块中语句并行执行，赋值操作右端操作数使用的是上一个时钟周期的旧值，此时 a&lt;&#x3D;b 与 b&lt;&#x3D;a 就可以相互不干扰的执行，达到交换寄存器值的目的。\n实例always @(posedge clk) begin   a &lt;&#x3D; b ; end\n always @(posedge clk) begin   b &lt;&#x3D; a; end\nVerilog 时序控制Verilog 提供了 2 大类时序控制方法：时延控制和事件控制。事件控制主要分为边沿触发事件控制与电平敏感事件控制\n时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。常规时延\ntxtreg  value_test ;\nreg  value_general ;\n#10  value_general    = value_test ;或：\ntxt#10 ;\nvalue_ single         = value_test ;内嵌时延\n遇到内嵌延时时，该语句先将计算结果保存，然后等待一定的时间后赋值给目标信号。\n内嵌时延控制加在赋值号之后。例如：\ntxtreg  value_test ;\nreg  value_embed ;\nvalue_embed        = #10 value_test ;需要说明的是，这 2 种时延控制方式的效果是有所不同的。\n当延时语句的赋值符号右端是常量时，2 种时延控制都能达到相同的延时赋值效果。\n当延时语句的赋值符号右端是变量时，2 种时延控制可能会产生不同的延时赋值效果。\n边沿触发事件控制在 Verilog 中，事件是指某一个 reg 或 wire 型变量发生了值的变化。事件控制用符号 @ 表示。\n设计：根据需求编写硬件描述语言（如Verilog或VHDL）代码来描述设计的功能和行为\nsynthesize综合，合成：综合代码，检查语法是否有错误,将高级的逻辑描述代码转换为逻辑门级别的网表或等效的门级电路\nFloorPlanner 是 FPGA 设计流程中的一个重要工具，用于执行布局（Place）阶段的子任务，即对设计中的逻辑电路进行布局安置。在 FPGA 设计流程中，FloorPlanner 的地位如下：\n\n布局规划：FloorPlanner 负责规划 FPGA 芯片上各个逻辑模块的布局位置，以最大程度地满足设计的性能和资源利用率要求。它会考虑逻辑模块之间的布线延迟、信号传输路径长度等因素，以优化整体的布局结构。\n资源分配：FloorPlanner 还负责将设计中的逻辑模块分配到 FPGA 芯片的不同区域，并且合理利用芯片上的资源（如片上存储器、DSP模块等），以满足设计对资源的需求。\n时序约束：在布局过程中，FloorPlanner 还会考虑时序约束，确保设计中的时序要求能够得到满足。它会尽可能减少逻辑模块之间的传输延迟，以确保时序性能。\n优化布局：FloorPlanner 通过对设计进行优化布局，以降低布线延迟、减少时序问题和功耗等方面的优化。这可以提高设计的性能、可靠性和功耗效率。\n\n在 FPGA 设计流程中，FloorPlanner 位于布局（Place）阶段之前，它为后续的布线（Route）阶段提供了优化的布局结果，从而帮助实现设计的最终映射和部署。\nPlace&amp;Route ：\n开发流程中的 Place &amp; Route 是指在将设计映射到 FPGA 芯片时的一个重要步骤。下面解释一下它的含义和作用：\n\nPlace（放置）：Place 指的是将设计中的逻辑元素（如逻辑门、寄存器等）放置到 FPGA 芯片的物理位置上。这一步骤考虑了芯片内部的布局和连接资源，以尽可能地优化性能和资源利用率。放置的目标是最小化延迟、最大化时序性能，并且尽量减少芯片内的布线冲突。\nRoute（布线）：Route 是指将设计中的逻辑元素之间的连接关系转化为芯片内部的实际物理连线。这一步骤考虑了芯片内部的连线资源、信号传输延迟等因素，以确保逻辑元素之间的连接能够有效地建立并满足时序要求。布线的目标是尽可能地降低信号传输延迟、最小化信号干扰，同时满足设计的时序约束。\n\n在 Verilog 中，reg 类型通常用于表示存储元素（如寄存器），而不是直接连接到模块的输出端口。输出端口通常使用 output 或 inout 声明，并且通常需要与 wire 类型一起使用。\nreg 类型在 Verilog 中表示的是寄存器类型，它在 always 块中使用，存储状态或信号。而 output 端口应该使用 wire 类型来表示，因为它们不会存储状态，只是将信号传递给其他部件。\n因此，你在模块顶层中使用 output reg 是不符合常规的 Verilog 设计习惯的，通常应该使用 output wire。\n\n","slug":"FPGA","date":"2024-04-24T03:03:09.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"6df1dc6e24cc645f9148dbaf83a17c60","title":"Android_Kotlin","content":"txt`class FirstActivity : AppCompatActivity() &#123;`\n`override fun onCreate(savedInstanceState: Bundle?) &#123;`\n`super.onCreate(savedInstanceState)`\n`&#125;`\n`&#125;`这段代码是使用 Kotlin 语言编写的 Android 应用程序中的一个活动（Activity）类。让我逐步解释其中的内容：\n\nclass FirstActivity : AppCompatActivity()：这是一个类的声明，类名为 FirstActivity，并且继承自 AppCompatActivity 类。AppCompatActivity 是 Android 开发中常用的一个基类，用于支持应用程序在较旧的 Android 版本上提供向后兼容性。\noverride fun onCreate(savedInstanceState: Bundle?)：这是 FirstActivity 类中的一个方法 onCreate() 的重写。在 Android 中，onCreate() 方法是活动生命周期的一部分，在活动第一次创建时被调用。savedInstanceState 参数是一个 Bundle 对象，其中包含了之前保存的活动状态信息，可以用于在活动重新创建时恢复状态。\nsuper.onCreate(savedInstanceState)：这是调用父类 AppCompatActivity 中的 onCreate() 方法，确保父类中的初始化工作得以执行。\n\n因此，这段代码定义了一个名为 FirstActivity 的活动类，当该活动第一次创建时，会调用父类的 onCreate() 方法进行初始化。\n在声明 savedInstanceState 参数时，如果在类型后面添加了 ?，则表示该参数可以接受 null 值。\n这样做的目的是为了允许 savedInstanceState 参数在某些情况下为 null，例如当活动或片段首次创建时，savedInstanceState 可能为 null，因为此时还没有保存任何状态信息。\n在 Kotlin 中，如果没有使用 ?，则表示该参数不接受 null 值，如果在实际使用中传递了 null 值，编译器将会报错。而使用了 ? 后，表示该参数可以接受 null 值，编译器将不会报错。\n因此，在 override fun onCreate(savedInstanceState: Bundle?) 中，Bundle? 表示 savedInstanceState 参数可以接受 null 值，即在某些情况下，savedInstanceState 可能为 null。\ntxt&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\nandroid:orientation=&quot;vertical&quot;\nandroid:layout_width=&quot;match_parent&quot;\nandroid:layout_height=&quot;match_parent&quot;&gt;\n&lt;Button\nandroid:id=&quot;@+id/button1&quot;\nandroid:layout_width=&quot;match_parent&quot;\nandroid:layout_height=&quot;wrap_content&quot;\nandroid:text=&quot;Button 1&quot;\n/&gt;\n&lt;/LinearLayout&gt;这段代码是一个简单的 Android 布局文件，使用 XML 格式描述了一个线性布局（LinearLayout）以及一个按钮（Button）的布局和属性。\n让我解释其中的一些关键部分：\n\n&lt;LinearLayout&gt;：这是一个布局容器，用于在垂直方向排列其子视图（例如按钮）。xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; 是 XML 命名空间声明，它使得可以在 XML 文件中使用 Android 提供的属性和元素。\nandroid:orientation=&quot;vertical&quot;：这个属性指定了线性布局的方向，即垂直方向。这意味着其中的子视图（此处为按钮）将会按照垂直方向排列。\nandroid:layout_width=&quot;match_parent&quot; 和 android:layout_height=&quot;match_parent&quot;：这两个属性指定了布局的宽度和高度。match_parent 表示该布局将会填充其父容器的宽度或高度，以占据尽可能多的空间。\n&lt;Button&gt;：这是一个按钮视图，在布局中用于响应用户的点击事件。\nandroid:id=&quot;@+id/button1&quot;：这个属性为按钮指定了一个唯一的标识符，可以在 Java 代码中使用这个标识符来查找和操作这个按钮。\nwrap_content 属性可以使得布局更加灵活，可以根据内容的大小动态调整视图的尺寸，而不是固定为特定的尺寸。\nandroid:text=&quot;Button 1&quot;：这个属性为按钮设置了显示的文本内容为 “Button 1”。\n\n因此，这段代码描述了一个垂直排列的线性布局，其中包含一个按钮，按钮显示文本为 “Button 1”。按钮的宽度会填充父容器的宽度，而高度则根据按钮文本的大小动态调整。\ntxtclass FirstActivity : AppCompatActivity() &#123;\noverride fun onCreate(savedInstanceState: Bundle?) &#123;\nsuper.onCreate(savedInstanceState)\nsetContentView(R.layout.first_layout)\n&#125;\n&#125;首先调用了 super.onCreate(savedInstanceState)，以确保调用了父类的 onCreate() 方法，以便执行必要的初始化操作。\n接着调用了 setContentView(R.layout.first_layout) 方法，这个方法用于设置该活动所使用的布局文件。在这里，first_layout 是指定的布局资源文件的名称，这个布局文件定义了活动的界面布局结构。\n因此，这段代码的作用是在 FirstActivity 中设置了一个布局文件 first_layout 作为活动的界面布局，并在活动创建时加载该布局。\nR.layout 是一个自动生成的资源标识符类，它包含了项目中所有布局文件的引用。在 Android 开发中，资源文件（如布局文件、字符串、图像等）都需要通过资源标识符来访问和引用。\n当你在项目中创建布局文件时，每个布局文件都会被编译成一个资源标识符，以便在代码中进行引用。这些资源标识符都会被统一放置在 R 类的内部静态类中，而 R.layout 则是其中用于引用布局文件的子类之一。\nIntent—&gt;用于通信的消息对象\n在 Android 中，Intent 是一种用于在不同组件之间进行通信的对象。它可以用于启动活动（Activity）、启动服务（Service）、发送广播（Broadcast）以及执行其他各种操作。Intent 提供了一种在不同组件之间传递数据和执行操作的机制。\nIntent 本质上是一个消息对象，用于指示想要执行的操作。它可以包含以下信息：\n\n操作（Action）：指示要执行的操作，如启动活动、启动服务、发送广播等。常见的操作包括 android.intent.action.VIEW（查看操作）、android.intent.action.SEND（发送操作）、android.intent.action.MAIN（主操作）等。\n数据（Data）：用于指定操作的数据，可以是 URI、文件路径、文本等。例如，如果要查看网页，可以将网页的 URL 作为数据传递给 Intent。\n类别（Category）：用于指定操作的类别，如 android.intent.category.LAUNCHER（启动器类别）、android.intent.category.BROWSABLE（可浏览类别）等。\n附加信息（Extras）：用于传递额外的数据给目标组件。Extras 是键值对的形式，可以包含各种数据类型，如字符串、整数、布尔值等。\n\nIntent 可以分为两种类型：\n\n显式 Intent：明确定义了目标组件的类名，用于启动特定的组件。\n隐式 Intent：没有明确指定目标组件，而是根据 Intent 的操作、数据等信息由系统来匹配合适的组件。\n\n通过使用 Intent，Android 应用程序可以实现各种功能，例如启动新的活动、执行后台任务、发送广播等，从而实现各种复杂的交互和功能。\nKotlin直接可以：\ntxtoverride fun onCreate(savedInstanceState: Bundle?) &#123;\nsuper.onCreate(savedInstanceState)\nsetContentView(R.layout.first_layout)\nbutton1.setOnClickListener &#123;\nToast.makeText(this, &quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show()\n&#125;\n&#125;在 Kotlin 中，函数声明的语法是：\ntxtfun 函数名(参数列表): 返回值类型 &#123;\n    // 函数体\n&#125;其中，返回值类型在函数名和参数列表之后，使用冒号 : 来标识。在这个语法中，返回值类型是必须的，但在某些情况下，如果函数没有返回值，可以将返回值类型指定为 Unit，或者省略返回值类型（在这种情况下，编译器会自动推断返回值类型为 Unit）。例如：\nkotlinkotlin\nfun greet(name: String): Unit &#123;\n    println(&quot;Hello, $name!&quot;)\n&#125;\n\n// 或者省略返回值类型，编译器会自动推断为 Unit\nfun greet(name: String) &#123;\n    println(&quot;Hello, $name!&quot;)\n&#125;txtoverride fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;\nmenuInflater.inflate(R.menu.main, menu)\nreturn true\n&#125;menuInflater 是 Android 开发中的一个类，用于从 XML 文件中创建菜单对象。在 Android 中，通常使用 XML 文件定义应用程序中的菜单，然后通过 MenuInflater 类将这些 XML 文件中定义的菜单加载到应用程序中的菜单对象中，以供在用户界面中显示和操作。\n具体来说，menuInflater.inflate() 方法用于将一个 XML 文件中定义的菜单资源加载到一个 Menu 对象中，这样就可以在应用程序的用户界面中显示这个菜单。\n在 Android 应用程序中，Activity 和 Fragment 是两种重要的组件，用于构建用户界面和处理用户交互。它们都可以包含用户界面的布局，并且可以响应用户的输入事件（如点击、滑动等）。\n下面是关于 Activity 和 Fragment 的简要介绍：\nActivity（活动）\n定义：Activity 是 Android 应用中的一个基本组件，代表一个单独的用户界面屏幕，通常是一个窗口、一个对话框或全屏显示的窗口。\n作用：Activity 主要负责管理用户与应用程序之间的交互，包括接收用户输入、处理用户操作，并在屏幕上显示相应的界面。\n生命周期：Activity 具有丰富的生命周期方法，如 onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy() 等，开发者可以根据需要重写这些方法来执行相应的操作。\n布局：Activity 可以通过设置布局文件（XML 文件）来定义用户界面的外观和行为，也可以通过代码动态地创建和管理用户界面。\n\nFragment（片段）\n定义：Fragment 是 Android 应用中的另一个基本组件，代表了一个可复用的用户界面模块，可以在一个 Activity 中嵌套多个 Fragment。\n作用：Fragment 主要用于构建灵活的用户界面，允许开发者将应用程序的功能拆分成可重用的模块，并在不同的屏幕尺寸和设备方向下进行适配。\n生命周期：Fragment 也有自己的生命周期方法，与 Activity 的生命周期方法类似，包括 onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy() 等。\n布局：Fragment 可以拥有自己的布局文件（XML 文件），也可以在宿主 Activity 中动态添加到布局中，允许开发者在运行时动态地添加、替换和移除 Fragment。\n\n总的来说，Activity 通常代表一个完整的屏幕，而 Fragment 则是 Activity 中一个可重用的组成部分，可以在一个 Activity 中组合多个 Fragment 来构建复杂的用户界面。在实际开发中，Activity 和 Fragment 经常一起使用，以实现灵活和高效的用户界面设计。\n在 Kotlin 中，?. 是安全调用运算符，用于在对象为非空时调用其方法或访问其属性。如果对象为 null，则安全调用运算符会短路并返回 null，而不会抛出空指针异常。\n在你提供的代码中，data?.getStringExtra(&quot;data_return&quot;) 的意思是，如果 data 不为 null，则调用 getStringExtra(&quot;data_return&quot;) 方法来获取名为 “data_return” 的额外数据，否则返回 null。这种写法可以避免在 data 为 null 时引发空指针异常。\nregisterForActivityResult(...)：这是一个用于注册 Activity Result 的函数。它接受一个 ActivityResultContract 对象作为参数，并返回一个 ActivityResultLauncher 对象。ActivityResultContract 是一个接口，用于定义活动启动和结果处理之间的合同。\nActivity类中定义了7个回调方法，覆盖了Activity生命周期的每一个环节:\n\nonCreate() 在Activity第一次被创建时调用\n\nonStart() 由不可见到可见时调用\n\nonResume()。这个方法在Activity准备好和用户进行交互的时候调用。此时的Activity一\n定位于返回栈的栈顶，并且处于运行状态。\n\nonPause()。这个方法在系统准备去启动或者恢复另一个Activity的时候调用。我们通常\n会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执\n行速度一定要快，不然会影响到新的栈顶Activity的使用。\n\nonStop()。这个方法在Activity完全不可见的时候调用。它和onPause()方法的主要区\n别在于，如果启动的新Activity是一个对话框式的Activity，那么onPause()方法会得到执行，而onStop()方法并不会执行。\n\nonDestroy()。这个方法在Activity被销毁之前调用，之后Activity的状态将变为销毁状态。\n\nonRestart()。这个方法在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。\n\n\nonPause() 方法是 Android Activity 生命周期中的一个回调方法，用于指示当前 Activity 正在失去焦点并即将暂停其可见性。当某些事件发生时，系统会调用 onPause() 方法，这些事件包括：\n\n启动另一个 Activity：当用户启动另一个 Activity 并且当前 Activity 失去焦点时，系统会调用 onPause() 方法。例如，当用户点击应用中的按钮，打开新的 Activity 时，当前 Activity 将暂停。\n打开对话框或弹出窗口：如果当前 Activity 打开了对话框、弹出了一个窗口或者其他部分覆盖了当前 Activity 但不完全遮挡，系统也会调用 onPause() 方法。\n接收到来电或其他中断：当用户接收到来电、收到短信或者其他中断事件时，当前 Activity 也会暂停，系统会调用 onPause() 方法。\n用户按下 Home 键或切换到最近任务列表：当用户按下 Home 键返回桌面或切换到最近任务列表时，当前 Activity 也会暂停，系统会调用 onPause() 方法。\n\n总之，onPause() 方法的调用情况涵盖了当前 Activity 失去焦点并即将暂停可见性的各种情况。\nonStart() 是 Android 活动生命周期中的一个方法，用于指示活动即将变为可见状态。当活动首次启动或从停止状态恢复到活动栈时，系统会调用 onStart() 方法。\n具体情况下，onStart() 方法会在以下几种情况下被调用：\n\n当活动首次启动：当用户启动应用程序并打开了包含该活动的界面时，系统会调用活动的 onStart() 方法。此时，活动将从不可见状态转变为可见状态。\n当活动从暂停状态恢复：如果一个活动从 onPause() 状态恢复到前台状态，系统会先调用 onStart() 方法，然后调用 onResume() 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。\n\n在 onStart() 方法中，通常执行一些与界面相关的初始化操作，比如恢复 UI 状态、注册广播接收器或者启动一些后台任务。需要注意的是，尽管活动已经变为可见状态，但此时活动并未处于用户的焦点下，用户可能无法与其进行交互。\nonResume() 是 Android 活动生命周期中的一个方法，用于指示活动即将成为用户焦点并开始与用户进行交互。当活动从不可见状态变为可见状态，并且用户可以开始与其进行交互时，系统会调用 onResume() 方法。\n具体情况下，onResume() 方法会在以下几种情况下被调用：\n\n当活动首次启动：当用户首次启动应用程序并打开了包含该活动的界面时，系统会先调用 onStart() 方法，然后调用 onResume() 方法。此时，活动将从不可见状态转变为可见状态，并且用户可以开始与其进行交互。\n当活动从暂停状态恢复：如果一个活动从 onPause() 状态恢复到前台状态，系统会先调用 onStart() 方法，然后调用 onResume() 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。\n当活动从停止状态恢复：如果一个活动从 onStop() 状态恢复到前台状态，系统会依次调用 onRestart()、onStart() 和 onResume() 方法。这种情况通常发生在用户按下 Home 键后再次打开应用程序的情况下。\n\n在 onResume() 方法中，通常执行一些与活动生命周期相关的操作，比如恢复用户的输入状态、启动动画效果或者连接到一些外部服务。需要注意的是，当活动处于 onResume() 状态时，它已经成为了用户焦点下的活动，并且用户可以直接与其进行交互。\n\n当将视图或布局的尺寸设置为 “wrap_content” 时，系统会根据其内容自动调整视图或布局的尺寸，以便刚好容纳其内\n在 Android 的清单文件（AndroidManifest.xml）中声明活动（Activity）时，可以使用两种方式：\n\n&lt;activity&gt;...&lt;/activity&gt;：这是一种传统的 XML 标签方式，用于定义活动的属性和行为。在 &lt;activity&gt; 标签中，可以指定活动的各种属性，例如名称、图标、主题等，并且可以包含其他标签和属性以提供更详细的配置。通常情况下，你可以在 &lt;activity&gt; 标签内部设置更多的属性，包括活动的名称、图标、主题等，以及与活动相关的其他设置。\n&lt;activity/&gt;：这是一种自闭合的 XML 标签方式，用于简单地声明一个活动而不指定任何属性或配置。这种方式适用于简单的活动声明，当你不需要指定任何属性或配置时，可以使用这种方式。例如，如果你的活动只需要基本的声明，而不需要指定任何其他属性或配置，你可以使用 &lt;activity/&gt; 标签。\n\n因此，你应该根据活动的具体需求和配置选择适当的方式。如果需要指定活动的各种属性和配置，可以使用 &lt;activity&gt;...&lt;/activity&gt; 标签；如果活动只需要基本的声明而不需要指定任何其他属性或配置，可以使用 &lt;activity/&gt; 标签。\n@style/Theme.AppCompat.Dialog 是指在 Android 应用程序中使用的一个预定义的对话框主题样式。这个样式通常用于创建对话框，即弹出式窗口，以在应用程序中显示临时信息、接受用户输入或执行其他操作。\n这个主题样式基于 AppCompat 库提供的默认对话框主题进行定义，并且与 AppCompat 库中其他主题一样，它提供了跨不同 Android 版本的一致外观和行为。这样，你的应用程序就可以在不同版本的 Android 上保持一致的外观和用户体验。\nandroid:exported=&quot;false&quot; 是 Android 清单文件中 &lt;activity&gt; 元素的一个属性，用于指定该活动是否能够被其他应用程序组件或者系统组件访问。具体含义如下：\n\n如果 android:exported=&quot;false&quot;，则表示该活动不会被其他应用程序或系统组件调用。这意味着该活动只能被声明它的应用程序内部的组件所访问，其他应用程序或系统组件无法直接启动或与其交互。\n如果 android:exported=&quot;true&quot;，则表示该活动可以被其他应用程序或系统组件调用。这意味着其他应用程序可以使用显式或隐式意图启动该活动，并且与其进行交互。\n\n在你的示例中，android:exported=&quot;false&quot; 意味着 DialogActivity 这个活动不会被其他应用程序或系统组件访问。它只能被声明它的应用程序内部的组件所访问，其他应用程序无法直接启动或与其交互。这通常用于内部使用的活动，例如只在应用程序内部使用的对话框或者配置界面。\n在 Android 开发中，Intent（意图）是用于在不同组件之间传递数据或执行操作的对象。它是一种在 Android 应用程序中实现组件之间通信的重要机制。\nIntent 主要有两种类型：显式 Intent 和隐式 Intent。\n\n显式 Intent：用于启动应用程序内部的组件，例如启动另一个活动（Activity）、启动服务（Service）等。显式 Intent 通过指定目标组件的类名来明确指示要执行的操作。\n示例：\n\n\ntxtIntent intent = new Intent(this, AnotherActivity.class);\nstartActivity(intent);隐式 Intent：用于启动应用程序内或其他应用程序中具有特定功能的组件，而不需要指定目标组件的类名。隐式 Intent 根据指定的动作（Action）、数据（Data）等信息来寻找合适的组件执行操作。\n示例：\n\ntxtIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.example.com&quot;));\nstartActivity(intent);\n\nIntent 的主要作用包括但不限于：\n\n启动活动、服务或广播接收器等组件。\n在组件之间传递数据，例如在不同活动之间传递参数。\n执行一些系统级别的操作，例如拨打电话、发送短信、打开网页等。\n\n总之，Intent 是 Android 应用程序中用于实现组件之间通信和执行操作的重要机制。\n在 Android 中，Bundle 是一个用来存储键值对数据的容器类。它通常被用于在不同的组件（如活动、片段）之间传递数据，或者在组件销毁和重新创建时保存和恢复数据的状态。\n在 onCreate() 方法中，Bundle 参数 savedInstanceState 表示上一个实例状态的数据。当活动被销毁并重新创建时（例如，由于设备旋转或内存紧张），Android 系统会调用 onSaveInstanceState() 方法来保存当前的状态数据，并将其存储在 Bundle 中。然后，在活动重新创建时，系统会将之前保存的状态数据传递给 onCreate() 方法的 savedInstanceState 参数。\ntxtLog.d(&quot;FirstActivity&quot;, this.toString())this.toString() 是调用当前对象的 toString() 方法。在 Java 中，几乎所有的对象都继承自 Object 类，而 Object 类中有一个 toString() 方法，用于返回对象的字符串表示形式\n当你调用 this.toString() 时，它会返回当前对象的字符串表示形式\nActivity的启动模式:\n\nstandard\nsingleTop  单栈顶\nsingleTask   单任务\nsingleInstance  单实例\n\n在 Kotlin 中，object 关键字用于定义单例对象。单例对象是指在程序运行期间只有一个实例存在的对象。在给定的作用域内，单例对象只能有一个实例，因此它们非常适合用于管理全局状态或提供全局访问点。\n关闭所有活动并不等同于关闭应用程序的进程。在 Android 应用程序中，当你调用 finish() 方法结束一个活动时，这个活动会被销毁，但应用程序的进程仍然在运行。即使所有活动都被销毁，应用程序的进程仍然存在于系统中。\n为了完全退出应用程序，有时需要调用 System.exit(0) 或者 Process.killProcess(Process.myPid()) 这样的方法来结束应用程序的进程。这样做可以确保应用程序的所有组件都被终止，包括活动、服务、广播接收器等，从而实现应用程序的完全退出。\n然而，这种做法通常被视为不推荐的，因为它可能会导致用户体验上的问题，以及系统资源的浪费。通常情况下，Android 系统会自动管理应用程序的进程，并在必要时终止它们，而不需要手动干预。因此，大多数情况下，关闭所有活动即可满足应用程序退出的需求，而无需手动杀死进程。\n在 Kotlin 中，companion object（伴生对象）具有以下作用：\n\n静态成员访问：伴生对象中的成员可以直接通过类名访问，就像 Java 中的静态成员一样。这使得可以在不创建类的实例的情况下访问这些成员。\n工厂方法：可以在伴生对象中定义工厂方法，用于创建类的实例。这种方法通常用于隐藏类的构造函数，提供一种更灵活的方式来创建实例。\n共享代码：伴生对象可以包含在类的所有实例之间共享的代码或常量。这些代码或常量对于类的所有实例都是相同的，可以方便地通过伴生对象访问。\n扩展方法：在伴生对象中还可以定义扩展方法，这些方法可以为类添加额外的功能，而无需继承或修改类的源代码。\n\n总的来说，伴生对象提供了一种在 Kotlin 中实现类级别功能的方式，它可以用于静态成员访问、工厂方法、共享代码和扩展方法等场景。\nStringBuilder是Java中的一个类，用于处理字符串。它允许你在不创建新的String对象的情况下进行字符串的修改和操作，这样可以提高性能并节省内存。\n当你需要对字符串进行频繁的修改时，使用StringBuilder通常比直接使用String更高效。这是因为String是不可变的，每次对String进行修改都会创建一个新的String对象，而StringBuilder允许你在同一个对象上执行多次修改操作。\n你可以使用StringBuilder的append()方法来添加字符串，使用delete()方法来删除字符串，使用insert()方法来在指定位置插入字符串，使用replace()方法来替换字符串等等。最后，你可以使用toString()方法将StringBuilder对象转换为String对象，以便进行进一步的操作或输出。\nval list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val builder = StringBuilder() builder.append(&quot;Start eating fruits.\\n&quot;) for (fruit in list) &#123; builder.append(fruit).append(&quot;\\n&quot;) &#125; builder.append(&quot;Ate all fruits.&quot;) val result = builder.toString() println(result) 为什么最后要调用builder.toString()，不能直接打印吗\n在上面的代码中，builder是一个StringBuilder对象，而println函数通常接受String类型的参数来进行输出。而builder对象是一个StringBuilder类型的对象，不是String类型的对象，因此无法直接传递给println函数。\n调用builder.toString()方法将StringBuilder对象转换为String类型的对象，这样就可以将其作为参数传递给println函数，从而实现输出。toString()方法会返回StringBuilder对象中包含的所有字符序列作为一个字符串。\n因此，为了能够正确地输出builder对象中的内容，需要先调用toString()方法将其转换为String类型的对象，然后再传递给println函数进行打印。\nwith 是 Kotlin 的一个标准库函数，它提供了一种简洁的方式来执行针对特定对象的一系列操作，并返回最后一个表达式的结果。\nAlertDialog.Builder(this).apply &#123; setTitle(&quot;This is Dialog&quot;) setMessage(&quot;Something important.&quot;) setCancelable(false) setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; &#125; setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; &#125; show() 是什么意思\n这段代码是使用 Kotlin 的标准库函数 apply 来构建一个 AlertDialog 对话框，并设置其标题、消息、按钮等属性。下面是代码的解释：\n\nAlertDialog.Builder(this)：创建了一个 AlertDialog.Builder 的实例，这个实例用于构建一个对话框。\napply &#123; ... &#125;：apply 是一个 Kotlin 标准库函数，它接收一个 lambda 表达式作为参数，并在 lambda 表达式的作用域内执行一系列操作。在这个例子中，apply 函数被调用后，会将调用者对象（即 AlertDialog.Builder 的实例）作为参数传递给 lambda 表达式，并在 lambda 表达式内部执行一系列设置操作。\nsetTitle(&quot;This is Dialog&quot;)：在 lambda 表达式中调用 setTitle 方法，设置对话框的标题为 “This is Dialog”。\nsetMessage(&quot;Something important.&quot;)：在 lambda 表达式中调用 setMessage 方法，设置对话框的消息内容为 “Something important.”。\nsetCancelable(false)：在 lambda 表达式中调用 setCancelable 方法，设置对话框为不可取消状态，即用户点击对话框外部或返回键时不会关闭对话框。\nsetPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; ... &#125;：在 lambda 表达式中调用 setPositiveButton 方法，设置对话框的确定按钮文本为 “OK”，并设置点击事件处理器。在这里，&#123; dialog, which -&gt; ... &#125; 是一个 lambda 表达式，表示当用户点击确定按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。\nsetNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; ... &#125;：在 lambda 表达式中调用 setNegativeButton 方法，设置对话框的取消按钮文本为 “Cancel”，并设置点击事件处理器。同样，&#123; dialog, which -&gt; ... &#125; 是一个 lambda 表达式，表示当用户点击取消按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。\nshow()：在所有设置完成后，调用 show 方法显示对话框。\n\n因此，这段代码的作用是创建一个带有标题、消息、确定按钮和取消按钮的对话框，并将其显示在界面上。\n三种基本布局：\n\nLinearLayout垂直排布\nRelativeLayout相对布局\nFrameLayout帧布局\n\n\noverride fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123; val view = LayoutInflater.from(context).inflate(resourceId, parent, false) val fruitImage: ImageView = view.findViewById(R.id.fruitImage) val fruitName: TextView = view.findViewById(R.id.fruitName) val fruit = getItem(position) // 获取当前项的Fruit实例 if (fruit != null) &#123; fruitImage.setImageResource(fruit.imageId) fruitName.text = fruit.name &#125; return view &#125;\n其中：val view &#x3D; LayoutInflater.from(context).inflate(resourceId, parent, false)\n作用是从 XML 布局文件中创建一个视图对象，并将其添加到指定的父视图中。\n解释每个参数的含义：\n\ncontext: 表示当前的上下文环境，通常是一个 Activity 或 Fragment 的实例。\nresourceId: 表示要加载的布局文件的资源 ID，即 XML 文件的唯一标识符。\nparent: 表示要将创建的视图添加到的父视图，通常是一个 ViewGroup，比如一个 LinearLayout 或者一个 RecyclerView。\nfalse: 表示在加载布局文件时，不将其添加到父视图中。这个参数设置为 false 表示我们会手动将视图添加到父视图中，而不是在加载时自动添加。\n\n接口在编程中有多种作用，包括但不限于以下几个方面：\n\n定义约束和契约：接口定义了一组方法或属性的规范，实现该接口的类必须提供这些方法或属性的具体实现。这种约束和契约使得代码更加清晰，使得不同的类可以共享相同的行为规范。\n实现多态：通过接口，可以实现多态，即在不同的类中使用相同的方法名，但实际调用的是各自类的具体实现。这样可以提高代码的灵活性和可扩展性。\n代码重用：接口可以用于定义通用的行为规范，使得多个类可以共享相同的接口定义，从而实现代码的重用。当多个类具有相似的行为或功能时，可以通过接口来统一定义这些行为或功能，避免重复编写代码。\n降低耦合性：通过接口，类与类之间的耦合度可以降低，因为类之间通过接口进行交互，而不是直接依赖于具体的实现。这样，当一个类的实现发生变化时，只需要修改实现该接口的类，而不需要修改其他使用该类的代码。\n接口委托：接口支持委托，一个接口可以通过另一个对象来实现其方法，这种方式称为接口委托。这种机制可以进一步提高代码的灵活性和可复用性。\n\n总的来说，接口是一种重要的编程工具，可以帮助程序员设计出更加灵活、可扩展和易于维护的代码结构。\n","slug":"Android-Kotlin","date":"2024-04-21T12:52:23.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"4961e15af02b68ebd599dc1652c0f600","title":"Inference_Framework","content":"","slug":"Inference-Framework","date":"2024-04-13T09:01:40.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"9247c802e822e7604ecac76759948ceb","title":"电路Learning","content":"\n\n\n一阶电路三要素法：https://zhuanlan.zhihu.com/p/367671862\n续流二极管的作用：当输入电压由变+VCC为0V时，三极管由饱和变为截止，这样继电器电感线圈中的电流突然失去了流通通路，若无续流二极管D将在线圈两端产生较大的反向电动势，极性为下正上负，电压值可达一百多伏，这个电压加上电源电压作用在三极管的集电极上足以损坏三极管。故续流二极管D的作用是将这个反向电动势通过图中箭头所指方向放电，使三极管集电极对地的电压最高不超过+VCC +0.7V。\n\n桥式全波整流电路\n\n\n","slug":"电路Learning","date":"2024-04-13T02:08:03.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"a92cda69d94e66650e74496352232332","title":"pcl","content":"&#96;&#96;c make -DCMAKE_BUILD_TYPE&#x3D;None `      -DCMAKE_INSTALL_PREFIX=/home/zgh/pcl_1.9.1_compile \\      -DBUILD_GPU=ON \\      -DBUILD_apps=ON \\      -DBUILD_examples=ON\n-DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-12.2 \\\n-DCUDA_ARCH_BIN=8.6 \\\n-DCUDA_ARCH_PTX=8.6 ..\ncmake  if(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;10.0&quot;)\n    set(__cuda_arch_bin &quot;3.0 3.5 5.0 5.2 5.3 6.0 6.1 7.0 7.2 7.5&quot;)\n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;9.1&quot;)\n    set(__cuda_arch_bin &quot;3.0 3.5 5.0 5.2 5.3 6.0 6.1 7.0 7.2&quot;)\n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;9.0&quot;)\n    set(__cuda_arch_bin &quot;3.0 3.5 5.0 5.2 5.3 6.0 6.1 7.0&quot;)  \n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;8.0&quot;)\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0) 3.0 3.5 5.0 5.2 5.3 6.0 6.1&quot;)\n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;6.5&quot;)\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0) 3.0 3.5 5.0 5.2&quot;)\n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;6.0&quot;)\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0) 3.0 3.5 5.0&quot;)\n  elseif(NOT $&#123;CUDA_VERSION_STRING&#125; VERSION_LESS &quot;5.0&quot;)\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0) 3.0 3.5&quot;)\n  elseif($&#123;CUDA_VERSION_STRING&#125; VERSION_GREATER &quot;4.1&quot;)\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0) 3.0&quot;)\n  else()\n    set(__cuda_arch_bin &quot;2.0 2.1(2.0)&quot;)\n  endif()NXHAY2OW76-eyJsaWNlbnNlSWQiOiJOWEhBWTJPVzc2IiwibGljZW5zZWVOYW1lIjoiSHVuYW4gSW5zdGl0dXRlIG9mIFNjaWVuY2UgYW5kIFRlY2hub2xvZ3kiLCJsaWNlbnNlZVR5cGUiOiJDTEFTU1JPT00iLCJhc3NpZ25lZU5hbWUiOiJ0bXUgaXRtYW5hZ2VyIiwiYXNzaWduZWVFbWFpbCI6InRtdWl0bWFuYWdlckBvdXRsb29rLmNvbSIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU0MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRTIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNWIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQU0kiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUENXTVAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiRFAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjMxMTA5TFBBQTAwOTAwNyIsImhhc2giOiI0MjU0OTY3OS8xMzU2NTA1OTotNDU5NTIyNTciLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwidHJpYWwiOmZhbHNlLCJhaUFsbG93ZWQiOnRydWV9-t3Mcnh+cc&#x2F;DF5z54xXxQ1wh2DTHULDDp0xl9P1s3jRugff7MKaHhYu8MFuKB8smfDaUysLfs94WjunQJeCc4L&#x2F;gMi024G9o&#x2F;O2yBx4&#x2F;Ho9yU7SeYOvnuMqPwwpczR&#x2F;U2JcIZAhH9YPdOo5E7CEtPEW5cq774wN7MrXnHK+LPN6uE4asZ&#x2F;Qk3g3TyqpD3R7ubTmtkAx8JF6iWrezyLNngezgq3NkSE+3LZFuOLep6EKsOJeuaPCKD1uSFJZK7yzUkcLq+H&#x2F;AZDOPZ+Gk9ZTl+P8TlRw3DIA1WDMORmycx5Q4mG+y2cNJoj9r0gfZPiw8OcmcQI8icyF2yTLnWOopRUg&#x3D;&#x3D;-MIIETDCCAjSgAwIBAgIBDzANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMTAxMDE2MDU0NFoXDTI0MTAxMTE2MDU0NFowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMjEwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC&#x2F;W3uCpU5M2y48rUR&#x2F;3fFR6y4xj1nOm3rIuGp2brELVGzdgK2BezjnDXpAxVDw5657hBkAUMoyByiDs2MgmVi9IcqdAwpk988&#x2F;Daaajq9xuU1of59jH9eQ9c3BmsEtdA4boN3VpenYKATwmpKYkJKVc07ZKoXL6kSyZuF7Jq7HoQZcclChbF75QJPGbri3cw9vDk&#x2F;e46kuzfwpGftvl6+vKibpInO6Dv0ocwImDbOutyZC7E+BwpEm1TJZW4XovMBegHhWC04cJvpH1u98xoR94ichw0jKhdppywARe43rGU96163RckIuFmFDQKZV9SMUrwpQFu4Z2D5yTNqnlLRfAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQU5FZqQ4gnVc+inIeZF+o3ID+VhcEwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBANLG1anEKid4W87vQkqWaQTkRtFKJ2GFtBeMhvLhIyM6Cg3FdQnMZr0qr9mlV0w289pf&#x2F;+M14J7S7SgsfwxMJvFbw9gZlwHvhBl24N349GuthshGO9P9eKmNPgyTJzTtw6FedXrrHV99nC7spaY84e+DqfHGYOzMJDrg8xHDYLLHk5Q2z5TlrztXMbtLhjPKrc2+ZajFFshgE5eowfkutSYxeX8uA5czFNT1ZxmDwX1KIelbqhh6XkMQFJui8v8Eo396&#x2F;sN3RAQSfvBd7Syhch2vlaMP4FAB11AlMKO2x&#x2F;1hoKiHBU3oU3OKRTfoUTfy1uH3T+t03k1Qkr0dqgHLxiv6QU5WrarR9tx&#x2F;dapqbsSmrYapmJ7S5+ghc4FTWxXJB1cjJRh3X+gwJIHjOVW+5ZVqXTG2s2Jwi2daDt6XYeigxgL2SlQpeL5kvXNCcuSJurJVcRZFYUkzVv85XfDauqGxYqaehPcK2TzmcXOUWPfxQxLJd2TrqSiO+mseqqkNTb3ZDiYS&#x2F;ZqdQoGYIUwJqXo+EDgqlmuWUhkWwCkyo4rtTZeAj+nP00v3n8JmXtO30Fip+lxpfsVR3tO1hk4Vi2kmVjXyRkW2G7D7WAVt+91ahFoSeRWlKyb4KcvGvwUaa43fWLem2hyI4di2pZdr3fcYJ3xvL5ejL3m14bKsfoOv\npcl::PointCloud 和 pcl::PCLPointCloud2 是 PCL 中两种不同的点云数据结构，它们之间的主要区别在于数据的组织形式和灵活性：\n\npcl::PointCloud：\npcl::PointCloud 是 PCL 中用于表示点云的模板类。\n它是一种比较高级的数据结构，已经预定义了点云中每个点的字段（如坐标、法向量等）以及数据类型（如PointXYZ、Normal等）。\n使用 pcl::PointCloud 可以更方便地访问和处理点云数据，因为它提供了成员函数来操作点云中的点，如添加、删除、修改等操作。\n\n\npcl::PCLPointCloud2：\npcl::PCLPointCloud2 是 PCL 中用于表示点云的更底层、更通用的数据结构。\n它是一种更灵活的数据结构，可以容纳任意类型和数量的字段，适合表示各种形式的点云数据。\n使用 pcl::PCLPointCloud2 需要通过字段的偏移量和数据类型来手动解析和访问点云数据，相对复杂一些。\n\n\n\n总的来说，pcl::PointCloud 更适合处理已知结构和类型的点云数据，而 pcl::PCLPointCloud2 则更适合处理未知结构或需要更大灵活性的点云数据。在实际应用中，根据具体需求选择合适的数据结构进行点云数据的处理和操作。\nstd::cerr 通常用于输出程序运行时的错误信息、警告信息等\n","slug":"pcl","date":"2024-01-31T02:04:42.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"a844e8402236c25b1a86bfe3611488cf","title":"Embedded","content":"为什么原理图里的stm32f4的VCAP1引脚要接一个4.7微法的电容，再接地呢\n2023&#x2F;12&#x2F;25 08:23:32\nSTM32F4芯片的VCAP1引脚是芯片内部电容的引出端，用于连接外部电容以提供给芯片内部振荡电路使用。在使用高速外设时，由于这些外设需要非常稳定的电源供应，因此需要在VCAP1引脚与地之间连接一个电容来提高芯片的稳定性。\n具体来说，连接4.7微法的电容可以起到平滑电压、提高电源噪声抑制能力等作用，从而提高芯片的工作稳定性和可靠性。此外，需要注意电容的选型要符合芯片手册的要求，不能超出规定的范围。\n2023&#x2F;12&#x2F;25 08:26:15芯片内部还有电容吗\n2023&#x2F;12&#x2F;25 08:26:20\n是的，芯片内部通常会包含一些电容。这些内部电容主要用于稳定芯片的电源供应和进行滤波。它们的作用包括：\ntxt电源滤波：在芯片内部集成了一些小型电容器，用于过滤电源中的噪声和干扰，确保芯片正常运行所需的电源干净和稳定。\n\n芯片电源稳定：芯片内部可能还包含一些供电相关的电容，用于提供瞬态响应和电源稳定性，以确保芯片在各种工作条件下都能正常工作。这些内部电容一般由芯片制造商在设计阶段根据具体需求添加，并在芯片手册或参考设计中进行了详细说明。在使用芯片时，我们不需要特别处理这些内部电容，只需按照芯片手册的要求合理连接外部电容即可。\n2023&#x2F;12&#x2F;25 08:26:41那为什么还要连接外部电容\n2023&#x2F;12&#x2F;25 08:26:48\n连接外部电容主要是为了进一步提高芯片的电源稳定性和抑制电磁干扰。虽然芯片内部已经包含了一些电容，但这些电容的容值较小且位置相对固定，可能无法满足某些特殊应用或高要求的电源稳定性。\n通过在VCAP1引脚与地之间连接外部电容，可以实现以下效果：\ntxt改善电源噪声抑制能力：外部电容可以提供更大的容值，能够更好地滤除电源中的高频噪声和纹波，从而提供更稳定的电源供应。\n\n提供额外的瞬态响应：外部电容能够快速响应芯片工作状态的变化，提供更好的瞬态响应能力，尤其在高速外设工作时，可以提供更稳定的电源给这些外设。\n\n抑制电磁干扰：外部电容能够帮助减少电源线上的电磁辐射和接收到的外界干扰信号，提高系统的抗干扰能力，保证芯片的正常运行。需要注意的是，具体的外部电容选型和连接方式应根据芯片厂商提供的参考设计或芯片手册的建议进行，以确保电路的稳定性和可靠性。\n\n\n配置通道    具有检测正反插…..等\n\n边带使用实现…..\n\n\n\n\n\nOSC32IN引脚，用于连接外部低速晶体振荡器（32.768 kHz）。这种振荡器通常用于实时时钟（RTC)的时基。\nOSC_IN引脚，用于连接外部高速晶体振荡器（通常在4 MHz到26 MHz之间）。这种振荡器通常用于系统时钟（SYSCLK）的时基。\nVBAT代表电池供电引脚（Voltage Battery）。VBAT引脚用于连接外部备用电池，通常是一个小型电池，以提供芯片的备份电源。\nVCAP1是指STM32系列芯片上的一个电容滤波器引脚，用于为芯片内部提供稳定的电源环境,用于去除芯片电源中的高频噪声和波动。\n\n在电路设计中，加入0欧电阻（也称为短接电阻）有以下几个常见的目的：\n\n电路连接：0欧电阻可以作为电路的连接点，将不同信号线或电源线连接在一起。它可以提供良好的电气连接，并保持信号或电流的连续性。\n信号分配：在复杂的电路板上，使用0欧电阻可以方便地将信号线分配到不同的位置。通过添加或移除0欧电阻，可以改变信号路径，以满足电路的布局要求。\n调试和测试：在调试和测试电路时，加入0欧电阻可以方便地连接测试仪器或测量点。它可以用作测试点或测量点的连接线，以便在需要时轻松接入测试设备。\n阻抗匹配：在高频电路设计中，0欧电阻可以用于阻抗匹配。通过选择适当的阻值，可以使电路中的阻抗更好地匹配，以最大限度地传输信号或功率。\n\n需要注意的是，加入0欧电阻并不会引入电阻本身的阻尼效应。它的主要作用是提供连接和分配功能，而不会对电路的整体电性能产生实质性的影响。\n\nTPS3823-33DBVR的MR引脚是干什么的\n1&#x2F;3&#x2F;2024, 5:11:40 PM\nTPS3823-33DBVR是一款超低功耗、微型化的复位监测器。MR引脚是器件的主复位引脚，用于手动地对器件进行复位操作。\n当MR引脚被拉低时，TPS3823-33DBVR会立即进行复位操作，并将RST引脚拉低，使被监测的系统或芯片得到重新启动。此外，当MR引脚保持低电平时，TPS3823-33DBVR将始终保持在复位状态，直到MR引脚上升到高电平。\n需要注意的是，MR引脚应该在正常工作时保持高电平，并通过一个合适的电阻接到正电源。当需要手动复位时，可以通过连接一个按钮或开关来将MR引脚拉低，从而触发复位操作。\n总之，TPS3823-33DBVR的MR引脚是用于手动复位操作的引脚，当MR引脚被拉低时，TPS3823-33DBVR会进行复位操作，从而实现对被监测系统或芯片的重新启动。\n1&#x2F;3&#x2F;2024, 5:12:51 PM\nTPS3823-33DBVR的WDI引脚是干什么的\n1&#x2F;3&#x2F;2024, 5:13:13 PM\nTPS3823-33DBVR的WDI引脚是用于喂狗定时器（Watchdog Timer）的输入引脚。\n喂狗定时器是一种用于监控系统运行状态的计时器。它需要周期性地接收一个喂狗脉冲来防止系统出现故障或死锁。如果在一定的时间内没有接收到喂狗脉冲，喂狗定时器会触发复位操作，使被监控的系统重新启动。\n在TPS3823-33DBVR中，WDI引脚用于接收外部喂狗脉冲。当WDI引脚接收到一个高电平脉冲时，喂狗定时器会被重置，系统继续正常运行。如果在一定时间内未接收到喂狗脉冲，喂狗定时器将超时，并触发复位操作。\n通过连接一个外部的喂狗脉冲源（例如微处理器的GPIO引脚），可以周期性地向TPS3823-33DBVR的WDI引脚提供喂狗脉冲。这样可以确保系统持续运行，并在出现故障或死锁时进行自动复位，提高系统的可靠性和稳定性。\n总之，TPS3823-33DBVR的WDI引脚用于接收外部喂狗脉冲，用于喂狗定时器的重置操作，以确保系统正常运行并防止故障或死锁。\nMPU6050https://blog.csdn.net/qq_52251819/article/details/134957492\n\nAHT21\n\nVdd_IO和Vdd是两个不同的电源引脚，常见于集成电路或芯片中。\n\nVdd（也称为Vcc）是供电引脚，用于提供主要的电源电压给芯片或集成电路的内部电路。它通常连接到正电源（例如+3.3V或+5V），以供应芯片内部的数字和模拟电路。\nVdd_IO（也称为Vcc_IO或VddIO）是IO供电引脚，用于提供给输入输出（IO）电路的电源电压。它通常连接到较低的电压（例如+1.8V或+3.3V），用于驱动芯片的输入和输出引脚。\n\n区别：\n\n功能：Vdd提供整个芯片的电源，包括内部逻辑、处理器核心等。Vdd_IO则专门提供给IO电路使用。\n电压级别：Vdd通常连接到较高的电压，而Vdd_IO连接到较低的电压。这是为了在现代集成电路中实现低功耗设计和电压兼容性。\n\n在 STM32 HAL 库中，xx_MspInit() 和 xx_Init() 函数是针对特定外设的初始化函数。\n\nxx_MspInit() 函数：该函数是外设的底层初始化函数，用于配置外设的时钟、引脚、中断等底层硬件资源。”xx” 是指特定外设的前缀，例如 GPIO、USART、SPI 等。xx_MspInit() 通常在应用程序初始化之前调用，主要目的是配置外设所需的底层硬件资源。\nxx_Init() 函数：该函数是外设的高层初始化函数，用于配置外设的工作模式、时钟频率、中断优先级等高层参数。它会调用底层的 xx_MspInit() 函数来初始化底层硬件资源，并进行一些高层配置。xx_Init() 通常在应用程序初始化阶段调用，用于配置外设的工作模式和参数。\n\nHAL_ADC_ConfigChannel()是ADC常规通道配置，一次配置一个通道\nHAL_ADC_PollForConversion()是轮询方式等待ADC常规通道转换完成\nHAL_ADC_GetValue()读取常规通道转换结果寄存器的数据\nHAL_ADC_Start（）以软件方式启动ADC常规转换的通道，然后调用HAL_ADC_PollForConversion()来查询转换是否完成，如果转换完成，使用HAL_ADC_GetValue()读出常规结果寄存器的32位数据\nstm32是32位的，所以指针总是32位的\n\n![(..&#x2F;images&#x2F;image-20240322125751723.png)\n\n\n工作模式：\n\n低功耗模式：\n\n\nstm32的SPI的Clock Phase(CPHA)设置为2 Edge是什么意思\n2024&#x2F;3&#x2F;23 14:29:32\n在 STM32 微控制器的 SPI（Serial Peripheral Interface）模块中，Clock Phase（时钟相位，通常用 CPHA 表示）参数用于定义数据采样的时机。当设置为 2 Edge 时，表示数据采样会在时钟的第二个边缘上进行。\n在 SPI 通信中，数据传输的时机是由时钟信号决定的。CPHA 参数定义了数据采样的时机相对于时钟信号的边缘。具体来说，CPHA 可以设置为 0 或 1，分别表示：\n\nCPHA &#x3D; 0：数据在时钟信号的第一个边缘上进行采样。也就是说，在时钟信号的上升沿或下降沿（取决于时钟极性）开始时采样数据。\nCPHA &#x3D; 1：数据在时钟信号的第二个边缘上进行采样。也就是说，在时钟信号的另一个沿（与上升沿或下降沿相反的沿）上采样数据。\n\n因此，当将 SPI 的 CPHA 参数设置为 2 Edge 时，表示数据采样会在时钟的第二个边缘上进行，这种设置通常用于特定的 SPI 设备或者通信协议要求，确保数据的正确采样和传输。在实际应用中，需要根据外设设备的要求和通信协议的规范来选择合适的 CPHA 设置，以确保 SPI 数据传输的准确性和稳定性。\n\n\n不使用预装载，设置的新ARR的值立即生效\n使用，会在下一个UEV事件生效\nPWM波：\n\n\ncHAL_TIM_IC_CaptureCallback(htim);\nHAL_TIM_OC_DelayElapsedCallback(htim);\nHAL_TIM_PWM_PulseFinishedCallback(htim);\nHAL_TIM_PeriodElapsedCallback(htim);\nHAL_TIM_TriggerCallback(htim);\nHAL_TIMEx_CommutCallback(htim);\n\nmpu_prototypes.h\nmpu_wrappers.h内存保护单元 ,内存保护单元(memory protection unit)，简称：MPU,使用MPU可以设置不同存储区域的存储访问特性（如只支持特权访问或全访问）和存储器属性（如可缓存、可共享），从而提高嵌入式系统的健壮性，使系统更加安全。优先执行mpu_prototypes.h,mpu_wrappers.h里的函数\n\n\n\n\nMPU：内存保护单元\nFPU：浮点数单元\n钩子函数类似于回调函数\n\n\n\n  \n\n\nfreertos中任何时候都要有一个任务占用CPU，所以就有了空闲任务\nsystick只有定时中断功能，1ms中断一次\nsystick定时器不仅可以产生滴答信号，还可以产生任务切换申请\n\n\n所以：Freertos的任务优先级总是低于系统中断的优先级\n\n\n","slug":"Embedded","date":"2023-12-25T00:29:56.000Z","categories_index":"","tags_index":"Embedded","author_index":"Zgh"},{"id":"2da31e9118a69e38c27812cfeb6f1fe9","title":"Esp32","content":"\n","slug":"Esp32","date":"2023-12-20T08:57:19.000Z","categories_index":"","tags_index":"esp32","author_index":"Zgh"},{"id":"f0da541dcd6df6287dc7b7bcefa5bded","title":"yolov5","content":"\n\nIOU —-交并比\nLou为1意味着预测边界框和地面真实边界框完全重叠。您可以为LOU设置阈值，以确定对象检测是否有效。假设您将LOU设置为0.5，在这种情况下。·如果LOU≥为0.5，则将目标检测归类为真阳性(TP)。如果LOU&lt;0.5，则为错误检测，并将其归类为假阳性(FP)。当图像中存在地面真实且模型未能检测到目标时，分类。作为假阴性(FN)。真负片(TN)：TN是我们没有预测到物体的图像的每一部分。度量对于目标检测没有用处，因此我们忽略TN。\n\nAP,MAP\n\n\n   \n \n网络架构和组件单阶段检测器：\n\nyolov5：（没有划出专门的颈部Neck）\n\ngit clone https://github.moeyy.xyz/https://github.com/ultralytics/yolov5.git\n\n\nnc: 80：这个参数表示模型分类数量（number of classes），默认为 80，对应着 COCO 数据集。\ndepth_multiple: 0.33：这个参数表示模型深度相对于基础版本的倍数。在 YOLOv5 中，有 S、M、L 和 X 四个版本，其中 S 为基础版本，即 depth_multiple: 1.0，而 M、L 和 X 版本为在此基础上分别加深了一定的层数。而 depth_multiple: 0.33 表示在 S 版本的基础上，深度缩小了 3 倍，即变成了 depth_multiple: 0.33 × 3 &#x3D; 0.99。\nwidth_multiple: 0.50：这个参数表示模型通道宽度相对于基础版本的倍数。与 depth_multiple 类似，S 版本的 width_multiple 是 1.0，而 M、L 和 X 版本则在此基础上分别扩大了一定的倍数。\nanchors：这是一个锚点数组，用于定义不同尺度下的 anchor boxes。YOLOv5 中使用了三个不同的尺度，每个尺度使用三个不同的 anchor boxes。这些锚点大小是相对于输入图像的，因此不同尺度下的大小会有所差别。\nbackbone：这一部分定义了模型的骨干网络（backbone），包括卷积层、批归一化层和激活函数等。YOLOv5 使用了 CSPDarknet53 这个网络作为基础骨干网络，并在此基础上进行改进。具体而言，YOLOv5 增加了空间注意力机制和SPP模块，以增强特征表达能力。\nhead：这一部分定义了模型的检测头（detection head），包括检测网络和分类网络。YOLOv5 中的检测网络采用了YOLOv3中的FPN结构，并在此基础上加入了PANet模块和SAM模块，以提高检测性能。\n\n序列数据的不同采样方法（随机采样和顺序分区）会导致隐状态初始化的差异，原因如下：\n\n随机采样： 在随机采样中，我们从序列数据中随机选择一个序列作为训练样本。这意味着每次训练时，我们都使用不同的序列作为输入。由于每个序列可能具有不同的上下文和语义信息，模型在每次训练时都需要重新适应不同的序列特征。因此，随机采样会导致隐状态的初始化与之前的训练批次存在一定差异。\n顺序分区： 在顺序分区中，我们按顺序依次读取序列数据进行训练。这意味着模型在每个训练批次中都会接收到相邻的序列数据。由于相邻的序列通常具有相似的上下文和语义信息，模型可以利用之前批次的隐藏状态来帮助理解当前批次的序列。因此，顺序分区会导致隐状态的初始化与之前的训练批次存在一定的相关性。\n\n不同的隐状态初始化差异可能会对模型的训练和预测产生影响。随机采样可以增加数据的多样性，帮助模型更好地适应不同的序列特征。然而，随机采样可能也会引入一些噪声，导致训练过程更加不稳定。顺序分区可以利用相邻序列之间的相关性，帮助模型更好地捕捉到序列的上下文信息。然而，顺序分区可能会限制模型对不同序列特征的适应能力。\n困惑度（perplexity）是自然语言处理中常用的一个评价指标，主要用于衡量语言模型的预测性能。困惑度越低，表示模型的预测能力越好。\n在自然语言处理中，我们通常使用语言模型来计算文本序列的概率。给定一个文本序列 $W&#x3D;w_1,w_2,…,w_n$，其概率可以表示为：\n$$P(W)&#x3D;P(w_1)\\times P(w_2|w_1) \\times … \\times P(w_n|w_1,w_2,…,w_{n-1})$$\n其中，$P(w_i|w_1,w_2,…,w_{i-1})$ 表示在已知前面 $i-1$ 个词的情况下，第 $i$ 个词的概率。语言模型的目标就是学习这种条件概率分布。在模型训练过程中，我们通常会使用最大似然估计法来估计模型参数。\n困惑度是一个数值指标，表示用当前语言模型对一个测试集进行预测时所得到的困惑程度。具体而言，如果测试集包含 $N$ 个词，我们可以计算出每个词的概率 $P(w_i)$，然后将这些概率求倒数并取对数，即：\n$$\\log \\frac{1}{P(w_1)}+\\log \\frac{1}{P(w_2|w_1)}+…+\\log \\frac{1}{P(w_N|w_1,w_2,…,w_{N-1})}$$\n然后，我们可以将上述结果除以测试集中的词数 $N$，得到平均困惑度。具体而言，平均困惑度的计算公式如下：\n$$\\text{Perplexity}&#x3D;exp\\left(-\\frac{1}{N}\\sum_{i&#x3D;1}^{N}\\log P(w_i)\\right)$$\n例如，如果我们有一个包含100个句子的测试集，其中总共包含1000个词，我们可以使用语言模型来预测每个词的概率，并计算出平均困惑度。假设我们的模型预测准确率较高，平均每个词的概率为0.9，则平均困惑度为：\n$$exp\\left(-\\frac{1}{1000}\\sum_{i&#x3D;1}^{1000}\\log 0.9\\right) \\approx 2.15$$\n这表示我们的模型对测试集中的文本序列进行预测时，每个词的平均困惑度为2.15。如果我们使用一个更好的语言模型，其困惑度可能会更低。\n用困惑度来评价模型确保了不同长度的序列具有可比性\n路径聚合网络模块\nFocus处理模块\n空间金字塔池化模块\n跨阶段局部网络模块\n\n​\t\n     IoU、GIoU、DIoU、CIoU损失函数         IoU、GIoU、DIoU、CIoU损失函数\n目标检测任务的损失函数由Classificition Loss和Bounding Box Regeression Loss两部分构成。目标检测任务中近几年来Bounding Box Regression Loss Function的演进过程，其演进路线是一、IOU(Intersection over Union)1. 特性(优点)\nIoU就是我们所说的交并比，是目标检测中最常用的指标，在anchor-based的方法。作用不仅用来确定正样本和负样本，还可以用来评价输出框（predict box）和ground-truth的距离。\n \n \\1. 可以说它可以反映预测检测框与真实检测框的检测效果。\n \\2. 还有一个很好的特性就是尺度不变性，也就是对尺度不敏感（scale invariant）， 在regression任务中，判断predict box和gt的距离最直接的指标就是IoU。**(**满足非负性；同一性；对称性；三角不等性)\n\n 2. 作为损失函数会出现的问题(缺点)\n\\1. 如果两个框没有相交，根据定义，IoU&#x3D;0，不能反映两者的距离大小（重合度）。同时因为loss&#x3D;0，没有梯度回传，无法进行学习训练。\n \\2. IoU无法精确的反映两者的重合度大小。如下图所示，三种情况IoU都相等，但看得出来他们的重合度是不一样的，左边的图回归的效果最好，右边的最差。\n \n 二、GIOU(Generalized Intersection over Union)\n1****、来源\n在CVPR2019中，论文\n《Generalized Intersection over Union: A Metric and A Loss for Bounding Box Regression》 https:arxiv.org&#x2F;abs&#x2F;1902.09630\n提出了GIoU的思想。由于IoU是比值的概念，对目标物体的scale是不敏感的。然而检测任务中的BBox的回归损失(MSE loss, l1-smooth loss等）优化和IoU优化不是完全等价的，而且 Ln 范数对物体的scale也比较敏感，IoU无法直接优化没有重叠的部分。\n \n 这篇论文提出可以直接把IoU设为回归的loss。\n \n 上面公式的意思是：先计算两个框的最小闭包区域面积_ _(通俗理解：同时包含了预测框和真实框的最小框的面积)，再计算出IoU，再计算闭包区域中不属于两个框的区域占闭包区域的比重，最后用IoU减去这个比重得到GIoU。\n 附：https://github.com/generalized-iou/g-darknet\n2****、 特性[1]\n与IoU相似，GIoU也是一种距离度量，作为损失函数的话， ,满足损失函数的基本要求\nGIoU对scale不敏感\nGIoU是IoU的下界，在两个框无线重合的情况下，IoU&#x3D;GIoU\nIoU取值[0,1]，但GIoU有对称区间，取值范围[-1,1]。在两者重合的时候取最大值1，在两者无交集且无限远的时候取最小值-1，因此GIoU是一个非常好的距离度量指标。\n与IoU只关注重叠区域不同，GIoU****不仅关注重叠区域，还关注其他的非重合区域，能更好的反映两者的重合度。\n \n \n 三、DIoU(Distance-IoU)[2]\n**1,**来源\nDIoU要比GIou更加符合目标框回归的机制，将目标与anchor之间的距离，重叠率以及尺度都考虑进去，使得目标框回归变得更加稳定，不会像IoU和GIoU一样出现训练过程中发散等问题。论文中\nDistance-IoU https://arxiv.org/pdf/1911.08287.pdf\n基于IoU和GIoU存在的问题，作者提出了两个问题： \\1. 直接最小化anchor框与目标框之间的归一化距离是否可行，以达到更快的收敛速度？ \\2. 如何使回归在与目标框有重叠甚至包含时更准确、更快？\n \n 其中，分别代表了预测框和真实框的中心点，且代表的是计算两个中心点间的欧式距离。c代表的是能够同时包含预测框和真实框的最小闭包区域的对角线距离。\n \n \n DIoU中对anchor框和目标框之间的归一化距离进行了建模\n附：\nYOLOV3 DIoU GitHub项目地址 https&#x2F;&#x2F;github.com&#x2F;Zzh-tju&#x2F;DIoU-darknet\n2****、优点\n与GIoU loss类似，DIoU loss（ ）在与目标框不重叠时，仍然可以为边界框提供移动方向。\nDIoU loss可以直接最小化两个目标框的距离，因此比GIoU loss收敛快得多。\n对于包含两个框在水平方向和垂直方向上这种情况，DIoU损失可以使回归非常快，而GIoU损失几乎退化为IoU损失。\nDIoU还可以替换普通的IoU评价策略，应用于NMS中，使得NMS得到的结果更加合理和有效。\n实现代码：[3]\n \n \n 四、CIoU(Complete-IoU)\n论文考虑到bbox回归三要素中的长宽比还没被考虑到计算中，因此，进一步在DIoU的基础上提出了CIoU。其惩罚项如下面公式：\n \n 实现代码：[5] \n \n \n \n\n\nL(IoU)&#x3D;1-IoU,L(GIoU)&#x3D;1-GIoU\n\npenalty item 惩罚项\n\n\n\n用1替换\n\n\nYOLO训练技巧\n1.\n\n2.\n余弦退火学习率调整的原理是根据余弦函数的形状动态地调整学习率。它通过将学习率从一个较大的初始值逐渐减小到一个较小的最小值来控制训练过程中的学习率变化。\n具体实现步骤如下：\n\n设置一个最大学习率和最小学习率的范围。\n定义一个周期数（通常是训练的总迭代次数）。\n对于每个训练迭代，计算当前周期数与总周期数之间的比例。\n使用余弦函数来动态计算学习率，公式如下：\n\ntxtlr = lr_min + 0.5 * (lr_max - lr_min) * (1 + cos(epoch / T_total * pi))其中，lr表示当前学习率，epoch表示当前周期数，T_total表示总周期数，lr_max表示最大学习率，lr_min表示最小学习率。\n\n将计算得到的学习率应用于优化器中进行权重更新。\n\n使用余弦退火学习率调整可以在训练初期使用较大的学习率来快速收敛，然后逐渐减小学习率以细化模型的优化过程。这种方法在训练中期能够跳出局部最优解并找到更好的全局最优解，有助于提高模型的泛化性能和训练效果。\n3.\n4.\n5.遗传算法\n6.AMP\n7.\n激活函数\n\n\n\n\n优点：激活区域可以更多样\n因此，引入了各种方法来压缩神经网络，以使大型模型可以在边缘设备上部署。模型压缩方法可以分为3类：剪枝、量化和知识蒸馏。在剪枝中，移除模型中不重要的冗余参数，以获得稀疏&#x2F;紧凑的模型结构。量化涉及使用低精度数据类型表示模型的激活和权重。最后，知识蒸馏是指利用大型准确模型作为教师来训练一个小型模型，使用教师模型提供的软标签来进行训练。cmake_minimum_required(VERSION 3.10) project(yolov5) add_definitions(-std&#x3D;c++11) add_definitions(-DAPI_EXPORTS) option(CUDA_USE_STATIC_CUDA_RUNTIME OFF) set(CMAKE_CXX_STANDARD 11) set(CMAKE_BUILD_TYPE Debug) # TODO(Call for PR): make cmake compatible with Windows set(CMAKE_CUDA_COMPILER &#x2F;usr&#x2F;local&#x2F;cuda-12.2&#x2F;bin&#x2F;nvcc) enable_language(CUDA) # include and link dirs of cuda and tensorrt, you need adapt them if yours are different # cuda include_directories(&#x2F;usr&#x2F;local&#x2F;cuda-12.2&#x2F;include) link_directories(&#x2F;usr&#x2F;local&#x2F;cuda-12.2&#x2F;lib64) # tensorrt # TODO(Call for PR): make TRT path configurable from command line include_directories(&#x2F;home&#x2F;nvidia&#x2F;TensorRT-8.2.5.1&#x2F;include&#x2F;) link_directories(&#x2F;home&#x2F;nvidia&#x2F;TensorRT-8.2.5.1&#x2F;lib&#x2F;) include_directories(${PROJECT_SOURCE_DIR}&#x2F;src&#x2F;) include_directories(${PROJECT_SOURCE_DIR}&#x2F;plugin&#x2F;) file(GLOB_RECURSE SRCS ${PROJECT_SOURCE_DIR}&#x2F;src&#x2F;.cpp ${PROJECT_SOURCE_DIR}&#x2F;src&#x2F;.cu) file(GLOB_RECURSE PLUGIN_SRCS ${PROJECT_SOURCE_DIR}&#x2F;plugin&#x2F;*.cu) add_library(myplugins SHARED ${PLUGIN_SRCS}) target_link_libraries(myplugins nvinfer cudart) find_package(OpenCV) include_directories(${OpenCV_INCLUDE_DIRS}) add_executable(yolov5_det yolov5_det.cpp ${SRCS}) target_link_libraries(yolov5_det nvinfer) target_link_libraries(yolov5_det cudart) target_link_libraries(yolov5_det myplugins) target_link_libraries(yolov5_det ${OpenCV_LIBS}) add_executable(yolov5_cls yolov5_cls.cpp ${SRCS}) target_link_libraries(yolov5_cls nvinfer) target_link_libraries(yolov5_cls cudart) target_link_libraries(yolov5_cls myplugins) target_link_libraries(yolov5_cls ${OpenCV_LIBS}) add_executable(yolov5_seg yolov5_seg.cpp ${SRCS}) target_link_libraries(yolov5_seg nvinfer) target_link_libraries(yolov5_seg cudart) target_link_libraries(yolov5_seg myplugins) target_link_libraries(yolov5_seg ${OpenCV_LIBS}) 这是cmakeLists.txt文件 cmake .. 报错： zgh@zgh-Legion-Y7000P-IAH7:~&#x2F;tensorrtx&#x2F;yolov5&#x2F;build$ cmake .. CMake Error at &#x2F;usr&#x2F;local&#x2F;share&#x2F;cmake-3.27&#x2F;Modules&#x2F;CMakeDetermineCUDACompiler.cmake:277 (message):  CMAKE_CUDA_ARCHITECTURES must be non-empty if set. Call Stack (most recent call first):  CMakeLists.txt:13 (enable_language)  – Configuring incomplete, errors occurred!\n2024&#x2F;1&#x2F;20 11:33:33\n该错误提示是由于没有指定 CMAKE_CUDA_ARCHITECTURES 变量，需要在 CMakeLists.txt 中添加以下语句：\ntxt\nset(CMAKE_CUDA_ARCHITECTURES &quot;60;61;70;75&quot;)其中，CMAKE_CUDA_ARCHITECTURES 指定了支持的 CUDA 架构版本号，这里的值可以根据你的 GPU 型号进行调整。\n在添加上述语句后，再次运行 cmake .. 命令即可。\ntxtcmake_minimum_required(VERSION 3.5)\nproject(Ball_Det)\nset(CMAKE_CXX_STANDARD 11)\nset(Cudart_LIBS &quot;/usr/local/cuda-12.2/targets/x86_64-linux/lib/libcudart.so&quot;)\nset(CMAKE_CUDA_COMPILER /usr/local/cuda-12.2/bin/nvcc)\nset(CMAKE_CUDA_ARCHITECTURES &quot;80&quot;)\ninclude_directories(/usr/local/cuda-12.2/include)\nlink_directories(/usr/local/cuda-12.2/lib64)\nenable_language(CUDA)\nfind_package(CUDA REQUIRED)\nfind_package(k4a REQUIRED)\nfind_package(OpenCV REQUIRED)\ninclude_directories(\n       Yolo\n        $&#123;OpenCV_INCLUDE_DIRS&#125;\n       /usr/local/cuda12.2/include\n       $&#123;CMAKE_CURRENT_LIST_DIR&#125;\n)\nadd_library(\n       Yolo\n       Yolo/yolov5.cpp\n)\n\ncuda_add_library(myplugins SHARED ./Yolo/yololayer.cu)\n\n\nadd_executable(Ball_Det\n       Mask_Detection.cpp\n       Yolo/yolov5.cpp\n       main.cpp\n       Ball_Detection.cpp\n       Yolo/calibrator.cpp\n)\ntarget_link_libraries(\n       Ball_Det\n       nvinfer\n       cudart\n       myplugins\n       /usr/local/cuda12.2/lib64\n       $&#123;Cudart_LIBS&#125;\n       $&#123;OpenCV_LIBS&#125;\n       libk4a.so\n        )","slug":"yolov5","date":"2023-12-16T12:04:59.000Z","categories_index":"","tags_index":"yolo","author_index":"Zgh"},{"id":"2dd54cd4b432aa48fbfa03c6312b571a","title":"deeplearning","content":"在 Pandas 中，.apply() 是用于对 DataFrame 或 Series 中的元素应用指定函数的方法。\n对于 DataFrame，.apply() 可以在行或列方向上应用函数。语法如下：\ntxtDataFrame.apply(func, axis=0)\nfunc 是要应用的函数，可以是一个已定义的函数，也可以是一个匿名函数（如 lambda 函数）。\naxis 是指定应用函数的方向，默认为 0，表示按列应用函数；设置为 1 则表示按行应用函数。\n\n对于 Series，.apply() 仅能在元素级别上应用函数，无需指定应用方向。语法如下：\ntxtSeries.apply(func)\nfunc 是要应用的函数，可以是一个已定义的函数，也可以是一个匿名函数（如 lambda 函数）。\n\n在上述代码中，.apply(lambda x: (x - x.mean()) / (x.std())) 就是将匿名函数 lambda x: (x - x.mean()) / (x.std()) 应用到 DataFrame 或 Series 中的每个元素上。结果是对 DataFrame 或 Series 中的每个元素进行标准化计算，并返回处理后的结果\n\n​                                                                                                         右–按照时间线展开图\n\n查询（自主提示）和键（非自主提示）之间的交互形成了注意力汇聚；注意力汇聚有选择地聚合了值（感官输入）以生成最终的输出。torch.repeat_interleave() 函数是 PyTorch 中的一个张量操作函数，用于生成一个重复值的张量。它的详细解释如下：\ntxt\ntorch.repeat_interleave(input, repeats, dim=None)参数说明：\n\ninput：输入张量。\nrepeats：重复次数，可以是一个整数、一个一维张量或一个与 input 张量形状相匹配的张量。\ndim（可选）：指定重复操作的维度。\n\n函数功能：\n\ntorch.repeat_interleave() 函数将输入张量 input 按指定的重复次数 repeats 进行重复，并生成一个新的张量。\n\ntxthttps://zhuanlan.zhihu.com/p/659067322\n\nsk-QxaDRZHsiyhtTFpB3JXHMkQ5fiK0AnEQZgM27mbiEIaIkF0G","slug":"deeplearning","date":"2023-12-16T02:57:26.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"61251d8b73997ae6479adce2ddc93d34","title":"Pytorch","content":"在 Python 中，lambda 是用来创建匿名函数的关键字。所谓匿名函数，即没有显式定义函数名的函数，通常用于需要临时定义简单函数的场景。\nlambda 函数的语法如下：\ntxtlambda arguments: expression其中：\n\narguments 是函数的参数，可以有多个参数，用逗号隔开。\nexpression 是函数的返回值计算表达式。\n\nlambda 函数通常用于需要一个函数，但是又不想正式定义一个函数的场景，比如作为其他函数的参数传递进去，或者在一些函数式编程的场景中使用。\nparams &#x3D; [W_xh, W_hh, b_h, W_hq, b_q]for param in params:        param.requires_grad_(True)\n目的是告诉 PyTorch 在模型训练过程中需要计算这些参数的梯度，并且在反向传播时对其进行更新。\nXt*Wxh + Ht−1*Whh=cat(Xt,Ht−1)*cat(Wxh,Whh)\ntorch.matmul(X, W_xh) + torch.matmul(H, W_hh)\ntorch.matmul(torch.cat((X, H), 1), torch.cat((W_xh, W_hh), 0))\n当一个类实现了 __call__ 方法时，它的实例对象可以像函数一样进行调用。这意味着你可以使用实例对象作为函数来调用，就好像调用一个函数一样。\n例如，假设有一个类 MyClass，并且实现了 __call__ 方法：\ntxtpython\nclass MyClass:\n    def __call__(self, x):\n        print(&quot;Calling MyClass with argument:&quot;, x)现在，你可以创建一个 MyClass 的实例，并将其作为函数进行调用：\ntxtpython\nobj = MyClass()\nobj(10)输出结果将是：\ntxt\nCalling MyClass with argument: 10所以class RNNModelScratch: #@save&quot;&quot;&quot;从零开始实现的循环神经网络模型&quot;&quot;&quot;def __init__(self, vocab_size, num_hiddens, device,get_params, init_state, forward_fn):self.vocab_size, self.num_hiddens = vocab_size, num_hiddensself.params = get_params(vocab_size, num_hiddens, device)self.init_state, self.forward_fn = init_state, forward_fndef __call__(self, X, state):X = F.one_hot(X.T, self.vocab_size).type(torch.float32)return self.forward_fn(X, state, self.params)\n可以这样调用：\nnet = RNNModelScratch(len(vocab), num_hiddens, d2l.try_gpu(), get_params,init_rnn_state, rnn)\nY, new_state = net(X.to(d2l.try_gpu()), state)\n**kwargs 是 Python 中的一种特殊语法，用于接收任意数量的关键字参数（keyword arguments）。在函数或方法的定义中，**kwargs 会将传递给函数的未命名关键字参数收集到一个字典中，其中字典的键是参数名，值是参数值。\n在这段代码中，**kwargs 被用作 NWKernelRegression 类的初始化方法 __init__ 的参数。通过使用 **kwargs，可以接收任意数量的关键字参数，并将它们存储为类的属性。这样做可以使代码更加灵活，允许用户在创建 NWKernelRegression 实例时传递额外的参数。\n例如，如果你创建了一个 NWKernelRegression 实例时传递了额外的参数，比如 model = NWKernelRegression(param1=10, param2=&#39;abc&#39;)，那么这些额外的参数会被收集到 kwargs 字典中，字典的键是参数名，值是参数值。你可以根据需要在 __init__ 方法中使用这些参数。\n总而言之，**kwargs 允许在函数或方法定义中接收任意数量的关键字参数，并将它们保存为字典以供后续使用。\n","slug":"Pytorch","date":"2023-12-15T14:50:19.000Z","categories_index":"","tags_index":"","author_index":"Zgh"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deployMore info: Deployment\n","slug":"hello-world","date":"2023-12-15T14:27:11.801Z","categories_index":"","tags_index":"","author_index":"Zgh"}]