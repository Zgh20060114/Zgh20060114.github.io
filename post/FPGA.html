<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>FPGA | Zgh&#39;s</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="assign 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在always块中）不同，后者在某种事件或条件发生时才更新值。 assign temp2 &#x3D; {32{1’b0}}; 是什么意思? 在Verilog中，assign temp2 &#x3D; &amp;#123;32&amp;#123;1&#39;b0&amp;#125;">
<meta property="og:type" content="article">
<meta property="og:title" content="FPGA">
<meta property="og:url" content="http://zgh20060114.github.io/post/FPGA.html">
<meta property="og:site_name" content="Zgh&#39;s">
<meta property="og:description" content="assign 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在always块中）不同，后者在某种事件或条件发生时才更新值。 assign temp2 &#x3D; {32{1’b0}}; 是什么意思? 在Verilog中，assign temp2 &#x3D; &amp;#123;32&amp;#123;1&#39;b0&amp;#125;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://zgh20060114.github.io/images/IMG_20240424_115210.jpg">
<meta property="og:image" content="http://zgh20060114.github.io/images/IMG_20240424_115158.jpg">
<meta property="og:image" content="http://zgh20060114.github.io/images/IMG_20240424_115542.jpg">
<meta property="og:image" content="http://zgh20060114.github.io/images/IMG_20240424_115525.jpg">
<meta property="og:image" content="http://zgh20060114.github.io/images/IMG_20240424_115506.jpg">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240427142422285.png">
<meta property="article:published_time" content="2024-04-24T03:03:09.000Z">
<meta property="article:modified_time" content="2024-05-08T09:06:28.445Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zgh20060114.github.io/images/IMG_20240424_115210.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Zgh's" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zgh&#39;s</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Zgh20060114.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-FPGA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/FPGA.html" class="article-date">
  <time class="dt-published" datetime="2024-04-24T03:03:09.000Z" itemprop="datePublished">2024-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      FPGA
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>assign</code> 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在always块中）不同，后者在某种事件或条件发生时才更新值。</p>
<p>assign temp2 &#x3D; {32{1’b0}}; 是什么意思?</p>
<p>在Verilog中，<code>assign temp2 = &#123;32&#123;1&#39;b0&#125;&#125;;</code> 这行代码声明了一个连续赋值，将 <code>temp2</code> 这个线网的值设置为一个32位的全0值。</p>
<p>这里的 <code>&#123;32&#123;1&#39;b0&#125;&#125;</code> 是一个重复拼接操作，含义如下：</p>
<ul>
<li><code>1&#39;b0</code> 是一个二进制数，表示一个位宽为1的数值，值为0。</li>
<li><code>&#123;32&#123;1&#39;b0&#125;&#125;</code> 表示将 <code>1&#39;b0</code> 这个值重复32次。</li>
</ul>
<h6 id="Verilog-数据类型"><a href="#Verilog-数据类型" class="headerlink" title="Verilog 数据类型"></a>Verilog 数据类型</h6><p>Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。</p>
<p><strong>整数（integer）</strong>   reg 型变量为无符号数，而 integer 型变量为有符号数</p>
<p><strong>实数（real）</strong></p>
<p>在Verilog中，<code>real</code> 和 <code>integer</code> 是数据类型关键字，分别用于声明实数类型和整数类型的变量。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">real data1;</span></span>
<span class="line"><span style="color: #babed8">integer temp;</span></span>
<span class="line"><span style="color: #babed8">initial begin</span></span>
<span class="line"><span style="color: #babed8">    data1 = 2e3;</span></span>
<span class="line"><span style="color: #babed8">    data1 = 3.75;</span></span>
<span class="line"><span style="color: #babed8">end</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">initial begin</span></span>
<span class="line"><span style="color: #babed8">    temp = data1; //temp 值的大小为3</span></span>
<span class="line"><span style="color: #babed8">end</span></span></code></pre></div><p>这段代码包含两个 <code>initial</code> 块，它们在仿真开始时执行一次。</p>
<p>第一个 <code>initial</code> 块中：</p>
<ol>
<li><code>data1</code> 被初始化为实数类型 <code>real</code>。</li>
<li><code>data1</code> 被赋值为 <code>2e3</code>，这意味着 <code>data1</code> 现在的值是2000.0。</li>
<li>随后，<code>data1</code> 被更新为 <code>3.75</code>。</li>
</ol>
<p>第二个 <code>initial</code> 块中：</p>
<ol>
<li><code>temp</code> 被初始化为整数类型 <code>integer</code>。</li>
<li><code>temp</code> 被赋值为 <code>data1</code> 的值。由于 <code>data1</code> 当前是 <code>3.75</code>，这个赋值会将实数转换为整数。在Verilog中，实数赋值给整数时，会进行取整操作，保留数值的整数部分，忽略小数部分。因此，<code>temp</code> 的值将是3。</li>
</ol>
<p>需要注意的是，您的注释 <code>//temp 值的大小为3</code> 是正确的，因为 <code>data1</code> 的值 <code>3.75</code> 在赋值给 <code>temp</code> 时会被取整为3。</p>
<p><strong>时间（time）</strong></p>
<p>Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间。例如：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">time current_time;</span></span>
<span class="line"><span style="color: #babed8">initial begin</span></span>
<span class="line"><span style="color: #babed8">    #100;</span></span>
<span class="line"><span style="color: #babed8">    current_time = $time; //current_time 的大小为 100</span></span>
<span class="line"><span style="color: #babed8">end</span></span></code></pre></div><p>这段代码包含一个 <code>initial</code> 块，它在仿真开始时执行一次。</p>
<p>在 <code>initial</code> 块中：</p>
<ol>
<li><code>current_time</code> 被初始化为时间类型 <code>time</code>。</li>
<li><code>#100;</code> 是一个延迟语句，它会使仿真暂停100个时间单位。在Verilog中，<code>#</code> 后面跟一个数字表示延迟的时间量。</li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>存储器</p>
<h6 id="参数-参数用来表示常量，用关键字-parameter-声明，只能赋值一次"><a href="#参数-参数用来表示常量，用关键字-parameter-声明，只能赋值一次" class="headerlink" title="参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次"></a>参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次</h6><p><strong>parameter</strong>    data_width &#x3D; 10’d32 ;</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。</p>
<p>字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0  来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”,  需要 14*8bit 的存储单元：</p>
<p><strong>reg</strong> [0: 14*8-1]    str ;<br> <strong>initial</strong> <strong>begin</strong><br>   str &#x3D; “run.runoob.com”;<br> <strong>end</strong>  </p>
<p><img src="/../images/IMG_20240424_115210.jpg" alt="IMG_20240424_115210"></p>
<p><img src="/../images/IMG_20240424_115158.jpg" alt="IMG_20240424_115158"></p>
<p><img src="/../images/IMG_20240424_115542.jpg" alt="IMG_20240424_115542"></p>
<p><img src="/../images/IMG_20240424_115525.jpg" alt="IMG_20240424_115525"></p>
<p><img src="/../images/IMG_20240424_115506.jpg" alt="IMG_20240424_115506"></p>
<h2 id="2-4-Verilog-表达式"><a href="#2-4-Verilog-表达式" class="headerlink" title="2.4 Verilog 表达式"></a>2.4 Verilog 表达式</h2><p>表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。</p>
<p> a^b ;      <em>&#x2F;&#x2F;a与b进行异或操作</em><br> address[9:0] + 10’b1 ;  <em>&#x2F;&#x2F;地址累加</em><br> flag1 &amp;&amp; flag2 ;  <em>&#x2F;&#x2F;逻辑与操作</em></p>
<p><em>always块里赋值对象不能是wire型</em></p>
<p>同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">//自右向左关联，两种写法等价</span></span>
<span class="line"><span style="color: #babed8">A+B-C ;</span></span>
<span class="line"><span style="color: #babed8">(A+B）-C ;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">//自右向左关联，两种写法等价，结果为 B、D 或 F</span></span>
<span class="line"><span style="color: #babed8">A ? B : C ? D : F ;</span></span>
<span class="line"><span style="color: #babed8">A ? B : (C ? D : F) ;</span></span></code></pre></div><p>求幂（**）、取模（%）</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">b = 4&#39;b100x;</span></span></code></pre></div><p><code>x</code> 是一个表示未知或不可确定状态的字符。它用于在仿真中表示一个位的值是未知的，这通常发生在综合过程中，当某些逻辑路径没有被明确赋值时，或者在设计中的某些部分还没有完全定义时。</p>
<p>无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和</p>
<p><strong>reg</strong> [3:0]     mula ;<br> <strong>reg</strong> [1:0]     mulb;<br> <strong>reg</strong> [5:0]     res ;<br> mula &#x3D; 4’he  ;<br> mulb &#x3D; 2’h3  ;<br> res  &#x3D; mula * mulb ; <em>&#x2F;&#x2F;结果为res&#x3D;6’h2a, 数据结果没有丢失位数</em></p>
<p>逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）</p>
<p>按位操作符包括：取反(<del>)，与（&amp;），或（|），异或（^），同或（</del>^）</p>
<p>按位操作符对 2 个操作数的每 1bit 数据进行按位操作,如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。</p>
<h3 id="归约操作符"><a href="#归约操作符" class="headerlink" title="归约操作符"></a>归约操作符</h3><p>归约操作符包括：归约与（&amp;），归约与非（<del>&amp;），归约或（|），归约或非（</del>|），归约异或（^），归约同或（~^）。</p>
<p>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</p>
<p>逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">A = 4&#39;b1010 ;</span></span>
<span class="line"><span style="color: #babed8">&amp;A ;      //结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#39;b0，可用来判断变量A是否全1</span></span>
<span class="line"><span style="color: #babed8">~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1&#39;b0, 可用来判断变量A是否为全0</span></span>
<span class="line"><span style="color: #babed8">^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1&#39;b0</span></span></code></pre></div><h3 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h3><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p>
<p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p>
<p>算术左移和逻辑左移时，右边低位会补 0。</p>
<p>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>A &#x3D; 4’b1100 ;<br> B &#x3D; 4’b0010 ;<br> A &#x3D; A &gt;&gt; 2 ;     <em>&#x2F;&#x2F;结果为 4’b0011</em><br> A &#x3D; A &lt;&lt; 1;     *&#x2F;&#x2F;结果为 4’b1000*<br> A &#x3D; A &lt;&lt;&lt; 1 ;    *&#x2F;&#x2F;结果为 4’b1000*<br> C &#x3D; B + (A&gt;&gt;&gt;2);   <em>&#x2F;&#x2F;结果为 2 + (-4&#x2F;4) &#x3D; 1, 4’b0001</em></p>
<h3 id="define-undef"><a href="#define-undef" class="headerlink" title="define, undef"></a><code>define, </code>undef</h3><p>在编译阶段，&#96;define 用于文本替换，类似于 C 语言中的 <strong>#define</strong>。</p>
<p>&#96;undef 用来取消之前的宏定义</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`ifdef       MCU51</span></span>
<span class="line"><span style="color: #babed8">    parameter DATA_DW = 8   ;</span></span>
<span class="line"><span style="color: #babed8">`elsif       WINDOW</span></span>
<span class="line"><span style="color: #babed8">    parameter DATA_DW = 64  ;</span></span>
<span class="line"><span style="color: #babed8">`else</span></span>
<span class="line"><span style="color: #babed8">    parameter DATA_DW = 32  ;</span></span>
<span class="line"><span style="color: #babed8">`endif</span></span></code></pre></div><h3 id="include"><a href="#include" class="headerlink" title="&#96;include"></a>&#96;include</h3><p>使用 &#96;include 可以在编译时将一个 Verilog 文件内嵌到另一个 Verilog 文件中，作用类似于 C 语言中的 #include 结构。</p>
<h3 id="timescale"><a href="#timescale" class="headerlink" title="timescale"></a>timescale</h3><p>在 Verilog 模型中，时延有具体的单位时间表述，并用 &#96;timescale 编译指令将时间单位与实际时间相关联。</p>
<p>该指令用于定义时延、仿真的单位和精度，格式为：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`timescale      time_unit / time_precision</span></span></code></pre></div><p>time_unit 表示时间单位，time_precision 表示时间精度，它们均是由数字以及单位  s（秒），ms（毫秒），us（微妙），ns（纳秒），ps（皮秒）和  fs（飞秒）组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小，例如下面例子中，输出端 Z 会延迟 5.21ns 输出  A&amp;B 的结果。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><code>timescale 1ns/100ps   *//时间单位为1ns，精度为100ps，合法*  *//</code>timescale 100ps&#x2F;1ns  &#x2F;&#x2F;不合法*<br> <strong>module</strong> AndFunc(Z, A, B);<br>   <strong>output</strong> Z;<br>   <strong>input</strong> A, B ;<br>   <strong>assign</strong> #5.207 Z &#x3D; A &amp; B<br> <strong>endmodule</strong></p>
<p>在编译过程中，<code>timescale 指令会影响后面所有模块中的时延值，直至遇到另一个 </code>timescale 指令或 &#96;resetall 指令。 </p>
<p>由于在 Verilog 中没有默认的 <code>timescale，如果没有指定 </code>timescale，Verilog 模块就有会继承前面编译模块的 &#96;timescale 参数。有可能导致设计出错。</p>
<p>如果一个设计中的多个模块都带有 &#96;timescale 时，模拟器总是定位在所有模块的最小时延精度上，并且所有时延都相应地换算为最小时延精度</p>
<h3 id="default-nettype"><a href="#default-nettype" class="headerlink" title="&#96;default_nettype"></a>&#96;default_nettype</h3><p>该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`default_nettype wand </span></span></code></pre></div><p>该实例定义的缺省的线网为线与类型。因此，如果在此指令后面的任何模块中的连线没有说明，那么该线网被假定为线与类型。  </p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`default_nettype none</span></span></code></pre></div><p>该实例定义后，将不再自动产生 wire 型变量。</p>
<h3 id="celldefine-endcelldefine"><a href="#celldefine-endcelldefine" class="headerlink" title="celldefine, endcelldefine"></a><code>celldefine, </code>endcelldefine</h3><p>这两个程序指令用于将模块标记为单元模块，他们包含模块的定义。例如一些与、或、非门，一些 PLL 单元，PAD 模型，以及一些 Analog IP 等。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><code>celldefine  **module** (    **input**    clk,    **input**    rst,    **output**   clk_pll,    **output**   flag);      ……  **endmodule**  </code>endcelldefine</p>
<h3 id="unconnected-drive-nounconnected-drive"><a href="#unconnected-drive-nounconnected-drive" class="headerlink" title="unconnected_drive, nounconnected_drive"></a><code>unconnected_drive, </code>nounconnected_drive</h3><p>在模块实例化中，出现在这两个编译指令间的任何未连接的输入端口，为正偏电路状态或者为反偏电路状态。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">assign</span></span></code></pre></div><p>用于对 wire 型变量进行赋值,不对寄存器赋值</p>
<p>进位输出（Carry  out，通常表示为Co或Cout）是全加器的一个输出，它表示在两个二进制位相加时是否产生了进位。在二进制加法中，当两个加数位（A和B）的和大于或等于2时，就会产生进位，因为二进制中的每一位只能表示0或1。进位输出就是用来表示这个进位的。</p>
<p><strong>module</strong> full_adder1(<br>   <strong>input</strong>   Ai, Bi, Ci,<br>   <strong>output</strong>  So, Co);</p>
<p>   <strong>assign</strong> So &#x3D; Ai ^ Bi ^ Ci ;<br>   <strong>assign</strong> Co &#x3D; (Ai &amp; Bi) | (Ci &amp; (Ai | Bi));<br> <strong>endmodule</strong></p>
<p>更简单的：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">module full_adder1(</span></span>
<span class="line"><span style="color: #babed8">    input Ai, Bi, Ci,</span></span>
<span class="line"><span style="color: #babed8">    output So, Co);</span></span>
<span class="line"><span style="color: #babed8">    </span></span>
<span class="line"><span style="color: #babed8">    assign &#123;Co, So&#125; = Ai + Bi + Ci;</span></span>
<span class="line"><span style="color: #babed8">endmodule</span></span></code></pre></div><p><em>&#x2F;&#x2F;普通时延，A&amp;B计算结果延时10个时间单位赋值给Z</em><br> <strong>wire</strong> Z, A, B ;<br> <strong>assign</strong> #10   Z &#x3D; A &amp; B ;</p>
<p> <em>&#x2F;&#x2F;隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。</em><br> <strong>wire</strong> A, B;<br> <strong>wire</strong> #10     Z &#x3D; A &amp; B;</p>
<p> <em>&#x2F;&#x2F;声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。</em><br> <strong>wire</strong> A, B;<br> <strong>wire</strong> #10 Z ;<br> <strong>assign</strong>      Z &#x3D;A &amp; B</p>
<h2 id="Verilog-过程结构"><a href="#Verilog-过程结构" class="headerlink" title="Verilog 过程结构"></a>Verilog 过程结构</h2><p>过程结构语句有 2 种，initial 与 always 语句</p>
<p>一个模块中可以包含多个 initial 和 always 语句，但 2 种语句不能嵌套使用。</p>
<p>但是 initial 语句或 always 语句内部可以理解为是顺序执行的（非阻塞赋值除外）。</p>
<h3 id="initial语句"><a href="#initial语句" class="headerlink" title="initial语句"></a>initial语句</h3><p>initial 语句从 0 时刻开始执行，只执行一次，多个 initial 块之间是相互独立的。</p>
<p>如果 initial 块内包含多个语句，需要使用关键字 begin 和 end 组成一个块语句。</p>
<p>如果 initial 块内只要一条语句，关键字 begin 和 end 可使用也可不使用。</p>
<p>initial 理论上来讲是不可综合的，多用于初始化、信号检测等。</p>
<h4 id="这些语句在模块间并行执行，与其在模块的前后顺序没有关系"><a href="#这些语句在模块间并行执行，与其在模块的前后顺序没有关系" class="headerlink" title="这些语句在模块间并行执行，与其在模块的前后顺序没有关系"></a>这些语句在模块间并行执行，与其在模块的前后顺序没有关系</h4><h3 id="always-语句"><a href="#always-语句" class="headerlink" title="always 语句"></a>always 语句</h3><p>与 initial 语句相反，always 语句是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。</p>
<p>由于循环执行的特点，always 语句多用于仿真时钟的产生，信号行为的检测等。   </p>
<h6 id="parameter-关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。"><a href="#parameter-关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。" class="headerlink" title="parameter 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。"></a><code>parameter</code> 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。</h6><p>连续性赋值使用assign语句，而过程性赋值使用always块。</p>
<p>阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。</p>
<p>阻塞赋值语句使用等号 &#x3D; 作为赋值符。</p>
<p>非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。</p>
<p>非阻塞赋值语句使用小于等于号 &lt;&#x3D; 作为赋值符。</p>
<p>如下所示，2 个 always 块中语句并行执行，赋值操作右端操作数使用的是上一个时钟周期的旧值，此时 a&lt;&#x3D;b 与 b&lt;&#x3D;a 就可以相互不干扰的执行，达到交换寄存器值的目的。</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><p><strong>always</strong> @(<strong>posedge</strong> clk) <strong>begin</strong><br>   a &lt;&#x3D; b ;<br> <strong>end</strong></p>
<p> <strong>always</strong> @(<strong>posedge</strong> clk) <strong>begin</strong><br>   b &lt;&#x3D; a;<br> <strong>end</strong></p>
<h2 id="Verilog-时序控制"><a href="#Verilog-时序控制" class="headerlink" title="Verilog 时序控制"></a>Verilog 时序控制</h2><p>Verilog 提供了 2 大类时序控制方法：时延控制和事件控制。事件控制主要分为边沿触发事件控制与电平敏感事件控制</p>
<h3 id="时延控制-根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。"><a href="#时延控制-根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。" class="headerlink" title="时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。"></a>时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。</h3><p><strong>常规时延</strong></p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">reg  value_test ;</span></span>
<span class="line"><span style="color: #babed8">reg  value_general ;</span></span>
<span class="line"><span style="color: #babed8">#10  value_general    = value_test ;</span></span></code></pre></div><p>或：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">#10 ;</span></span>
<span class="line"><span style="color: #babed8">value_ single         = value_test ;</span></span></code></pre></div><p><strong>内嵌时延</strong></p>
<p>遇到内嵌延时时，该语句先将计算结果保存，然后等待一定的时间后赋值给目标信号。</p>
<p>内嵌时延控制加在赋值号之后。例如：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">reg  value_test ;</span></span>
<span class="line"><span style="color: #babed8">reg  value_embed ;</span></span>
<span class="line"><span style="color: #babed8">value_embed        = #10 value_test ;</span></span></code></pre></div><p>需要说明的是，这 2 种时延控制方式的效果是有所不同的。</p>
<p>当延时语句的赋值符号右端是常量时，2 种时延控制都能达到相同的延时赋值效果。</p>
<p>当延时语句的赋值符号右端是变量时，2 种时延控制可能会产生不同的延时赋值效果。</p>
<h3 id="边沿触发事件控制"><a href="#边沿触发事件控制" class="headerlink" title="边沿触发事件控制"></a>边沿触发事件控制</h3><p>在 Verilog 中，事件是指某一个 reg 或 wire 型变量发生了值的变化。事件控制用符号 @ 表示。</p>
<p><strong>设计</strong>：根据需求编写硬件描述语言（如Verilog或VHDL）代码来描述设计的功能和行为</p>
<p>synthesize综合，合成：综合代码，检查语法是否有错误,将高级的逻辑描述代码转换为逻辑门级别的网表或等效的门级电路</p>
<p>FloorPlanner 是 FPGA 设计流程中的一个重要工具，用于执行布局（Place）阶段的子任务，即对设计中的逻辑电路进行布局安置。在 FPGA 设计流程中，FloorPlanner 的地位如下：</p>
<ol>
<li><strong>布局规划</strong>：FloorPlanner 负责规划 FPGA 芯片上各个逻辑模块的布局位置，以最大程度地满足设计的性能和资源利用率要求。它会考虑逻辑模块之间的布线延迟、信号传输路径长度等因素，以优化整体的布局结构。</li>
<li><strong>资源分配</strong>：FloorPlanner 还负责将设计中的逻辑模块分配到 FPGA 芯片的不同区域，并且合理利用芯片上的资源（如片上存储器、DSP模块等），以满足设计对资源的需求。</li>
<li><strong>时序约束</strong>：在布局过程中，FloorPlanner 还会考虑时序约束，确保设计中的时序要求能够得到满足。它会尽可能减少逻辑模块之间的传输延迟，以确保时序性能。</li>
<li><strong>优化布局</strong>：FloorPlanner 通过对设计进行优化布局，以降低布线延迟、减少时序问题和功耗等方面的优化。这可以提高设计的性能、可靠性和功耗效率。</li>
</ol>
<p>在 FPGA 设计流程中，FloorPlanner 位于布局（Place）阶段之前，它为后续的布线（Route）阶段提供了优化的布局结果，从而帮助实现设计的最终映射和部署。</p>
<p><strong>Place&amp;Route</strong> ：</p>
<p>开发流程中的 Place &amp; Route 是指在将设计映射到 FPGA 芯片时的一个重要步骤。下面解释一下它的含义和作用：</p>
<ol>
<li><strong>Place（放置）</strong>：Place 指的是将设计中的逻辑元素（如逻辑门、寄存器等）放置到 FPGA 芯片的物理位置上。这一步骤考虑了芯片内部的布局和连接资源，以尽可能地优化性能和资源利用率。放置的目标是最小化延迟、最大化时序性能，并且尽量减少芯片内的布线冲突。</li>
<li><strong>Route（布线）</strong>：Route 是指将设计中的逻辑元素之间的连接关系转化为芯片内部的实际物理连线。这一步骤考虑了芯片内部的连线资源、信号传输延迟等因素，以确保逻辑元素之间的连接能够有效地建立并满足时序要求。布线的目标是尽可能地降低信号传输延迟、最小化信号干扰，同时满足设计的时序约束。</li>
</ol>
<p>在 Verilog 中，<code>reg</code> 类型通常用于表示存储元素（如寄存器），而不是直接连接到模块的输出端口。输出端口通常使用 <code>output</code> 或 <code>inout</code> 声明，并且通常需要与 <code>wire</code> 类型一起使用。</p>
<p><code>reg</code> 类型在 Verilog 中表示的是寄存器类型，它在 <code>always</code> 块中使用，存储状态或信号。而 <code>output</code> 端口应该使用 <code>wire</code> 类型来表示，因为它们不会存储状态，只是将信号传递给其他部件。</p>
<p>因此，你在模块顶层中使用 <code>output reg</code> 是不符合常规的 Verilog 设计习惯的，通常应该使用 <code>output wire</code>。</p>
<p><img src="/../images/image-20240427142422285.png" alt="image-20240427142422285"></p>
<p>半加器（Half Adder）和全加器（Full Adder）是数字电路中用于执行二进制加法的基本组件。它们的主要区别在于它们处理的输入数量和功能。</p>
<p>半加器： 半加器是一个组合逻辑电路，它接受两个二进制位作为输入，并产生两个输出：和（Sum）和进位（Carry）。半加器只处理两个输入位的加法，不考虑来自较低位的进位。半加器的输出进位只能表示当前两个输入位相加是否产生了进位。</p>
<p>半加器的逻辑可以表示为：</p>
<ul>
<li><p>•</p>
<p>和（Sum） &#x3D; A XOR B</p>
</li>
<li><p>•</p>
<p>进位（Carry） &#x3D; A AND B</p>
</li>
</ul>
<p>其中，A和B是两个输入位，XOR表示异或门，AND表示与门。</p>
<p>全加器： 全加器也是一个组合逻辑电路，它接受三个二进制位作为输入，并产生两个输出：和（Sum）和进位（Carry）。全加器的三个输入包括两个加数位（A和B）以及来自较低位的进位（Carry-in）。全加器能够处理包括进位在内的三个位的加法。</p>
<p>全加器的逻辑可以表示为：</p>
<ul>
<li><p>•</p>
<p>和（Sum） &#x3D; (A XOR B) XOR Carry-in</p>
</li>
<li><p>•</p>
<p>进位（Carry） &#x3D; (A AND B) OR (Carry-in AND (A XOR B))</p>
</li>
</ul>
<p>其中，Carry-in是来自较低位的进位，OR表示或门。</p>
<p>区别：</p>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<p>  输入数量：半加器有两个输入，全加器有三个输入。</p>
<ol start="2">
<li><ol start="2">
<li></li>
</ol>
</li>
</ol>
<p>  功能：半加器只计算两个输入位的和和进位，而全加器计算三个输入位（包括来自较低位的进位）的和和进位。</p>
<ol start="3">
<li><ol start="3">
<li></li>
</ol>
</li>
</ol>
<p>  应用：半加器通常用于构建更复杂的加法器电路，如全加器。全加器则用于实现多位二进制数的加法，因为它能够处理进位。</p>
<p>在实际的数字电路设计中，全加器更为常用，因为它可以级联（Cascade）起来构成多位加法器，如4位、8位、16位等，从而实现更复杂的算术运算。</p>
<p>在Verilog中，<code>parameter</code>是一个关键字，用于定义模块（module）的参数</p>
<p><code>parameter</code>定义的值在模块的整个实例化过程中都是固定的，不能被重新赋值。这意味着一旦定义了<code>parameter</code>，它的值在整个模块中都是不变的。</p>
<p>Assignment 赋值</p>
<p>SP代表single port单端口模式，即同一时钟控制读写，同一时间只能写或者度</p>
<p>在您提供的 Verilog 代码片段中，<code>ram_inst</code> 是一个实例化语句，用于创建一个 RAM 模块的实例。这个实例使用了多个引脚（pins），这些引脚定义了模块的输入和输出接口。下面是每个引脚的详细解释：</p>
<ul>
<li><p>•</p>
<p><code>.dout(dout_o)</code>：这是 RAM 模块的输出引脚，名为 <code>dout</code>，它是一个 8 位宽度的输出信号。在这个实例中，它被连接到了一个名为 <code>dout_o</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.clk(clk)</code>：这是 RAM 模块的时钟输入引脚，用于同步数据写入和读取操作。它被连接到了一个名为 <code>clk</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.oce(oce_i)</code>：这是 RAM 模块的输出使能输入引脚，用于控制 <code>dout</code> 信号是否输出数据。它被连接到了一个名为 <code>oce_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.ce(ce_i)</code>：这是 RAM 模块的芯片使能输入引脚，用于控制 RAM 是否可以进行读写操作。它被连接到了一个名为 <code>ce_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.reset(reset_i)</code>：这是 RAM 模块的复位输入引脚，用于将 RAM 恢复到初始状态。它被连接到了一个名为 <code>reset_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.wre(wre_i)</code>：这是 RAM 模块的写使能输入引脚，用于控制是否可以写入数据到 RAM。它被连接到了一个名为 <code>wre_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.ad(addr)</code>：这是 RAM 模块的地址输入引脚，用于指定要读取或写入的 RAM 单元的地址。它被连接到了一个名为 <code>addr</code> 的信号，该信号是 11 位宽度的。</p>
</li>
<li><p>•</p>
<p><code>.din(data_i)</code>：这是 RAM 模块的数据输入引脚，用于写入数据到 RAM。它被连接到了一个名为 <code>data_i</code> 的信号，该信号是 8 位宽度的。</p>
</li>
</ul>
<p>每个引脚都是 RAM 模块与其外部接口之间的连接点，它们定义了模块如何与外部信号交互。在实际的设计中，您需要确保这些引脚被正确地连接到相应的信号，并且信号的类型和宽度与 RAM 模块的要求相匹配。</p>
<p>FPGA中BRAM和DRAM的区别</p>
<p>FPGA（现场可编程门阵列）中的BRAM（块RAM）和DRAM（动态RAM）是两种不同类型的存储器，它们在设计和使用上有着显著的区别：</p>
<ol>
<li><strong>类型和用途</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：是静态RAM（SRAM）的一种形式，通常集成在FPGA芯片内部。它提供快速的存储解决方案，适用于需要高速、小容量存储的应用，如缓存、缓冲区或FPGA内部的数据存储。</li>
<li><strong>DRAM</strong>：是一种动态RAM，与FPGA芯片外部连接。它具有更高的存储密度，但速度较BRAM慢。DRAM适用于需要大容量存储的应用，如图像处理、视频缓冲和大量数据存储。</li>
</ul>
<ol start="2">
<li><strong>存储机制</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：作为静态RAM，它不需要刷新电路来维持数据。每个存储单元都使用六晶体管（6T）的SRAM细胞结构，这意味着它可以无限期地保持数据，直到被写入新数据。</li>
<li><strong>DRAM</strong>：作为动态RAM，它需要定期刷新来维持数据。每个存储单元通常由一个电容器和一个晶体管组成，因此它的密度可以更高，但速度较慢，并且需要更复杂的控制逻辑。</li>
</ul>
<ol start="3">
<li><strong>性能特点</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：提供单周期访问时间，这意味着访问数据几乎立即完成，适用于要求严格实时性能的应用。</li>
<li><strong>DRAM</strong>：由于其刷新要求，访问速度较慢，通常需要多个时钟周期来访问数据。</li>
</ul>
<ol start="4">
<li><strong>集成度</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：在FPGA芯片内部，与逻辑元素紧密集成，可以提供非常低的延迟访问。</li>
<li><strong>DRAM</strong>：通常作为外部组件连接到FPGA，通过内存接口（如DDR）进行通信。</li>
</ul>
<ol start="5">
<li><strong>功耗</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：由于其简单性和快速访问能力，通常功耗较低。</li>
<li><strong>DRAM</strong>：由于需要刷新和复杂的控制逻辑，功耗通常更高。</li>
</ul>
<p>在选择使用BRAM还是DRAM时，设计者需要根据应用需求、性能要求、成本考虑和功耗限制来做出决策。对于需要高速、小容量存储的应用，BRAM通常是更好的选择；而对于需要大容量存储的应用，DRAM可能是更合适的选择。</p>
<p>在FPGA中，BRAM（块RAM）可以被配置为单端口模式或双端口模式，这两种模式在数据访问方式上有所不同：</p>
<ol>
<li><strong>单端口模式</strong>：</li>
</ol>
<ul>
<li>在单端口模式下，BRAM有一个数据访问端口，即地址和数据线是共用的。</li>
<li>在任何给定的时间，单端口BRAM只能进行一次读操作或写操作。如果在一个时钟周期内同时尝试进行读和写操作，通常会发生冲突，除非特定的FPGA具有特殊的管理机制。</li>
<li>单端口模式适用于那些不需要同时进行读写操作的应用场景，或者那些可以接受顺序访问的应用场景。</li>
</ul>
<ol start="2">
<li><strong>双端口模式</strong>：</li>
</ol>
<ul>
<li>双端口模式允许BRAM同时通过两个独立的端口进行访问，每个端口都有自己的地址线、数据线和控制线。</li>
<li>这意味着双端口BRAM可以在同一时钟周期内进行一次读操作和一次写操作，或者同时进行两次读操作，访问不同的地址。</li>
<li>双端口模式适用于需要同时或并行访问存储器中不同位置的应用场景，如图像处理、缓存和乒乓缓冲等。</li>
</ul>
<p>在某些FPGA中，BRAM还可以配置为更高级的端口模式，如四端口模式，这允许更多的并行访问。设计者根据具体应用的需求来选择最合适的端口模式，以优化性能和资源利用。</p>
<p>十六进制数系统中的每个数字代表4位二进制数</p>
<p>在Verilog中，<code>defparam</code>是一个编译器指令，用于在模块实例化时重定义参数的值。这条指令可以用来改变模块实例化时参数的默认值。</p>
<p>在Verilog中，<code>localparam</code>关键字用于声明一个模块内部的参数，这个参数在模块的整个作用域内都是常量。<code>localparam</code>声明的参数是不可变的，它们的值在编译时就已经确定了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/FPGA.html" data-id="clxbjvuxp000861cxbhoich4q" data-title="FPGA" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/post/Algo.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Algo
        
      </div>
    </a>
  
  
    <a href="/post/Android-Kotlin.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android_Kotlin</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/" rel="tag">C++STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PNC/" rel="tag">PNC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/esp32/" rel="tag">esp32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robot-kinematics/" rel="tag">robot_kinematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yolo/" rel="tag">yolo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%89%E8%B6%B3/" rel="tag">玉足</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-STL/" style="font-size: 10px;">C++STL</a> <a href="/tags/Embedded/" style="font-size: 10px;">Embedded</a> <a href="/tags/PNC/" style="font-size: 10px;">PNC</a> <a href="/tags/esp32/" style="font-size: 10px;">esp32</a> <a href="/tags/robot-kinematics/" style="font-size: 10px;">robot_kinematics</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/%E7%8E%89%E8%B6%B3/" style="font-size: 10px;">玉足</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">计算机图形学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/kitty.html">kitty</a>
          </li>
        
          <li>
            <a href="/post/guitar.html">guitar</a>
          </li>
        
          <li>
            <a href="/post/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0.html">最优控制与强化学习</a>
          </li>
        
          <li>
            <a href="/post/ncnn-yolov8-seg.html">ncnn-yolov8-seg</a>
          </li>
        
          <li>
            <a href="/post/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html">流体力学</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>