<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>OpenGL | Zgh&#39;s</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jiujiubashiyi&#x2F;p&#x2F;16429717.html GLFW,GLAD,opengl是什么，有什么联系 GLFW、GLAD和OpenGL是计算机图形学中常用的三个库，它们之间存在着紧密的联系：  OpenGL：是一个跨语言、跨平台的编程接口，用于渲染2D、3D向量图形。它是由硅谷图形公司（Silicon Graphics,  SGI）在1">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL">
<meta property="og:url" content="http://zgh20060114.github.io/post/OpenGL.html">
<meta property="og:site_name" content="Zgh&#39;s">
<meta property="og:description" content="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jiujiubashiyi&#x2F;p&#x2F;16429717.html GLFW,GLAD,opengl是什么，有什么联系 GLFW、GLAD和OpenGL是计算机图形学中常用的三个库，它们之间存在着紧密的联系：  OpenGL：是一个跨语言、跨平台的编程接口，用于渲染2D、3D向量图形。它是由硅谷图形公司（Silicon Graphics,  SGI）在1">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240517165248939.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240517165400128.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/pipeline.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240603155209855.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240608192337289.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240608192358635.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240608192525938.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/coordinate_systems.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240609164419389.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240609164929887.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240609165058873.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240609211854570.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240609212927721.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240609213514370.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240609221012736.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240610000155256.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611133720092.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611133805550.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611133838091.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611140046801.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611140651535.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611141635271.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611141659727.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611143342649.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611143614094.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611144943071.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611145404898.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611153315884.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240611155005492.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240613162635475.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240613160828062.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240613161203147.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/basic_lighting_phong.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240618134143162.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240618134913056.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240618135228887.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240618135413787.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240618141855717.png">
<meta property="article:published_time" content="2024-05-17T08:51:10.000Z">
<meta property="article:modified_time" content="2024-06-24T08:28:56.235Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zgh20060114.github.io/images/image-20240517165248939.png">
  
    <link rel="alternate" href="/atom.xml" title="Zgh's" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zgh&#39;s</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Zgh20060114.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-OpenGL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/OpenGL.html" class="article-date">
  <time class="dt-published" datetime="2024-05-17T08:51:10.000Z" itemprop="datePublished">2024-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      OpenGL
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240517165248939.png" alt="image-20240517165248939"></p>
<p><img src="/../images/image-20240517165400128.png" alt="image-20240517165400128"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiujiubashiyi/p/16429717.html">https://www.cnblogs.com/jiujiubashiyi/p/16429717.html</a></p>
<p>GLFW,GLAD,opengl是什么，有什么联系</p>
<p>GLFW、GLAD和OpenGL是计算机图形学中常用的三个库，它们之间存在着紧密的联系：</p>
<ol>
<li><strong>OpenGL</strong>：是一个跨语言、跨平台的编程接口，用于渲染2D、3D向量图形。它是由硅谷图形公司（Silicon Graphics,  SGI）在1992年开发的。OpenGL是图形硬件制造商的标准，也是创作高质量计算机图形的基本工具。OpenGL提供了一个非常灵活的编程接口，让开发者能够利用它来渲染图形。</li>
<li><strong>GLFW</strong>：是一个跨平台的OpenGL应用程序接口（API）的多线程窗口和输入管理器。简单来说，GLFW用来创建窗口、处理输入事件（如键盘、鼠标点击等），并管理OpenGL上下文。它使得开发者可以比较容易地创建一个OpenGL环境，因为它简化了OpenGL程序中许多繁琐的设置步骤。</li>
<li><strong>GLAD</strong>：是一个自动生成OpenGL函数指针的库。在OpenGL中，许多操作需要通过指针来调用函数，而在不同的操作系统和硬件平台上，这些函数指针的位置可能会有所不同。GLAD就是用来处理这些函数指针的，它会根据当前的平台和OpenGL的版本自动生成对应的函数指针。这为开发者减少了处理这些底层细节的麻烦。</li>
</ol>
<p><strong>它们之间的联系</strong>：</p>
<ul>
<li>使用OpenGL之前，需要创建一个OpenGL环境，这个环境包括一个窗口以及一个上下文，这是通过GLFW来完成的。</li>
<li>GLAD用来确保所有的OpenGL函数调用都能够正确地指向相应的函数，这样开发者就不需要手动查找和设置这些函数指针了。</li>
<li>通常，一个OpenGL程序的设置流程是这样的：首先初始化GLFW，然后使用GLFW创建一个窗口和OpenGL上下文，接着使用GLAD自动加载OpenGL函数，最后就可以开始使用OpenGL进行绘图了。</li>
</ul>
<p>综上，GLFW和GLAD都是帮助开发者更简单、更有效地使用OpenGL的辅助工具。通过它们，开发者可以专注于图形内容的创作，而不必担心底层的细节问题。</p>
<p>glfwMakeContextCurrent(window);是什么意思</p>
<p><code>glfwMakeContextCurrent(window);</code> 是一行来自 GLFW（OpenGL Framework）库的代码。GLFW 是一个跨平台的库，用于窗口和输入处理，它使得创建 OpenGL 应用程序变得更加容易。</p>
<p>这句代码的作用是将 OpenGL 渲染上下文关联到由 <code>window</code> 参数指定的窗口。在 OpenGL 中，渲染上下文是用来进行图形绘制的环境，它定义了一系列可以用来配置和控制渲染行为的设置。</p>
<p>在创建窗口之后，必须调用 <code>glfwMakeContextCurrent</code> 函数来指定哪个窗口的上下文将被当前的线程使用。只有当前上下文中的 OpenGL 调用才会对指定的窗口产生影响。如果没有激活任何上下文，任何 OpenGL 调用都会导致错误。</p>
<p>简单来说，当你想要在特定的窗口上绘制图形时，你需要确保该窗口的 OpenGL 上下文被设置为当前上下文。这就是 <code>glfwMakeContextCurrent(window);</code> 这行代码的目的。</p>
<p>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress) 是什么意思</p>
<p><code>gladLoadGLLoader</code> 是一个函数，通常在 C 或 C++ 程序中使用，用于初始化 OpenGL 函数指针。OpenGL 是一个用于渲染2D和3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。<code>gladLoadGLLoader</code> 函数是 GLAD 库的一部分，GLAD 是一个小型且易于使用的库，它负责在每次调用 OpenGL 函数之前，动态地加载和绑定正确的 OpenGL 函数指针。</p>
<p><code>glfwGetProcAddress</code> 是另一个函数，属于 GLFW 库（一个用于创建窗口、输入处理等的前端库，常与OpenGL一起使用）。<code>glfwGetProcAddress</code> 的作用是获取指向特定OpenGL函数的指针，该函数在OpenGL核心或者扩展中定义。</p>
<pre><code>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)
</code></pre>
<p>这表示在初始化GLAD库时，它将使用GLFW库提供的函数指针来加载OpenGL函数。这允许应用程序使用OpenGL函数，而不需要关心底层的具体实现细节。</p>
<p>这种机制的好处是，应用程序只需要链接到一个库（比如GLFW），而GLFW会负责查找和加载正确的OpenGL函数。这样做可以简化应用程序的编写和维护工作，同时也确保了应用程序可以轻松地与不同平台的OpenGL版本兼容。</p>
<p><strong>双缓冲(Double Buffer)</strong></p>
<p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p>
<ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li>
</ul>
<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素.3D坐标转为2D坐标的处理过程是由OpenGL的<strong>图形渲染管线</strong>（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。(图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出)</p>
<p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做<strong>着色器</strong>(Shader)。</p>
<p><strong>OpenGL着色器</strong>是用OpenGL着色器语言(OpenGL Shading Language, <strong>GLSL</strong>)写成的</p>
<p><img src="/../images/pipeline.png" alt="img"></p>
<p>为了让OpenGL知道我们的<strong>坐标和颜色值</strong>构成的到底是什么，OpenGL需要你去指定这些数据所表示的<strong>渲染类型</strong>。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做**图元(Primitive)**，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</p>
<p><strong>图形渲染管线的第一个部分</strong>—-<strong>顶点着色器</strong></p>
<p>把3D坐标转为另一种3D坐标</p>
<p><strong>几何着色器</strong></p>
<p>一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状</p>
<p><strong>图元装配</strong></p>
<p>将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状</p>
<p><strong>光栅化阶段</strong></p>
<p>把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的**片段(Fragment)**。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<p>OpenGL中的一个<strong>片段</strong>是OpenGL渲染一个像素所需的所有数据</p>
<p><strong>片段着色器</strong></p>
<p>片段着色器的主要目的是计算一个像素的最终颜色</p>
<p><strong>Alpha测试和混合(Blending)阶段</strong></p>
<p>这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同</p>
<p><code>GL_ARRAY_BUFFER</code>目标用于表示顶点属性数据的缓冲区对象</p>
<p>在OpenGL中，VAO（Vertex Array Object）和VBO（Vertex Buffer Object）是用于管理顶点数据的重要概念，并且它们之间存在一定的关系。</p>
<ol>
<li>VAO（Vertex Array Object）：<ul>
<li>VAO是OpenGL中用于存储顶点属性状态的对象。它包含了多个指向VBO的指针，用于指定顶点属性数据的格式、排列方式等。</li>
<li>VAO可以看作是对VBO的管理器，它记录了OpenGL如何解释顶点数据，包括顶点的位置、颜色、法线等信息。通过绑定VAO，可以轻松地切换顶点属性的设置，从而简化渲染流程。</li>
</ul>
</li>
<li>VBO（Vertex Buffer Object）：<ul>
<li>VBO是用于存储顶点数据的缓冲区对象。它可以存储顶点的位置、颜色、纹理坐标等信息。</li>
<li>通过将顶点数据存储在VBO中，可以有效地管理和传输大量的顶点数据，而不必反复传输到GPU。</li>
</ul>
</li>
</ol>
<p>关系：</p>
<ul>
<li>VBO存储了实际的顶点数据，例如顶点的位置、颜色、纹理坐标等。</li>
<li>VAO描述了顶点数据的格式和布局，它指明了如何从VBO中读取顶点数据以供渲染使用。</li>
<li>通常情况下，我们先创建和绑定VAO，然后配置相应的VBO，并将VBO与VAO关联。这样，在渲染时只需绑定相应的VAO即可，OpenGL就会根据VAO中的配置自动获取正确的顶点数据进行渲染。</li>
</ul>
<p>总结来说，VAO用于管理顶点属性状态，而VBO用于存储实际的顶点数据。它们共同协作，使得在OpenGL中管理和使用顶点数据变得更加灵活和高效。</p>
<p>我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）</p>
<p>着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p>
<p>Uniform是另一种从我们的应用程序在 CPU 上传递数据到 GPU 上的着色器的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>
<p>在OpenGL中，VBO（Vertex Buffer Object）和VAO（Vertex Array Object）都是用于管理顶点数据的对象。它们之间的联系和区别如下：</p>
<p>联系：</p>
<ul>
<li>VBO和VAO都是用于管理顶点属性数据的对象。</li>
<li>它们都可以通过OpenGL API进行创建、绑定、更新和删除等操作。</li>
<li>VAO可以保存多个VBO的绑定状态，使得我们在绘制时只需绑定VAO即可同时启用多个顶点属性数组。</li>
</ul>
<p>区别：</p>
<ul>
<li>VBO是用于存储和管理顶点数据的缓冲对象，包括顶点位置、法线、颜色、纹理坐标等属性数据。它能够提高渲染效率，因为可以将这些数据上传到显卡内存中，而不需要每次绘制时都从系统内存中获取。</li>
<li>VAO是用于管理VBO的绑定状态的对象，它记录了VBO的绑定状态以及每个属性在VBO中的偏移量、类型等信息。VAO可以看作是一组VBO的绑定描述符，它规定了如何从VBO中获取顶点属性数据。</li>
</ul>
<p>总体来说，VBO和VAO在OpenGL中都扮演着非常重要的角色，它们都可以提高渲染效率，使得开发者可以更加方便地管理和操作顶点属性数据。其中，VBO主要用于存储和管理顶点数据，而VAO则是用于在绘制时快速激活和绑定多个顶点属性数组。</p>
<p>把两个角度都发送</p>
<p>试一下发后两个数据，看看是不是数据的问题</p>
<p>试试发5个</p>
<p><img src="/../images/image-20240603155209855.png" alt="image-20240603155209855">2024.6.3.15.52Matlab报错，遂改，无用！！！！</p>
<p>艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节.这样就可以让物体非常精细而不用指定额外的顶点</p>
<p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p>
<p>使用 Xlib 来获取窗口大小需要一些底层的操作，但可以通过以下步骤来实现：</p>
<p>首先，你需要安装 <code>python-xlib</code> 库。你可以使用以下命令在 Ubuntu 上安装：</p>
<pre><code class="bash">sudo apt-get install python-xlib
</code></pre>
<p>然后，你可以使用下面的代码来获取当前活动窗口的大小：</p>
<pre><code class="python">from Xlib import display

def get_screen_size():
    disp = display.Display()
    screen = disp.screen()
    root_win = screen.root
    windowID = root_win.get_full_property(disp.intern_atom(&#39;_NET_ACTIVE_WINDOW&#39;), 0).value[0]
    window = disp.create_resource_object(&#39;window&#39;, windowID)
    geometry = window.get_geometry()
    return geometry.width, geometry.height

width, height = get_screen_size()
print(&quot;Window size: &#123;&#125; x &#123;&#125;&quot;.format(width, height))
</code></pre>
<p>这段代码中，我们首先创建了一个 <code>Display</code> 对象，然后获取了当前活动窗口的 ID。接着，我们使用这个窗口 ID 创建了一个 <code>window</code> 对象，并通过这个对象的 <code>get_geometry</code> 方法获取了窗口的宽度和高度。</p>
<p>请注意，使用 Xlib 需要对 X 窗口系统有一定的了解，因为它是一个底层的库，直接和 X 服务器进行交互。希望这个示例能够帮助你开始使用 Xlib 来获取窗口大小。</p>
<ul>
<li><code>layout(location=0)</code>: 这是一个着色器布局限定符（layout qualifier），用于指定顶点属性在输入阶段的位置。在这里，<code>location=0</code> 表示顶点属性的位置索引为 0。这个位置索引将与顶点数组对象（VAO）中的对应属性绑定，以确保正确地将顶点数据传递给顶点着色器。</li>
<li><code>in</code>: 这是一个输入变量修饰符，用于指示这个变量是从外部传递给顶点着色器的。</li>
<li><code>vec3</code>: 这是指定变量类型的关键字，表示这个变量是一个三维向量。</li>
<li><code>in_position</code>: 这是变量的名称，用于在顶点着色器中引用这个输入变量。在这里，<code>in_position</code> 可能表示顶点的位置信息。</li>
</ul>
<p>在OpenGL中，<code>gl_Position</code>是一个内置的变量，用于表示顶点着色器（Vertex Shader）输出的顶点位置。它是一个四维向量（<code>vec4</code>），表示顶点的齐次坐标（Homogeneous Coordinates），通常用于表示三维空间中的点。齐次坐标是四维的，其中前三个分量表示点的位置，而第四个分量通常被用于表示点的类型或者进行透视除法（Perspective Division）。在顶点着色器中，对 <code>gl_Position</code> 的设置将影响后续的图元装配（Primitive Assembly）和光栅化（Rasterization）阶段，最终确定绘制的像素位置。因此，正确设置 <code>gl_Position</code> 是绘制正确图形的关键。</p>
<p>[[ 0.5  0.5  0.   0.   1.   0. ]<br> [-0.5  0.5  0.   1.   0.   0. ]<br> [-0.5 -0.5  0.   0.   0.   1. ]<br> [ 0.5  0.5  0.   0.   1.   0. ]<br> [-0.5 -0.5  0.   0.   0.   1. ]<br> [ 0.5 -0.5  0.   1.   0.   0. ]]</p>
<pre><code>layout(location=0) in vec3 in_position;
layout(location=1) in vec3 in_color;
</code></pre>
<pre><code>self.vbo_format = &#39;3f 3f&#39;
self.attrs = (&#39;in_position&#39;, &#39;in_color&#39;)
</code></pre>
<pre><code>vertex_data = np.hstack([vertices_array, colors_array])
</code></pre>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p><img src="/../images/image-20240608192337289.png" alt="image-20240608192337289"></p>
<h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p><img src="/../images/image-20240608192358635.png" alt="image-20240608192358635"></p>
<p>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p>
<ul>
<li>弧度转角度：<code>角度 = 弧度 * (180.0f / PI)</code></li>
<li>角度转弧度：<code>弧度 = 角度 * (PI / 180.0f)</code></li>
</ul>
<p><img src="/../images/image-20240608192525938.png" alt="image-20240608192525938"></p>
<p>我这一辈子，抠抠搜搜的花了很多钱，精精明明的上了很多当。骂骂咧咧的干了很多活，小心翼翼的闯了很多祸。精打细算的欠了一屁股帐。认认真真的范了很多错。掏心掏肺的结了很多仇。不明不白的吃了很多亏。窝窝囊囊的活了几十年。</p>
<ol>
<li><code>glm::mat4 trans;</code>：首先声明了一个4x4的矩阵trans，用于表示变换矩阵。</li>
<li><code>trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));</code>：这一行代码对trans进行了旋转变换。使用了glm库中的rotate函数，将trans矩阵绕Z轴旋转90度（使用radians函数将角度转换为弧度），并将结果赋值给trans本身。</li>
<li><code>trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));</code>：接着对trans进行了缩放变换。使用了glm库中的scale函数，将trans矩阵沿着X、Y、Z三个轴分别缩放0.5倍，并将结果再次赋值给trans本身。</li>
</ol>
<ul>
<li>局部空间(Local Space，或者称为物体空间(Object Space))</li>
<li>世界空间(World Space)</li>
<li>观察空间(View Space，或者称为视觉空间(Eye Space))</li>
<li>裁剪空间(Clip Space)</li>
<li>屏幕空间(Screen Space)</li>
</ul>
<p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕</p>
<p>坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p>
<p><img src="/../images/coordinate_systems.png" alt="coordinate_systems"></p>
<ol>
<li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li>
<li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li>
<li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>
<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li>
<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li>
</ol>
<p>你可能已经大致了解了每个坐标空间的作用。我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。</p>
<h2 id="局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间-摄像机空间-———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间"><a href="#局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间-摄像机空间-———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间" class="headerlink" title="局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间"></a>局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间</h2><p><img src="/../images/image-20240609164419389.png" alt="image-20240609164419389"></p>
<p><img src="/../images/image-20240609164929887.png" alt="image-20240609164929887"></p>
<p><img src="/../images/image-20240609165058873.png" alt="image-20240609165058873"></p>
<p><img src="/../images/image-20240609211854570.png" alt="image-20240609211854570"></p>
<p><img src="/../images/image-20240609212927721.png" alt="image-20240609212927721"></p>
<p><img src="/../images/image-20240609213514370.png" alt="image-20240609213514370"></p>
<p>glm::LookAt函数需要一个位置、目标和上向量。它会创建一个观察矩阵。</p>
<p>为了改变摄像机方向</p>
<p><img src="/../images/image-20240609221012736.png" alt="image-20240609221012736"></p>
<p><code>self.m_projection=glm.perspective(V_FOV,ASPECT_RATIO,NEARPLANE,FARPLANE)</code></p>
<p>使用 GLM 库中的 <code>glm::perspective()</code> 函数创建了一个投影矩阵（projection matrix）.会根据给定的参数创建一个透视投影矩阵，并返回这个矩阵。这个投影矩阵描述了从摄像机位置观察场景时的投影效果，将三维场景转换为二维屏幕空间</p>
<p><img src="/../images/image-20240610000155256.png" alt="image-20240610000155256"></p>
<p>对连续时间正弦信号考虑下面表示式：<br>x ( t ) &#x3D; s i n ( 2 π f 0 t + φ )<br>可以按抽样频率 fs&#x3D;1&#x2F;Ts对 x(t)抽样来获得离散时间信号<br>x [ n ] &#x3D; x ( t )|t &#x3D;nTs       &#x3D;  x ( t ) |t&#x3D;n &#x2F; fs &#x3D; s i n ( 2 πf0 &#x2F;fsn + φ ),<br>f0 &#x3D;500Hz， fs 取 100Hz， 绘出 x[n]及其 DTFT</p>
<p><img src="/../images/image-20240611133720092.png" alt="image-20240611133720092"></p>
<p><img src="/../images/image-20240611133805550.png" alt="image-20240611133805550"></p>
<p><img src="/../images/image-20240611133838091.png" alt="image-20240611133838091"></p>
<p><img src="/../images/image-20240611140046801.png" alt="image-20240611140046801"></p>
<p>以 5000HZ 和 1000HZ 分别对其采样得到 x1(n)， x2(n)；画出它们的 DTFT 并比较</p>
<p><img src="/../images/image-20240611140651535.png" alt="image-20240611140651535"></p>
<p><img src="/../images/image-20240611141635271.png" alt="image-20240611141635271"></p>
<p>我们可以从第一个方程中直接得到 A 和 φ 的关系：</p>
<p><img src="/../images/image-20240611141659727.png" alt="image-20240611141659727"></p>
<p>φ ！&#x3D;π&#x2F;2+kπ</p>
<p>x(t)&#x3D;2cos(π&#x2F;3 *t)</p>
<p><img src="/../images/image-20240611143342649.png" alt="image-20240611143342649"></p>
<p><img src="/../images/image-20240611143614094.png" alt="image-20240611143614094"></p>
<p><img src="/../images/image-20240611144943071.png" alt="image-20240611144943071"></p>
<p><img src="/../images/image-20240611145404898.png" alt="image-20240611145404898"></p>
<p>现实中无法实现理想低通滤波器。然而，可以按下面的方法计算由理想低通滤波器产生的<br>波形：理想低通运算相当于信号频谱与频域的矩形函数相乘，这对应于信号与通过傅里叶逆变<br>换得到的时域 sinc 函数的卷积。当其应用于点样本时，卷积和为 sinc 函数内插：</p>
<p>xa(t)&#x3D;sum_{n&#x3D;-无穷}^{正无穷} [xa(nt) sin(π(t-nTs)&#x2F;Ts)&#x2F;(π(t-nTs)&#x2F;Ts)]</p>
<p>(3.18)<br>其中，样本 xa(nt)取自 t&#x3D; nTs处。<br>a. 假设只有有限数量的信号样本是非零值，且只需在有限时间区间上进行信号重建，写出<br>基于(3.18)式的 sinc 内插表示式。</p>
<p><code>syms t n Ts xa;</code></p>
<p><code>xa_t = symsum(xa * sin(pi*(t-n*Ts)/Ts)/(pi*(t-n*Ts)/Ts), n, -inf, inf);</code></p>
<p><img src="/../images/image-20240611153315884.png" alt="image-20240611153315884"></p>
<p>C：<br><img src="/../images/image-20240611155005492.png" alt="image-20240611155005492"></p>
<p>根据奈奎斯特采样定理，要求 fs≥2fbfs≥2fb 以避免混叠现象。因此，fb&lt;fs2fb&lt;2fs 是满足采样定理的条件。</p>
<p><img src="/../images/image-20240613162635475.png" alt="image-20240613162635475"></p>
<p>45HZ，基本周期 T是 1&#x2F;45</p>
<p><img src="/../images/image-20240613160828062.png" alt="image-20240613160828062"></p>
<h3 id="结果分析与总结"><a href="#结果分析与总结" class="headerlink" title="结果分析与总结"></a>结果分析与总结</h3><ol>
<li><strong>分析长度 ( 0.5T_p &#x3D; 0.1 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率较低，频率成分不清晰，可能会导致频率混淆。</li>
<li>由于分析长度小于一个周期，频谱分析结果可能包含较多的谐波失真和旁瓣效应。</li>
</ul>
</li>
<li><strong>分析长度 ( 1.5T_p &#x3D; 0.3 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率有所提高，主要频率成分变得更加明显。</li>
<li>由于分析长度超过一个周期，频谱分析结果更加准确，频率成分容易识别。</li>
</ul>
</li>
<li><strong>分析长度 ( 2T_p &#x3D; 0.4 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率进一步提高，主要频率成分非常清晰。</li>
<li>更长的分析长度提供了更好的频率分辨率，但同时也增加了计算时间和资源需求。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>选择合适的分析长度</strong>：分析长度可以通过基本周期 ( T_p ) 的整数倍来选择。一般来说，分析长度至少应等于或大于一个周期 ( T_p )，这样可以确保频谱分析结果的准确性。</li>
<li><strong>平衡分辨率和计算复杂度</strong>：较长的分析长度提供更好的频率分辨率，但也会增加计算时间和资源。在实际应用中，需要在频率分辨率和计算复杂度之间取得平衡。</li>
<li><strong>避免过短的分析长度</strong>：过短的分析长度（例如小于一个周期）可能导致频谱结果混乱，难以准确识别主要频率成分</li>
</ul>
<p><img src="/../images/image-20240613161203147.png" alt="image-20240613161203147"></p>
<p>你可以看到，白色的阳光实际上是所有可见颜色的集合，物体吸收了其中的大部分颜色。它仅反射了代表物体颜色的部分，被反射颜色的组合就是我们所感知到的颜色（此例中为珊瑚红）。</p>
<p>这些颜色反射的定律被直接地运用在图形领域。当我们在OpenGL中创建一个光源时，我们希望给光源一个颜色。在上一段中我们有一个白色的太阳，所以我们也将光源设置为白色。当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色（也就是我们所感知到的颜色）。让我们再次审视我们的玩具（这一次它还是珊瑚红），看看如何在图形学中计算出它的反射颜色。我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量了：</p>
<pre><code class="c++">glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
glm::vec3 toyColor(1.0f, 0.5f, 0.31f);
glm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f);
</code></pre>
<p>我们可以看到玩具的颜色<strong>吸收</strong>了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，我们可以定义物体的颜色为&#x3D;&#x3D;<strong>物体从一个光源反射各个颜色分量的大小</strong>。&#x3D;&#x3D;</p>
<p>**现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为冯氏光照模型(Phong Lighting Model)。冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。下面这张图展示了这些光照分量看起来的样子：</p>
<p><img src="/../images/basic_lighting_phong.png" alt="img"></p>
<ul>
<li>环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li>
<li>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。</li>
<li>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>
</ul>
<p>在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体进行任何缩放操作，所以我们并不真的需要使用一个法线矩阵，而是仅以模型矩阵乘以法线就可以。但是如果你会进行不等比缩放，使用法线矩阵去乘以法向量就是必须的了。</p>
<p><img src="/../images/image-20240618134143162.png" alt="image-20240618134143162"></p>
<p><img src="/../images/image-20240618134913056.png" alt="image-20240618134913056"></p>
<p><img src="/../images/image-20240618135228887.png" alt="image-20240618135228887"></p>
<p><img src="/../images/image-20240618135413787.png" alt="image-20240618135413787"></p>
<p>已知周期信号 <em>x</em>(<em>t</em>) &#x3D; 0.75 + 3.4 cos 2πft + 2.7 cos 4<em>π</em> <em>ft</em> +1.5sin 3.5<em>π</em> <em>ft</em> + 2.5sin 7<em>π</em> <em>ft</em>  ，其<br>中 25&#x2F;16Hz,若截断时间长度分别为信号周期的 0.9 和 1.1 倍，试分别绘制这八种窗函数<br>提取的 x(t)的频谱。</p>
<p><img src="/../images/image-20240618141855717.png" alt="image-20240618141855717"></p>
<p>根据下列指标采用窗函数法设计低通数字滤波器， 通带截止频率wp&#x3D; 0.2π ，阻带截止频率</p>
<p>ws &#x3D; 0.3π，通带最大衰减 0.25dB，阻带最小衰减 50dB。</p>
<p>（1） 分别利用汉明窗、布莱克曼窗和凯泽窗设计该滤波器，且滤波器具有线性相位。绘出脉冲响应 h(n)及滤波器的频率响应；</p>
<p>（2） 增加 N，观察过渡带和最大肩峰值的变化。</p>
<p>利用汉明窗设计数字微分器</p>
<p>Hd(e^jw)&#x3D;</p>
<p>jw,0&lt;w&lt;π;</p>
<p>-jw,-π&lt;w&lt;0.</p>
<p>要求 <em>N</em> &#x3D; 21，且滤波器具有线性相位。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/OpenGL.html" data-id="clxbjvuxq000c61cx46uggxj5" data-title="OpenGL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/post/openmv.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          openmv
        
      </div>
    </a>
  
  
    <a href="/post/CUDA.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CUDA</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/" rel="tag">C++STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PNC/" rel="tag">PNC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/esp32/" rel="tag">esp32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robot-kinematics/" rel="tag">robot_kinematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yolo/" rel="tag">yolo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%89%E8%B6%B3/" rel="tag">玉足</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-STL/" style="font-size: 10px;">C++STL</a> <a href="/tags/Embedded/" style="font-size: 10px;">Embedded</a> <a href="/tags/PNC/" style="font-size: 10px;">PNC</a> <a href="/tags/esp32/" style="font-size: 10px;">esp32</a> <a href="/tags/robot-kinematics/" style="font-size: 10px;">robot_kinematics</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/%E7%8E%89%E8%B6%B3/" style="font-size: 10px;">玉足</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">计算机图形学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/ncnn-yolov8-seg.html">ncnn-yolov8-seg</a>
          </li>
        
          <li>
            <a href="/post/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html">流体力学</a>
          </li>
        
          <li>
            <a href="/post/%E5%9B%9B%E8%B6%B3.html">四足</a>
          </li>
        
          <li>
            <a href="/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6.html">图形学</a>
          </li>
        
          <li>
            <a href="/post/motion-planning.html">motion_planning</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>