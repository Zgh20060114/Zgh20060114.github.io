<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Android_Kotlin | Zgh&#39;s</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="txt&#96;class FirstActivity : AppCompatActivity() &amp;#123;&#96; &#96;override fun onCreate(savedInstanceState: Bundle?) &amp;#123;&#96; &#96;super.onCreate(savedInstanceState)&#96; &#96;&amp;#125;&#96; &#96;&amp;#125;&#96;这段代码是使用 Kotlin 语言编写的 Android 应用程">
<meta property="og:type" content="article">
<meta property="og:title" content="Android_Kotlin">
<meta property="og:url" content="http://zgh20060114.github.io/post/Android-Kotlin.html">
<meta property="og:site_name" content="Zgh&#39;s">
<meta property="og:description" content="txt&#96;class FirstActivity : AppCompatActivity() &amp;#123;&#96; &#96;override fun onCreate(savedInstanceState: Bundle?) &amp;#123;&#96; &#96;super.onCreate(savedInstanceState)&#96; &#96;&amp;#125;&#96; &#96;&amp;#125;&#96;这段代码是使用 Kotlin 语言编写的 Android 应用程">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240422135757284.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240423231325479.png">
<meta property="og:image" content="http://zgh20060114.github.io/images/image-20240429211327595.png">
<meta property="article:published_time" content="2024-04-21T12:52:23.000Z">
<meta property="article:modified_time" content="2024-05-26T03:07:48.662Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zgh20060114.github.io/images/image-20240422135757284.png">
  
    <link rel="alternate" href="/atom.xml" title="Zgh's" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zgh&#39;s</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Zgh20060114.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Android-Kotlin" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Android-Kotlin.html" class="article-date">
  <time class="dt-published" datetime="2024-04-21T12:52:23.000Z" itemprop="datePublished">2024-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Android_Kotlin
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`class FirstActivity : AppCompatActivity() &#123;`</span></span>
<span class="line"><span style="color: #babed8">`override fun onCreate(savedInstanceState: Bundle?) &#123;`</span></span>
<span class="line"><span style="color: #babed8">`super.onCreate(savedInstanceState)`</span></span>
<span class="line"><span style="color: #babed8">`&#125;`</span></span>
<span class="line"><span style="color: #babed8">`&#125;`</span></span></code></pre></div><p>这段代码是使用 Kotlin 语言编写的 Android 应用程序中的一个活动（Activity）类。让我逐步解释其中的内容：</p>
<ol>
<li><code>class FirstActivity : AppCompatActivity()</code>：这是一个类的声明，类名为 <code>FirstActivity</code>，并且继承自 <code>AppCompatActivity</code> 类。<code>AppCompatActivity</code> 是 Android 开发中常用的一个基类，用于支持应用程序在较旧的 Android 版本上提供向后兼容性。</li>
<li><code>override fun onCreate(savedInstanceState: Bundle?)</code>：这是 <code>FirstActivity</code> 类中的一个方法 <code>onCreate()</code> 的重写。在 Android 中，<code>onCreate()</code> 方法是活动生命周期的一部分，在活动第一次创建时被调用。<code>savedInstanceState</code> 参数是一个 <code>Bundle</code> 对象，其中包含了之前保存的活动状态信息，可以用于在活动重新创建时恢复状态。</li>
<li><code>super.onCreate(savedInstanceState)</code>：这是调用父类 <code>AppCompatActivity</code> 中的 <code>onCreate()</code> 方法，确保父类中的初始化工作得以执行。</li>
</ol>
<p>因此，这段代码定义了一个名为 <code>FirstActivity</code> 的活动类，当该活动第一次创建时，会调用父类的 <code>onCreate()</code> 方法进行初始化。</p>
<p>在声明 <code>savedInstanceState</code> 参数时，如果在类型后面添加了 <code>?</code>，则表示该参数可以接受 <code>null</code> 值。</p>
<p>这样做的目的是为了允许 <code>savedInstanceState</code> 参数在某些情况下为 null，例如当活动或片段首次创建时，<code>savedInstanceState</code> 可能为 null，因为此时还没有保存任何状态信息。</p>
<p>在 Kotlin 中，如果没有使用 <code>?</code>，则表示该参数不接受 null 值，如果在实际使用中传递了 null 值，编译器将会报错。而使用了 <code>?</code> 后，表示该参数可以接受 null 值，编译器将不会报错。</p>
<p>因此，在 <code>override fun onCreate(savedInstanceState: Bundle?)</code> 中，<code>Bundle?</code> 表示 <code>savedInstanceState</code> 参数可以接受 null 值，即在某些情况下，<code>savedInstanceState</code> 可能为 null。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span></span>
<span class="line"><span style="color: #babed8">android:orientation=&quot;vertical&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_width=&quot;match_parent&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_height=&quot;match_parent&quot;&gt;</span></span>
<span class="line"><span style="color: #babed8">&lt;Button</span></span>
<span class="line"><span style="color: #babed8">android:id=&quot;@+id/button1&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_width=&quot;match_parent&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_height=&quot;wrap_content&quot;</span></span>
<span class="line"><span style="color: #babed8">android:text=&quot;Button 1&quot;</span></span>
<span class="line"><span style="color: #babed8">/&gt;</span></span>
<span class="line"><span style="color: #babed8">&lt;/LinearLayout&gt;</span></span></code></pre></div><p>这段代码是一个简单的 Android 布局文件，使用 XML 格式描述了一个线性布局（LinearLayout）以及一个按钮（Button）的布局和属性。</p>
<p>让我解释其中的一些关键部分：</p>
<ul>
<li><code>&lt;LinearLayout&gt;</code>：这是一个布局容器，用于在垂直方向排列其子视图（例如按钮）。<code>xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</code> 是 XML 命名空间声明，它使得可以在 XML 文件中使用 Android 提供的属性和元素。</li>
<li><code>android:orientation=&quot;vertical&quot;</code>：这个属性指定了线性布局的方向，即垂直方向。这意味着其中的子视图（此处为按钮）将会按照垂直方向排列。</li>
<li><code>android:layout_width=&quot;match_parent&quot;</code> 和 <code>android:layout_height=&quot;match_parent&quot;</code>：这两个属性指定了布局的宽度和高度。<code>match_parent</code> 表示该布局将会填充其父容器的宽度或高度，以占据尽可能多的空间。</li>
<li><code>&lt;Button&gt;</code>：这是一个按钮视图，在布局中用于响应用户的点击事件。</li>
<li><code>android:id=&quot;@+id/button1&quot;</code>：这个属性为按钮指定了一个唯一的标识符，可以在 Java 代码中使用这个标识符来查找和操作这个按钮。</li>
<li><code>wrap_content</code> 属性可以使得布局更加灵活，可以根据内容的大小动态调整视图的尺寸，而不是固定为特定的尺寸。</li>
<li><code>android:text=&quot;Button 1&quot;</code>：这个属性为按钮设置了显示的文本内容为 “Button 1”。</li>
</ul>
<p>因此，这段代码描述了一个垂直排列的线性布局，其中包含一个按钮，按钮显示文本为 “Button 1”。按钮的宽度会填充父容器的宽度，而高度则根据按钮文本的大小动态调整。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">class FirstActivity : AppCompatActivity() &#123;</span></span>
<span class="line"><span style="color: #babed8">override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span>
<span class="line"><span style="color: #babed8">super.onCreate(savedInstanceState)</span></span>
<span class="line"><span style="color: #babed8">setContentView(R.layout.first_layout)</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>首先调用了 <code>super.onCreate(savedInstanceState)</code>，以确保调用了父类的 <code>onCreate()</code> 方法，以便执行必要的初始化操作。</p>
<p>接着调用了 <code>setContentView(R.layout.first_layout)</code> 方法，这个方法用于设置该活动所使用的布局文件。在这里，<code>first_layout</code> 是指定的布局资源文件的名称，这个布局文件定义了活动的界面布局结构。</p>
<p>因此，这段代码的作用是在 <code>FirstActivity</code> 中设置了一个布局文件 <code>first_layout</code> 作为活动的界面布局，并在活动创建时加载该布局。</p>
<p><code>R.layout</code> 是一个自动生成的资源标识符类，它包含了项目中所有布局文件的引用。在 Android 开发中，资源文件（如布局文件、字符串、图像等）都需要通过资源标识符来访问和引用。</p>
<p>当你在项目中创建布局文件时，每个布局文件都会被编译成一个资源标识符，以便在代码中进行引用。这些资源标识符都会被统一放置在 <code>R</code> 类的内部静态类中，而 <code>R.layout</code> 则是其中用于引用布局文件的子类之一。</p>
<p>Intent—&gt;用于通信的消息对象</p>
<p>在 Android 中，Intent 是一种用于在不同组件之间进行通信的对象。它可以用于启动活动（Activity）、启动服务（Service）、发送广播（Broadcast）以及执行其他各种操作。Intent 提供了一种在不同组件之间传递数据和执行操作的机制。</p>
<p>Intent 本质上是一个消息对象，用于指示想要执行的操作。它可以包含以下信息：</p>
<ol>
<li><strong>操作（Action）</strong>：指示要执行的操作，如启动活动、启动服务、发送广播等。常见的操作包括 <code>android.intent.action.VIEW</code>（查看操作）、<code>android.intent.action.SEND</code>（发送操作）、<code>android.intent.action.MAIN</code>（主操作）等。</li>
<li><strong>数据（Data）</strong>：用于指定操作的数据，可以是 URI、文件路径、文本等。例如，如果要查看网页，可以将网页的 URL 作为数据传递给 Intent。</li>
<li><strong>类别（Category）</strong>：用于指定操作的类别，如 <code>android.intent.category.LAUNCHER</code>（启动器类别）、<code>android.intent.category.BROWSABLE</code>（可浏览类别）等。</li>
<li><strong>附加信息（Extras）</strong>：用于传递额外的数据给目标组件。Extras 是键值对的形式，可以包含各种数据类型，如字符串、整数、布尔值等。</li>
</ol>
<p>Intent 可以分为两种类型：</p>
<ul>
<li><strong>显式 Intent</strong>：明确定义了目标组件的类名，用于启动特定的组件。</li>
<li><strong>隐式 Intent</strong>：没有明确指定目标组件，而是根据 Intent 的操作、数据等信息由系统来匹配合适的组件。</li>
</ul>
<p>通过使用 Intent，Android 应用程序可以实现各种功能，例如启动新的活动、执行后台任务、发送广播等，从而实现各种复杂的交互和功能。</p>
<p>Kotlin直接可以：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span>
<span class="line"><span style="color: #babed8">super.onCreate(savedInstanceState)</span></span>
<span class="line"><span style="color: #babed8">setContentView(R.layout.first_layout)</span></span>
<span class="line"><span style="color: #babed8">button1.setOnClickListener &#123;</span></span>
<span class="line"><span style="color: #babed8">Toast.makeText(this, &quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show()</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>在 Kotlin 中，函数声明的语法是：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">fun 函数名(参数列表): 返回值类型 &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 函数体</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>其中，返回值类型在函数名和参数列表之后，使用冒号 <code>:</code> 来标识。在这个语法中，返回值类型是必须的，但在某些情况下，如果函数没有返回值，可以将返回值类型指定为 <code>Unit</code>，或者省略返回值类型（在这种情况下，编译器会自动推断返回值类型为 <code>Unit</code>）。例如：</p>
<div class="language-kotlin"><button title="Copy code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">kotlin</span></span>
<span class="line"><span style="color: #C792EA">fun</span><span style="color: #BABED8"> </span><span style="color: #82AAFF">greet</span><span style="color: #BABED8">(name: </span><span style="color: #FFCB6B">String</span><span style="color: #BABED8">): </span><span style="color: #FFCB6B">Unit</span><span style="color: #BABED8"> &#123;</span></span>
<span class="line"><span style="color: #BABED8">    </span><span style="color: #82AAFF">println</span><span style="color: #BABED8">(</span><span style="color: #C3E88D">&quot;Hello, </span><span style="color: #BABED8">$name</span><span style="color: #C3E88D">!&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #BABED8">&#125;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #676E95; font-style: italic">// 或者省略返回值类型，编译器会自动推断为 Unit</span></span>
<span class="line"><span style="color: #C792EA">fun</span><span style="color: #BABED8"> </span><span style="color: #82AAFF">greet</span><span style="color: #BABED8">(name: </span><span style="color: #FFCB6B">String</span><span style="color: #BABED8">) &#123;</span></span>
<span class="line"><span style="color: #BABED8">    </span><span style="color: #82AAFF">println</span><span style="color: #BABED8">(</span><span style="color: #C3E88D">&quot;Hello, </span><span style="color: #BABED8">$name</span><span style="color: #C3E88D">!&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #BABED8">&#125;</span></span></code></pre></div><div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">override fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;</span></span>
<span class="line"><span style="color: #babed8">menuInflater.inflate(R.menu.main, menu)</span></span>
<span class="line"><span style="color: #babed8">return true</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p><code>menuInflater</code> 是 Android 开发中的一个类，用于从 XML 文件中创建菜单对象。在 Android 中，通常使用 XML 文件定义应用程序中的菜单，然后通过 <code>MenuInflater</code> 类将这些 XML 文件中定义的菜单加载到应用程序中的菜单对象中，以供在用户界面中显示和操作。</p>
<p>具体来说，<code>menuInflater.inflate()</code> 方法用于将一个 XML 文件中定义的菜单资源加载到一个 <code>Menu</code> 对象中，这样就可以在应用程序的用户界面中显示这个菜单。</p>
<p>在 Android 应用程序中，Activity 和 Fragment 是两种重要的组件，用于构建用户界面和处理用户交互。它们都可以包含用户界面的布局，并且可以响应用户的输入事件（如点击、滑动等）。</p>
<p>下面是关于 Activity 和 Fragment 的简要介绍：</p>
<h3 id="Activity（活动）"><a href="#Activity（活动）" class="headerlink" title="Activity（活动）"></a>Activity（活动）</h3><ol>
<li><strong>定义</strong>：Activity 是 Android 应用中的一个基本组件，代表一个单独的用户界面屏幕，通常是一个窗口、一个对话框或全屏显示的窗口。</li>
<li><strong>作用</strong>：Activity 主要负责管理用户与应用程序之间的交互，包括接收用户输入、处理用户操作，并在屏幕上显示相应的界面。</li>
<li><strong>生命周期</strong>：Activity 具有丰富的生命周期方法，如 <code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code> 等，开发者可以根据需要重写这些方法来执行相应的操作。</li>
<li><strong>布局</strong>：Activity 可以通过设置布局文件（XML 文件）来定义用户界面的外观和行为，也可以通过代码动态地创建和管理用户界面。</li>
</ol>
<h3 id="Fragment（片段）"><a href="#Fragment（片段）" class="headerlink" title="Fragment（片段）"></a>Fragment（片段）</h3><ol>
<li><strong>定义</strong>：Fragment 是 Android 应用中的另一个基本组件，代表了一个可复用的用户界面模块，可以在一个 Activity 中嵌套多个 Fragment。</li>
<li><strong>作用</strong>：Fragment 主要用于构建灵活的用户界面，允许开发者将应用程序的功能拆分成可重用的模块，并在不同的屏幕尺寸和设备方向下进行适配。</li>
<li><strong>生命周期</strong>：Fragment 也有自己的生命周期方法，与 Activity 的生命周期方法类似，包括 <code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code> 等。</li>
<li><strong>布局</strong>：Fragment 可以拥有自己的布局文件（XML 文件），也可以在宿主 Activity 中动态添加到布局中，允许开发者在运行时动态地添加、替换和移除 Fragment。</li>
</ol>
<p>总的来说，Activity 通常代表一个完整的屏幕，而 Fragment 则是 Activity 中一个可重用的组成部分，可以在一个 Activity 中组合多个 Fragment 来构建复杂的用户界面。在实际开发中，Activity 和 Fragment 经常一起使用，以实现灵活和高效的用户界面设计。</p>
<p>在 Kotlin 中，<code>?.</code> 是安全调用运算符，用于在对象为非空时调用其方法或访问其属性。如果对象为 null，则安全调用运算符会短路并返回 null，而不会抛出空指针异常。</p>
<p>在你提供的代码中，<code>data?.getStringExtra(&quot;data_return&quot;)</code> 的意思是，如果 <code>data</code> 不为 null，则调用 <code>getStringExtra(&quot;data_return&quot;)</code> 方法来获取名为 “data_return” 的额外数据，否则返回 null。这种写法可以避免在 <code>data</code> 为 null 时引发空指针异常。</p>
<p><code>registerForActivityResult(...)</code>：这是一个用于注册 Activity Result 的函数。它接受一个 <code>ActivityResultContract</code> 对象作为参数，并返回一个 <code>ActivityResultLauncher</code> 对象。<code>ActivityResultContract</code> 是一个接口，用于定义活动启动和结果处理之间的合同。</p>
<p>Activity类中定义了7个回调方法，覆盖了Activity生命周期的每一个环节:</p>
<ul>
<li><p>onCreate() 在Activity第一次被创建时调用</p>
</li>
<li><p>onStart() 由不可见到可见时调用</p>
</li>
<li><p>onResume()。这个方法在Activity准备好和用户进行交互的时候调用。此时的Activity一</p>
<p>定位于返回栈的栈顶，并且处于运行状态。</p>
</li>
<li><p>onPause()。这个方法在系统准备去启动或者恢复另一个Activity的时候调用。我们通常</p>
<p>会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执</p>
<p>行速度一定要快，不然会影响到新的栈顶Activity的使用。</p>
</li>
<li><p>onStop()。这个方法在Activity完全不可见的时候调用。它和onPause()方法的主要区</p>
<p>别在于，如果启动的新Activity是一个对话框式的Activity，那么onPause()方法会得到执行，而onStop()方法并不会执行。</p>
</li>
<li><p>onDestroy()。这个方法在Activity被销毁之前调用，之后Activity的状态将变为销毁状态。</p>
</li>
<li><p>onRestart()。这个方法在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。</p>
</li>
</ul>
<p><code>onPause()</code> 方法是 Android Activity 生命周期中的一个回调方法，用于指示当前 Activity 正在失去焦点并即将暂停其可见性。当某些事件发生时，系统会调用 <code>onPause()</code> 方法，这些事件包括：</p>
<ol>
<li>启动另一个 Activity：当用户启动另一个 Activity 并且当前 Activity 失去焦点时，系统会调用 <code>onPause()</code> 方法。例如，当用户点击应用中的按钮，打开新的 Activity 时，当前 Activity 将暂停。</li>
<li>打开对话框或弹出窗口：如果当前 Activity 打开了对话框、弹出了一个窗口或者其他部分覆盖了当前 Activity 但不完全遮挡，系统也会调用 <code>onPause()</code> 方法。</li>
<li>接收到来电或其他中断：当用户接收到来电、收到短信或者其他中断事件时，当前 Activity 也会暂停，系统会调用 <code>onPause()</code> 方法。</li>
<li>用户按下 Home 键或切换到最近任务列表：当用户按下 Home 键返回桌面或切换到最近任务列表时，当前 Activity 也会暂停，系统会调用 <code>onPause()</code> 方法。</li>
</ol>
<p>总之，<code>onPause()</code> 方法的调用情况涵盖了当前 Activity 失去焦点并即将暂停可见性的各种情况。</p>
<p><code>onStart()</code> 是 Android 活动生命周期中的一个方法，用于指示活动即将变为可见状态。当活动首次启动或从停止状态恢复到活动栈时，系统会调用 <code>onStart()</code> 方法。</p>
<p>具体情况下，<code>onStart()</code> 方法会在以下几种情况下被调用：</p>
<ol>
<li><strong>当活动首次启动</strong>：当用户启动应用程序并打开了包含该活动的界面时，系统会调用活动的 <code>onStart()</code> 方法。此时，活动将从不可见状态转变为可见状态。</li>
<li><strong>当活动从暂停状态恢复</strong>：如果一个活动从 <code>onPause()</code> 状态恢复到前台状态，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。</li>
</ol>
<p>在 <code>onStart()</code> 方法中，通常执行一些与界面相关的初始化操作，比如恢复 UI 状态、注册广播接收器或者启动一些后台任务。需要注意的是，尽管活动已经变为可见状态，但此时活动并未处于用户的焦点下，用户可能无法与其进行交互。</p>
<p><code>onResume()</code> 是 Android 活动生命周期中的一个方法，用于指示活动即将成为用户焦点并开始与用户进行交互。当活动从不可见状态变为可见状态，并且用户可以开始与其进行交互时，系统会调用 <code>onResume()</code> 方法。</p>
<p>具体情况下，<code>onResume()</code> 方法会在以下几种情况下被调用：</p>
<ol>
<li><strong>当活动首次启动</strong>：当用户首次启动应用程序并打开了包含该活动的界面时，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。此时，活动将从不可见状态转变为可见状态，并且用户可以开始与其进行交互。</li>
<li><strong>当活动从暂停状态恢复</strong>：如果一个活动从 <code>onPause()</code> 状态恢复到前台状态，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。</li>
<li><strong>当活动从停止状态恢复</strong>：如果一个活动从 <code>onStop()</code> 状态恢复到前台状态，系统会依次调用 <code>onRestart()</code>、<code>onStart()</code> 和 <code>onResume()</code> 方法。这种情况通常发生在用户按下 Home 键后再次打开应用程序的情况下。</li>
</ol>
<p>在 <code>onResume()</code> 方法中，通常执行一些与活动生命周期相关的操作，比如恢复用户的输入状态、启动动画效果或者连接到一些外部服务。需要注意的是，当活动处于 <code>onResume()</code> 状态时，它已经成为了用户焦点下的活动，并且用户可以直接与其进行交互。</p>
<p><img src="/../images/image-20240422135757284.png" alt="image-20240422135757284"></p>
<p>当将视图或布局的尺寸设置为 “wrap_content” 时，系统会根据其内容自动调整视图或布局的尺寸，以便刚好容纳其内</p>
<p>在 Android 的清单文件（AndroidManifest.xml）中声明活动（Activity）时，可以使用两种方式：</p>
<ol>
<li><code>&lt;activity&gt;...&lt;/activity&gt;</code>：这是一种传统的 XML 标签方式，用于定义活动的属性和行为。在 <code>&lt;activity&gt;</code> 标签中，可以指定活动的各种属性，例如名称、图标、主题等，并且可以包含其他标签和属性以提供更详细的配置。通常情况下，你可以在 <code>&lt;activity&gt;</code> 标签内部设置更多的属性，包括活动的名称、图标、主题等，以及与活动相关的其他设置。</li>
<li><code>&lt;activity/&gt;</code>：这是一种自闭合的 XML 标签方式，用于简单地声明一个活动而不指定任何属性或配置。这种方式适用于简单的活动声明，当你不需要指定任何属性或配置时，可以使用这种方式。例如，如果你的活动只需要基本的声明，而不需要指定任何其他属性或配置，你可以使用 <code>&lt;activity/&gt;</code> 标签。</li>
</ol>
<p>因此，你应该根据活动的具体需求和配置选择适当的方式。如果需要指定活动的各种属性和配置，可以使用 <code>&lt;activity&gt;...&lt;/activity&gt;</code> 标签；如果活动只需要基本的声明而不需要指定任何其他属性或配置，可以使用 <code>&lt;activity/&gt;</code> 标签。</p>
<p><code>@style/Theme.AppCompat.Dialog</code> 是指在 Android 应用程序中使用的一个预定义的对话框主题样式。这个样式通常用于创建对话框，即弹出式窗口，以在应用程序中显示临时信息、接受用户输入或执行其他操作。</p>
<p>这个主题样式基于 AppCompat 库提供的默认对话框主题进行定义，并且与 AppCompat 库中其他主题一样，它提供了跨不同 Android 版本的一致外观和行为。这样，你的应用程序就可以在不同版本的 Android 上保持一致的外观和用户体验。</p>
<p><code>android:exported=&quot;false&quot;</code> 是 Android 清单文件中 <code>&lt;activity&gt;</code> 元素的一个属性，用于指定该活动是否能够被其他应用程序组件或者系统组件访问。具体含义如下：</p>
<ul>
<li>如果 <code>android:exported=&quot;false&quot;</code>，则表示该活动不会被其他应用程序或系统组件调用。这意味着该活动只能被声明它的应用程序内部的组件所访问，其他应用程序或系统组件无法直接启动或与其交互。</li>
<li>如果 <code>android:exported=&quot;true&quot;</code>，则表示该活动可以被其他应用程序或系统组件调用。这意味着其他应用程序可以使用显式或隐式意图启动该活动，并且与其进行交互。</li>
</ul>
<p>在你的示例中，<code>android:exported=&quot;false&quot;</code> 意味着 <code>DialogActivity</code> 这个活动不会被其他应用程序或系统组件访问。它只能被声明它的应用程序内部的组件所访问，其他应用程序无法直接启动或与其交互。这通常用于内部使用的活动，例如只在应用程序内部使用的对话框或者配置界面。</p>
<p>在 Android 开发中，<code>Intent</code>（意图）是用于在不同组件之间传递数据或执行操作的对象。它是一种在 Android 应用程序中实现组件之间通信的重要机制。</p>
<p><code>Intent</code> 主要有两种类型：显式 Intent 和隐式 Intent。</p>
<ol>
<li><p><strong>显式 Intent</strong>：用于启动应用程序内部的组件，例如启动另一个活动（Activity）、启动服务（Service）等。显式 Intent 通过指定目标组件的类名来明确指示要执行的操作。</p>
<p>示例：</p>
</li>
</ol>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">Intent intent = new Intent(this, AnotherActivity.class);</span></span>
<span class="line"><span style="color: #babed8">startActivity(intent);</span></span></code></pre></div><p><strong>隐式 Intent</strong>：用于启动应用程序内或其他应用程序中具有特定功能的组件，而不需要指定目标组件的类名。隐式 Intent 根据指定的动作（Action）、数据（Data）等信息来寻找合适的组件执行操作。</p>
<p>示例：</p>
<ol>
<li><div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.example.com&quot;));</span></span>
<span class="line"><span style="color: #babed8">startActivity(intent);</span></span></code></pre></div></li>
</ol>
<p><code>Intent</code> 的主要作用包括但不限于：</p>
<ul>
<li>启动活动、服务或广播接收器等组件。</li>
<li>在组件之间传递数据，例如在不同活动之间传递参数。</li>
<li>执行一些系统级别的操作，例如拨打电话、发送短信、打开网页等。</li>
</ul>
<p>总之，<code>Intent</code> 是 Android 应用程序中用于实现组件之间通信和执行操作的重要机制。</p>
<p>在 Android 中，<code>Bundle</code> 是一个用来存储键值对数据的容器类。它通常被用于在不同的组件（如活动、片段）之间传递数据，或者在组件销毁和重新创建时保存和恢复数据的状态。</p>
<p>在 <code>onCreate()</code> 方法中，<code>Bundle</code> 参数 <code>savedInstanceState</code> 表示上一个实例状态的数据。当活动被销毁并重新创建时（例如，由于设备旋转或内存紧张），Android 系统会调用 <code>onSaveInstanceState()</code> 方法来保存当前的状态数据，并将其存储在 <code>Bundle</code> 中。然后，在活动重新创建时，系统会将之前保存的状态数据传递给 <code>onCreate()</code> 方法的 <code>savedInstanceState</code> 参数。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">Log.d(&quot;FirstActivity&quot;, this.toString())</span></span></code></pre></div><p><code>this.toString()</code> 是调用当前对象的 <code>toString()</code> 方法。在 Java 中，几乎所有的对象都继承自 <code>Object</code> 类，而 <code>Object</code> 类中有一个 <code>toString()</code> 方法，用于返回对象的字符串表示形式</p>
<p>当你调用 <code>this.toString()</code> 时，它会返回当前对象的字符串表示形式</p>
<p>Activity的启动模式:</p>
<ul>
<li>standard</li>
<li>singleTop  单栈顶</li>
<li>singleTask   单任务</li>
<li>singleInstance  单实例</li>
</ul>
<p>在 Kotlin 中，<code>object</code> 关键字用于定义单例对象。单例对象是指在程序运行期间只有一个实例存在的对象。在给定的作用域内，单例对象只能有一个实例，因此它们非常适合用于管理全局状态或提供全局访问点。</p>
<p>关闭所有活动并不等同于关闭应用程序的进程。在 Android 应用程序中，当你调用 <code>finish()</code> 方法结束一个活动时，这个活动会被销毁，但应用程序的进程仍然在运行。即使所有活动都被销毁，应用程序的进程仍然存在于系统中。</p>
<p>为了完全退出应用程序，有时需要调用 <code>System.exit(0)</code> 或者 <code>Process.killProcess(Process.myPid())</code> 这样的方法来结束应用程序的进程。这样做可以确保应用程序的所有组件都被终止，包括活动、服务、广播接收器等，从而实现应用程序的完全退出。</p>
<p>然而，这种做法通常被视为不推荐的，因为它可能会导致用户体验上的问题，以及系统资源的浪费。通常情况下，Android 系统会自动管理应用程序的进程，并在必要时终止它们，而不需要手动干预。因此，大多数情况下，关闭所有活动即可满足应用程序退出的需求，而无需手动杀死进程。</p>
<p>在 Kotlin 中，<code>companion object</code>（伴生对象）具有以下作用：</p>
<ol>
<li><strong>静态成员访问</strong>：伴生对象中的成员可以直接通过类名访问，就像 Java 中的静态成员一样。这使得可以在不创建类的实例的情况下访问这些成员。</li>
<li><strong>工厂方法</strong>：可以在伴生对象中定义工厂方法，用于创建类的实例。这种方法通常用于隐藏类的构造函数，提供一种更灵活的方式来创建实例。</li>
<li><strong>共享代码</strong>：伴生对象可以包含在类的所有实例之间共享的代码或常量。这些代码或常量对于类的所有实例都是相同的，可以方便地通过伴生对象访问。</li>
<li><strong>扩展方法</strong>：在伴生对象中还可以定义扩展方法，这些方法可以为类添加额外的功能，而无需继承或修改类的源代码。</li>
</ol>
<p>总的来说，伴生对象提供了一种在 Kotlin 中实现类级别功能的方式，它可以用于静态成员访问、工厂方法、共享代码和扩展方法等场景。</p>
<p>StringBuilder是Java中的一个类，用于处理字符串。它允许你在不创建新的String对象的情况下进行字符串的修改和操作，这样可以提高性能并节省内存。</p>
<p>当你需要对字符串进行频繁的修改时，使用StringBuilder通常比直接使用String更高效。这是因为String是不可变的，每次对String进行修改都会创建一个新的String对象，而StringBuilder允许你在同一个对象上执行多次修改操作。</p>
<p>你可以使用StringBuilder的append()方法来添加字符串，使用delete()方法来删除字符串，使用insert()方法来在指定位置插入字符串，使用replace()方法来替换字符串等等。最后，你可以使用toString()方法将StringBuilder对象转换为String对象，以便进行进一步的操作或输出。</p>
<p><code>val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val builder = StringBuilder() builder.append(&quot;Start eating fruits.\n&quot;) for (fruit in list) &#123; builder.append(fruit).append(&quot;\n&quot;) &#125; builder.append(&quot;Ate all fruits.&quot;) val result = builder.toString() println(result) 为什么最后要调用builder.toString()</code>，不能直接打印吗</p>
<p>在上面的代码中，builder是一个StringBuilder对象，而println函数通常接受String类型的参数来进行输出。而builder对象是一个StringBuilder类型的对象，不是String类型的对象，因此无法直接传递给println函数。</p>
<p>调用builder.toString()方法将StringBuilder对象转换为String类型的对象，这样就可以将其作为参数传递给println函数，从而实现输出。toString()方法会返回StringBuilder对象中包含的所有字符序列作为一个字符串。</p>
<p>因此，为了能够正确地输出builder对象中的内容，需要先调用toString()方法将其转换为String类型的对象，然后再传递给println函数进行打印。</p>
<p><code>with</code> 是 Kotlin 的一个标准库函数，它提供了一种简洁的方式来执行针对特定对象的一系列操作，并返回最后一个表达式的结果。</p>
<p><code>AlertDialog.Builder(this).apply &#123; setTitle(&quot;This is Dialog&quot;) setMessage(&quot;Something important.&quot;) setCancelable(false) setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; &#125; setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; &#125; show()</code> 是什么意思</p>
<p>这段代码是使用 Kotlin 的标准库函数 <code>apply</code> 来构建一个 <code>AlertDialog</code> 对话框，并设置其标题、消息、按钮等属性。下面是代码的解释：</p>
<ol>
<li><code>AlertDialog.Builder(this)</code>：创建了一个 <code>AlertDialog.Builder</code> 的实例，这个实例用于构建一个对话框。</li>
<li><code>apply &#123; ... &#125;</code>：<code>apply</code> 是一个 Kotlin 标准库函数，它接收一个 lambda 表达式作为参数，并在 lambda 表达式的作用域内执行一系列操作。在这个例子中，<code>apply</code> 函数被调用后，会将调用者对象（即 <code>AlertDialog.Builder</code> 的实例）作为参数传递给 lambda 表达式，并在 lambda 表达式内部执行一系列设置操作。</li>
<li><code>setTitle(&quot;This is Dialog&quot;)</code>：在 lambda 表达式中调用 <code>setTitle</code> 方法，设置对话框的标题为 “This is Dialog”。</li>
<li><code>setMessage(&quot;Something important.&quot;)</code>：在 lambda 表达式中调用 <code>setMessage</code> 方法，设置对话框的消息内容为 “Something important.”。</li>
<li><code>setCancelable(false)</code>：在 lambda 表达式中调用 <code>setCancelable</code> 方法，设置对话框为不可取消状态，即用户点击对话框外部或返回键时不会关闭对话框。</li>
<li><code>setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; ... &#125;</code>：在 lambda 表达式中调用 <code>setPositiveButton</code> 方法，设置对话框的确定按钮文本为 “OK”，并设置点击事件处理器。在这里，<code>&#123; dialog, which -&gt; ... &#125;</code> 是一个 lambda 表达式，表示当用户点击确定按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。</li>
<li><code>setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; ... &#125;</code>：在 lambda 表达式中调用 <code>setNegativeButton</code> 方法，设置对话框的取消按钮文本为 “Cancel”，并设置点击事件处理器。同样，<code>&#123; dialog, which -&gt; ... &#125;</code> 是一个 lambda 表达式，表示当用户点击取消按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。</li>
<li><code>show()</code>：在所有设置完成后，调用 <code>show</code> 方法显示对话框。</li>
</ol>
<p>因此，这段代码的作用是创建一个带有标题、消息、确定按钮和取消按钮的对话框，并将其显示在界面上。</p>
<p>三种基本布局：</p>
<ul>
<li>LinearLayout垂直排布</li>
<li>RelativeLayout相对布局</li>
<li>FrameLayout帧布局</li>
</ul>
<p><img src="/../images/image-20240423231325479.png" alt="image-20240423231325479"></p>
<p><code>override fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123; val view = LayoutInflater.from(context).inflate(resourceId, parent, false) val fruitImage: ImageView = view.findViewById(R.id.fruitImage) val fruitName: TextView = view.findViewById(R.id.fruitName) val fruit = getItem(position) // 获取当前项的Fruit实例 if (fruit != null) &#123; fruitImage.setImageResource(fruit.imageId) fruitName.text = fruit.name &#125; return view &#125;</code></p>
<p>其中：val view &#x3D; LayoutInflater.from(context).inflate(resourceId, parent, false)</p>
<p>作用是从 XML 布局文件中创建一个视图对象，并将其添加到指定的父视图中。</p>
<p>解释每个参数的含义：</p>
<ul>
<li><code>context</code>: 表示当前的上下文环境，通常是一个 Activity 或 Fragment 的实例。</li>
<li><code>resourceId</code>: 表示要加载的布局文件的资源 ID，即 XML 文件的唯一标识符。</li>
<li><code>parent</code>: 表示要将创建的视图添加到的父视图，通常是一个 ViewGroup，比如一个 LinearLayout 或者一个 RecyclerView。</li>
<li><code>false</code>: 表示在加载布局文件时，不将其添加到父视图中。这个参数设置为 <code>false</code> 表示我们会手动将视图添加到父视图中，而不是在加载时自动添加。</li>
</ul>
<p>接口在编程中有多种作用，包括但不限于以下几个方面：</p>
<ol>
<li><strong>定义约束和契约</strong>：接口定义了一组方法或属性的规范，实现该接口的类必须提供这些方法或属性的具体实现。这种约束和契约使得代码更加清晰，使得不同的类可以共享相同的行为规范。</li>
<li><strong>实现多态</strong>：通过接口，可以实现多态，即在不同的类中使用相同的方法名，但实际调用的是各自类的具体实现。这样可以提高代码的灵活性和可扩展性。</li>
<li><strong>代码重用</strong>：接口可以用于定义通用的行为规范，使得多个类可以共享相同的接口定义，从而实现代码的重用。当多个类具有相似的行为或功能时，可以通过接口来统一定义这些行为或功能，避免重复编写代码。</li>
<li><strong>降低耦合性</strong>：通过接口，类与类之间的耦合度可以降低，因为类之间通过接口进行交互，而不是直接依赖于具体的实现。这样，当一个类的实现发生变化时，只需要修改实现该接口的类，而不需要修改其他使用该类的代码。</li>
<li><strong>接口委托</strong>：接口支持委托，一个接口可以通过另一个对象来实现其方法，这种方式称为接口委托。这种机制可以进一步提高代码的灵活性和可复用性。</li>
</ol>
<p>总的来说，接口是一种重要的编程工具，可以帮助程序员设计出更加灵活、可扩展和易于维护的代码结构。</p>
<p>interface接口</p>
<p>sealed class密封类</p>
<p><img src="/../images/image-20240429211327595.png" alt="image-20240429211327595"></p>
<p><code>companion object</code> 是 Kotlin 中的一个关键字，它用于创建一个伴随对象。伴随对象是类中的一个单例对象，可以通过类名直接访问其中的属性和方法</p>
<p>news_content_frag.xml——–&gt;NewsContentFragment类———–&gt;NewsContentActivity</p>
<p>news_item.xml——–&gt;news_title_frag.xml———&gt;NewsTitleFragment类———-&gt;</p>
<p>layout&#x2F;activity_main.xml——-&gt;单页模式;</p>
<p>NewsTitleFragment类————&gt;</p>
<p>​														layout-sw600dp&#x2F;activity_main.xml——–&gt;双页模式;</p>
<p>NewsContentFragment类——-&gt;</p>
<p>在NewsTitleFragment类中通过RecyclerView将新闻列表展示出来</p>
<p>在 Kotlin 中，<code>open</code> 关键字用于声明一个类、方法或属性是可以被继承或覆盖的。具体来说：</p>
<ul>
<li><strong>类（Class）</strong>：在类声明前加上 <code>open</code> 关键字，表示这个类是可以被其他类继承的。如果不加 <code>open</code> 关键字，则默认情况下类是 <code>final</code> 的，不能被继承。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">kotlin</span></span>
<span class="line"><span style="color: #babed8">open class BaseActivity : AppCompatActivity() &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 可以被继承的类</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><ul>
<li><strong>方法（Method）</strong>：在方法声明前加上 <code>open</code> 关键字，表示这个方法是可以被子类覆盖（重写）的。如果不加 <code>open</code> 关键字，则默认情况下方法是 <code>final</code> 的，不能被子类覆盖。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">kotlin</span></span>
<span class="line"><span style="color: #babed8">open fun someMethod() &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 可以被子类重写的方法</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><ul>
<li><strong>属性（Property）</strong>：在属性声明前加上 <code>open</code> 关键字，表示这个属性是可以被子类覆盖的。如果不加 <code>open</code> 关键字，则默认情况下属性是 <code>final</code> 的，不能被子类覆盖。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">kotlin</span></span>
<span class="line"><span style="color: #babed8">open val someProperty: Int = 0</span></span></code></pre></div><p>使用 <code>open</code> 关键字可以让类的设计更加灵活，允许其他类继承并重写其中的方法，或者覆盖属性的行为。</p>
<p><code>val square: (Int) -&gt; Int = &#123; x: Int -&gt; x * x &#125;</code></p>
<p>square是(Int) -&gt; Int函数类型的变量，表示接受一个 <code>Int</code> 类型的参数，并返回一个 <code>Int</code> 类型的结果。</p>
<p>Lambda 表达式 <code>&#123; x: Int -&gt; x * x &#125;</code> 被赋给了这个变量</p>
<p><code>fun save(inputText: String) &#123;</code><br><code>try &#123;</code><br><code>val output = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE)</code><br><code>val writer = BufferedWriter(OutputStreamWriter(output))</code><br><code>writer.use &#123;</code><br><code>it.write(inputText)</code><br><code>&#125;</code><br><code>&#125; catch (e: IOException) &#123;</code><br><code>e.printStackTrace()</code><br><code>&#125;</code><br><code>&#125;</code></p>
<p>这段代码定义了一个名为 <code>save</code> 的函数，它接受一个 <code>inputText</code> 参数，类型为 <code>String</code>。函数的作用是将输入的文本内容保存到文件中。让我解释一下代码的逻辑：</p>
<ol>
<li><code>openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE)</code>: 这行代码打开一个名为 “data” 的文件，并返回一个 <code>FileOutputStream</code> 对象。这个文件将会存储在应用的内部存储空间中，因为使用了 <code>Context.MODE_PRIVATE</code> 参数，表示只有当前应用可以访问这个文件，并且会覆盖掉同名的文件（如果存在）。</li>
<li><code>val writer = BufferedWriter(OutputStreamWriter(output))</code>: 这行代码创建了一个 <code>BufferedWriter</code> 对象，并将其包装在一个 <code>OutputStreamWriter</code> 中，以便将文本写入到 <code>output</code> 中。</li>
<li><code>writer.use &#123; it.write(inputText) &#125;</code>: 这行代码使用 Kotlin 的 <code>use</code> 函数，确保在使用结束后正确关闭 <code>writer</code>，以释放资源。在 <code>use</code> 函数的 lambda 表达式中，调用了 <code>write</code> 方法，将 <code>inputText</code> 写入到文件中。</li>
<li><code>catch (e: IOException) &#123; e.printStackTrace() &#125;</code>: 这是一个异常处理块，如果在保存文件时发生了 <code>IOException</code> 异常，程序将会打印异常的堆栈信息。</li>
</ol>
<p>将委托功能分为了两种：类委托和委托属性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Android-Kotlin.html" data-id="clxbjvuxm000261cx1h1s1bu0" data-title="Android_Kotlin" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/post/FPGA.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          FPGA
        
      </div>
    </a>
  
  
    <a href="/post/Inference-Framework.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Inference_Framework</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/" rel="tag">C++STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PNC/" rel="tag">PNC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/esp32/" rel="tag">esp32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robot-kinematics/" rel="tag">robot_kinematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yolo/" rel="tag">yolo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%89%E8%B6%B3/" rel="tag">玉足</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-STL/" style="font-size: 10px;">C++STL</a> <a href="/tags/Embedded/" style="font-size: 10px;">Embedded</a> <a href="/tags/PNC/" style="font-size: 10px;">PNC</a> <a href="/tags/esp32/" style="font-size: 10px;">esp32</a> <a href="/tags/robot-kinematics/" style="font-size: 10px;">robot_kinematics</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/%E7%8E%89%E8%B6%B3/" style="font-size: 10px;">玉足</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">计算机图形学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html">流体力学</a>
          </li>
        
          <li>
            <a href="/post/%E5%9B%9B%E8%B6%B3.html">四足</a>
          </li>
        
          <li>
            <a href="/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6.html">图形学</a>
          </li>
        
          <li>
            <a href="/post/motion-planning.html">motion_planning</a>
          </li>
        
          <li>
            <a href="/post/Realsense.html">Realsense</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>