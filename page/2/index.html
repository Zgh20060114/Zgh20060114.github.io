<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Zgh&#39;s</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Zgh的个人站">
<meta property="og:type" content="website">
<meta property="og:title" content="Zgh&#39;s">
<meta property="og:url" content="http://zgh20060114.github.io/page/2/index.html">
<meta property="og:site_name" content="Zgh&#39;s">
<meta property="og:description" content="Zgh的个人站">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Zgh's" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zgh&#39;s</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Zgh20060114.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ROS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/ROS.html" class="article-date">
  <time class="dt-published" datetime="2024-09-20T23:57:14.000Z" itemprop="datePublished">2024-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/ROS.html">ROS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240921180747237.png" alt="image-20240921180747237"></p>
<p><img src="/../images/image-20240922084731413.png" alt="image-20240922084731413"></p>
<p><em><strong>legged_control</strong></em></p>
<p>基于OCS2和ros-controls的非线性<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MPC&spm=1001.2101.3001.7020">MPC 1</a>与WBC框架</p>
<ul>
<li><strong>docs</strong> - 包含项目文档和说明。</li>
<li><strong>legged_common</strong> - 共享的数据结构和函数库。</li>
<li><strong>legged_control</strong> - 主控制堆栈的源码，实现了NMPC和WBC的核心算法。</li>
<li><strong>legged_controllers</strong> - 控制器的具体实现，如腿部运动模式控制器。</li>
<li><strong>legged_estimation</strong> - 估计相关的组件，可能涉及状态估计或传感器数据处理。</li>
<li><strong>legged_examples</strong> - 示例代码，可能含有特定机器人的示例配置或仿真设置。</li>
<li><strong>legged_gazebo</strong> - Gazebo仿真相关文件，用于虚拟环境中测试机器人。</li>
<li><strong>legged_hw</strong> - 硬件交互层，用于实际机器人的控制。</li>
<li><strong>legged_interface</strong> - 提供与机器人交互的API。</li>
<li><strong>legged_wbc</strong> - Whole Body Control的相关代码。</li>
<li><strong>qpoases_catkin</strong> - 可能是作为依赖项的QPOASES求解器的ROS集成。</li>
</ul>
<p>Ubuntu 20.04    </p>
<p>ROS noetic </p>
<p>catkin</p>
<p><em><strong>OCS2 是一个针对切换系统优化控制的 C++ 工具箱，适用于机器人任务，包括路径约束处理和 URDF 模型支持。它提供了高效算法如 SLQ、iLQR 和 SQP，并具有 ROS 接口。工具箱包含自动微分工具，确保在有限计算能力的机器人应用中实现数值稳定和高效控制。</strong></em></p>
<p>OCS2是一个大型单库项目；请<strong>不要</strong>尝试编译整个仓库。</p>
<p>URDF文件和YAML文件通常在 ROS 启动文件中被调用。具体步骤如下：</p>
<ol>
<li><p><strong>URDF 文件</strong>：</p>
<ul>
<li>在启动文件（<code>.launch</code>）中使用 <code>&lt;param&gt;</code> 标签将 URDF 文件加载到参数服务器：<pre><code class="xml">&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro $(find your_package)/urdf/your_robot.urdf.xacro&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>YAML 文件</strong>：</p>
<ul>
<li>也可以在启动文件中使用 <code>&lt;rosparam&gt;</code> 标签加载 YAML 文件：<pre><code class="xml">&lt;rosparam file=&quot;$(find your_package)/config/your_config.yaml&quot; command=&quot;load&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>节点中访问</strong>：</p>
<ul>
<li>在你的 ROS 节点代码中，可以通过 <code>ros::param::get()</code> 或 <code>ros::NodeHandle</code> 来访问这些参数。</li>
</ul>
</li>
</ol>
<p>这样，URDF 和 YAML 文件就能在你的 ROS 项目中被有效地调用和使用。</p>
<pre><code>&lt;geometry&gt;  &lt;!--几何形状--&gt;
</code></pre>
<pre><code>&lt;inertial&gt;      &lt;!--惯性属性--&gt;
</code></pre>
<pre><code>&lt;joint name=&quot;world_to_slideBar&quot; type=&quot;fixed&quot;&gt;  &lt;!--这个关节用于将 slideBar 固定在世界坐标系中的特定位置，使得它在仿真中保持稳定，提供支撑作用。--&gt;
    &lt;parent link=&quot;world&quot;/&gt;
    &lt;child link=&quot;slideBar&quot;/&gt;
    &lt;origin xyz=&quot;0.0 0.0 2.0&quot;/&gt;
&lt;/joint&gt;
</code></pre>
<pre><code>&lt;gazebo reference=&quot;slideBar&quot;&gt;
</code></pre>
<ul>
<li><strong>Gazebo特定属性</strong>: 用于指定该链接在 Gazebo 中的特性。</li>
</ul>
<p>​     <code>&lt;mass value=&quot;0.1&quot;/&gt;</code></p>
<ul>
<li><strong>质量</strong>: 指定了链接的质量为 0.1 千克</li>
</ul>
<h4 id="位置"><a href="#位置" class="headerlink" title="&lt;origin&gt;  位置"></a><code>&lt;origin&gt;</code>  位置</h4><p><img src="/../images/image-20240924221522926.png" alt="image-20240924221522926"></p>
<p>自由度通俗的讲就是为了唯一确定一个机构的运动状态所必须的独立变量的个数</p>
<p><img src="/../images/image-20240925083033316.png" alt="image-20240925083033316"></p>
<p><img src="/../images/image-20240925085251799.png" alt="image-20240925085251799"></p>
<p>c12&#x3D;cos(seta1+seta2 )</p>
<p><img src="/../images/image-20240925085203224.png" alt="image-20240925085203224"></p>
<p><img src="/../images/image-20240925090201537.png" alt="image-20240925090201537"></p>
<p><img src="/../images/image-20240925091223929.png" alt="image-20240925091223929"></p>
<p><img src="/../images/image-20240925123003125.png" alt="image-20240925123003125"></p>
<pre><code>&lt;joint name=&quot;base_to_plat&quot; type=&quot;prismatic&quot;&gt;
    &lt;axis xyz=&quot;1 0 0&quot;/&gt;
    &lt;origin xyz=&quot;0.0 0.0 0.0&quot;/&gt;
    &lt;parent link=&quot;slideBar&quot;/&gt;
    &lt;child link=&quot;cart&quot;/&gt;
    &lt;limit effort=&quot;100000.0&quot; lower=&quot;-15&quot; upper=&quot;15&quot; velocity=&quot;100&quot;/&gt;
    &lt;dynamics damping=&quot;0.0&quot; friction=&quot;0.0&quot;/&gt;
&lt;/joint&gt;
</code></pre>
<p>是什么意思</p>
<p>这段代码定义了一个名为 <code>base_to_plat</code> 的滑动关节（prismatic joint），其主要功能是让 <code>cart</code> 在 <code>slideBar</code> 上进行线性滑动。以下是对每个部分的详细解释：</p>
<h3 id="1"><a href="#1" class="headerlink" title="1. &lt;joint name=&quot;base_to_plat&quot; type=&quot;prismatic&quot;&gt;"></a>1. <code>&lt;joint name=&quot;base_to_plat&quot; type=&quot;prismatic&quot;&gt;</code></h3><ul>
<li><strong>名称和类型</strong>:<ul>
<li><code>name=&quot;base_to_plat&quot;</code>: 该关节的名称是 <code>base_to_plat</code>。</li>
<li><code>type=&quot;prismatic&quot;</code>: 关节类型为滑动关节，允许连接的部分沿一个轴线性移动。</li>
</ul>
</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2. &lt;axis xyz=&quot;1 0 0&quot;/&gt;"></a>2. <code>&lt;axis xyz=&quot;1 0 0&quot;/&gt;</code></h3><ul>
<li><strong>运动轴</strong>:<ul>
<li><code>xyz=&quot;1 0 0&quot;</code>: 表示滑动关节的运动轴为 X 轴。<code>1</code> 表示在 X 方向上有运动，而 Y 和 Z 方向上没有运动。</li>
</ul>
</li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3. &lt;origin xyz=&quot;0.0 0.0 0.0&quot;/&gt;"></a>3. <code>&lt;origin xyz=&quot;0.0 0.0 0.0&quot;/&gt;</code></h3><ul>
<li><strong>原点位置</strong>:<ul>
<li><code>xyz=&quot;0.0 0.0 0.0&quot;</code>: 该关节的原点位置设置在 (0, 0, 0)，通常是关节的中心点。</li>
</ul>
</li>
</ul>
<h3 id="4"><a href="#4" class="headerlink" title="4. &lt;parent link=&quot;slideBar&quot;/&gt;"></a>4. <code>&lt;parent link=&quot;slideBar&quot;/&gt;</code></h3><ul>
<li><strong>父链接</strong>:<ul>
<li><code>link=&quot;slideBar&quot;</code>: 指定 <code>slideBar</code> 是该关节的父链接。也就是说，<code>cart</code> 相对于 <code>slideBar</code> 移动。</li>
</ul>
</li>
</ul>
<h3 id="5"><a href="#5" class="headerlink" title="5. &lt;child link=&quot;cart&quot;/&gt;"></a>5. <code>&lt;child link=&quot;cart&quot;/&gt;</code></h3><ul>
<li><strong>子链接</strong>:<ul>
<li><code>link=&quot;cart&quot;</code>: 指定 <code>cart</code> 是该关节的子链接。表示 <code>cart</code> 将通过该关节的运动影响到。</li>
</ul>
</li>
</ul>
<h3 id="6"><a href="#6" class="headerlink" title="6. &lt;limit effort=&quot;100000.0&quot; lower=&quot;-15&quot; upper=&quot;15&quot; velocity=&quot;100&quot;/&gt;"></a>6. <code>&lt;limit effort=&quot;100000.0&quot; lower=&quot;-15&quot; upper=&quot;15&quot; velocity=&quot;100&quot;/&gt;</code></h3><ul>
<li><strong>运动限制</strong>:<ul>
<li><code>effort=&quot;100000.0&quot;</code>: 该关节能够承受的最大力为 100,000（单位通常为牛顿）。</li>
<li><code>lower=&quot;-15&quot;</code>: 关节的最小位置限制为 -15（单位通常为米），表示 <code>cart</code> 可以向后滑动的最大距离。</li>
<li><code>upper=&quot;15&quot;</code>: 关节的最大位置限制为 15（单位通常为米），表示 <code>cart</code> 可以向前滑动的最大距离。</li>
<li><code>velocity=&quot;100&quot;</code>: 关节的最大速度为 100（单位通常为米&#x2F;秒），表示 <code>cart</code> 的移动速度限制。</li>
</ul>
</li>
</ul>
<h3 id="7"><a href="#7" class="headerlink" title="7. &lt;dynamics damping=&quot;0.0&quot; friction=&quot;0.0&quot;/&gt;"></a>7. <code>&lt;dynamics damping=&quot;0.0&quot; friction=&quot;0.0&quot;/&gt;</code></h3><ul>
<li><strong>动力学属性</strong>:<ul>
<li><code>damping=&quot;0.0&quot;</code>: 阻尼系数为 0，表示没有额外的阻力影响滑动。</li>
<li><code>friction=&quot;0.0&quot;</code>: 摩擦系数为 0，表示在滑动过程中没有摩擦力。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段代码的主要目的是定义一个滑动关节，使得 <code>cart</code> 可以在 X 轴上滑动，受到的限制和动力学特性被明确设定。这在机器人和机械模拟中是非常重要的，可以精确控制其运动行为。</p>
<pre><code>&lt;transmission name=&quot;tran2&quot;&gt;
    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
    &lt;joint name=&quot;base_to_plat&quot;&gt;
        &lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;
    &lt;/joint&gt;
    &lt;actuator name=&quot;planar_motor_2&quot;&gt;
        &lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;
        &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;
    &lt;/actuator&gt;
&lt;/transmission&gt;
</code></pre>
<p>是什么意思</p>
<p>这段代码定义了一个名为 <code>tran2</code> 的传动系统，主要用于连接一个滑动关节和一个执行器。以下是各部分的解释：</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1. &lt;transmission name=&quot;tran2&quot;&gt;"></a>1. <code>&lt;transmission name=&quot;tran2&quot;&gt;</code></h3><ul>
<li><strong>传动系统名称</strong>: 这个传动系统被命名为 <code>tran2</code>。</li>
</ul>
<h3 id="2-transmission-interface-SimpleTransmission"><a href="#2-transmission-interface-SimpleTransmission" class="headerlink" title="2. &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;"></a>2. <code>&lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;</code></h3><ul>
<li><strong>传动类型</strong>: 使用简单传动接口，表明传动的实现相对直接。</li>
</ul>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3. &lt;joint name=&quot;base_to_plat&quot;&gt;"></a>3. <code>&lt;joint name=&quot;base_to_plat&quot;&gt;</code></h3><ul>
<li><strong>关节连接</strong>: 连接到先前定义的滑动关节 <code>base_to_plat</code>。</li>
</ul>
<h3 id="4-hardware-interface-EffortJointInterface"><a href="#4-hardware-interface-EffortJointInterface" class="headerlink" title="4. &lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;"></a>4. <code>&lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;</code></h3><ul>
<li><strong>硬件接口</strong>: 该关节使用的是努力关节接口，意味着通过施加力来控制关节运动。</li>
</ul>
<h3 id="5-1"><a href="#5-1" class="headerlink" title="5. &lt;actuator name=&quot;planar_motor_2&quot;&gt;"></a>5. <code>&lt;actuator name=&quot;planar_motor_2&quot;&gt;</code></h3><ul>
<li><strong>执行器名称</strong>: 该传动系统连接的执行器名为 <code>planar_motor_2</code>。</li>
</ul>
<h3 id="6-1"><a href="#6-1" class="headerlink" title="6. &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;"></a>6. <code>&lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;</code></h3><ul>
<li><strong>机械减速比</strong>: 设置为 1，表示执行器的输出与输入之间没有减速，直接传递力。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>整体上，这段代码用于定义一个简单的传动系统，将滑动关节和电机连接起来，以便通过施加力来控制滑动运动。</p>
<h5 id="JointState-消息内容"><a href="#JointState-消息内容" class="headerlink" title="JointState 消息内容"></a><code>JointState</code> 消息内容</h5><p><code>JointState</code> 消息通常包含以下字段：</p>
<ul>
<li><strong><code>name</code></strong>: 存储关节名称的字符串数组。</li>
<li><strong><code>position</code></strong>: 存储每个关节当前角度或位置的浮点数数组。</li>
<li><strong><code>velocity</code></strong>: 存储每个关节当前速度的浮点数数组。</li>
<li><strong><code>effort</code></strong>: 存储每个关节当前力矩或用力程度的浮点数数组。</li>
</ul>
<p><img src="/../images/image-20240927144924380.png" alt="image-20240927144924380"></p>
<p>LQR（线性二次调节器，Linear Quadratic Regulator）是一种用于控制系统的优化方法。它旨在通过最小化某个代价函数来设计控制器，通常用于线性动态系统。</p>
<h3 id="LQR-的基本公式"><a href="#LQR-的基本公式" class="headerlink" title="LQR 的基本公式"></a>LQR 的基本公式</h3><p>假设有一个线性系统描述为：<br>$ \dot{x} &#x3D; Ax + Bu $<br>其中：</p>
<ul>
<li>( x ) 是状态向量</li>
<li>( u ) 是控制输入</li>
<li>( A ) 和 ( B ) 是系统矩阵</li>
</ul>
<p>LQR 通过最小化以下代价函数来设计控制器：<br>$ J &#x3D; \int_0^{\infty} (x^T Q x + u^T R u) , dt $<br>其中：</p>
<ul>
<li>( Q ) 是状态权重矩阵，通常是半正定的$(Q \geq 0 )$</li>
<li>( R ) 是控制输入权重矩阵，通常是正定的（$ R &gt; 0 $）</li>
</ul>
<h3 id="最优控制律"><a href="#最优控制律" class="headerlink" title="最优控制律"></a>最优控制律</h3><p>通过求解代价函数的最小值，可以得到最优控制律：<br>$ u &#x3D; -Kx $<br>其中 $K $是增益矩阵，通过以下公式计算：<br>$K &#x3D; R^{-1} B^T P $<br>而$  P $ 是 Riccati 方程的解：<br>$A^T P + PA - PBR^{-1}B^T P + Q &#x3D; 0 $ </p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>LQR 方法通过设计一个控制器，最小化系统状态和控制输入的加权平方和，从而实现对线性系统的有效控制。它广泛应用于工程、自动控制、机器人等领域。</p>
<h3 id="代码实现过程"><a href="#代码实现过程" class="headerlink" title="代码实现过程"></a>代码实现过程</h3><p>在你提供的代码中，LQR控制器的设计过程主要包含以下几个步骤：</p>
<ol>
<li><p><strong>逆矩阵计算</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;double, 1, 1&gt; R_inv = R_.inverse();
</code></pre>
<p>这里计算了控制输入权重矩阵 (R) 的逆。</p>
</li>
<li><p><strong>计算 BRB 项</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;double, 4, 4&gt; BRB = B_ * R_inv(0, 0) * B_.transpose();
</code></pre>
<p>这一步计算了 $BR^{-1}B^T$项，用于构建哈密尔顿矩阵。</p>
</li>
<li><p><strong>构造哈密尔顿矩阵</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;do	uble, 8, 8&gt; H;
H.topLeftCorner(4, 4) = A_;
H.topRightCorner(4, 4) = -BRB;
H.bottomLeftCorner(4, 4) = -Q_;
H.bottomRightCorner(4, 4) = -A_.transpose();
</code></pre>
<p>哈密尔顿矩阵 (H) 是 LQR 解的核心部分，它结合了系统的动态矩阵 (A)、控制输入矩阵 (B) 和权重矩阵 (Q) 和 (R)。</p>
</li>
<li><p><strong>特征值和特征向量计算</strong>：</p>
<pre><code class="cpp">Eigen::ComplexEigenSolver&lt;Eigen::Matrix&lt;double, 8, 8&gt;&gt; ces;
ces.compute(H);
</code></pre>
<p>通过计算哈密尔顿矩阵的特征值和特征向量来获取系统的稳定性信息。</p>
</li>
<li><p><strong>选择稳定特征向量</strong>：</p>
<pre><code class="cpp">for (int i = 0; i &lt; 8; ++i)
&#123;
    if (eigenvalues(i).real() &lt; 0 &amp;&amp; index &lt; 4)
    &#123;
        Vs.col(index) = eigenvectors.col(i);
        ++index;
    &#125;
&#125;
</code></pre>
<p>选择具有负实部的特征值对应的特征向量，以确保系统的稳定性。</p>
</li>
<li><p><strong>解Ricatti方程</strong>：</p>
<pre><code class="cpp">Eigen::MatrixXcd P_c = Vs2 * Vs1.inverse();
Eigen::Matrix4d P = P_c.real(); // Take the real part
</code></pre>
<p>通过特征向量计算 Riccati 方程的解 (P)，这是 LQR 控制中的关键步骤。</p>
</li>
<li><p><strong>计算 LQR 增益矩阵</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;double, 1, 4&gt; K_temp = R_inv(0, 0) * B_.transpose() * P;
return K_temp.transpose();
</code></pre>
<p>最后计算控制增益矩阵 (K)，该矩阵用于生成控制输入。</p>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>LQR 控制器的实现通过构造哈密尔顿矩阵，计算其特征值和特征向量，求解 Riccati 方程，最终得到一个最优控制增益 (K)。通过这种方式，LQR 能够有效地平衡系统的性能和控制输入，以保证系统的稳定性和响应速度。</p>
<p><code>Eigen::MatrixXd</code> 和 <code>Eigen::Matrix4d</code> 是 Eigen 库中用于表示矩阵的两种不同类型。它们的主要区别如下：</p>
<h3 id="1-尺寸"><a href="#1-尺寸" class="headerlink" title="1. 尺寸"></a>1. 尺寸</h3><ul>
<li><strong><code>Eigen::MatrixXd</code></strong>:<ul>
<li>这是一个动态大小的矩阵，表示一个任意大小的矩阵。</li>
<li>在运行时可以根据需要动态调整其行数和列数。</li>
</ul>
</li>
<li><strong><code>Eigen::Matrix4d</code></strong>:<ul>
<li>这是一个固定大小的矩阵，专门表示一个 <strong>4x4</strong> 的矩阵。</li>
<li>行数和列数在编译时就已经确定，不能被更改。</li>
</ul>
</li>
</ul>
<h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><ul>
<li><strong><code>Eigen::MatrixXd</code></strong>:<ul>
<li>由于是动态大小，内存分配通常是在堆上进行管理，可能会有额外的开销。</li>
</ul>
</li>
<li><strong><code>Eigen::Matrix4d</code></strong>:<ul>
<li>由于大小固定，内存分配是静态的，通常在栈上分配，性能更高，尤其在小矩阵操作时。</li>
</ul>
</li>
</ul>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul>
<li><strong><code>Eigen::MatrixXd</code></strong>:<ul>
<li>适合处理不确定大小的矩阵，特别是在算法中需要处理各种尺寸的情况时。</li>
</ul>
</li>
<li><strong><code>Eigen::Matrix4d</code></strong>:<ul>
<li>适合处理明确为 <strong>4x4</strong> 矩阵的场景，如图形变换、旋转矩阵等。</li>
</ul>
</li>
</ul>
<p>###ubuntu上ros与anaconda冲突的最好解决办法：</p>
<pre><code>catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3
</code></pre>
<p>下次再安装ros时，在anaconda环境里安装，要不然python混乱太搞了</p>
<p>现在有更好的方法：</p>
<pre><code class="bash">export PATH=&quot;/usr/bin:$PATH&quot;
</code></pre>
<pre><code class="bash">zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ which python
/usr/local/anaconda3/bin/python
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ which python3
/usr/local/anaconda3/bin/python3
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ sudo vim ~/.bashrc
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ source ~/.bashrc
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ which python3
/usr/bin/python3
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ which python
/usr/bin/python
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ python -V
Python 3.8.10
</code></pre>
<p>完美解決</p>
<p>[ERROR] [1728964010.917743989]: [registerPublisher] Failed to contact master at [localhost:11311].  Retrying…</p>
<p>只是roscore没开</p>
<p>在 MoveIt! 的 <code>moveit_setup_assistant</code> 中，配置规划组时的 <strong>Base Link</strong> 和 <strong>Tip Link</strong> 是指机器人模型中关节链的起始和结束部分。具体来说：</p>
<h3 id="Base-Link"><a href="#Base-Link" class="headerlink" title="Base Link"></a>Base Link</h3><ul>
<li><strong>定义</strong>: Base Link 是指关节链的起始位置，通常是机器人的“基础”或“根”部分。这通常是固定的、与机器人底座相连的链接。</li>
<li><strong>作用</strong>: 它作为整个机器人运动的参考点，所有的运动都是相对于这个基准链接进行的。在机器人操作时，Base Link 通常是地面上的固定部分，负责提供稳定性。</li>
</ul>
<h3 id="Tip-Link"><a href="#Tip-Link" class="headerlink" title="Tip Link"></a>Tip Link</h3><ul>
<li><strong>定义</strong>: Tip Link 是指关节链的结束位置，它是规划组的最后一个链接。通常，这个链接表示执行器的末端，如机械手爪、工具或传感器等。</li>
<li><strong>作用</strong>: Tip Link 是你希望 MoveIt! 进行运动规划的目标位置。通过指定 Tip Link，MoveIt! 可以计算从 Base Link 到 Tip Link 的运动轨迹。</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>以一个机械臂为例：</p>
<ul>
<li><strong>Base Link</strong>: 机械臂的底座部分，可能是与地面固定的框架。</li>
<li><strong>Tip Link</strong>: 如果机械臂的末端是一个夹具，那么这个夹具的位置就是 Tip Link。</li>
</ul>
<p>在 MoveIt! 的设置中，您提到的参数具有特定的含义和功能。以下是每个参数的解释：</p>
<h3 id="1-Group-Name-arm"><a href="#1-Group-Name-arm" class="headerlink" title="1. Group Name: arm"></a>1. Group Name: <strong>arm</strong></h3><ul>
<li><strong>定义</strong>: 这是规划组指定的名称。在这个例子中，<code>arm</code> 表示该规划组控制的是机器人的手臂。</li>
<li><strong>作用</strong>: 通过命名规划组，可以在后续的运动规划和控制中方便地引用这一组链接和关节。</li>
</ul>
<h3 id="2-Kinematic-Solver-kdl-kinematics-plugin-KDLKinematicsPlugin"><a href="#2-Kinematic-Solver-kdl-kinematics-plugin-KDLKinematicsPlugin" class="headerlink" title="2. Kinematic Solver: kdl_kinematics_plugin&#x2F;KDLKinematicsPlugin"></a>2. Kinematic Solver: <strong>kdl_kinematics_plugin&#x2F;KDLKinematicsPlugin</strong></h3><ul>
<li><strong>定义</strong>: 这是所使用的运动学求解器。<code>KDLKinematicsPlugin</code> 是基于 Kinematics and Dynamics Library (KDL) 的运动学求解插件。</li>
<li><strong>作用</strong>: 它负责计算机器人的正向运动学和逆向运动学。正向运动学用于从关节角度计算末端执行器的位置，而逆向运动学则用于根据目标位置计算所需的关节角度。</li>
</ul>
<h3 id="3-Kin-Search-Resolution-0-005"><a href="#3-Kin-Search-Resolution-0-005" class="headerlink" title="3. Kin. Search Resolution: 0.005"></a>3. Kin. Search Resolution: <strong>0.005</strong></h3><ul>
<li><strong>定义</strong>: 这个参数表示在进行运动规划时的搜索分辨率，单位是米（m）。</li>
<li><strong>作用</strong>: 它定义了在搜索空间中步进的大小。较小的值会导致更精细的搜索，这可能增加计算时间，但能提供更高精度的路径。</li>
</ul>
<h3 id="4-Kin-Search-Timeout-sec-0-05"><a href="#4-Kin-Search-Timeout-sec-0-05" class="headerlink" title="4. Kin. Search Timeout (sec): 0.05"></a>4. Kin. Search Timeout (sec): <strong>0.05</strong></h3><ul>
<li><strong>定义</strong>: 这是运动规划过程中允许的最大搜索时间，单位是秒。</li>
<li><strong>作用</strong>: 如果在 0.05 秒内未找到有效的运动规划，求解器将停止搜索。这可以帮助避免长时间的计算延迟，尤其是在实时应用中，但也可能导致未找到可行的解决方案。</li>
</ul>
<p>在配置机械臂的末端执行器（End Effector）时，需要填写一些参数</p>
<ol>
<li><strong>End Effector Name（末端执行器名称）</strong>：<ul>
<li>这是给末端执行器（例如夹爪、工具等）起的名称。</li>
</ul>
</li>
<li><strong>End Effector Group（末端执行器组）</strong>：<ul>
<li>这是将末端执行器归类到特定组中的选项。此组通常用于定义哪些关节或链接与该末端执行器相关。在您的例子中，组名是 <code>gripper</code>。</li>
</ul>
</li>
<li><strong>Parent Link（父链接）</strong>：<ul>
<li>这是末端执行器连接到的父链接。通常，这是机械臂的一部分，负责控制末端执行器的位置和姿态。在例子中，父链接为 <code>grasping_frame</code>，这可能是机械臂的一个特定链接，用于抓取物体。</li>
</ul>
</li>
<li><strong>Parent Group（父组， 可选项）</strong>：<ul>
<li>这是一个可选字段，如果希望将末端执行器与某个特定的组关联，可以在这里填写。若不需要特别设置，此项可以留空</li>
</ul>
</li>
</ol>
<p>roslaunch moveit_setup_assistant setup_assistant.launch</p>
<p>要在source .&#x2F;devel&#x2F;setup.bash的终端使用</p>
<p>学长您好，我看您的【ROS-Moveit!】机械臂控制探索学机械臂联合仿真，但是您开源的代码为啥在运行：<br>roslaunch pigot_moveit_config moveit_planning_execution.launch<br>后，rviz显示出错呀，</p>
<h2 id="woc-noetic版本的压根就不用改，新建其他功能包，直接用demo-gazebo-launch，要不然你猜为什么moveit的配置助手会生成关于gazebo的文件，为什么生成gazebo的urdf，就是让你用的，怪不得显示不了xacro模型"><a href="#woc-noetic版本的压根就不用改，新建其他功能包，直接用demo-gazebo-launch，要不然你猜为什么moveit的配置助手会生成关于gazebo的文件，为什么生成gazebo的urdf，就是让你用的，怪不得显示不了xacro模型" class="headerlink" title="woc,noetic版本的压根就不用改，新建其他功能包，直接用demo_gazebo.launch，要不然你猜为什么moveit的配置助手会生成关于gazebo的文件，为什么生成gazebo的urdf，就是让你用的，怪不得显示不了xacro模型"></a>woc,noetic版本的压根就不用改，新建其他功能包，直接用demo_gazebo.launch，要不然你猜为什么moveit的配置助手会生成关于gazebo的文件，为什么生成gazebo的urdf，就是让你用的，怪不得显示不了xacro模型</h2><p><img src="/../images/image-20241017230010555.png" alt="image-20241017230010555"></p>
<p><img src="/../images/image-20241017230248766.png" alt="image-20241017230248766"></p>
<p> <img src="/../images/image-20241017230611243.png" alt="image-20241017230611243"></p>
<img src="../images/image-20241017230728048.png" alt="image-20241017230728048" style="zoom:50%;" />



<p><img src="/../images/image-20241017231440886.png" alt="image-20241017231440886">1. <code>&lt;visual&gt;</code></p>
<p>定义机器人的可视化外观，主要包括几何形状和材质。</p>
<ul>
<li><p><strong><code>&lt;geometry&gt;</code></strong>: 指定连接的几何形状。在这个示例中，使用了一个网格文件（STL格式）来定义 <code>link_1</code> 的形状。该文件的路径是：</p>
<pre><code>Copy Codepackage://lebai_lm3_support/meshesc/lm3/visual/link1.stl
</code></pre>
</li>
<li><p><strong><code>&lt;material&gt;</code></strong>: 定义连接的材质和颜色。在此示例中，材质名为 <code>white</code>，并且设置了RGBA颜色值（红、绿、蓝、透明度）为 <code>(0.86, 0.85, 0.81, 1.0)</code>。这意味着连接的颜色为一种淡灰色，完全不透明。</p>
</li>
</ul>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2. &lt;collision&gt;"></a>2. <code>&lt;collision&gt;</code></h3><p>这一部分描述连接的碰撞模型，它与可视化模型通常是不同的。碰撞模型用于物理仿真，确保机器人在模拟环境中与其他物体进行碰撞检测。</p>
<ul>
<li><p><code>&lt;geometry&gt;</code></p>
<p>: 这里也使用了一个网格文件，但它的路径是：</p>
<pre><code>Copy Codepackage://lebai_lm3_support/meshes/lm3/collision/link1.stl
</code></pre>
<p>通常，碰撞模型会比可视化模型简单，以提高仿真性能。</p>
</li>
</ul>
<h3 id="3-2"><a href="#3-2" class="headerlink" title="3. &lt;inertial&gt;"></a>3. <code>&lt;inertial&gt;</code></h3><p>这一部分定义了连接的惯性属性，包括质量和转动惯量。惯性属性在机器人运动学和动力学计算中至关重要。</p>
<ul>
<li><strong><code>&lt;origin&gt;</code></strong>: 定义了惯性参考点的位置和方向。<code>rpy</code> 指的是绕X、Y、Z轴的滚转（roll）、俯仰（pitch）、偏航（yaw）角度，这里均为 <code>0.0</code>，表示没有旋转。<code>xyz</code> 指的是惯性参考点相对于链接坐标系的位置，这里是 <code>(0.0, -0.011, -0.015)</code>。</li>
<li><strong><code>&lt;mass&gt;</code></strong>: 定义连接的质量，这里为 <code>2.147 kg</code>。</li>
<li><strong><code>&lt;inertia&gt;</code></strong>: 定义连接的转动惯量矩阵。<code>ixx</code>、<code>iyy</code> 和 <code>izz</code> 分别表示绕X、Y、Z轴的转动惯量，而 <code>ixy</code>、<code>ixz</code> 和 <code>iyz</code> 是关于这些轴的耦合项</li>
</ul>
<p><img src="/../images/image-20241025155947665.png" alt="image-20241025155947665"></p>
<p><img src="/../images/image-20241025162239093.png" alt="image-20241025162239093"></p>
<p><img src="/../images/image-20241025162708189.png" alt="image-20241025162708189"></p>
<p><img src="/../images/image-20241026083208134.png" alt="image-20241026083208134"></p>
<p><img src="/../images/image-20241027155220611.png" alt="image-20241027155220611"></p>
<p><img src="/../images/image-20241106085645596.png" alt="image-20241106085645596"></p>
<p><img src="/../images/image-20241106093458515.png" alt="image-20241106093458515"></p>
<p>下次淘宝下单不要付款，先放弃付款，然后再付款的时候有几率跳出“付款再减XX元”，应该是后台店铺给的，香！！！</p>
<p><img src="/../images/image-20241106161656760.png" alt="image-20241106161656760"></p>
<p><img src="/../images/image-20241106162318720.png" alt="image-20241106162318720"></p>
<p><img src="/../images/image-20241106164939969.png" alt="image-20241106164939969"></p>
<p><img src="/../images/image-20241107093349782.png" alt="image-20241107093349782"></p>
<p><img src="/../images/image-20241107155026702.png" alt="image-20241107155026702"></p>
<p><img src="/../images/image-20241107162050814.png" alt="image-20241107162050814"></p>
<p><img src="/../images/image-20241108140359784.png" alt="image-20241108140359784"></p>
<p><img src="/../images/image-20241110121251925.png" alt="image-20241110121251925"></p>
<p><img src="/../images/image-20241110205130168.png" alt="image-20241110205130168"></p>
<p><img src="/../images/image-20241110210042338.png" alt="image-20241110210042338"></p>
<p><img src="/../images/image-20241111095941858.png" alt="image-20241111095941858"></p>
<p><img src="/../images/image-20241111102055992.png" alt="image-20241111102055992"></p>
<p><img src="/../images/image-20241114111359106.png" alt="image-20241114111359106"></p>
<p><img src="/../images/image-20241114155901919.png" alt="image-20241114155901919"></p>
<p>pid校正可以看成迟后超前的特例</p>
<p><img src="/../images/image-20241115070328025.png" alt="image-20241115070328025"></p>
<p><img src="/../images/image-20241115200232871.png" alt="image-20241115200232871"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/ROS.html" data-id="cm1bdrnch0001vzcxgetpe45n" data-title="ROS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ODriver" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/ODriver.html" class="article-date">
  <time class="dt-published" datetime="2024-09-06T02:16:53.000Z" itemprop="datePublished">2024-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/ODriver.html">ODriver</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>共有PWM模块、ADC电流采集、定时器编码器配置、SVPWM模块、FOC核心、PID模块、电压限幅模块，其实有了PWM与SVPWM以及一些必要的数学变换，我们就可以开环使电机转起来了，加入电角度与电流采集作为反馈后，我们就能做到电流闭环，再加入速度PID就可以做到速度闭环，其他的模块只是这些目的的辅助手段罢了</p>
<p> 一、编码器的分类</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">按工作原理的不同可分为增量型和绝对值型。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">(1) 增量型 （增量式可以理解为信号即位移的增加，需要参考量）</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8"> 增量式编码器的原理是将位移转换成周期性的电信号，再把这个电信号转变成计数脉冲，用脉冲的个数表示位移的大小。增量式编码器转轴旋转时，有相应的脉冲输出，其旋转方向的判别和脉冲数量的增减借助后部的判向电路和计数器来实现。其计数起点任意设定，可实现多圈无限累加和测量。还可以把每转发出一个脉冲的Z信号，作为参考机械零位。编码器轴转一圈会输出固定的脉冲，脉冲数由编码器光栅的线数决定。需要提高分辨率时，可利用 90 度相位差的 A、B两路信号对原脉冲数进行倍频，或者更换高分辨率编码器。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8"> 简单来说，增量型编码器总共有三种相线输出，A相、B相、Z相。其中电机每转过一定的角度，A相和B相就输出一个脉冲，且A相和B相相互延迟1/4周期，电机的正反转就是根据A相和B相的延迟关系判断的。Z相为单圈脉冲，即每转一圈输出一个脉冲，可以作为参考机械零位。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">(2) 绝对型（直接输出数字量的传感器，不需要参考量）</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">绝对编码器光码盘上有许多道光通道刻线，每道刻线依次以2线、4线、8线、16线编排，这样，在编码器的每一个位置，通过读取每道刻线的通、暗，获得一组从2的零次方到2的n-1次方的唯一的2进制编码（格雷码），这就称为n位绝对编码器。这样的编码器是由光电码盘进行记忆的。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">简单来说，就是对应一圈，电机的每个角度都有一个与该角度对应二进制的数值，且这个数值不会改变，所以称为绝对型编码器。</span></span></code></pre></div><p>二、不同编码器的优缺点及其对应应用范围</p>
<p>   增量型：</p>
<p>增量式编码器十分合适测速度，可无限累加丈量<br>是存在零点累计差错，抗干扰较差，接纳设备的停机需断电回忆<br>增量式编码器的一般应用测速，测转动方向，测移动角度、距离(相对)。</p>
<p>   绝对型：</p>
<p>发生电源故障也不丢失轴位置<br>绝对式编码器十分适合测量位置，可直接输出<br>绝对编码器一般能够以 8 到 12位输出 360 °更精确，但也更昂贵</p>
<h2 id="0、系统配置"><a href="#0、系统配置" class="headerlink" title="0、系统配置"></a>0、系统配置</h2><h2 id="1、电机有力了！（PWM模块）"><a href="#1、电机有力了！（PWM模块）" class="headerlink" title="1、电机有力了！（PWM模块）"></a>1、电机有力了！（PWM模块）</h2><p>高级定时器主要用于产生6路互补的PWM来驱动MOS管，加入死区防止电源导通，本文未使用刹车引脚。高级定时器1通道1、2、3用于产生PWM，通道4用于触发ADC电流采样，根据扇区的位置，灵活设置PWM占空比，进而选择合理的触发点，避免在噪声点采样。引脚配置与PWM极性请根据自己的硬件合理配置，如IR2101是高电平有效，而IR2103则是低端低有效，高端高有效。</p>
<p>定时器从0开始向上计数 当0-t1段,定时器计数器TIMx_CNT值小于CCRx值,输出低电平 t1-t2段,定时器计数器TIMx_CNT值大于CCRx值,输出高电平 当TIMx_CNT值达到ARR时,定时器溢出,重新向上计数…循环此过程 至此一个PWM周期完成</p>
<p>TIMx_ARR寄存器确定PWM频率，<br>TIMx_CCRx寄存器确定占空比</p>
<p><img src="/../images/image-20240907102129162.png" alt="image-20240907102129162"></p>
<p>LED等推挽输出</p>
<p><img src="/../images/image-20240909104907079.png" alt="image-20240909104907079"></p>
<p><img src="/../images/image-20240909105404369.png" alt="image-20240909105404369"></p>
<p><img src="/../images/image-20240909105448227.png" alt="image-20240909105448227"></p>
<p><img src="/../images/image-20240909105833521.png" alt="image-20240909105833521"></p>
<p><img src="/../images/image-20240910132838967.png" alt="image-20240910132838967"></p>
<p><img src="/../images/image-20240910132746715.png" alt="image-20240910132746715"></p>
<p><img src="/../images/image-20240910132952045.png" alt="image-20240910132952045"></p>
<p><img src="/../images/v2-49051363300bd5ea2f30d5391c784ece_720w.webp" alt="img"></p>
<p><img src="/../images/image-20240915213051309.png" alt="image-20240915213051309"></p>
<p><img src="/../images/image-20240915213823875.png" alt="image-20240915213823875"></p>
<p><img src="/../images/image-20240915214652354.png" alt="image-20240915214652354"></p>
<p><img src="/../images/image-20240916160612586.png" alt="image-20240916160612586"></p>
<p><img src="/../images/image-20240916161725535.png" alt="image-20240916161725535"></p>
<p>使用opencv进行颜色识别时受光照影响很大怎么办?<br>1.白平衡算法</p>
<p>2.对于图像数据受到光照度不足或者曝光引起的对比度太小的情况，在图像处理中一般是图像直方图均衡化的方法来处理。直方图均衡化是通过拉伸像素强度分布范围来增强图像对比度的一种方法。例如，更亮的图像将所有像素限制在高值。但是一个好的图像会有来自图像所有区域的像素。因此，我们需要将这个直方图扩展到两端，而这就是直方图均衡化所做的事情(用简单的话来说)。这通常会改善图像的对比度。<br><strong>全局直方图均衡化</strong>,<strong>自适应局部直方图均衡化</strong></p>
<h6 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值?"></a>自适应阈值?</h6><p>- </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/ODriver.html" data-id="cm1bdrncg0000vzcx2kspdeqb" data-title="ODriver" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Cplusplus" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Cplusplus.html" class="article-date">
  <time class="dt-published" datetime="2024-08-21T15:35:17.000Z" itemprop="datePublished">2024-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Cplusplus.html">Cplusplus</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="模版元编程与函数式"><a href="#模版元编程与函数式" class="headerlink" title="模版元编程与函数式"></a>模版元编程与函数式</h3><p><img src="/../images/image-20240808230648900.png" alt="image-20240808230648900"></p>
<p><img src="/../images/image-20240820160811024.png" alt="image-20240820160811024"></p>
<p>template <typename T></p>
<p><img src="/../images/image-20240820162244999.png" alt="image-20240820162244999"></p>
<p><img src="/../images/image-20240820162358151.png" alt="image-20240820162358151"></p>
<p><code>std::enable_if</code> 是 C++ 标准库中的一个模板工具，通常用于实现 SFINAE（Substitution Failure Is Not An Error）技术。它位于 <code>&lt;type_traits&gt;</code> 头文件中，用于在模板编程中根据条件启用或禁用模板的实例化。</p>
<ul>
<li><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>std::enable_if</code> 的基本结构如下：</p>
<pre><code class="cpp">template &lt;bool B, typename T = void&gt;
struct enable_if &#123;
  using type = T;
&#125;;

template &lt;typename T&gt;
struct enable_if&lt;false, T&gt; &#123;
  // 这个结构体是未定义的
&#125;;
</code></pre>
</li>
<li><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3></li>
<li><p><strong><code>std::enable_if</code> 主要有两个模板参数</strong>：</p>
<ul>
<li><code>B</code>：一个布尔值（通常是编译时常量表达式），用于决定 <code>type</code> 成员是否有效。</li>
<li><code>T</code>：一个默认类型（默认为 <code>void</code>），当 <code>B</code> 为真时，<code>type</code> 成员将定义为 <code>T</code>。</li>
</ul>
</li>
<li><p><strong>当 <code>B</code> 为真时</strong>，<code>std::enable_if</code> 的 <code>type</code> 成员被定义为 <code>T</code>。这意味着我们可以使用 <code>std::enable_if</code> 的 <code>type</code> 来在模板中进行条件判断。</p>
</li>
<li><p><strong>当 <code>B</code> 为假时</strong>，<code>std::enable_if</code> 的 <code>type</code> 成员没有定义。尝试使用这种情况下的 <code>type</code> 成员会导致编译错误，从而使得该模板实例化失败。这样可以用来控制模板的选择和重载。</p>
</li>
<li><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个使用 <code>std::enable_if</code> 的示例，演示如何根据类型的特性来启用或禁用函数模板：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

// 用于启用整数类型的模板函数
template&lt;typename T&gt;
typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type
printType() &#123;
  std::cout &lt;&lt; &quot;Integral type\n&quot;;
&#125;

// 用于启用非整数类型的模板函数
template&lt;typename T&gt;
typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value, void&gt;::type
printType() &#123;
  std::cout &lt;&lt; &quot;Non-integral type\n&quot;;
&#125;

int main() &#123;
  printType&lt;int&gt;();    // 输出: Integral type
  printType&lt;double&gt;(); // 输出: Non-integral type
  return 0;
&#125;
</code></pre>
<p>在这个示例中：</p>
</li>
<li><p><code>printType&lt;int&gt;()</code> 会选择第一个模板版本，因为 <code>int</code> 是整数类型。</p>
</li>
<li><p><code>printType&lt;double&gt;()</code> 会选择第二个模板版本，因为 <code>double</code> 不是整数类型。</p>
</li>
<li><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3></li>
<li><p><strong>编译时替换</strong>：<code>std::enable_if</code> 根据布尔表达式 <code>B</code> 的值来决定是否定义 <code>type</code> 成员。</p>
</li>
<li><p><strong>条件启用</strong>：在模板参数中使用 <code>std::enable_if</code> 可以有效地启用或禁用某些模板实例化。</p>
</li>
<li><p><strong>SFINAE</strong>：如果 <code>B</code> 为假，<code>type</code> 成员未定义，尝试实例化使用 <code>type</code> 的模板将导致编译错误，从而引发 SFINAE 机制。</p>
<p>通过这种方式，<code>std::enable_if</code> 可以帮助实现条件模板选择，使得模板编程更加灵活和强大。</p>
<p><img src="/../images/image-20240820163258259.png" alt="image-20240820163258259"></p>
<p>模板的参数可以作为编译器常量，可以自动优化</p>
<p><img src="/../images/image-20240820163542636.png" alt="image-20240820163542636"></p>
<p><img src="/../images/image-20240820163702315.png" alt="image-20240820163702315"></p>
<p><img src="/../images/image-20240820163833807.png" alt="image-20240820163833807"></p>
<p>N变一次，编译器就会重新实例化一遍模版函数，编译就变慢</p>
<p>模版函数必须定义在同一个文件里才能使用（必须是内联的或者在头文件里的），所以模板函数的定义和实现无法分离，因此除非特殊手段，模板函数的定义和实现必须放到头文件里。</p>
<p>模板函数太多会导致头文件非常大。</p>
<p>模板函数内联要加static</p>
<p><img src="/../images/image-20240821074758660.png" alt="image-20240821074758660">{:height 34, :width 232}</p>
<p><img src="/../images/image-20240821075058309.png" alt="image-20240821075058309"></p>
<p><img src="/../images/image-20240821080547610.png" alt="image-20240821080547610"></p>
<p><img src="/../images/image-20240821080851591.png" alt="image-20240821080851591"></p>
<p><code>if constexpr</code> 是 C++17 中引入的一种编译时条件语句。它允许在编译时根据条件选择代码路径，从而避免在运行时进行条件判断。与传统的 <code>if</code> 语句不同，<code>if constexpr</code> 在编译时会根据条件是否为 <code>true</code> 来决定是否编译相应的代码块。</p>
<p>举个例子：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

template &lt;typename T&gt;
void print_type() &#123;
  if constexpr (std::is_integral&lt;T&gt;::value) &#123;
      std::cout &lt;&lt; &quot;Integral type&quot; &lt;&lt; std::endl;
  &#125; else &#123;
      std::cout &lt;&lt; &quot;Non-integral type&quot; &lt;&lt; std::endl;
  &#125;
&#125;

int main() &#123;
  print_type&lt;int&gt;();    // 输出 &quot;Integral type&quot;
  print_type&lt;double&gt;(); // 输出 &quot;Non-integral type&quot;
&#125;
</code></pre>
<p>在这个例子中，<code>if constexpr</code> 会在编译时检查 <code>std::is_integral&lt;T&gt;::value</code> 是否为 <code>true</code>，然后编译对应的代码块。这使得 <code>print_type</code> 函数的行为在编译时就被确定下来，从而避免了在运行时的类型检查。</p>
<p><img src="/../images/image-20240821081339456.png" alt="image-20240821081339456"></p>
<p><img src="/../images/image-20240821082517892.png" alt="image-20240821082517892"></p>
<p><img src="/../images/image-20240821082721689.png" alt="image-20240821082721689"></p>
<p><img src="/../images/image-20240821090104734.png" alt="image-20240821090104734"></p>
<p><img src="/../images/image-20240821090237051.png" alt="image-20240821090237051"></p>
<p><img src="/../images/image-20240821090714458.png" alt="image-20240821090714458">但是这样要把模板实例化的，每一种	情况都声明</p>
<p>所以，尽量不要把模板分离</p>
<p><img src="/../images/image-20240821091734245.png" alt="image-20240821091734245">延迟编译：当一个函数定义在头文件里，可能用不到，可以在前面加 template  <class T = void>这个假模板，只有被调用的时候才会被编译</p>
<p><img src="/../images/image-20240821093416355.png" alt="image-20240821093416355"></p>
<p>可以把函数的信息打印出来</p>
<p><img src="/../images/image-20240821094441153.png" alt="image-20240821094441153"></p>
<p><img src="/../images/image-20240821094522021.png" alt="image-20240821094522021"></p>
<p><img src="/../images/image-20240821094700080.png" alt="image-20240821094700080"></p>
<p><img src="/../images/image-20240821095549768.png" alt="image-20240821095549768"></p>
<p>c++里的引用（int &amp;）相当于C里面的指针（int*）</p>
<p><img src="/../images/image-20240821145117646.png" alt="image-20240821145117646">引用没有空，指针可以空</p>
<p>auto &amp;  auto const &amp; 也可</p>
<p><img src="/../images/image-20240821150609535.png" alt="image-20240821150609535"></p>
<p>懒汉单例模式（Lazy Singleton）是一种设计模式，用于确保一个类只有一个实例，并提供一个全局访问点。与饿汉单例模式不同，懒汉单例模式会在需要实例时才进行初始化，因此被称为“懒汉”模式。</p>
</li>
<li><h3 id="懒汉单例模式的特点"><a href="#懒汉单例模式的特点" class="headerlink" title="懒汉单例模式的特点"></a>懒汉单例模式的特点</h3><ol>
<li><strong>延迟初始化</strong>：单例对象只有在第一次被使用时才会创建。</li>
<li><strong>线程安全问题</strong>：在多线程环境下，需要处理线程安全问题，以确保只有一个实例被创建。</li>
</ol>
</li>
<li><h3 id="懒汉单例模式的实现方式"><a href="#懒汉单例模式的实现方式" class="headerlink" title="懒汉单例模式的实现方式"></a>懒汉单例模式的实现方式</h3><p>下面是一个基本的懒汉单例模式的实现示例（不考虑线程安全）：</p>
<pre><code class="cpp">class Singleton &#123;
public:
  // 获取单例实例的静态方法
  static Singleton* getInstance() &#123;
      if (instance == nullptr) &#123;
          instance = new Singleton();
      &#125;
      return instance;
  &#125;

  // 禁止拷贝构造函数和赋值操作符
  Singleton(const Singleton&amp;) = delete;
  Singleton&amp; operator=(const Singleton&amp;) = delete;

private:
  // 私有构造函数
  Singleton() &#123;&#125;

  // 静态成员变量，用于存储唯一的实例
  static Singleton* instance;
&#125;;

// 静态成员变量的初始化
Singleton* Singleton::instance = nullptr;
</code></pre>
</li>
<li><h3 id="线程安全的实现"><a href="#线程安全的实现" class="headerlink" title="线程安全的实现"></a>线程安全的实现</h3><p>在多线程环境下，上述实现可能会导致线程安全问题，因此需要对其进行改进。可以使用互斥锁（<code>mutex</code>）来确保线程安全：</p>
<pre><code class="cpp">#include &lt;mutex&gt;

class Singleton &#123;
public:
  // 获取单例实例的静态方法
  static Singleton* getInstance() &#123;
      if (instance == nullptr) &#123;
          std::lock_guard&lt;std::mutex&gt; lock(mutex);
          if (instance == nullptr) &#123;
              instance = new Singleton();
          &#125;
      &#125;
      return instance;
  &#125;

  // 禁止拷贝构造函数和赋值操作符
  Singleton(const Singleton&amp;) = delete;
  Singleton&amp; operator=(const Singleton&amp;) = delete;

private:
  // 私有构造函数
  Singleton() &#123;&#125;

  // 静态成员变量，用于存储唯一的实例
  static Singleton* instance;
  // 互斥锁，用于保证线程安全
  static std::mutex mutex;
&#125;;

// 静态成员变量的初始化
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex;
</code></pre>
</li>
<li><h3 id="C-11-及以后的标准"><a href="#C-11-及以后的标准" class="headerlink" title="C++11 及以后的标准"></a>C++11 及以后的标准</h3><p>在C++11及以后的标准中，可以使用<code>std::call_once</code>来确保实例的唯一性，并提高线程安全性：</p>
<pre><code class="cpp">#include &lt;mutex&gt;

class Singleton &#123;
public:
  // 获取单例实例的静态方法
  static Singleton* getInstance() &#123;
      std::call_once(flag, []() &#123;
          instance.reset(new Singleton());
      &#125;);
      return instance.get();
  &#125;

  // 禁止拷贝构造函数和赋值操作符
  Singleton(const Singleton&amp;) = delete;
  Singleton&amp; operator=(const Singleton&amp;) = delete;

private:
  // 私有构造函数
  Singleton() &#123;&#125;

  // 静态成员变量，用于存储唯一的实例
  static std::unique_ptr&lt;Singleton&gt; instance;
  // 静态变量，用于确保单例实例只创建一次
  static std::once_flag flag;
&#125;;

// 静态成员变量的初始化
std::unique_ptr&lt;Singleton&gt; Singleton::instance;
std::once_flag Singleton::flag;
</code></pre>
<p>在这个实现中，<code>std::call_once</code> 和 <code>std::once_flag</code> 确保了即使在多线程环境中，单例对象也只会被创建一次。<code>std::unique_ptr</code> 自动管理内存，避免了手动释放内存的麻烦。</p>
<p>使用互斥锁（mutex）来确保线程安全时为什么只有锁：std::lock_guard<a href="std::mutex">std::mutex</a> lock(mutex); 没有解锁?</p>
<p>在使用 <code>std::lock_guard&lt;std::mutex&gt;</code> 时，解锁是由 <code>std::lock_guard</code> 自动处理的，而不需要显式地调用解锁操作。这是因为 <code>std::lock_guard</code> 是一个RAII（Resource Acquisition Is Initialization）风格的类，它的设计目的是简化互斥锁的管理并自动释放资源。</p>
</li>
<li><h3 id="RAII-和-std-lock-guard"><a href="#RAII-和-std-lock-guard" class="headerlink" title="RAII 和 std::lock_guard"></a>RAII 和 <code>std::lock_guard</code></h3><p>RAII 是一种编程习惯，确保资源（如内存、文件句柄、互斥锁等）的生命周期由对象的生命周期来管理。<code>std::lock_guard</code> 利用 RAII 原则来管理互斥锁的锁定和解锁：</p>
<ol>
<li><strong>构造函数</strong>：当 <code>std::lock_guard</code> 对象被创建时，它会在构造函数中自动锁定传递给它的 <code>std::mutex</code> 对象。</li>
<li><strong>析构函数</strong>：当 <code>std::lock_guard</code> 对象被销毁（即其作用域结束时），它的析构函数会自动释放（解锁）互斥锁。</li>
</ol>
<p>这种设计使得你不需要显式地编写解锁代码，降低了因为遗漏解锁操作而导致的潜在错误。</p>
</li>
<li><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3></li>
<li><p><code>std::lock_guard&lt;std::mutex&gt; lock(mutex);</code></p>
<p>：</p>
<ul>
<li>当执行到这行代码时，<code>lock</code> 对象会在构造函数中自动锁定 <code>mutex</code>。</li>
<li>当 <code>lock</code> 对象超出作用域（例如，<code>getInstance</code> 方法的执行结束时），<code>lock</code> 的析构函数会被调用，从而自动解锁 <code>mutex</code>。</li>
</ul>
</li>
<li><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li>
<li><p><strong>自动解锁</strong>：减少了因为忘记解锁导致的死锁问题。</p>
</li>
<li><p><strong>简化代码</strong>：不需要显式地管理锁的释放，使代码更加简洁和易于维护。</p>
</li>
<li><p><strong>异常安全</strong>：即使在 <code>getInstance</code> 方法中发生异常，<code>std::lock_guard</code> 也会确保互斥锁在 <code>lock</code> 对象被销毁时正确解锁，从而避免死锁。</p>
<p>通过 <code>std::lock_guard</code> 或其他类似的 RAII 风格的工具，C++ 提供了一种简洁而安全的方式来管理互斥锁，帮助程序员编写更健壮的多线程代码。</p>
<p><img src="/../images/image-20240821154750452.png" alt="image-20240821154750452"></p>
<p><img src="/../images/image-20240821155047037.png" alt="image-20240821155047037"></p>
</li>
</ul>
<p><img src="/../images/image-20240822093944038.png" alt="image-20240822093944038"></p>
<p>decltype(auto)和auto的区别</p>
<p><code>decltype(auto)</code> 和 <code>auto</code> 都用于类型推导，但它们有不同的行为：</p>
<ol>
<li><p><strong><code>auto</code></strong>:</p>
<ul>
<li>用于自动推导变量的类型。<code>auto</code> 根据表达式的值推导类型，不会保留表达式的引用性（即 <code>auto</code> 不会推导出引用类型，除非显式指定）。</li>
<li>例如，<code>auto x = 5;</code> 中，<code>x</code> 的类型是 <code>int</code>。</li>
</ul>
</li>
<li><p><strong><code>decltype(auto)</code></strong>:</p>
<ul>
<li>结合 <code>decltype</code> 和 <code>auto</code> 的特性。它推导出表达式的类型，包括引用（<code>decltype</code> 会保留表达式的原始类型）。</li>
<li>例如，<code>decltype(auto) y = (5);</code> 中，<code>y</code> 的类型是 <code>int&amp;</code>，因为 <code>(5)</code> 是一个左值引用。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>:</p>
<ul>
<li>使用 <code>auto</code> 时，结果类型是值类型。</li>
<li>使用 <code>decltype(auto)</code> 时，结果类型保持原表达式的类型，包括引用。</li>
</ul>
<p><img src="/../images/image-20240822094955233.png" alt="image-20240822094955233"></p>
<p><img src="/../images/image-20240822095110135.png" alt="image-20240822095110135"></p>
<p><img src="/../images/image-20240822095353349.png" alt="image-20240822095353349">T1{}创建一个T1的对象</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p><img src="/../images/image-20240822100310129.png" alt="image-20240822100310129"></p>
<p>函数作为参数传入另一个函数，实际传的是这个函数的起始地址</p>
<p><img src="/../images/image-20240822100649562.png" alt="image-20240822100649562"></p>
<p>确实相当于函数指针</p>
<p><img src="/../images/image-20240822100903926.png" alt="image-20240822100903926"></p>
<p><img src="/../images/image-20240822102642020.png" alt="image-20240822102642020"></p>
<p><img src="/../images/image-20240822102841702.png" alt="image-20240822102841702"></p>
<p><img src="/../images/image-20240822103024352.png" alt="image-20240822103024352"></p>
<p><img src="/../images/image-20240822103222797.png" alt="image-20240822103222797"></p>
<p><img src="/../images/image-20240822103620126.png" alt="image-20240822103620126"></p>
<p><img src="/../images/image-20240822103849124.png" alt="image-20240822103849124"></p>
<p><img src="/../images/image-20240822104300564.png" alt="image-20240822104300564"></p>
<p><img src="/../images/image-20240822142510370.png" alt="image-20240822142510370"></p>
<p><img src="/../images/image-20240822142730386.png" alt="image-20240822142730386"></p>
<p>###避免使用模板参数</p>
<p><img src="/../images/image-20240822143331265.png" alt="image-20240822143331265"></p>
<p>类型擦除技术：std::function容器</p>
<p><img src="/../images/image-20240822143825237.png" alt="image-20240822143825237"></p>
<p><img src="/../images/image-20240822145011740.png" alt="image-20240822145011740">但是没办法做部分特例化</p>
<p><img src="/../images/image-20240822145901194.png" alt="image-20240822145901194"></p>
<p><strong>立即调用 Lambda</strong>：在 lambda 表达式的定义后面加上 <code>()</code>，立即调用这个匿名函数。 lambda 表达式的返回值可以用于初始化变量或进行其他操作。</p>
<p><img src="/../images/image-20240822150515258.png" alt="image-20240822150515258"></p>
<p>可以利用return自带的break效果既实现break又赋值的效果</p>
<p><img src="/../images/image-20240822151844264.png" alt="image-20240822151844264"></p>
<p><img src="/../images/image-20240822152541777.png" alt="image-20240822152541777"></p>
<p><img src="/../images/image-20240822152759758.png" alt="image-20240822152759758"></p>
<p><img src="/../images/image-20240822153156878.png" alt="image-20240822153156878"></p>
<p><img src="/../images/image-20240822161836536.png" alt="image-20240822161836536"></p>
<p><img src="/../images/image-20240822162204007.png" alt="image-20240822162204007"></p>
<p>左值持久，右值短暂，左值有持久的状态，而右值要么是字面常量，要么是在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC&spm=1001.2101.3001.7020">表达式求值</a>过程中创建的临时对象(将要被销毁的对象)。</p>
<p>右值引用的好处是减少右值作为参数传递时的复制开销</p>
<p>使用std::move可以获得绑定到一个左值的右值引用</p>
<pre><code class="cpp">int intValue = 10;
int &amp;&amp;intValue3 = std::move(intValue);
</code></pre>
<p><code>decltype(auto)</code> 是 C++11 引入的一种类型推断工具，它结合了 <code>decltype</code> 和 <code>auto</code> 的特性，用于在声明变量时推断其类型。与 <code>auto</code> 不同，<code>decltype(auto)</code> 更精确地推断变量的类型，包括引用性。</p>
<ul>
<li><p><strong>用法</strong>：<code>decltype(auto)</code> 在声明变量时，会推断出表达式的确切类型，包括是否是引用类型。</p>
<pre><code class="cpp">int x = 10;
int&amp; ref = x;
decltype(auto) y = ref; // y 是 int&amp;，与 ref 类型相同
</code></pre>
</li>
<li><p><strong>区别</strong>：<code>auto</code> 只推断值类型，而 <code>decltype(auto)</code> 会保持原有的引用类型或常量性。</p>
<pre><code class="cpp">auto a = x;          // a 是 int
decltype(auto) b = x; // b 是 int，b 不是引用
decltype(auto) c = ref; // c 是 int&amp;，与 ref 类型相同
</code></pre>
</li>
</ul>
<p><strong>总结</strong>：<code>decltype(auto)</code> 在需要精确类型推断，包括引用时非常有用。</p>
<p>但是tuple容器的万能推导由于历史原因，不是decltype(auto),而是auto &amp;&amp;</p>
<p><img src="/../images/image-20240825111507625.png" alt="image-20240825111507625"></p>
<p><img src="/../images/image-20240825111624413.png" alt="image-20240825111624413"></p>
<p>结构化绑定的基本语法如下：</p>
<p>auto [var1, var2, var3] &#x3D; expression;</p>
<p><img src="/../images/image-20240825112136528.png" alt="image-20240825112136528"></p>
<p><img src="/../images/image-20240825154641671.png" alt="image-20240825154641671"></p>
<p><img src="/../images/image-20240825155359129.png" alt="image-20240825155359129"></p>
<p><img src="/../images/image-20240825155541735.png" alt="image-20240825155541735"></p>
<p><img src="/../images/image-20240826130922114.png" alt="image-20240826130922114">optional就像一个更安全的指针</p>
<p>在 C++ 中，<code>union</code> 是一种数据结构，它允许在同一内存位置存储不同的数据类型。<code>union</code> 的所有成员共享同一块内存区域，这意味着在任何给定时刻，<code>union</code> 只能存储一个成员的数据。使用 <code>union</code> 可以节省内存，特别是在需要存储多种不同类型但从不同时存储这些类型时。</p>
<h3 id="union-的基本语法"><a href="#union-的基本语法" class="headerlink" title="union 的基本语法"></a><code>union</code> 的基本语法</h3><pre><code class="cpp">union UnionName &#123;
    type1 member1;
    type2 member2;
    type3 member3;
    // more members
&#125;;
</code></pre>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><p><strong>内存共享</strong>：</p>
<ul>
<li><code>union</code> 中的所有成员共享同一块内存。因此，<code>union</code> 的大小由其最大成员的大小决定。</li>
</ul>
</li>
<li><p><strong>只能存储一个成员</strong>：</p>
<ul>
<li>虽然 <code>union</code> 可以定义多个成员，但在任何时刻只能存储一个成员的数据。写入一个成员会覆盖掉之前写入的成员的数据。</li>
</ul>
</li>
<li><p><strong>节省内存</strong>：</p>
<ul>
<li>因为所有成员共用一块内存，所以 <code>union</code> 可以节省内存，尤其是在只需要存储其中一个成员的数据时。</li>
</ul>
</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code class="cpp">#include &lt;iostream&gt;

union Data &#123;
    int intValue;
    float floatValue;
    char charValue;
&#125;;

int main() &#123;
    Data data;

    data.intValue = 5;
    std::cout &lt;&lt; &quot;intValue: &quot; &lt;&lt; data.intValue &lt;&lt; std::endl;

    data.floatValue = 3.14;
    std::cout &lt;&lt; &quot;floatValue: &quot; &lt;&lt; data.floatValue &lt;&lt; std::endl;

    data.charValue = &#39;A&#39;;
    std::cout &lt;&lt; &quot;charValue: &quot; &lt;&lt; data.charValue &lt;&lt; std::endl;

    // 访问数据会输出不确定的结果，因为各个成员共享同一内存
    std::cout &lt;&lt; &quot;intValue (after modifying to charValue): &quot; &lt;&lt; data.intValue &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p>在上面的示例中，<code>union</code> <code>Data</code> 可以存储 <code>int</code>, <code>float</code>, 和 <code>char</code> 三种数据类型，但它们共享同一块内存。当写入 <code>floatValue</code> 后，之前存储的 <code>intValue</code> 的数据会被覆盖，读取 <code>intValue</code> 会得到不可预测的结果。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p><strong>类型安全</strong>：</p>
<ul>
<li>使用 <code>union</code> 时要注意类型安全。读取当前未写入的成员数据可能会导致未定义的行为。</li>
</ul>
</li>
<li><p><strong>构造和析构</strong>：</p>
<ul>
<li><code>union</code> 允许只有一个成员的构造和析构。C++11 之后，<code>union</code> 可以包含具有非平凡构造函数、析构函数或拷贝&#x2F;移动操作符的成员，但这些操作必须在使用 <code>union</code> 的情况下正确处理。</li>
</ul>
</li>
<li><p><strong><code>std::variant</code> 替代</strong>：</p>
<ul>
<li>C++17 引入了 <code>std::variant</code>，这是一个更安全的替代 <code>union</code>，提供了类型安全的联合体和更丰富的功能。</li>
</ul>
</li>
</ul>
<p>总的来说，<code>union</code> 是一个低级数据结构，用于内存优化和处理不同类型的数据，但在实际编程中需谨慎使用。</p>
<p><img src="/../images/image-20240826131405785.png" alt="image-20240826131405785"></p>
<p><img src="/../images/image-20240826133023527.png" alt="image-20240826133023527"></p>
<p><img src="/../images/image-20240826133352602.png" alt="image-20240826133352602"></p>
<p><img src="/../images/image-20240826134549406.png" alt="image-20240826134549406"></p>
<p><img src="/../images/image-20240826135522792.png" alt="image-20240826135522792"></p>
<ul>
<li>使用 <code>auto</code> 作为参数类型实际上利用了 C++ 的模板机制，因为 <code>auto</code> 类型推断相当于模板类型参数的自动推导。虽然 lambda 本身不是一个模板，但它的参数使用 <code>auto</code> 实际上是利用了模板的类型推断机制。</li>
<li><code>[&amp;] (auto const &amp;t)&#123;&#125;</code> 使用了模板特性中的类型推断机制，通过 <code>auto</code> 使得 lambda 表达式能够处理多种不同类型的参数。这个功能在 C++11 及其后续版本中成为了更灵活、强大的工具，使得代码更加简洁和通用。</li>
</ul>
<p><img src="/../images/image-20240826140520404.png" alt="image-20240826140520404"></p>
<p><img src="/../images/image-20240826140928719.png" alt="image-20240826140928719"></p>
<h1 id="从汇编角度看编译器优化"><a href="#从汇编角度看编译器优化" class="headerlink" title="从汇编角度看编译器优化"></a>从汇编角度看编译器优化</h1><p>编译器是从源代码生成汇编语言</p>
<p><img src="/../images/image-20240826142543763.png" alt="image-20240826142543763"></p>
<p>RIP是当前执行的代码的地址</p>
<p>MMX，XMM，YMM都是用于储存浮点数的寄存器</p>
<p>把局部变量放入寄存器，读写就更快了</p>
<p>rsp代表堆栈：      -4（%rsp）其中-代表是堆栈上的某一个地址</p>
<p><img src="/../images/image-20240826143356174.png" alt="image-20240826143356174"></p>
<p><img src="/../images/image-20240826145632245.png" alt="image-20240826145632245"></p>
<p><img src="/../images/image-20240826145948278.png" alt="image-20240826145948278"></p>
<p>eax与rax的低32位是共用的</p>
<p>ax与eax的低16位是通用的</p>
<p><img src="/../images/image-20240826162116558.png" alt="image-20240826162116558"></p>
<p><img src="/../images/image-20240826162507877.png" alt="image-20240826162507877">%eax ：返回值</p>
<p><img src="/../images/image-20240826163129510.png" alt="image-20240826163129510"></p>
<p><img src="/../images/image-20240826163353133.png" alt="image-20240826163353133"></p>
<p><img src="/../images/image-20240826163854896.png" alt="image-20240826163854896"></p>
<p>l代表32位，q代表64位</p>
<p><img src="/../images/image-20240826164111288.png" alt="image-20240826164111288"></p>
<p><img src="/../images/image-20240826165156571.png" alt="image-20240826165156571"></p>
<p><img src="/../images/image-20240826165630808.png" alt="image-20240826165630808"></p>
<p>在 C++ 中，<code>ThreadPool threadPool &#123;&#125;;</code> 和 <code>ThreadPool threadPool ;</code> 是两种不同的初始化方式，它们对 <code>ThreadPool</code> 对象的初始化有所不同。</p>
<h3 id="1-ThreadPool-threadPool"><a href="#1-ThreadPool-threadPool" class="headerlink" title="1. ThreadPool threadPool {};"></a>1. <code>ThreadPool threadPool &#123;&#125;;</code></h3><p>这是 <strong>直接初始化（Direct Initialization）</strong> 的一种方式，使用了 <strong>统一初始化语法</strong>（Uniform Initialization Syntax）。具体来说，这种写法会调用 <code>ThreadPool</code> 的默认构造函数，并且初始化所有成员变量为默认值：</p>
<ul>
<li><strong>如果 <code>ThreadPool</code> 有默认构造函数</strong>，它将被调用来创建对象。</li>
<li><strong>如果 <code>ThreadPool</code> 的构造函数</strong>没有显式初始化某些成员变量，它们会被自动初始化为其类型的默认值。对于基本数据类型（如 <code>int</code>），这意味着它们会被初始化为 <code>0</code>。对于指针类型，它们会被初始化为 <code>nullptr</code>。</li>
</ul>
<h3 id="2-ThreadPool-threadPool"><a href="#2-ThreadPool-threadPool" class="headerlink" title="2. ThreadPool threadPool ;"></a>2. <code>ThreadPool threadPool ;</code></h3><p>这是 <strong>默认初始化（Default Initialization）</strong> 的一种方式。在这种情况下，<code>ThreadPool</code> 对象的初始化行为依赖于以下几种情况：</p>
<ul>
<li><strong>如果 <code>ThreadPool</code> 有默认构造函数</strong>，它将被调用来创建对象。</li>
<li><strong>如果 <code>ThreadPool</code> 的构造函数没有显式初始化某些成员变量</strong>，那么这些成员变量的初始化方式依赖于它们的类型和是否有默认构造函数。基本数据类型（如 <code>int</code>）不会被初始化到任何特定值（它们会是未定义的），指针类型也不会自动初始化（它们的值是不确定的）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>ThreadPool threadPool &#123;&#125;;</code>**：使用统一初始化语法，所有成员变量被初始化为其类型的默认值，较为安全。</li>
<li><strong><code>ThreadPool threadPool ;</code><strong>：默认初始化，成员变量的初始值依赖于其类型和构造函数，</strong>可能会导致未定义行为（对于基本数据类型）</strong>。</li>
</ul>
<p>在实践中，推荐使用 <code>ThreadPool threadPool &#123;&#125;;</code> 以确保对象的成员变量被正确地初始化，避免潜在的未定义行为。</p>
<p>在对象构造时，<code>std::lock_guard</code> 会自动锁定传入的互斥锁，而在对象析构时，它会自动释放锁</p>
<p><strong><code>std::lock_guard&lt;std::mutex&gt; guard(lock);</code></strong></p>
<p>当执行 <code>std::lock_guard&lt;std::mutex&gt; guard(lock);</code> 时：</p>
<ul>
<li><strong>锁定</strong>: <code>guard</code> 对象在创建时会自动调用 <code>lock()</code> 方法来锁定传入的互斥锁（<code>lock</code>）。</li>
<li><strong>作用域结束</strong>: 当 <code>guard</code> 对象的作用域结束（例如，离开当前的代码块或函数）时，它的析构函数会自动调用 <code>unlock()</code> 方法来解锁互斥锁</li>
</ul>
<p>要理解 <code>subset</code> 中的这行数据，我们可以将其拆解成几部分来分析：</p>
<pre><code class="plaintext">[[ 0.          1.          2.          3.          4.          5.
   6.          7.          8.         -1.         -1.          9.
  -1.         -1.         10.         11.         12.         -1.
  21.50975911 13.        ]]
</code></pre>
<h3 id="1-关键点索引"><a href="#1-关键点索引" class="headerlink" title="1. 关键点索引"></a>1. 关键点索引</h3><ul>
<li>前 18 个值 <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, -1, -1, 9, -1, -1, 10, 11, 12, -1]</code> 代表了关键点的索引。<ul>
<li>正整数表示该位置有一个有效的关键点索引。</li>
<li><code>-1</code> 表示该位置没有对应的关键点。</li>
</ul>
</li>
</ul>
<h3 id="2-总评分"><a href="#2-总评分" class="headerlink" title="2. 总评分"></a>2. 总评分</h3><ul>
<li><code>21.50975911</code> 是这个组合的总评分。这个评分是所有有效关键点的评分之和或某种加权评分的结果。</li>
</ul>
<h3 id="3-关键点数量"><a href="#3-关键点数量" class="headerlink" title="3. 关键点数量"></a>3. 关键点数量</h3><ul>
<li><code>13</code> 是这个组合中的有效关键点数量。这里 <code>13</code> 表示在该组合中共有 13 个有效的关键点索引。</li>
</ul>
<h3 id="结合信息"><a href="#结合信息" class="headerlink" title="结合信息"></a>结合信息</h3><p>这个 <code>subset</code> 行数据表示一个关键点组合，其中包含 13 个有效的关键点，所有这些关键点的索引被列出。组合的总评分为 <code>21.50975911</code>。通过这些信息，你可以了解该组合的结构以及它在某种评分机制下的表现。</p>
<h4 id="详细解读："><a href="#详细解读：" class="headerlink" title="详细解读："></a>详细解读：</h4><ul>
<li>有效关键点索引为 <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</code>，总共 13 个。</li>
<li>索引为 <code>-1</code> 的位置表示这些位置没有有效的关键点。</li>
<li>总评分 <code>21.50975911</code> 可能是根据这些有效关键点的某些特性（如评分、置信度等）计算出来的。</li>
</ul>
<p>这样的 <code>subset</code> 数据通常用于在处理关键点检测任务中，选择或评估最佳的关键点组合。</p>
<p>这个是candidate： [[2.19000000e+02 1.18000000e+02 9.45192695e-01 0.00000000e+00] [1.96000000e+02 2.63000000e+02 9.28416848e-01 1.00000000e+00] [8.70000000e+01 2.89000000e+02 8.54923248e-01 2.00000000e+00] [6.60000000e+01 4.49000000e+02 8.24636817e-01 3.00000000e+00] [1.20000000e+02 5.07000000e+02 7.98071980e-01 4.00000000e+00] [3.07000000e+02 2.38000000e+02 8.55016530e-01 5.00000000e+00] [3.64000000e+02 3.76000000e+02 7.69826353e-01 6.00000000e+00] [2.81000000e+02 4.45000000e+02 8.87847126e-01 7.00000000e+00] [1.68000000e+02 5.42000000e+02 4.70188409e-01 8.00000000e+00] [2.98000000e+02 5.27000000e+02 4.78751719e-01 9.00000000e+00] [1.94000000e+02 1.03000000e+02 9.33498561e-01 1.00000000e+01] [2.30000000e+02 1.02000000e+02 9.27351594e-01 1.10000000e+01] [1.35000000e+02 1.22000000e+02 8.83832693e-01 1.20000000e+01]] 这个是subset: [[ 0.          1.          2.          3.          4.          5.   6.          7.          8.         -1.         -1.          9.  -1.         -1.         10.         11.         12.         -1.  21.50975911 13.        ]]</p>
<p>“Stack underflow”和“stack overflow”都是与栈（stack）数据结构相关的错误，但它们的含义和发生的情况不同：</p>
<h3 id="Stack-Overflow（栈溢出）"><a href="#Stack-Overflow（栈溢出）" class="headerlink" title="Stack Overflow（栈溢出）"></a>Stack Overflow（栈溢出）</h3><ul>
<li><strong>定义</strong>：栈溢出发生在栈的大小超过其最大容量时。通常是由于过深的递归调用或在栈上分配了过多的局部变量导致的。</li>
<li><strong>后果</strong>：栈溢出通常会导致程序崩溃或异常终止，因为系统无法继续在栈上分配内存。</li>
</ul>
<h3 id="Stack-Underflow（栈下溢出）"><a href="#Stack-Underflow（栈下溢出）" class="headerlink" title="Stack Underflow（栈下溢出）"></a>Stack Underflow（栈下溢出）</h3><ul>
<li><strong>定义</strong>：栈下溢出发生在试图从空栈中弹出元素时。例如，尝试执行“pop”操作但栈为空。</li>
<li><strong>后果</strong>：栈下溢出可能导致访问未定义的内存，程序可能会抛出异常或返回错误。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>溢出（overflow）</strong>：栈容量超出限制。</li>
<li><strong>下溢（underflow）</strong>：试图从空栈中移除元素。</li>
</ul>
<p><code>NULL</code> 是一个预处理宏，通常被定义为 <code>0</code> 或 <code>((void*)0)</code>。它在类型上是一个整数，因此可能导致类型不安全的情况。</p>
<ul>
<li><p><code>nullptr</code> 是 C++11 引入的一个关键字，表示空指针。它是一个特定的类型 <code>std::nullptr_t</code>，能更好地支持类型安全。</p>
</li>
<li><p><strong>OpenGL 上下文</strong>：OpenGL 上下文是一个包含了所有 OpenGL 状态的信息的环境。每个窗口通常会有一个自己的上下文。</p>
</li>
</ul>
<p>gcc -E main.cpp | tail -n 15 是什么意思</p>
<p><code>gcc -E main.cpp | tail -n 15</code> 是一个命令行指令，具体含义如下：</p>
<ul>
<li><code>gcc</code>：GNU 编译器集合，用于编译 C 和 C++ 程序。</li>
<li><code>-E</code>：该选项告诉 <code>gcc</code> 只进行预处理，即处理源代码中的宏和包含文件，但不进行编译。</li>
<li><code>main.cpp</code>：要处理的源文件。</li>
<li><code>|</code>：管道符，用于将前一个命令的输出传递给后一个命令。</li>
<li><code>tail -n 15</code>：该命令输出前一个命令的最后 15 行。</li>
</ul>
<p>因此，整个命令的作用是预处理 <code>main.cpp</code> 文件，并显示预处理后的结果的最后 15 行。这通常用于调试宏和包含的头文件。</p>
<p>constexpr</p>
<p>编译时常量</p>
<p><em>在编译时计算</em></p>
<p>结合 <code>if constexpr</code> 根据条件选择性编译代码</p>
<p><code>__attribute__((inline))</code> 是 GCC 和 Clang 编译器中的一个扩展，用于建议编译器将某个函数内联。内联函数的目的是减少函数调用的开销，通过将函数代码直接插入到调用处来提高性能。</p>
<ol>
<li><strong>性能优化</strong>：可以减少函数调用的开销，尤其是在小型函数中。</li>
<li><strong>不强制</strong>：即使使用了 <code>inline</code> 属性，编译器仍然可以选择不内联，具体取决于优化策略和函数的复杂性。</li>
<li><strong>适用场景</strong>：通常用于小的、频繁调用的函数。</li>
</ol>
<p>把std::string opengl_errno_name(int err)改成static const char *opengl_errno_name(int err)的好处</p>
<p>将 <code>std::string opengl_errno_name(int err)</code> 改为 <code>static const char *opengl_errno_name(int err)</code> 的好处包括：</p>
<ol>
<li><strong>性能提升</strong>：使用 <code>const char*</code> 可以减少内存分配和拷贝操作，提高性能，尤其在频繁调用的情况下。</li>
<li><strong>内存管理</strong>：<code>const char*</code> 不需要动态分配内存，避免了内存泄漏的风险，使用起来更加安全。</li>
<li><strong>简单性</strong>：直接返回字符串字面量或静态数组，使代码更简洁，减少不必要的复杂性。</li>
<li><strong>更好地适应 C 风格 API</strong>：在与 C 语言库交互时，使用 <code>const char*</code> 更加兼容。</li>
</ol>
<p><code>#include &lt;GL/gl.h&gt;</code> 和 <code>#include &lt;GL/glu.h&gt;</code> 是 OpenGL 的头文件，它们用于图形编程。具体来说：</p>
<ol>
<li>**<code>&lt;GL/gl.h&gt;</code>**：<ul>
<li>包含了 OpenGL 的核心函数和常量，提供了绘制图形所需的基本接口，比如渲染点、线、三角形等几何图形，以及设置视图、光照、纹理等功能。</li>
</ul>
</li>
<li>**<code>&lt;GL/glu.h&gt;</code>**：<ul>
<li>提供了一些辅助功能和工具，简化了 OpenGL 的使用。例如，它包含了用于生成和操作网格、处理矩阵变换、创建透视和正交投影等的函数。</li>
</ul>
</li>
</ol>
<p><code>#include &lt;GLFW/glfw3.h&gt;</code> 是用于包含 GLFW 库的头文件，GLFW 是一个开源的跨平台库，主要用于创建窗口、处理用户输入以及管理 OpenGL 上下文。具体功能包括：</p>
<ol>
<li><strong>创建和管理窗口</strong>：可以创建多种类型的窗口，并设置其属性。</li>
<li><strong>处理输入</strong>：支持键盘、鼠标和游戏手柄输入，方便处理用户交互。</li>
<li><strong>上下文管理</strong>：简化 OpenGL 上下文的创建和管理，使得在窗口中进行图形渲染更为高效。、</li>
</ol>
<p><code>#include &lt;glm/glm.hpp&gt;</code> 和 <code>#include &lt;glm/ext.hpp&gt;</code> 是用于包含 GLM（OpenGL Mathematics）库的头文件。具体功能如下：</p>
<ol>
<li>**<code>&lt;glm/glm.hpp&gt;</code>**：<ul>
<li>提供基础数学类型和操作，例如向量、矩阵、四元数等，支持高效的数学运算，适用于图形编程和物理计算。</li>
</ul>
</li>
<li>**<code>&lt;glm/ext.hpp&gt;</code>**：<ul>
<li>包含一些扩展功能，比如矩阵变换、投影、视图等常用数学函数，方便进行更复杂的数学运算。</li>
</ul>
</li>
</ol>
<p>GLM 常用于 OpenGL 应用程序中，以简化数学计算和数据管理。</p>
<p>❥ 基本<br>jk &#x2F; kj &#x2F; <Esc> 回到普通模式<br>q &#x2F; :wq &#x2F; ZZ 保存并退出<br>Q 记录宏<br>gl &#x2F; $ 移动到行末尾<br>gh &#x2F; ^ 移动到行开头（不包括空格）<br>3gl &#x2F; $2l 移动到行末尾倒数第 3 个字符<br>3gh &#x2F; ^2h 移动到行开头倒数第 3 个字符<br>❥ 跳转<br>gd 跳转到定义<br>gD 跳转到声明<br>gy 跳转到变量类型的定义<br>gY 跳转到虚函数实现<br>go 头文件和源文件来回跳转<br>gr 寻找符号引用<br>gz 罗列所有相关信息（定义、引用等）<br>gf 打开光标下的文件名<br>gF 打开光标下的文件名并跳到右侧指定的行号<br>gx 打开光标下的网页链接<br><C-o> 跳转回来<br>❥ 重构<br>gcc 注释&#x2F;取消注释当前选中的代码&#x2F;行<br>gn 重命名变量<br>gw 尝试自动修复问题<br>g&#x3D; 自动格式化当前代码<br>❥ 预览<br>K 悬浮窗查看文档<br>gsf 预览函数定义<br>gsc 预览类定义<br>gsd 预览语法错误<br>❥ 开关<br>gso 打开大纲<br>gsg 打开 Git 面板<br>gsp 打开项目文件树<br>gss 查看所有静态语法错误<br>gsl 查看所有编译器报错<br>gsi 开关 Inlay Hint<br><F8> 或 <C-t> 打开&#x2F;关闭终端<br>❥ 标签页<br><F4> 一键保存所有打开的文件<br><F3> 切换到下一个标签页<br><F2> 切换到上一个标签页<br><F1> 将当前标签页固定在最前<br><S-F3> 将当前标签页右移一位<br><S-F2> 将当前标签页左移一位<br><S-F1> 关闭当前标签页<br><C-S-F3> 关闭右侧所有标签页<br><C-S-F2>关闭左侧所有标签页<br><C-S-F1> 关闭除当前标签页外所有<br>g<Space> 选择跳转到一个标签页<br>❥ 文本查找<br>,, 当前文件中模糊查找<br>,k 当前项目中正则表达式查找<br>,l 当前项目中的所有文件<br>,b 当前 Vim 已打开文件<br>,o 最近打开过的历史文件<br>,i 当前所有加入 Git 仓库的文件<br>,p 当前 Git 有未提交修改的文件<br>,c 所有 Git 提交历史<br>,v 所有 Git 分支<br>❥ 选择<br>vac 选中当前类<br>vic 选中当前类体内<br>vaf 选中当前函数<br>vif 选中当前函数体<br>vab 选中当前块<br>vib 选中当前块中内容<br>vai 选中当前函数调用语句<br>vii 选中当前函数调用语句的参数列表<br>vap 选中当前参数（包括逗号）<br>vip 选中当前参数（不包括逗号）<br>vin 选中当前数字<br>vat 选中当前注释块</p>
<ul>
<li>扩大选择</li>
</ul>
<ul>
<li>缩小选择<br>举一反三：dat 删除当前注释块，cip 修改当前参数<br>❥ 移动<br>]c 下一个类开头<br>[c 上一个类开头<br>]C 下一个类结尾<br>[C 上一个类结尾<br>]f 下一个函数开头<br>[f 上一个函数开头<br>]F 下一个函数结尾<br>[F 上一个函数结尾<br>…以此类推，所有英文字母同上“选择”所述…<br><Space> 全屏任意移动<br>❥ 换位<br>mh 左移参数<br>ml 右移参数<br>mj 下移当前语句<br>mk 上移当前语句<br>maf 下移当前函数<br>mif 上移当前函数<br>mac 下移当前类<br>mic 上移当前类<br>❥ 括号<br>可视模式中：<br>s) 给当前选中内容包上 () 括号<br>s} 给当前选中内容包上 {} 括号<br>s] 给当前选中内容包上 [] 括号<br>s&gt; 给当前选中内容包上 &lt;&gt; 尖括号<br>s’ 给当前选中内容包上 ‘’ 单引号<br>s” 给当前选中内容包上 “” 双引号<br>stspan 给当前选中内容包上<span>标签<br>sta href&#x3D;”b.html” 给当前选中内容包上<a href="b.html">标签<br>普通（NORMAL）模式中：<br>ysi<range><brace> 添加括号<br>cs<oldbrace><newbrace> 改变括号<br>ds<brace> 删除括号<br>❥ CMake<br>cmc 或 :CMakeGenerate 配置当前项目<br>cmb 或 :CMakeBuild 构建当前项目<br>cmr 或 :CMakeRun 运行当前项目<br>cms 或 :CMakeStopRunner 杀死当前终端中的正在运行的程序<br>❥ 文件树<br>y 拷贝<br>x 剪切<br>d 删除<br>p 粘贴<br>a 创建</li>
</ul>
<p>ALT+shift+左右箭头   跳转</p>
<pre><code class="yaml">pendulum:
    joint_state_controller:
        publish_rate: 100
        type: joint_state_controller/JointStateController
    x_controller:
        joint: base_to_plat
        type: effort_controllers/JointEffortController
</code></pre>
<p>其中joint_state_controller和x_controller是什么意思 这个文件的作用是什么</p>
<h3 id="1-joint-state-controller"><a href="#1-joint-state-controller" class="headerlink" title="1. joint_state_controller"></a>1. <strong>joint_state_controller</strong></h3><ul>
<li><strong>用途</strong>：这个控制器用于发布机器人的关节状态（例如位置、速度和加速度）到 ROS 主题。它通常是机器人系统中的基础控制器，负责获取各个关节的状态信息并将其传递给其他组件。</li>
<li><strong>类型</strong>：<code>joint_state_controller/JointStateController</code> 是一个标准的控制器类型，用于处理关节状态的更新。</li>
<li><code>joint_state_controller</code> 是用于发布所有关节状态信息的控制器。它会收集机器人的所有关节（如位置、速度和加速度）的状态，并将这些信息发布到 ROS 主题上，通常是 <code>/joint_states</code> 主题。</li>
<li><strong>publish_rate</strong>：表示发布关节状态的频率，这里设置为 100 Hz。</li>
</ul>
<h3 id="2-x-controller"><a href="#2-x-controller" class="headerlink" title="2. x_controller"></a>2. <strong>x_controller</strong></h3><ul>
<li><strong>用途</strong>：这个控制器用于控制名为 <code>base_to_plat</code> 的关节的努力（力或扭矩）。通常用于执行某种运动控制任务，比如驱动一个关节以实现预期的动态行为。</li>
<li><strong>类型</strong>：<code>effort_controllers/JointEffortController</code> 是一个控制器类型，专注于控制关节施加的力或扭矩。</li>
</ul>
<h3 id="文件的作用"><a href="#文件的作用" class="headerlink" title="文件的作用"></a>文件的作用</h3><p>这个文件主要是用于配置 ROS 控制器管理器，定义机器人各个关节的控制方式及其参数。通过这个配置，您可以在启动时自动加载和初始化这些控制器，使得机器人能够实时进行关节状态的监测和控制。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>joint_state_controller</code></strong> 负责关节状态的信息发布。</li>
<li><strong><code>x_controller</code></strong> 则用于具体关节的力量控制。</li>
<li>整个 YAML 文件用于配置和管理这些控制器，使机器人能够有效地执行控制任务。</li>
</ul>
<p>##并发</p>
<p><img src="/../images/image-20240928131042017.png" alt="image-20240928131042017"></p>
<p>###0.时间 time</p>
<p><img src="/../images/image-20241005183555504.png" alt="image-20241005183555504"></p>
<p>###1.线程  thread</p>
<p><img src="/../images/image-20241005183759412.png" alt="image-20241005183759412"></p>
<p>join汇合加入，把子线程加到主线程里，这样主线程只有在子线程结束后才会退出</p>
<p><img src="/../images/image-20241005185354229.png" alt="image-20241005185354229"></p>
<p>当想要对线程进行封装时，会发现线程会随着封装函数执行过去而被销毁（因为thread的析构函数）：</p>
<p><img src="/../images/image-20241005190729501.png" alt="image-20241005190729501"></p>
<p>使用detach（）,还是不行（因为没用join，主线程不会等子线程）：</p>
<p><img src="/../images/image-20241005190842874.png" alt="image-20241005190842874"></p>
<p>全局变量，生命周期会大于封装函数，join，等待子线程：<br><img src="/../images/image-20241005191516568.png" alt="image-20241005191516568"></p>
<p>利用析构函数简化：<br><img src="/../images/image-20241005191923023.png" alt="image-20241005191923023"></p>
<p>再简化，标准函数帮你把析构函数写了：</p>
<p><img src="/../images/image-20241005183933864.png" alt="image-20241005183933864"></p>
<h3 id="2-异步async"><a href="#2-异步async" class="headerlink" title="2.异步async"></a>2.异步async</h3><p>异步相当于thread的帮手函数,专注于任务本身而不是底层的线程管理,不用那么底层了，使用简单了，但是能力也就下降了。</p>
<p><code>std::async</code> 和 <code>std::thread</code> 都是 C++11 引入的用于处理并发和多线程编程的工具，但它们在设计目的、使用方式和抽象级别上存在一些关键的关系与区别。以下是它们之间的详细比较：</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li><strong>都属于 C++ 标准库</strong>：两者都是 C++11 提供的并发支持的一部分，旨在简化多线程编程。</li>
<li><strong>功能互补</strong>：尽管各自的设计有不同侧重点，但它们可以一起使用。例如，可以在 <code>std::async</code> 中使用 <code>std::thread</code>，或者在创建线程时使用 <code>std::async</code> 来管理结果。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>std::thread</code></th>
<th><code>std::async</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>抽象级别</strong></td>
<td>更低级别的线程管理</td>
<td>更高层次的异步任务管理</td>
</tr>
<tr>
<td><strong>线程控制</strong></td>
<td>开发者需要手动管理线程的生命周期（启动、加入、分离）</td>
<td>自动管理线程的生命周期，返回 <code>std::future</code></td>
</tr>
<tr>
<td><strong>执行策略</strong></td>
<td>一般立即启动新线程</td>
<td>可选择立即执行或延迟执行（<code>std::launch::async</code> 或 <code>std::launch::deferred</code>）</td>
</tr>
<tr>
<td><strong>结果处理</strong></td>
<td>返回值需要通过共享数据或其他同步机制来获取</td>
<td>通过 <code>std::future</code> 对象直接获取结果</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>异常不会传播到主线程，需要手动管理</td>
<td>异常会被捕获并在调用 <code>future.get()</code> 时重新抛出</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>需要细致控制线程行为的场景，如实时系统、服务器等</td>
<td>简单的异步任务、并行计算、提高程序响应性</td>
</tr>
</tbody></table>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="使用-std-thread-的示例："><a href="#使用-std-thread-的示例：" class="headerlink" title="使用 std::thread 的示例："></a>使用 <code>std::thread</code> 的示例：</h4><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

void task() &#123;
    std::cout &lt;&lt; &quot;Task is running in a separate thread.\n&quot;;
&#125;

int main() &#123;
    std::thread t(task);
    t.join();  // 等待线程完成
    return 0;
&#125;
</code></pre>
<h4 id="使用-std-async-的示例："><a href="#使用-std-async-的示例：" class="headerlink" title="使用 std::async 的示例："></a>使用 <code>std::async</code> 的示例：</h4><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;future&gt;

int task() &#123;
    return 42;  // 返回结果
&#125;

int main() &#123;
    std::future&lt;int&gt; result = std::async(task);
    std::cout &lt;&lt; &quot;Result from async task: &quot; &lt;&lt; result.get() &lt;&lt; &#39;\n&#39;;  // 获取结果
    return 0;
&#125;
</code></pre>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**选择使用 <code>std::thread</code>**：当你需要更细粒度的线程控制，或者需要实现复杂的线程交互时。</li>
<li>**选择使用 <code>std::async</code>**：当你希望简化异步任务的管理，并专注于任务本身而不是底层的线程管理时。</li>
</ul>
<p>根据具体的需求和场景，开发者可以灵活选择这两者中的一种或结合使用。</p>
<p><img src="/../images/image-20241005185145651.png" alt="image-20241005185145651"></p>
<p><img src="/../images/image-20241005202136786.png" alt="image-20241005202136786"></p>
<p><img src="/../images/image-20241005202235380.png" alt="image-20241005202235380"></p>
<p>std::async相当于在后台开一个线程偷偷执行,如果不想用线程的话，可以用假线程：</p>
<p><img src="/../images/image-20241005203007249.png" alt="image-20241005203007249"></p>
<p>std::async的底层实现：（应该用不到吧）</p>
<p><img src="/../images/image-20241005204852974.png" alt="image-20241005204852974"></p>
<h3 id="3-互斥量"><a href="#3-互斥量" class="headerlink" title="3.互斥量"></a>3.互斥量</h3><p><img src="/../images/image-20241005211544279.png" alt="image-20241005211544279"></p>
<p>std::lock_guard grd(mtx); <em>&#x2F;&#x2F; 创建 lock_guard 对象 grd，锁定 mtx</em></p>
<p>这个有个弊端：不能提前unlock，可以用std::unique_lock:</p>
<p><img src="/../images/image-20241005213525208.png" alt="image-20241005213525208"></p>
<p>如果你即想使用unique_lock的自动解锁，又想手动lock：</p>
<p><img src="/../images/image-20241006100018130.png" alt="image-20241006100018130"></p>
<p>这个是已经上锁了，又想使用自动解锁：<br><img src="/../images/image-20241006100334056.png" alt="image-20241006100334056"></p>
<h3 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h3><p>问题一：</p>
<p><img src="/../images/image-20241005182028304.png" alt="image-20241005182028304"></p>
<p>不要同时锁两个</p>
<p><img src="/../images/image-20241005182958030.png" alt="image-20241005182958030"></p>
<p>保证线程里上锁的顺序一样</p>
<p><img src="/../images/image-20241005183050653.png" alt="image-20241005183050653"></p>
<p>使用标准库里的std::lock</p>
<p><img src="/../images/image-20241005183311794.png" alt="image-20241005183311794"></p>
<p>同样，为了避免忘记解锁，有了一个RALL版本的std::lock<br><img src="/../images/image-20241006100806745.png" alt="image-20241006100806745"></p>
<p>问题二：</p>
<p><img src="/../images/image-20241006101009888.png" alt="image-20241006101009888"></p>
<p>std::recursive_mutex</p>
<p><img src="/../images/image-20241006101432670.png" alt="image-20241006101432670"></p>
<h3 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5.数据结构"></a>5.数据结构</h3><p><img src="/../images/image-20241006101750387.png" alt="image-20241006101750387"></p>
<p>封装一下：</p>
<p><img src="/../images/image-20241006102058522.png" alt="image-20241006102058522"></p>
<p>因为mutex::lock()不是const的 ,那么使用mutable修饰一下：</p>
<p><img src="/../images/image-20241006102636082.png" alt="image-20241006102636082"></p>
<p>####读写锁：</p>
<p><img src="/../images/image-20241006102823718.png" alt="image-20241006102823718"></p>
<p>std::shared_mutex<br><img src="/../images/image-20241006103549484.png" alt="image-20241006103549484"></p>
<p>lock()的RAII是std::unique_lock</p>
<p>lock_shared()的RAII是std::shared_lock</p>
<p><img src="/../images/image-20241006104139107.png" alt="image-20241006104139107"></p>
<p><img src="/../images/image-20241006105913707.png" alt="image-20241006105913707"></p>
<h3 id="6-条件变量"><a href="#6-条件变量" class="headerlink" title="6.条件变量"></a>6.条件变量</h3><p><img src="/../images/image-20241006110451776.png" alt="image-20241006110451776"></p>
<p><img src="/../images/image-20241006110619094.png" alt="image-20241006110619094"></p>
<p><img src="/../images/image-20241006111315559.png" alt="image-20241006111315559"></p>
<p><img src="/../images/image-20241006115747920.png" alt="image-20241006115747920"></p>
<p><img src="/../images/image-20241006120359417.png" alt="image-20241006120359417"></p>
<p><img src="/../images/image-20241006120454654.png" alt="image-20241006120454654"></p>
<p>###7.原子操作（硬件层面）</p>
<p>前面的都是操作系统层面的</p>
<p>硬件解释：</p>
<p><img src="/../images/image-20241006123756588.png" alt="image-20241006123756588"></p>
<p><img src="/../images/image-20241006123820764.png" alt="image-20241006123820764"></p>
<p><img src="/../images/image-20241006124016522.png" alt="image-20241006124016522"></p>
<p>原子变量：</p>
<p><img src="/../images/image-20241006125728044.png" alt="image-20241006125728044"></p>
<p><img src="/../images/image-20241006125817277.png" alt="image-20241006125817277"> </p>
<p><img src="/../images/image-20241006130153788.png" alt="image-20241006130153788"></p>
<p><img src="/../images/image-20241006144356518.png" alt="image-20241006144356518"></p>
<p><img src="/../images/image-20241006144621864.png" alt="image-20241006144621864"></p>
<p><img src="/../images/image-20241006145302292.png" alt="image-20241006145302292"></p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>###——TBB开启的并行编程之旅（Intel TBB并行编程框架）</p>
<p>###0.从并发到并行</p>
<p><img src="/../images/image-20241006150631389.png" alt="image-20241006150631389"></p>
<p><img src="/../images/image-20241006150757093.png" alt="image-20241006150757093"></p>
<p><img src="/../images/image-20241006151002766.png" alt="image-20241006151002766"></p>
<p> 不需要手动创建线程池：</p>
<p><img src="/../images/image-20241006180452099.png" alt="image-20241006180452099"></p>
<p>  std::thread是操作系统意义上的线程，TBB的一个任务不一定代表一个线程，把任务分配到线程上去， TBB可视为一个高效调度器</p>
<p>ubuntu20.04蓝牙耳机连上了，但是声音还是输出在内置扬声器上，使用 <code>pactl load-module module-bluetooth-discover</code> 时遇到“模块初始化失败”的错误.</p>
<ol>
<li><p><strong>检查 Bluetooth 服务</strong>：<br>确保 Bluetooth 服务正在运行。可以使用以下命令启动服务：</p>
<pre><code class="bash">sudo systemctl start bluetooth
</code></pre>
</li>
<li><p><strong>安装必要的包</strong>：<br>确保已安装 PulseAudio 和 Bluetooth 支持。运行以下命令安装相关组件：</p>
<pre><code class="bash">sudo apt install pulseaudio pulseaudio-module-bluetooth pavucontrol
</code></pre>
</li>
<li><p><strong>重启 PulseAudio</strong>：<br>有时重启 PulseAudio 可以解决问题。可以使用以下命令：</p>
<pre><code class="bash">pulseaudio -k
pulseaudio --start
</code></pre>
</li>
</ol>
<p>当然可以。根据你提供的代码，系统的状态空间方程可以表示为以下形式：<br>状态方程：<br>$$[<br>\begin{align*}<br>\dot{x}_1 &amp;&#x3D; x_2 \<br>\dot{x}_2 &amp;&#x3D; \frac{-b \cdot (I + m \cdot l^2)}{P} \cdot x_2 + \frac{m \cdot m \cdot g \cdot l^2}{P} \cdot x_3 \<br>\dot{x}_3 &amp;&#x3D; x_4 \<br>\dot{x}_4 &amp;&#x3D; \frac{-b \cdot m \cdot l}{P} \cdot x_2 + \frac{m \cdot g \cdot l \cdot (M + m)}{P} \cdot x_3 + \frac{1}{P} \cdot u<br>\end{align*}<br>]$$<br>其中，( x_1 ) 和 ( x_2 ) 可能表示倒立摆的位移和速度，而 ( x_3 ) 和 ( x_4 ) 可能表示摆角和角速度。控制输入 ( u ) 是作用在倒立摆上的力。<br>输入方程：<br>$$[<br>u &#x3D; 0 \cdot x_1 + \frac{(I + m \cdot l^2)}{P} \cdot x_2 + 0 \cdot x_3 + \frac{m \cdot l}{P} \cdot x_4<br>]$$<br>但实际上，控制输入 ( u ) 是由控制器决定的，所以输入方程应该表示控制律，而不是状态变量直接映射到控制输入。<br>根据你的代码，状态空间方程的矩阵形式是：<br>$$[<br>\begin{align*}<br>\dot{\mathbf{x}} &amp;&#x3D; \mathbf{A} \mathbf{x} + \mathbf{B} u \<br>y &amp;&#x3D; \mathbf{C} \mathbf{x} + \mathbf{D} u<br>\end{align*}<br>]$$<br>其中，(\mathbf{x}) 是状态向量，(u) 是控制输入，(y) 是系统输出。在你的代码中，并没有明确给出输出矩阵 (\mathbf{C}) 和直接馈通矩阵 (\mathbf{D})，所以我们假设它们是：<br>$$[<br>\mathbf{C} &#x3D; \begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 0 &amp; 0<br>\end{bmatrix}, \quad<br>\mathbf{D} &#x3D; \begin{bmatrix}<br>0 \<br>0<br>\end{bmatrix}<br>]$$<br>这意味着系统的输出是状态向量 (\mathbf{x}) 的前两个元素。<br>因此，状态空间方程的矩阵形式为：<br>$[<br>\mathbf{A} &#x3D; \begin{bmatrix}<br>0 &amp; 1 &amp; 0 &amp; 0 \<br>0 &amp; -\frac{b \cdot (I + m \cdot l^2)}{P} &amp; \frac{m \cdot m \cdot g \cdot l^2}{P} &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>0 &amp; -\frac{b \cdot m \cdot l}{P} &amp; \frac{m \cdot g \cdot l \cdot (M + m)}{P} &amp; 0<br>\end{bmatrix}<br>]$<br>$$[<br>\mathbf{B} &#x3D; \begin{bmatrix}<br>0 \<br>\frac{(I + m \cdot l^2)}{P} \<br>0 \<br>\frac{m \cdot l}{P}<br>\end{bmatrix}<br>]$$<br>请注意，这里的 $(\mathbf{A})$ 和 $(\mathbf{B})$ 矩阵与你代码中定义的矩阵相匹配，但是根据你的系统定义，你可能需要调整 $(\mathbf{C})$ 和 $(\mathbf{D}) $矩阵以反映实际的系统输出。</p>
<p><img src="/../images/image-20241006163519590.png" alt="image-20241006163519590"></p>
<p> <img src="/../images/image-20241006171703693.png" alt="image-20241006171703693"></p>
<p><img src="/../images/image-20241006171811928.png" alt="image-20241006171811928"></p>
<p><img src="/../images/image-20241006181422178.png" alt="image-20241006181422178"></p>
<p><img src="/../images/image-20241006181816664.png" alt="image-20241006181816664"></p>
<h3 id="1-并行循环"><a href="#1-并行循环" class="headerlink" title="1.并行循环"></a>1.并行循环</h3><p>并行的for循环  <img src="/../images/image-20241006194116633.png" alt="image-20241006194116633"></p>
<p><img src="/../images/image-20241006195247291.png" alt="image-20241006195247291"></p>
<p>简单，但是有代价，无法被编译器优化了<img src="/../images/image-20241006195533798.png" alt="image-20241006195533798"></p>
<p>这个是不需要索引的时候可以用</p>
<p><img src="/../images/image-20241006195955333.png" alt="image-20241006195955333"></p>
<p>二维</p>
<p><img src="/../images/image-20241006200235271.png" alt="image-20241006200235271"></p>
<p>三维</p>
<h3 id="2-缩并与扫描"><a href="#2-缩并与扫描" class="headerlink" title="2,缩并与扫描"></a>2,缩并与扫描</h3><p>并行缩并</p>
<p><img src="/../images/image-20241006201321218.png" alt="image-20241006201321218"></p>
<p> <img src="/../images/image-20241006201514955.png" alt="image-20241006201514955"></p>
<p> <img src="/../images/image-20241006202300112.png" alt="image-20241006202300112"></p>
<p>但是，任务是动态分配到线程上，也就是range会变化，精度就会变，为了性能结果会有不同。所以：</p>
<p><img src="/../images/image-20241006202538659.png" alt="image-20241006202538659"></p>
<p>并行缩并的好处，相比于普通的串行缩并：</p>
<p><img src="/../images/image-20241006205437392.png" alt="image-20241006205437392"></p>
<p>串行相加，很大的e指数加上一个很小的float数，误差很大（浮点数不能大加小(等于没加)）</p>
<h3 id="3-并行扫描"><a href="#3-并行扫描" class="headerlink" title="3.并行扫描"></a>3.并行扫描</h3><p><img src="/../images/image-20241006210256789.png" alt="image-20241006210256789"></p>
<p>通常用于生成直方图</p>
<p><img src="/../images/image-20241006211843354.png" alt="image-20241006211843354"></p>
<p><img src="/../images/image-20241006212155394.png" alt="image-20241006212155394"></p>
<p><img src="/../images/image-20241006212546708.png" alt="image-20241006212546708"></p>
<p><img src="/../images/image-20241006214913619.png" alt="image-20241006214913619"></p>
<p>考试比较喜欢的考法是将这三种校正与“<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=4356198&content_type=Article&match_order=1&q=PID%E6%A0%A1%E6%AD%A3&zhida_source=entity">PID校正</a>”校正结合起来，他们喜欢说PID校正，毕竟PD、PI、PID校正分别是超前、滞后、和滞后-超前校正的特殊情况。</p>
<p>$\text{最大超前角}\\varphi_m&#x3D;\gamma^{\prime\prime}-\gamma+5°&#x3D;45°-0°+5°&#x3D;50°\a&#x3D;\frac{1+\mathrm{sin}\varphi_m}{1-\mathrm{sin}\varphi_m}\approx8:,\quad10\mathrm{lg}a\approx9\mathrm{dB}$ </p>
<p><img src="/../images/v2-62e4aec82258978849246f82c939a7fe_720w.webp" alt="img"></p>
<p><img src="/../images/v2-a80d3c8cc88df0c0f3fe1ae310ba5edc_720w.webp" alt="img"></p>
<p>文件扩展名 <code>.tpp</code> 通常表示 <strong>C++ 模板实现文件</strong>。它与 C++ 模板相关，主要用于存放模板类或函数的实现。</p>
<h3 id="具体用途"><a href="#具体用途" class="headerlink" title="具体用途"></a>具体用途</h3><ol>
<li><p><strong>模板定义分离</strong>：在 C++ 中，通常将模板的声明和实现分开。在头文件（<code>.hpp</code> 或 <code>.h</code>）中，你可以声明一个模板，而在 <code>.tpp</code> 文件中实现该模板。这种做法有助于保持代码的组织性和可读性。</p>
</li>
<li><p><strong>包含在头文件中</strong>：为了使用 <code>.tpp</code> 文件中的实现，通常会在相应的头文件中通过 <code>#include</code> 指令将其包含进来。</p>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设你有一个简单的模板类 <code>MyClass</code>，可以这样组织文件：</p>
<p><strong>MyClass.hpp</strong></p>
<pre><code class="cpp">#ifndef MYCLASS_HPP
#define MYCLASS_HPP

template &lt;typename T&gt;
class MyClass &#123;
public:
    MyClass(T value);
    void display();

private:
    T data;
&#125;;

#include &quot;MyClass.tpp&quot; // 包含实现文件

#endif // MYCLASS_HPP
</code></pre>
<p><strong>MyClass.tpp</strong></p>
<pre><code class="cpp">#include &quot;MyClass.hpp&quot;
#include &lt;iostream&gt;

template &lt;typename T&gt;
MyClass&lt;T&gt;::MyClass(T value) : data(value) &#123;&#125;

template &lt;typename T&gt;
void MyClass&lt;T&gt;::display() &#123;
    std::cout &lt;&lt; data &lt;&lt; std::endl;
&#125;
</code></pre>
<p>debug生成的代码没有经过优化</p>
<h3 id="4-TBB的任务域与for循环的嵌套"><a href="#4-TBB的任务域与for循环的嵌套" class="headerlink" title="4.TBB的任务域与for循环的嵌套"></a>4.TBB的任务域与for循环的嵌套</h3><p><img src="/../images/image-20241011101745036.png" alt="image-20241011101745036"></p>
<p>指定任务域里使用的线程</p>
<p>并行嵌套for循环</p>
<p><img src="/../images/image-20241011102146940.png" alt="image-20241011102146940"></p>
<p>但是嵌套for循环会出现死锁问题:</p>
<p><img src="/../images/image-20241011102321351.png" alt="image-20241011102321351"></p>
<p>为啥：(性能优化：线程里的任务做完了，会去其他线程里取任务帮忙)</p>
<p><img src="/../images/image-20241011102603422.png" alt="image-20241011102603422"></p>
<p>解决办法：</p>
<p><img src="/../images/image-20241011103110746.png" alt="image-20241011103110746"></p>
<p><img src="/../images/image-20241011103358416.png" alt="image-20241011103358416"></p>
<p><img src="/../images/image-20241011110039932.png" alt="image-20241011110039932"></p>
<h3 id="5-任务分配"><a href="#5-任务分配" class="headerlink" title="5.任务分配"></a>5.任务分配</h3><p>并行的时候怎样把一个任务均匀的分配到每个线程&#x2F;核心（因为通常几个核心就开几个线程)呢：（线程和任务都不动）</p>
<p><img src="/../images/image-20241011111101669.png" alt="image-20241011111101669"></p>
<p>效果不太好，不能让核心闲着，让核心上一直有线程在运行</p>
<p>解决：让线程数大于核心数（让线程动起来）</p>
<p><img src="/../images/image-20241011112225107.png" alt="image-20241011112225107"></p>
<p>但是操作系统轮换是有开销（overhead）的，而且有可能破坏缓存一致性</p>
<p>解决：线程池（让任务动起来）</p>
<p><img src="/../images/image-20241011114443951.png" alt="image-20241011114443951"></p>
<p>TBB的工作窃取法：</p>
<p><img src="/../images/image-20241011115732981.png" alt="image-20241011115732981"></p>
<p><img src="/../images/image-20241011120205530.png" alt="image-20241011120205530"></p>
<p>tbb::static_partitioner的线程与任务数量一致</p>
<p><img src="/../images/image-20241011120455377.png" alt="image-20241011120455377"></p>
<p><img src="/../images/image-20241011120545985.png" alt="image-20241011120545985"></p>
<p>默认粒度（一个任务里的元素）是1</p>
<p><img src="/../images/image-20241011120835292.png" alt="image-20241011120835292"></p>
<p><img src="/../images/image-20241011135601948.png" alt="image-20241011135601948"><img src="/../images/image-20241011135646042.png" alt="image-20241011135646042"></p>
<h3 id="tbb-static-partitioner"><a href="#tbb-static-partitioner" class="headerlink" title="tbb::static_partitioner"></a><code>tbb::static_partitioner</code></h3><ul>
<li><p><strong>描述</strong>：将任务静态地分配给线程。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>在任务开始时就确定每个线程将处理哪些任务。</li>
<li>适合于任务量相对均匀且已知的情况。</li>
<li>不会在运行时重新平衡负载，因此可能导致某些线程空闲而其他线程忙碌。</li>
</ul>
</li>
</ul>
<h3 id="2-tbb-simple-partitioner"><a href="#2-tbb-simple-partitioner" class="headerlink" title="2. tbb::simple_partitioner"></a>2. <code>tbb::simple_partitioner</code></h3><ul>
<li><p><strong>描述</strong>：提供一个简单的分区策略。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>任务被划分为较小的块，并且每个线程可以从待处理任务中获取一个块。</li>
<li>相对于 <code>static_partitioner</code>，<code>simple_partitioner</code> 允许更好的负载平衡。</li>
<li>适用于任务量不均或动态变化的情况。</li>
</ul>
</li>
</ul>
<h3 id="3-tbb-auto-partitioner"><a href="#3-tbb-auto-partitioner" class="headerlink" title="3. tbb::auto_partitioner"></a>3. <code>tbb::auto_partitioner</code></h3><ul>
<li><p><strong>描述</strong>：动态调整任务分配以优化性能。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>在运行时监控线程的工作负载，并根据需要进行任务重新分配。</li>
<li>可以实现更好的负载均衡，特别是在任务执行时间不均匀的情况下。</li>
<li>适用于复杂的并行任务，能自动适应系统负载。</li>
</ul>
</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>静态分配</strong>（<code>static_partitioner</code>）适用于可预测且均匀的任务；不适合动态负载。</li>
<li><strong>简单分配</strong>（<code>simple_partitioner</code>）在一定程度上改进了负载平衡，但仍然保持简单的结构。</li>
<li><strong>自动分配</strong>（<code>auto_partitioner</code>）最灵活，适合于动态和不均匀的工作负载，通过实时监测和调整提高整体性能。</li>
</ul>
<p>tbb::static_partitioner对循环体不均匀的情况效果不如tbb::simple_partitioner(操作系统调度)</p>
<p>越来越快</p>
<p><img src="/../images/image-20241011140440217.png" alt="image-20241011140440217"></p>
<p><img src="/../images/image-20241011140721127.png" alt="image-20241011140721127"></p>
<p>但是auto_partitioner一定比simple_partitioner快吗</p>
<p><img src="/../images/image-20241011144432532.png" alt="image-20241011144432532"></p>
<p><img src="/../images/image-20241011154029009.png" alt="image-20241011154029009"></p>
<h3 id="6-并发容器"><a href="#6-并发容器" class="headerlink" title="6.并发容器"></a>6.并发容器</h3><p>问题：</p>
<p><img src="/../images/image-20241011155237153.png" alt="image-20241011155237153"></p>
<p>解决：</p>
<p><img src="/../images/image-20241011155440540.png" alt="image-20241011155440540"></p>
<p><img src="/../images/image-20241011160119354.png" alt="image-20241011160119354"></p>
<p>push_back()返回的是一个迭代器</p>
<p>用*获取迭代器指向的元素的引用，再用and（&amp;）获取这个元素的指针</p>
<p><img src="/../images/image-20241011160927535.png" alt="image-20241011160927535"></p>
<p>tbb::concurrent_vector还是一个多线程安全的容器</p>
<p><img src="/../images/image-20241011161401578.png" alt="image-20241011161401578"></p>
<p>访问：随机访问效率不高</p>
<p><img src="/../images/image-20241011162020029.png" alt="image-20241011162020029"></p>
<p>推荐顺序访问：</p>
<p><img src="/../images/image-20241011162546845.png" alt="image-20241011162546845"></p>
<p><img src="/../images/image-20241011164325073.png" alt="image-20241011164325073"></p>
<p><img src="/../images/image-20241011164827207.png" alt="image-20241011164827207"></p>
<p>这些STL容器前加上concurrent就变成了多线程安全版</p>
<p>vector&#x2F;concurrent_vector有一个常见的用法：用于并行筛选数据：</p>
<h3 id="7-并行筛选"><a href="#7-并行筛选" class="headerlink" title="7.并行筛选"></a>7.并行筛选</h3><p><img src="/../images/image-20241021101434094.png" alt="image-20241021101434094"></p>
<p><img src="/../images/image-20241021101859492.png" alt="image-20241021101859492"></p>
<p><img src="/../images/image-20241021102554406.png" alt="image-20241021102554406"></p>
<p> <img src="/../images/image-20241021103037177.png" alt="image-20241021103037177"></p>
<p>但需要连续数据时，还是需要std::vetor</p>
<p><img src="/../images/image-20241021103348500.png" alt="image-20241021103348500"></p>
<p><img src="/../images/image-20241021104040889.png" alt="image-20241021104040889"></p>
<p><img src="/../images/image-20241021105118738.png" alt="image-20241021105118738"></p>
<h5 id="8-分治与排序"><a href="#8-分治与排序" class="headerlink" title="8.分治与排序"></a>8.分治与排序</h5><p><img src="/../images/image-20241021111447378.png" alt="image-20241021111447378"></p>
<p>反而变慢了：</p>
<p><img src="/../images/image-20241021111303257.png" alt="image-20241021111303257"></p>
<p><img src="/../images/image-20241021111344357.png" alt="image-20241021111344357"></p>
<p>分治</p>
<p><img src="/../images/image-20241021111634419.png" alt="image-20241021111634419"></p>
<p><img src="/../images/image-20241021111951889.png" alt="image-20241021111951889"></p>
<p><img src="/../images/image-20241021112626978.png" alt="image-20241021112626978"></p>
<h5 id="9-流水线并行"><a href="#9-流水线并行" class="headerlink" title="9.流水线并行"></a>9.流水线并行</h5><h3 id="CUDA开启的GPU编程"><a href="#CUDA开启的GPU编程" class="headerlink" title="CUDA开启的GPU编程"></a>CUDA开启的GPU编程</h3><p><img src="/../images/image-20241021114316913.png" alt="image-20241021114316913"></p>
<p><img src="/../images/image-20241021114756000.png" alt="image-20241021114756000"></p>
<p>类对象的声明</p>
<p><code>ThreadPool threadPool &#123;&#125;;</code> 和 <code>ThreadPool threadPool;</code> 的主要区别在于初始化方式：</p>
<h3 id="1-ThreadPool-threadPool-1"><a href="#1-ThreadPool-threadPool-1" class="headerlink" title="1. ThreadPool threadPool {};"></a>1. <code>ThreadPool threadPool &#123;&#125;;</code></h3><ul>
<li><strong>列表初始化</strong>：使用了列表初始化（uniform initialization），这是 C++11 引入的一种语法。</li>
<li><strong>安全性</strong>：这种方式可以防止窄化转换（例如，浮点数到整数的转换），因此更安全。</li>
<li><strong>调用构造函数</strong>：会调用 <code>ThreadPool</code> 类的默认构造函数。</li>
</ul>
<h3 id="2-ThreadPool-threadPool-1"><a href="#2-ThreadPool-threadPool-1" class="headerlink" title="2. ThreadPool threadPool;"></a>2. <code>ThreadPool threadPool;</code></h3><ul>
<li><strong>默认构造</strong>：这是经典的对象定义语法，直接调用默认构造函数。</li>
<li><strong>行为</strong>：如果 <code>ThreadPool</code> 类没有定义任何构造函数，编译器会自动生成一个默认构造函数。</li>
<li><strong>窄化问题</strong>：没有列表初始化的安全性，如果初始化涉及类型转换，可能会导致窄化。</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>功能上</strong>：两者都用于创建 <code>ThreadPool</code> 对象并调用默认构造函数。</li>
<li><strong>安全性</strong>：<code>ThreadPool threadPool &#123;&#125;;</code> 更安全，适用于需要避免潜在类型转换问题的场景。</li>
</ul>
<p>不存在这样的写法：<code>ThreadPool threadPool ();</code></p>
<h3 id="加括号是错的，加花括号是安全的，推荐花括号"><a href="#加括号是错的，加花括号是安全的，推荐花括号" class="headerlink" title="加括号是错的，加花括号是安全的，推荐花括号"></a>加括号是错的，加花括号是安全的，推荐花括号</h3><p>变量的声明</p>
<p><code>std::atomic_flag flag;</code> 和 <code>std::atomic_flag flag &#123;&#125;;</code> 的效果是相同的，都会将 <code>flag</code> 初始化为未设置状态。不过，使用 <code>&#123;&#125;</code> 的形式更加显式，可能更符合现代C++的最佳实践。</p>
<p><code>new SimpleTask()</code> 和 <code>new SimpleTask</code> 在功能上是等价的，都是创建一个 <code>SimpleTask</code> 对象并返回指向该对象的指针。</p>
<p>非常量左值引用问题</p>
<h3 id="常量引用（const-T-）可以绑定到临时对象，而非常量左值引用（T-）则不能。"><a href="#常量引用（const-T-）可以绑定到临时对象，而非常量左值引用（T-）则不能。" class="headerlink" title="常量引用（const T&amp;）可以绑定到临时对象，而非常量左值引用（T&amp;）则不能。"></a>常量引用（<code>const T&amp;</code>）可以绑定到临时对象，而非常量左值引用（<code>T&amp;</code>）则不能。</h3><pre><code class="cpp">glm::vec3 setPixel(size_t x,size_t y,glm::vec3 &amp;pixel)&#123;
        return pixels[width*y+x]=pixel;
    &#125;
</code></pre>
<pre><code>film.setPixel(y,x,glm::vec3(0.5,0.4,0.3));
</code></pre>
<p><code>Non-const lvalue reference to type &#39;vec&lt;...&gt;&#39; cannot bind to a temporary of type &#39;vec&lt;...&gt;&#39;</code></p>
<p>或者</p>
<pre><code>film.setPixel(y,x,&#123;0.5,0.4,0.3&#125;);
</code></pre>
<p><code>Non-const lvalue reference to type &#39;glm::vec3&#39; (aka &#39;vec&lt;3, float, defaultp&gt;&#39;) cannot bind to an initializer list temporary</code></p>
<p>改为：</p>
<pre><code>    glm::vec3 setPixel(size_t x,size_t y,const glm::vec3 &amp;pixel)&#123;
        return pixels[width*y+x]=pixel;
    &#125;
</code></pre>
<p>&#96;&#96;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Cplusplus.html" data-id="cm040oe8600005rcxhs4q231b" data-title="Cplusplus" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Qt" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Qt.html" class="article-date">
  <time class="dt-published" datetime="2024-08-21T15:30:34.000Z" itemprop="datePublished">2024-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Qt.html">Qt</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>QWidget</code> 和 <code>QMainWindow</code> 是 Qt 框架中的两个重要类，它们都用于创建图形用户界面（GUI），但有一些关键的区别：</p>
<h3 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a><code>QWidget</code></h3><ul>
<li><strong>基础类</strong>: <code>QWidget</code> 是 Qt 中所有用户界面对象的基类。它提供了一个基础的窗口部件，其他窗口部件（如按钮、文本框）都是从 <code>QWidget</code> 继承而来的。</li>
<li><strong>功能</strong>: <code>QWidget</code> 本身是一个通用的窗口部件，没有特别的窗口管理功能。它可以作为窗口的基础组件，也可以作为其他复杂组件的容器。</li>
<li><strong>布局管理</strong>: <code>QWidget</code> 提供了布局管理功能，可以使用布局管理器来控制其子部件的位置和大小。</li>
<li><strong>使用场景</strong>: 你可以将 <code>QWidget</code> 用作对话框、工具条、或是任何其他需要的窗口部件。如果你只需要一个简单的窗口，<code>QWidget</code> 是一个合适的选择。</li>
</ul>
<h3 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a><code>QMainWindow</code></h3><ul>
<li><strong>派生类</strong>: <code>QMainWindow</code> 是 <code>QWidget</code> 的子类，提供了更丰富的窗口功能和特性。</li>
<li><strong>功能</strong>: <code>QMainWindow</code> 是设计用于主窗口的类，它提供了菜单栏、工具栏、状态栏和中央窗口区域的支持。这使得它特别适合用于主应用窗口的设计。</li>
<li><strong>布局管理</strong>: <code>QMainWindow</code> 提供了特定的布局区域，如菜单栏、工具栏、状态栏和中央部件区域。你可以使用这些功能来创建更复杂的应用程序界面。</li>
<li><strong>使用场景</strong>: 当你需要一个具有菜单栏、工具栏和状态栏的主窗口时，<code>QMainWindow</code> 是一个理想的选择。它适合用于具有复杂界面的桌面应用程序。</li>
</ul>
<h3 id="主要区别总结"><a href="#主要区别总结" class="headerlink" title="主要区别总结"></a>主要区别总结</h3><ol>
<li><strong>功能扩展</strong>:<ul>
<li><code>QWidget</code>: 基础窗口部件，功能较少，适合用于创建简单的窗口或部件。</li>
<li><code>QMainWindow</code>: 提供额外的功能，如菜单栏、工具栏和状态栏，适合用于主应用窗口。</li>
</ul>
</li>
<li><strong>使用场景</strong>:<ul>
<li><code>QWidget</code>: 适合用作对话框、工具条、或简单的窗口部件。</li>
<li><code>QMainWindow</code>: 适合用于需要复杂用户界面的主窗口。</li>
</ul>
</li>
<li><strong>布局支持</strong>:<ul>
<li><code>QWidget</code>: 你需要手动设置布局。</li>
<li><code>QMainWindow</code>: 提供了内置的菜单栏、工具栏、状态栏和中央部件区域，可以直接使用这些功能来设计主窗口界面。</li>
</ul>
</li>
</ol>
<p>connect(menu, &amp;QMenu::triggered, this, &amp;Widget::onMenuTriggered); 为什么QMenu* menu;时不报错 当QMenu  menu;时报错:No matching member function for call to ‘connect’</p>
<p>在 Qt 中，<code>connect</code> 函数的作用是将一个信号与一个槽函数连接起来。它依赖于信号发射的对象和槽函数的对象都是有效的，并且能够正确识别和匹配。</p>
<h3 id="使用-QMenu-menu"><a href="#使用-QMenu-menu" class="headerlink" title="使用 QMenu* menu"></a>使用 <code>QMenu* menu</code></h3><div class="language-cpp"><button title="Copy code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">QMenu</span><span style="color: #89DDFF">*</span><span style="color: #BABED8"> menu </span><span style="color: #89DDFF">=</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">new</span><span style="color: #BABED8"> </span><span style="color: #82AAFF">QMenu</span><span style="color: #89DDFF">();</span></span>
<span class="line"><span style="color: #82AAFF">connect</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">menu</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">QMenu</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">triggered</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">this,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">Widget</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">onMenuTriggered</span><span style="color: #89DDFF">);</span></span></code></pre></div><ul>
<li>这里，<code>menu</code> 是一个指向 <code>QMenu</code> 对象的指针。</li>
<li><code>connect</code> 函数可以使用 <code>menu</code> 指针来连接信号和槽，因为 <code>QMenu</code> 对象在堆上分配，并且其生命周期由指针管理。</li>
<li><code>QMenu</code> 的实例通过指针能够正确地传递给 <code>connect</code>，并且 <code>QMenu</code> 的成员函数和信号可以被正确识别。</li>
</ul>
<h3 id="使用-QMenu-menu-1"><a href="#使用-QMenu-menu-1" class="headerlink" title="使用 QMenu menu"></a>使用 <code>QMenu menu</code></h3><div class="language-cpp"><button title="Copy code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">QMenu menu</span><span style="color: #89DDFF">;</span></span>
<span class="line"><span style="color: #82AAFF">connect</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">menu</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">QMenu</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">triggered</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">this,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">Widget</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">onMenuTriggered</span><span style="color: #89DDFF">);</span></span></code></pre></div><ul>
<li>这里，<code>menu</code> 是一个栈上的 <code>QMenu</code> 对象。</li>
<li>栈上的对象在 <code>connect</code> 时会导致问题，因为 <code>connect</code> 期望信号发射对象在其生命周期内有效。栈上的对象会在超出作用域时被销毁。</li>
<li>在这个情况下，<code>menu</code> 可能在连接信号和槽时已经过早销毁，导致 <code>connect</code> 函数找不到有效的信号源。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>QMenu* menu</code>：指针允许动态管理对象的生命周期，<code>connect</code> 可以正常工作。</li>
<li><code>QMenu menu</code>：栈上的对象在超出作用域时可能被销毁，导致 <code>connect</code> 函数不能正确地处理信号和槽。</li>
</ul>
<p>因此，使用指针确保 <code>QMenu</code> 对象在 <code>connect</code> 调用期间有效。</p>
<p><img src="/../images/image-20240823104744847.png" alt="image-20240823104744847"></p>
<p><img src="/../images/image-20240823104804653.png" alt="image-20240823104804653"></p>
<p>定义对象的指针，让widght来管理对象的生命周期，要是直接定义对象，可能不知道什么时候对象就被销毁了，有些用到这些对象的函数就可能报错，因为在栈上找不到他了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Qt.html" data-id="cm040gf6300012ucx6mgg6k5d" data-title="Qt" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-risc-v" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/risc-v.html" class="article-date">
  <time class="dt-published" datetime="2024-06-18T04:31:10.000Z" itemprop="datePublished">2024-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/risc-v.html">risc_v</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240618123232143.png" alt="image-20240618123232143"></p>
<p>在RISC-V架构中，IF_ID和ID_EX是两个流水线寄存器，用于在指令执行过程中传递数据。</p>
<ol>
<li>IF_ID（Instruction Fetch to Instruction Decode）：IF_ID流水线寄存器用于在指令提取阶段（Instruction Fetch）和指令解码阶段（Instruction Decode）之间传递数据。它保存了从指令缓存中提取的指令，并将其传递给下一个阶段进行解码。</li>
<li>ID_EX（Instruction Decode to Execute）：ID_EX流水线寄存器用于在指令解码阶段（Instruction Decode）和指令执行阶段（Execute）之间传递数据。它保存了从IF_ID寄存器中解码得到的指令信息，包括操作码、寄存器地址等，并将这些信息传递给下一个阶段进行执行。</li>
</ol>
<p>通过使用这些流水线寄存器，RISC-V架构可以实现指令流水线的并行执行，提高指令的执行效率。</p>
<ol>
<li><strong>IF (Instruction Fetch) 取指</strong>：<ul>
<li>这一阶段的主要任务是从内存中的指令缓存或主存中取回当前要执行的指令。</li>
<li>在这个阶段，程序计数器（PC，Program Counter）会指向当前要取的指令地址。</li>
<li>CPU将该地址发给指令缓存，读取该地址处的指令，并将其存储到流水线寄存器（如IF&#x2F;ID寄存器）中，以便在下一阶段使用。</li>
</ul>
</li>
<li><strong>ID (Instruction Decode) 译码</strong>：<ul>
<li>这一阶段的主要任务是对取回的指令进行解码，即解析指令的操作码和操作数。</li>
<li>具体来说，CPU会读取并识别指令的操作码（Opcode），确定这条指令的类型和需要执行的操作。</li>
<li>同时，CPU还会确定指令所涉及的源操作数和目标寄存器。如果需要从寄存器文件中读取操作数，这一阶段也会执行这些操作。</li>
<li>解码后的信息会存储在流水线寄存器（如ID&#x2F;EX寄存器）中，以便在后续的执行阶段使用。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/risc-v.html" data-id="cm03k1yqc0001gycx8zxxb5cx" data-title="risc_v" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-raytracing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/raytracing.html" class="article-date">
  <time class="dt-published" datetime="2024-06-12T08:08:14.000Z" itemprop="datePublished">2024-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/raytracing.html">raytracing</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 C++ 中，冒号（<code>:</code>）用于初始化类的成员变量或调用父类的构造函数。这种语法称为成员初始化列表（member initialization list），它允许在构造函数体执行之前对成员变量进行初始化。</p>
<p>在这里，<code>vec3() : e&#123;0,0,0&#125; &#123;&#125;</code> 中的冒号后面就是成员初始化列表。<code>: e&#123;0,0,0&#125;</code> 表示对类的成员变量 <code>e</code> 进行初始化，其中 <code>&#123;0,0,0&#125;</code> 是对数组 <code>e</code> 的初始化值。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">double&amp; operator[](int i) &#123; return e[i]; &#125;</span></span></code></pre></div><p><strong><code>double&amp;</code></strong>:</p>
<ul>
<li>返回类型是 <code>double&amp;</code>，即返回一个 <code>double</code> 类型的左值引用。</li>
<li>左值引用允许函数返回一个可修改的元素，这样调用者可以直接修改这个元素。</li>
</ul>
<h3 id="左值和右值的定义"><a href="#左值和右值的定义" class="headerlink" title="左值和右值的定义"></a>左值和右值的定义</h3><ul>
<li><strong>左值（lvalue）</strong>: 可以取地址的值，通常表示内存中的一个位置。例如，变量、数组元素、对象成员等都是左值。</li>
<li><strong>右值（rvalue）</strong>: 不存在明确地址的临时值，通常是表达式的结果或者字面量。例如，字面量、临时对象、运算结果等。</li>
</ul>
<p>引用和原变量本质上是同一个东西，对引用的修改就是对原变量的修改</p>
<p><code>double&amp;</code> 表示引用</p>
<p><code>inline</code> 关键字在C++中用于建议编译器将某个函数的代码在每次调用时直接插入到调用处，而不是进行常规的函数调用。从而可以减少函数调用的开销，尤其是当函数体非常小、调用频繁时，这种优化可能会带来性能提升。</p>
<p><code>using color = vec3;</code> 这行代码是一个类型别名（type alias）的定义，将 <code>vec3</code> 类型重命名为 <code>color</code> 类型。也就是说，使用 <code>color</code> 关键字可以代替 <code>vec3</code> 类型的使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/raytracing.html" data-id="clxbjvuxs000j61cxdrun7t8l" data-title="raytracing" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-FOC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/FOC.html" class="article-date">
  <time class="dt-published" datetime="2024-05-28T23:30:54.000Z" itemprop="datePublished">2024-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/FOC.html">FOC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>可以看出，我们只需要像步进电机那样不断的重复这六部换向就可以让BLDC转动起来，甚至会产生一种错觉，是不是我们换向越快电机转的越快呢？答案是:否，这里我们一定要认识到，是当转子处于特定位置时才去触发换向操作，换向是被动换向，想要提高转速一定是要提高电流，让定子产生的磁场更强，让转子更快的达到目标点然后触发换向</p>
<p>如何获得转子角度？<br>我们已经知道了要先检测角度再去换向，那么如何检测当前角度呢？，有以下三种方式。<br>1.通过安装编码器来计算出当前角度。<br>2.通过安装霍尔元件计算当前角度。<br>3.通过检测电流来计算当前角度</p>
<p>编码器方式获取电机当前角度<br>编码器方式分为两种，增量式编码器和绝对式编码器。<br>增量式编码器：<br>每次启动之气都需要做一次校准，而且为了防止单片机性能问题导致脉冲丢失，还需要对编码器每圈校准一次。因此经常使用ABZ三轴编码器，AB输出正交信号，Z轴输出中断。<br>绝对式编码器：<br>只需要在出厂之前做一次校准，之后如果没有拆机便不需要校准，通讯方式一般是SPI和IIC,需要考虑通讯时间对系统的影响。<br>为什么要对编码器进行校准？<br>因为我们无法保证在安装的时候让编码器的0°（机械角度）刚好对应电机绕组的0°（电气角度）</p>
<p><img src="/../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTQ3MzI5,size_16,color_FFFFFF,t_70#pic_center.png" alt="img"></p>
<p>伸开左手，使拇指与其他四指垂直且在一个平面内，让磁感线从手心流入，四指指向电流方向，大拇指指向的就是安培力方向（即导体受力方向）</p>
<p><img src="/../images/resize,m_lfit,limit_1,w_536.jpeg" alt="img"></p>
<p>右手平展，使大拇指与其余四指垂直，并且都跟手掌在一个平面内。把右手放入磁场中，让<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=526702&ss_c=ssc.citiao.link">磁感线</a>从掌心进入（当磁感线为直线时，相当于手心面向N极），大拇指指向导线运动方向，则四指所指方向为导线中感应电流（动生电动势）的方向。</p>
<p><img src="/../images/image-20240529094507089.png" alt="image-20240529094507089"></p>
<p>根据想得到的电流矢量到u1,u2,u3上投影的正负，来判断在哪个扇区里，u1,u2,u3可由u_alpha,u_beta表示出</p>
<p><img src="/../images/image-20240529130329149.png" alt="image-20240529130329149"></p>
<p><img src="/../images/image-20240529130513189.png" alt="image-20240529130513189"></p>
<p><img src="/../images/image-20240529144317410.png" alt="image-20240529144317410"></p>
<p><img src="/../images/image-20240529144120858.png" alt="image-20240529144120858"></p>
<p><img src="/../images/image-20240529144220989.png" alt="image-20240529144220989"></p>
<p><img src="/../images/image-20240530115230681.png" alt="image-20240530115230681"></p>
<p>从定子来计算</p>
<p><img src="/../images/image-20240530115639643.png" alt="image-20240530115639643">可以计算出反电动势，进而计算转子的速度和位置（无感)</p>
<p>当变压器的初级绕组通电后，线圈所产生的磁通在铁心流动，因为铁心本身也是导体（由硅钢片制成），在垂直于磁力线的平面上就会感应电势，这个电势在铁心的断面上形成闭合回路并产生电流，好象一个旋涡所以称为“涡流”。这个“涡流”使变压器的损耗增加，并且使变压器的铁心发热变压器的温升增加。由“涡流”所产生的损耗我们称为“铁损”。<br>另外要绕制变压器需要用大量的铜线，这些铜导线存在着电阻，电流流过时这电阻会消耗一定的功率，这部分损耗往往变成热量而消耗，我们称这种损耗为“铜损”。<br>铁损等于铜损时，变压器效率最高。大概就是变压器额定负荷的0.65倍左右。</p>
<p>从绕组来计算（d,q,轴的电压方程）</p>
<p><img src="/../images/image-20240530130008389.png" alt="image-20240530130008389"></p>
<p>由于定子自感的属性，电流会滞后电压90度</p>
<p><img src="/../images/image-20240530180512850.png" alt="image-20240530180512850"></p>
<p><img src="/../images/image-20240530180534254.png" alt="image-20240530180534254"></p>
<p>要等幅变换，所以要乘（2&#x2F;3）</p>
<p>如果遇到乘(根号下2&#x2F;3),是等功率变换</p>
<p><img src="/../images/image-20240530181152049.png" alt="image-20240530181152049"></p>
<p><img src="/../images/image-20240530193807755.png" alt="image-20240530193807755"></p>
<p><img src="/../images/image-20240530193832651.png" alt="image-20240530193832651"></p>
<p>反帕克变换就是对帕克变换旋转矩阵求逆</p>
<p>MOS管是电压驱动型，三极管是电流驱动型</p>
<p><img src="/../images/image-20240531080240566.png" alt="image-20240531080240566"></p>
<p><img src="/../images/image-20240531102816686.png" alt="image-20240531102816686"></p>
<p>电角度&#x3D;极对数（或者<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%A7%E6%95%B0&spm=1001.2101.3001.7020">级数</a>&#x2F;2）*机械角度</p>
<p><img src="/../images/image-20240531110753146.png" alt="image-20240531110753146"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/FOC.html" data-id="clxbjvuxp000761cx4xv48vr8" data-title="FOC" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-openmv" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/openmv.html" class="article-date">
  <time class="dt-published" datetime="2024-05-20T06:46:47.000Z" itemprop="datePublished">2024-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/openmv.html">openmv</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240520144720306.png" alt="image-20240520144720306"></p>
<p><img src="/../images/image-20240520144755468.png" alt="image-20240520144755468"></p>
<p>安装库<strong>libxcb-cursor.so.0，</strong></p>
<div class="language-bash"><button title="Copy code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #FFCB6B">sudo</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">apt</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">install</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">libxcb-cursor0</span></span></code></pre></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/openmv.html" data-id="clxbjvuxr000h61cxfy7lffir" data-title="openmv" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OpenGL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/OpenGL.html" class="article-date">
  <time class="dt-published" datetime="2024-05-17T08:51:10.000Z" itemprop="datePublished">2024-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/OpenGL.html">OpenGL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240517165248939.png" alt="image-20240517165248939"></p>
<p><img src="/../images/image-20240517165400128.png" alt="image-20240517165400128"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiujiubashiyi/p/16429717.html">https://www.cnblogs.com/jiujiubashiyi/p/16429717.html</a></p>
<p>GLFW,GLAD,opengl是什么，有什么联系</p>
<p>GLFW、GLAD和OpenGL是计算机图形学中常用的三个库，它们之间存在着紧密的联系：</p>
<ol>
<li><strong>OpenGL</strong>：是一个跨语言、跨平台的编程接口，用于渲染2D、3D向量图形。它是由硅谷图形公司（Silicon Graphics,  SGI）在1992年开发的。OpenGL是图形硬件制造商的标准，也是创作高质量计算机图形的基本工具。OpenGL提供了一个非常灵活的编程接口，让开发者能够利用它来渲染图形。</li>
<li><strong>GLFW</strong>：是一个跨平台的OpenGL应用程序接口（API）的多线程窗口和输入管理器。简单来说，GLFW用来创建窗口、处理输入事件（如键盘、鼠标点击等），并管理OpenGL上下文。它使得开发者可以比较容易地创建一个OpenGL环境，因为它简化了OpenGL程序中许多繁琐的设置步骤。</li>
<li><strong>GLAD</strong>：是一个自动生成OpenGL函数指针的库。在OpenGL中，许多操作需要通过指针来调用函数，而在不同的操作系统和硬件平台上，这些函数指针的位置可能会有所不同。GLAD就是用来处理这些函数指针的，它会根据当前的平台和OpenGL的版本自动生成对应的函数指针。这为开发者减少了处理这些底层细节的麻烦。</li>
</ol>
<p><strong>它们之间的联系</strong>：</p>
<ul>
<li>使用OpenGL之前，需要创建一个OpenGL环境，这个环境包括一个窗口以及一个上下文，这是通过GLFW来完成的。</li>
<li>GLAD用来确保所有的OpenGL函数调用都能够正确地指向相应的函数，这样开发者就不需要手动查找和设置这些函数指针了。</li>
<li>通常，一个OpenGL程序的设置流程是这样的：首先初始化GLFW，然后使用GLFW创建一个窗口和OpenGL上下文，接着使用GLAD自动加载OpenGL函数，最后就可以开始使用OpenGL进行绘图了。</li>
</ul>
<p>综上，GLFW和GLAD都是帮助开发者更简单、更有效地使用OpenGL的辅助工具。通过它们，开发者可以专注于图形内容的创作，而不必担心底层的细节问题。</p>
<p>glfwMakeContextCurrent(window);是什么意思</p>
<p><code>glfwMakeContextCurrent(window);</code> 是一行来自 GLFW（OpenGL Framework）库的代码。GLFW 是一个跨平台的库，用于窗口和输入处理，它使得创建 OpenGL 应用程序变得更加容易。</p>
<p>这句代码的作用是将 OpenGL 渲染上下文关联到由 <code>window</code> 参数指定的窗口。在 OpenGL 中，渲染上下文是用来进行图形绘制的环境，它定义了一系列可以用来配置和控制渲染行为的设置。</p>
<p>在创建窗口之后，必须调用 <code>glfwMakeContextCurrent</code> 函数来指定哪个窗口的上下文将被当前的线程使用。只有当前上下文中的 OpenGL 调用才会对指定的窗口产生影响。如果没有激活任何上下文，任何 OpenGL 调用都会导致错误。</p>
<p>简单来说，当你想要在特定的窗口上绘制图形时，你需要确保该窗口的 OpenGL 上下文被设置为当前上下文。这就是 <code>glfwMakeContextCurrent(window);</code> 这行代码的目的。</p>
<p>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress) 是什么意思</p>
<p><code>gladLoadGLLoader</code> 是一个函数，通常在 C 或 C++ 程序中使用，用于初始化 OpenGL 函数指针。OpenGL 是一个用于渲染2D和3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。<code>gladLoadGLLoader</code> 函数是 GLAD 库的一部分，GLAD 是一个小型且易于使用的库，它负责在每次调用 OpenGL 函数之前，动态地加载和绑定正确的 OpenGL 函数指针。</p>
<p><code>glfwGetProcAddress</code> 是另一个函数，属于 GLFW 库（一个用于创建窗口、输入处理等的前端库，常与OpenGL一起使用）。<code>glfwGetProcAddress</code> 的作用是获取指向特定OpenGL函数的指针，该函数在OpenGL核心或者扩展中定义。</p>
<pre><code>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)
</code></pre>
<p>这表示在初始化GLAD库时，它将使用GLFW库提供的函数指针来加载OpenGL函数。这允许应用程序使用OpenGL函数，而不需要关心底层的具体实现细节。</p>
<p>这种机制的好处是，应用程序只需要链接到一个库（比如GLFW），而GLFW会负责查找和加载正确的OpenGL函数。这样做可以简化应用程序的编写和维护工作，同时也确保了应用程序可以轻松地与不同平台的OpenGL版本兼容。</p>
<p><strong>双缓冲(Double Buffer)</strong></p>
<p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p>
<ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li>
</ul>
<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素.3D坐标转为2D坐标的处理过程是由OpenGL的<strong>图形渲染管线</strong>（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。(图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出)</p>
<p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做<strong>着色器</strong>(Shader)。</p>
<p><strong>OpenGL着色器</strong>是用OpenGL着色器语言(OpenGL Shading Language, <strong>GLSL</strong>)写成的</p>
<p><img src="/../images/pipeline.png" alt="img"></p>
<p>为了让OpenGL知道我们的<strong>坐标和颜色值</strong>构成的到底是什么，OpenGL需要你去指定这些数据所表示的<strong>渲染类型</strong>。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做**图元(Primitive)**，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</p>
<p><strong>图形渲染管线的第一个部分</strong>—-<strong>顶点着色器</strong></p>
<p>把3D坐标转为另一种3D坐标</p>
<p><strong>几何着色器</strong></p>
<p>一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状</p>
<p><strong>图元装配</strong></p>
<p>将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状</p>
<p><strong>光栅化阶段</strong></p>
<p>把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的**片段(Fragment)**。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<p>OpenGL中的一个<strong>片段</strong>是OpenGL渲染一个像素所需的所有数据</p>
<p><strong>片段着色器</strong></p>
<p>片段着色器的主要目的是计算一个像素的最终颜色</p>
<p><strong>Alpha测试和混合(Blending)阶段</strong></p>
<p>这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同</p>
<p><code>GL_ARRAY_BUFFER</code>目标用于表示顶点属性数据的缓冲区对象</p>
<p>在OpenGL中，VAO（Vertex Array Object）和VBO（Vertex Buffer Object）是用于管理顶点数据的重要概念，并且它们之间存在一定的关系。</p>
<ol>
<li>VAO（Vertex Array Object）：<ul>
<li>VAO是OpenGL中用于存储顶点属性状态的对象。它包含了多个指向VBO的指针，用于指定顶点属性数据的格式、排列方式等。</li>
<li>VAO可以看作是对VBO的管理器，它记录了OpenGL如何解释顶点数据，包括顶点的位置、颜色、法线等信息。通过绑定VAO，可以轻松地切换顶点属性的设置，从而简化渲染流程。</li>
</ul>
</li>
<li>VBO（Vertex Buffer Object）：<ul>
<li>VBO是用于存储顶点数据的缓冲区对象。它可以存储顶点的位置、颜色、纹理坐标等信息。</li>
<li>通过将顶点数据存储在VBO中，可以有效地管理和传输大量的顶点数据，而不必反复传输到GPU。</li>
</ul>
</li>
</ol>
<p>关系：</p>
<ul>
<li>VBO存储了实际的顶点数据，例如顶点的位置、颜色、纹理坐标等。</li>
<li>VAO描述了顶点数据的格式和布局，它指明了如何从VBO中读取顶点数据以供渲染使用。</li>
<li>通常情况下，我们先创建和绑定VAO，然后配置相应的VBO，并将VBO与VAO关联。这样，在渲染时只需绑定相应的VAO即可，OpenGL就会根据VAO中的配置自动获取正确的顶点数据进行渲染。</li>
</ul>
<p>总结来说，VAO用于管理顶点属性状态，而VBO用于存储实际的顶点数据。它们共同协作，使得在OpenGL中管理和使用顶点数据变得更加灵活和高效。</p>
<p>我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）</p>
<p>着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p>
<p>Uniform是另一种从我们的应用程序在 CPU 上传递数据到 GPU 上的着色器的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>
<p>在OpenGL中，VBO（Vertex Buffer Object）和VAO（Vertex Array Object）都是用于管理顶点数据的对象。它们之间的联系和区别如下：</p>
<p>联系：</p>
<ul>
<li>VBO和VAO都是用于管理顶点属性数据的对象。</li>
<li>它们都可以通过OpenGL API进行创建、绑定、更新和删除等操作。</li>
<li>VAO可以保存多个VBO的绑定状态，使得我们在绘制时只需绑定VAO即可同时启用多个顶点属性数组。</li>
</ul>
<p>区别：</p>
<ul>
<li>VBO是用于存储和管理顶点数据的缓冲对象，包括顶点位置、法线、颜色、纹理坐标等属性数据。它能够提高渲染效率，因为可以将这些数据上传到显卡内存中，而不需要每次绘制时都从系统内存中获取。</li>
<li>VAO是用于管理VBO的绑定状态的对象，它记录了VBO的绑定状态以及每个属性在VBO中的偏移量、类型等信息。VAO可以看作是一组VBO的绑定描述符，它规定了如何从VBO中获取顶点属性数据。</li>
</ul>
<p>总体来说，VBO和VAO在OpenGL中都扮演着非常重要的角色，它们都可以提高渲染效率，使得开发者可以更加方便地管理和操作顶点属性数据。其中，VBO主要用于存储和管理顶点数据，而VAO则是用于在绘制时快速激活和绑定多个顶点属性数组。</p>
<p>把两个角度都发送</p>
<p>试一下发后两个数据，看看是不是数据的问题</p>
<p>试试发5个</p>
<p><img src="/../images/image-20240603155209855.png" alt="image-20240603155209855">2024.6.3.15.52Matlab报错，遂改，无用！！！！</p>
<p>艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节.这样就可以让物体非常精细而不用指定额外的顶点</p>
<p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p>
<p>使用 Xlib 来获取窗口大小需要一些底层的操作，但可以通过以下步骤来实现：</p>
<p>首先，你需要安装 <code>python-xlib</code> 库。你可以使用以下命令在 Ubuntu 上安装：</p>
<pre><code class="bash">sudo apt-get install python-xlib
</code></pre>
<p>然后，你可以使用下面的代码来获取当前活动窗口的大小：</p>
<pre><code class="python">from Xlib import display

def get_screen_size():
    disp = display.Display()
    screen = disp.screen()
    root_win = screen.root
    windowID = root_win.get_full_property(disp.intern_atom(&#39;_NET_ACTIVE_WINDOW&#39;), 0).value[0]
    window = disp.create_resource_object(&#39;window&#39;, windowID)
    geometry = window.get_geometry()
    return geometry.width, geometry.height

width, height = get_screen_size()
print(&quot;Window size: &#123;&#125; x &#123;&#125;&quot;.format(width, height))
</code></pre>
<p>这段代码中，我们首先创建了一个 <code>Display</code> 对象，然后获取了当前活动窗口的 ID。接着，我们使用这个窗口 ID 创建了一个 <code>window</code> 对象，并通过这个对象的 <code>get_geometry</code> 方法获取了窗口的宽度和高度。</p>
<p>请注意，使用 Xlib 需要对 X 窗口系统有一定的了解，因为它是一个底层的库，直接和 X 服务器进行交互。希望这个示例能够帮助你开始使用 Xlib 来获取窗口大小。</p>
<ul>
<li><code>layout(location=0)</code>: 这是一个着色器布局限定符（layout qualifier），用于指定顶点属性在输入阶段的位置。在这里，<code>location=0</code> 表示顶点属性的位置索引为 0。这个位置索引将与顶点数组对象（VAO）中的对应属性绑定，以确保正确地将顶点数据传递给顶点着色器。</li>
<li><code>in</code>: 这是一个输入变量修饰符，用于指示这个变量是从外部传递给顶点着色器的。</li>
<li><code>vec3</code>: 这是指定变量类型的关键字，表示这个变量是一个三维向量。</li>
<li><code>in_position</code>: 这是变量的名称，用于在顶点着色器中引用这个输入变量。在这里，<code>in_position</code> 可能表示顶点的位置信息。</li>
</ul>
<p>在OpenGL中，<code>gl_Position</code>是一个内置的变量，用于表示顶点着色器（Vertex Shader）输出的顶点位置。它是一个四维向量（<code>vec4</code>），表示顶点的齐次坐标（Homogeneous Coordinates），通常用于表示三维空间中的点。齐次坐标是四维的，其中前三个分量表示点的位置，而第四个分量通常被用于表示点的类型或者进行透视除法（Perspective Division）。在顶点着色器中，对 <code>gl_Position</code> 的设置将影响后续的图元装配（Primitive Assembly）和光栅化（Rasterization）阶段，最终确定绘制的像素位置。因此，正确设置 <code>gl_Position</code> 是绘制正确图形的关键。</p>
<p>[[ 0.5  0.5  0.   0.   1.   0. ]<br> [-0.5  0.5  0.   1.   0.   0. ]<br> [-0.5 -0.5  0.   0.   0.   1. ]<br> [ 0.5  0.5  0.   0.   1.   0. ]<br> [-0.5 -0.5  0.   0.   0.   1. ]<br> [ 0.5 -0.5  0.   1.   0.   0. ]]</p>
<pre><code>layout(location=0) in vec3 in_position;
layout(location=1) in vec3 in_color;
</code></pre>
<pre><code>self.vbo_format = &#39;3f 3f&#39;
self.attrs = (&#39;in_position&#39;, &#39;in_color&#39;)
</code></pre>
<pre><code>vertex_data = np.hstack([vertices_array, colors_array])
</code></pre>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p><img src="/../images/image-20240608192337289.png" alt="image-20240608192337289"></p>
<h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p><img src="/../images/image-20240608192358635.png" alt="image-20240608192358635"></p>
<p>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p>
<ul>
<li>弧度转角度：<code>角度 = 弧度 * (180.0f / PI)</code></li>
<li>角度转弧度：<code>弧度 = 角度 * (PI / 180.0f)</code></li>
</ul>
<p><img src="/../images/image-20240608192525938.png" alt="image-20240608192525938"></p>
<p>我这一辈子，抠抠搜搜的花了很多钱，精精明明的上了很多当。骂骂咧咧的干了很多活，小心翼翼的闯了很多祸。精打细算的欠了一屁股帐。认认真真的范了很多错。掏心掏肺的结了很多仇。不明不白的吃了很多亏。窝窝囊囊的活了几十年。</p>
<ol>
<li><code>glm::mat4 trans;</code>：首先声明了一个4x4的矩阵trans，用于表示变换矩阵。</li>
<li><code>trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));</code>：这一行代码对trans进行了旋转变换。使用了glm库中的rotate函数，将trans矩阵绕Z轴旋转90度（使用radians函数将角度转换为弧度），并将结果赋值给trans本身。</li>
<li><code>trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));</code>：接着对trans进行了缩放变换。使用了glm库中的scale函数，将trans矩阵沿着X、Y、Z三个轴分别缩放0.5倍，并将结果再次赋值给trans本身。</li>
</ol>
<ul>
<li>局部空间(Local Space，或者称为物体空间(Object Space))</li>
<li>世界空间(World Space)</li>
<li>观察空间(View Space，或者称为视觉空间(Eye Space))</li>
<li>裁剪空间(Clip Space)</li>
<li>屏幕空间(Screen Space)</li>
</ul>
<p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕</p>
<p>坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p>
<p><img src="/../images/coordinate_systems.png" alt="coordinate_systems"></p>
<ol>
<li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li>
<li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li>
<li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>
<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li>
<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li>
</ol>
<p>你可能已经大致了解了每个坐标空间的作用。我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。</p>
<h2 id="局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间-摄像机空间-———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间"><a href="#局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间-摄像机空间-———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间" class="headerlink" title="局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间"></a>局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间</h2><p><img src="/../images/image-20240609164419389.png" alt="image-20240609164419389"></p>
<p><img src="/../images/image-20240609164929887.png" alt="image-20240609164929887"></p>
<p><img src="/../images/image-20240609165058873.png" alt="image-20240609165058873"></p>
<p><img src="/../images/image-20240609211854570.png" alt="image-20240609211854570"></p>
<p><img src="/../images/image-20240609212927721.png" alt="image-20240609212927721"></p>
<p><img src="/../images/image-20240609213514370.png" alt="image-20240609213514370"></p>
<p>glm::LookAt函数需要一个位置、目标和上向量。它会创建一个观察矩阵。</p>
<p>为了改变摄像机方向</p>
<p><img src="/../images/image-20240609221012736.png" alt="image-20240609221012736"></p>
<p><code>self.m_projection=glm.perspective(V_FOV,ASPECT_RATIO,NEARPLANE,FARPLANE)</code></p>
<p>使用 GLM 库中的 <code>glm::perspective()</code> 函数创建了一个投影矩阵（projection matrix）.会根据给定的参数创建一个透视投影矩阵，并返回这个矩阵。这个投影矩阵描述了从摄像机位置观察场景时的投影效果，将三维场景转换为二维屏幕空间</p>
<p><img src="/../images/image-20240610000155256.png" alt="image-20240610000155256"></p>
<p>对连续时间正弦信号考虑下面表示式：<br>x ( t ) &#x3D; s i n ( 2 π f 0 t + φ )<br>可以按抽样频率 fs&#x3D;1&#x2F;Ts对 x(t)抽样来获得离散时间信号<br>x [ n ] &#x3D; x ( t )|t &#x3D;nTs       &#x3D;  x ( t ) |t&#x3D;n &#x2F; fs &#x3D; s i n ( 2 πf0 &#x2F;fsn + φ ),<br>f0 &#x3D;500Hz， fs 取 100Hz， 绘出 x[n]及其 DTFT</p>
<p><img src="/../images/image-20240611133720092.png" alt="image-20240611133720092"></p>
<p><img src="/../images/image-20240611133805550.png" alt="image-20240611133805550"></p>
<p><img src="/../images/image-20240611133838091.png" alt="image-20240611133838091"></p>
<p><img src="/../images/image-20240611140046801.png" alt="image-20240611140046801"></p>
<p>以 5000HZ 和 1000HZ 分别对其采样得到 x1(n)， x2(n)；画出它们的 DTFT 并比较</p>
<p><img src="/../images/image-20240611140651535.png" alt="image-20240611140651535"></p>
<p><img src="/../images/image-20240611141635271.png" alt="image-20240611141635271"></p>
<p>我们可以从第一个方程中直接得到 A 和 φ 的关系：</p>
<p><img src="/../images/image-20240611141659727.png" alt="image-20240611141659727"></p>
<p>φ ！&#x3D;π&#x2F;2+kπ</p>
<p>x(t)&#x3D;2cos(π&#x2F;3 *t)</p>
<p><img src="/../images/image-20240611143342649.png" alt="image-20240611143342649"></p>
<p><img src="/../images/image-20240611143614094.png" alt="image-20240611143614094"></p>
<p><img src="/../images/image-20240611144943071.png" alt="image-20240611144943071"></p>
<p><img src="/../images/image-20240611145404898.png" alt="image-20240611145404898"></p>
<p>现实中无法实现理想低通滤波器。然而，可以按下面的方法计算由理想低通滤波器产生的<br>波形：理想低通运算相当于信号频谱与频域的矩形函数相乘，这对应于信号与通过傅里叶逆变<br>换得到的时域 sinc 函数的卷积。当其应用于点样本时，卷积和为 sinc 函数内插：</p>
<p>xa(t)&#x3D;sum_{n&#x3D;-无穷}^{正无穷} [xa(nt) sin(π(t-nTs)&#x2F;Ts)&#x2F;(π(t-nTs)&#x2F;Ts)]</p>
<p>(3.18)<br>其中，样本 xa(nt)取自 t&#x3D; nTs处。<br>a. 假设只有有限数量的信号样本是非零值，且只需在有限时间区间上进行信号重建，写出<br>基于(3.18)式的 sinc 内插表示式。</p>
<p><code>syms t n Ts xa;</code></p>
<p><code>xa_t = symsum(xa * sin(pi*(t-n*Ts)/Ts)/(pi*(t-n*Ts)/Ts), n, -inf, inf);</code></p>
<p><img src="/../images/image-20240611153315884.png" alt="image-20240611153315884"></p>
<p>C：<br><img src="/../images/image-20240611155005492.png" alt="image-20240611155005492"></p>
<p>根据奈奎斯特采样定理，要求 fs≥2fbfs≥2fb 以避免混叠现象。因此，fb&lt;fs2fb&lt;2fs 是满足采样定理的条件。</p>
<p><img src="/../images/image-20240613162635475.png" alt="image-20240613162635475"></p>
<p>45HZ，基本周期 T是 1&#x2F;45</p>
<p><img src="/../images/image-20240613160828062.png" alt="image-20240613160828062"></p>
<h3 id="结果分析与总结"><a href="#结果分析与总结" class="headerlink" title="结果分析与总结"></a>结果分析与总结</h3><ol>
<li><strong>分析长度 ( 0.5T_p &#x3D; 0.1 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率较低，频率成分不清晰，可能会导致频率混淆。</li>
<li>由于分析长度小于一个周期，频谱分析结果可能包含较多的谐波失真和旁瓣效应。</li>
</ul>
</li>
<li><strong>分析长度 ( 1.5T_p &#x3D; 0.3 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率有所提高，主要频率成分变得更加明显。</li>
<li>由于分析长度超过一个周期，频谱分析结果更加准确，频率成分容易识别。</li>
</ul>
</li>
<li><strong>分析长度 ( 2T_p &#x3D; 0.4 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率进一步提高，主要频率成分非常清晰。</li>
<li>更长的分析长度提供了更好的频率分辨率，但同时也增加了计算时间和资源需求。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>选择合适的分析长度</strong>：分析长度可以通过基本周期 ( T_p ) 的整数倍来选择。一般来说，分析长度至少应等于或大于一个周期 ( T_p )，这样可以确保频谱分析结果的准确性。</li>
<li><strong>平衡分辨率和计算复杂度</strong>：较长的分析长度提供更好的频率分辨率，但也会增加计算时间和资源。在实际应用中，需要在频率分辨率和计算复杂度之间取得平衡。</li>
<li><strong>避免过短的分析长度</strong>：过短的分析长度（例如小于一个周期）可能导致频谱结果混乱，难以准确识别主要频率成分</li>
</ul>
<p><img src="/../images/image-20240613161203147.png" alt="image-20240613161203147"></p>
<p>你可以看到，白色的阳光实际上是所有可见颜色的集合，物体吸收了其中的大部分颜色。它仅反射了代表物体颜色的部分，被反射颜色的组合就是我们所感知到的颜色（此例中为珊瑚红）。</p>
<p>这些颜色反射的定律被直接地运用在图形领域。当我们在OpenGL中创建一个光源时，我们希望给光源一个颜色。在上一段中我们有一个白色的太阳，所以我们也将光源设置为白色。当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色（也就是我们所感知到的颜色）。让我们再次审视我们的玩具（这一次它还是珊瑚红），看看如何在图形学中计算出它的反射颜色。我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量了：</p>
<pre><code class="c++">glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
glm::vec3 toyColor(1.0f, 0.5f, 0.31f);
glm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f);
</code></pre>
<p>我们可以看到玩具的颜色<strong>吸收</strong>了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，我们可以定义物体的颜色为&#x3D;&#x3D;<strong>物体从一个光源反射各个颜色分量的大小</strong>。&#x3D;&#x3D;</p>
<p>**现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为冯氏光照模型(Phong Lighting Model)。冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。下面这张图展示了这些光照分量看起来的样子：</p>
<p><img src="/../images/basic_lighting_phong.png" alt="img"></p>
<ul>
<li>环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li>
<li>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。</li>
<li>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>
</ul>
<p>在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体进行任何缩放操作，所以我们并不真的需要使用一个法线矩阵，而是仅以模型矩阵乘以法线就可以。但是如果你会进行不等比缩放，使用法线矩阵去乘以法向量就是必须的了。</p>
<p><img src="/../images/image-20240618134143162.png" alt="image-20240618134143162"></p>
<p><img src="/../images/image-20240618134913056.png" alt="image-20240618134913056"></p>
<p><img src="/../images/image-20240618135228887.png" alt="image-20240618135228887"></p>
<p><img src="/../images/image-20240618135413787.png" alt="image-20240618135413787"></p>
<p>已知周期信号 <em>x</em>(<em>t</em>) &#x3D; 0.75 + 3.4 cos 2πft + 2.7 cos 4<em>π</em> <em>ft</em> +1.5sin 3.5<em>π</em> <em>ft</em> + 2.5sin 7<em>π</em> <em>ft</em>  ，其<br>中 25&#x2F;16Hz,若截断时间长度分别为信号周期的 0.9 和 1.1 倍，试分别绘制这八种窗函数<br>提取的 x(t)的频谱。</p>
<p><img src="/../images/image-20240618141855717.png" alt="image-20240618141855717"></p>
<p>根据下列指标采用窗函数法设计低通数字滤波器， 通带截止频率wp&#x3D; 0.2π ，阻带截止频率</p>
<p>ws &#x3D; 0.3π，通带最大衰减 0.25dB，阻带最小衰减 50dB。</p>
<p>（1） 分别利用汉明窗、布莱克曼窗和凯泽窗设计该滤波器，且滤波器具有线性相位。绘出脉冲响应 h(n)及滤波器的频率响应；</p>
<p>（2） 增加 N，观察过渡带和最大肩峰值的变化。</p>
<p>利用汉明窗设计数字微分器</p>
<p>Hd(e^jw)&#x3D;</p>
<p>jw,0&lt;w&lt;π;</p>
<p>-jw,-π&lt;w&lt;0.</p>
<p>要求 <em>N</em> &#x3D; 21，且滤波器具有线性相位。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/OpenGL.html" data-id="clxbjvuxq000c61cx46uggxj5" data-title="OpenGL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CUDA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/CUDA.html" class="article-date">
  <time class="dt-published" datetime="2024-05-14T04:45:58.000Z" itemprop="datePublished">2024-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/CUDA.html">CUDA</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240514124728144.png" alt="image-20240514124728144"></p>
<p>PCIe传输速率比较慢</p>
<p><img src="/../images/image-20240514125248067.png" alt="image-20240514125248067"></p>
<p><img src="/../images/image-20240514134619194.png" alt="image-20240514134619194"></p>
<p><img src="/../images/image-20240514163840122.png" alt="image-20240514163840122"></p>
<p><img src="/../images/image-20240514164819180.png" alt="image-20240514164819180"></p>
<p>CPU启动核函数之后，由这个核函数在GPU设备里产生的所有的线程构成了一个grid(网格)</p>
<p>而一个grid又由多个线程块（block）组成，一个线程块里包含一组线程（thread）</p>
<p>进行CUDA编程时，要做的就是减少计算核心空闲的时间，让计算核心一直处于计算中</p>
<p>CPU，GPU在进行内存相互访问的时候，会很耗时</p>
<p><img src="/../images/image-20240514170821304.png" alt="image-20240514170821304"></p>
<p><img src="/../images/image-20240514200242464.png" alt="image-20240514200242464"></p>
<p><img src="/../images/image-20240514200453776.png" alt="image-20240514200453776"></p>
<p>一维：</p>
<p><img src="/../images/image-20240514215215578.png" alt="image-20240514215215578"></p>
<p><img src="/../images/image-20240514214149999.png" alt="image-20240514214149999"></p>
<p>二维：</p>
<p><img src="/../images/image-20240514214513695.png" alt="image-20240514214513695"></p>
<p>三维：<br><img src="/../images/image-20240515094438706.png" alt="image-20240515094438706"></p>
<p><img src="/../images/image-20240515094525884.png" alt="image-20240515094525884"></p>
<p><img src="/../images/image-20240515095616319.png" alt="image-20240515095616319"></p>
<p>-arch和-code 都与GPU的兼容性有关，在指定计算能力的时候，GPU的真实架构计算能力一定要大于虚拟架构计算能力的</p>
<p><img src="/../images/image-20240515100052890.png" alt="image-20240515100052890"></p>
<p><img src="/../images/image-20240515100901251.png" alt="image-20240515100901251"></p>
<p><img src="/../images/image-20240515101949472.png" alt="image-20240515101949472"></p>
<p><img src="/../images/image-20240515102254655.png" alt="image-20240515102254655"></p>
<p><img src="/../images/image-20240515104802323.png" alt="image-20240515104802323"></p>
<p>即时编译，增加兼容性：</p>
<p><img src="/../images/image-20240515104350368.png" alt="image-20240515104350368"></p>
<p>两个都是compute_XY(虚拟)</p>
<p><img src="/../images/image-20240518093831448.png" alt="image-20240518093831448"></p>
<p><img src="/../images/image-20240518094156107.png" alt="image-20240518094156107"></p>
<p>在C++中，<code>exit(-1)</code> 和 <code>return -1</code> 都可以用来表示程序的异常退出或者返回一个错误码，但它们之间有一些重要的区别：</p>
<ol>
<li><code>exit(-1)</code> 是一个系统调用，它会立即终止整个程序的执行，并返回一个指定的退出码给操作系统。这会终止程序的执行并进行清理工作（如关闭文件、释放内存等），然后返回退出码。<code>exit</code> 函数是C标准库中的函数，定义在 <code>&lt;cstdlib&gt;</code> 头文件中。</li>
<li><code>return -1</code> 通常出现在函数中，用于从当前函数中返回一个指定的值。当函数的返回类型是整型时，<code>return -1</code> 将会将 -1 这个值返回给调用该函数的地方。如果 <code>-1</code> 是 <code>main</code> 函数的返回值，那么它会被返回给操作系统作为程序的退出码。</li>
</ol>
<p>因此，<code>exit(-1)</code> 会立即终止整个程序的执行，而 <code>return -1</code> 只是从当前函数中返回一个值。</p>
<p><img src="/../images/image-20240518101534052.png" alt="image-20240518101534052"></p>
<p><img src="/../images/image-20240518102522434.png" alt="image-20240518102522434">双指针</p>
<p><img src="/../images/image-20240518102902454.png" alt="image-20240518102902454"></p>
<p><img src="/../images/image-20240518103123516.png" alt="image-20240518103123516"></p>
<p><img src="/../images/image-20240518103306357.png" alt="image-20240518103306357"></p>
<p><code>cudaDeviceReset()</code>函数用于重置当前设备上的所有状态信息。它会清除当前设备上的所有内存分配和设备端的运行时状态，释放所有CUDA资源，并将设备状态恢复到初始化时的状态。这个函数通常在程序结束前被调用，以确保释放所有CUDA资源并将GPU状态还原到初始状态。</p>
<p>调用<code>cudaDeviceReset()</code>函数可以帮助确保程序结束时释放了所有CUDA资源，从而避免内存泄漏和其他问题。</p>
<p>在CUDA中，核函数（kernel function）和设备函数（device function）是两个不同的概念。</p>
<ol>
<li>核函数（Kernel Function）：<ul>
<li>核函数是在GPU上执行的并行函数，由关键字<code>__global__</code>声明。它们可以被从CPU代码调用，并在GPU上并行执行。在CUDA中，核函数通常用于执行大规模数据并行计算。</li>
</ul>
</li>
<li>设备函数（Device Function）：<ul>
<li>设备函数是在GPU上执行的函数，但它们只能被其他设备函数调用，不能从CPU代码中直接调用。设备函数通常用于封装重复使用的代码逻辑，以便在核函数中进行调用，以提高代码复用性和可读性。</li>
</ul>
</li>
</ol>
<p>虽然它们都是在GPU上执行的函数，但核函数和设备函数在调用方式、用途和作用域上有明显的区别。核函数是CUDA程序中由CPU代码调用的入口点，而设备函数是为了在核函数内部使用而设计的。</p>
<p><img src="/../images/image-20240518143353274.png" alt="image-20240518143353274"></p>
<p><img src="/../images/image-20240518145238232.png" alt="image-20240518145238232"></p>
<p><img src="/../images/image-20240518145441046.png" alt="image-20240518145441046"></p>
<p><code>__FILE__</code> 和 <code>__LINE__</code> 是C&#x2F;C++中的预定义宏，它们分别代表当前源文件的文件名和行号</p>
<p><img src="/../images/image-20240518152527144.png" alt="image-20240518152527144"></p>
<p><img src="/../images/image-20240524144504885.png" alt="image-20240524144504885"></p>
<p><code>%g</code> 是 C++ 语言中的格式化输出控制符之一，用于打印浮点数。它根据浮点数的值自动选择 <code>%f</code> 或 <code>%e</code> 中较短的一个输出形式来打印。</p>
<p>具体来说：</p>
<ul>
<li>如果浮点数的绝对值小于 0.0001 或者大于等于 10^6，<code>%g</code> 就会采用 <code>%e</code> 的输出形式，用科学计数法表示浮点数。</li>
<li>否则，<code>%g</code> 会采用 <code>%f</code> 的输出形式，用普通的小数形式表示浮点数。</li>
</ul>
<p>在 CUDA 编程中，<code>cudaEventQuery(start)</code> 表示查询事件 <code>start</code> 的状态。具体来说，它用于检查事件是否已经被记录。如果事件已经被记录，那么 <code>cudaEventQuery</code> 将立即返回。如果事件还没有被记录，那么 <code>cudaEventQuery</code> 将等待事件被记录后才返回。</p>
<p>在上述代码中，<code>cudaEventQuery(start)</code> 的目的可能是为了确保在记录 <code>stop</code> 事件之前，<code>start</code> 事件已经被成功记录。这样可以确保测量的时间间隔准确，避免了 <code>start</code> 事件尚未记录就立即记录 <code>stop</code> 事件的情况。</p>
<p><img src="/../images/image-20240524163028697.png" alt="image-20240524163028697"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/CUDA.html" data-id="clxbjvuxn000361cxbiegh8zs" data-title="CUDA" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/" rel="tag">C++STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PNC/" rel="tag">PNC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/esp32/" rel="tag">esp32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robot-kinematics/" rel="tag">robot_kinematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yolo/" rel="tag">yolo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%89%E8%B6%B3/" rel="tag">玉足</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-STL/" style="font-size: 10px;">C++STL</a> <a href="/tags/Embedded/" style="font-size: 10px;">Embedded</a> <a href="/tags/PNC/" style="font-size: 10px;">PNC</a> <a href="/tags/esp32/" style="font-size: 10px;">esp32</a> <a href="/tags/robot-kinematics/" style="font-size: 10px;">robot_kinematics</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/%E7%8E%89%E8%B6%B3/" style="font-size: 10px;">玉足</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">计算机图形学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/ncnn-yolov8-seg.html">ncnn-yolov8-seg</a>
          </li>
        
          <li>
            <a href="/post/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html">流体力学</a>
          </li>
        
          <li>
            <a href="/post/%E5%9B%9B%E8%B6%B3.html">四足</a>
          </li>
        
          <li>
            <a href="/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6.html">图形学</a>
          </li>
        
          <li>
            <a href="/post/motion-planning.html">motion_planning</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>