<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Zgh&#39;s</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Zgh的个人站">
<meta property="og:type" content="website">
<meta property="og:title" content="Zgh&#39;s">
<meta property="og:url" content="http://zgh20060114.github.io/page/2/index.html">
<meta property="og:site_name" content="Zgh&#39;s">
<meta property="og:description" content="Zgh的个人站">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Zgh's" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zgh&#39;s</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Zgh20060114.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Qt" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Qt.html" class="article-date">
  <time class="dt-published" datetime="2024-08-21T15:30:34.000Z" itemprop="datePublished">2024-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Qt.html">Qt</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>QWidget</code> 和 <code>QMainWindow</code> 是 Qt 框架中的两个重要类，它们都用于创建图形用户界面（GUI），但有一些关键的区别：</p>
<h3 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a><code>QWidget</code></h3><ul>
<li><strong>基础类</strong>: <code>QWidget</code> 是 Qt 中所有用户界面对象的基类。它提供了一个基础的窗口部件，其他窗口部件（如按钮、文本框）都是从 <code>QWidget</code> 继承而来的。</li>
<li><strong>功能</strong>: <code>QWidget</code> 本身是一个通用的窗口部件，没有特别的窗口管理功能。它可以作为窗口的基础组件，也可以作为其他复杂组件的容器。</li>
<li><strong>布局管理</strong>: <code>QWidget</code> 提供了布局管理功能，可以使用布局管理器来控制其子部件的位置和大小。</li>
<li><strong>使用场景</strong>: 你可以将 <code>QWidget</code> 用作对话框、工具条、或是任何其他需要的窗口部件。如果你只需要一个简单的窗口，<code>QWidget</code> 是一个合适的选择。</li>
</ul>
<h3 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a><code>QMainWindow</code></h3><ul>
<li><strong>派生类</strong>: <code>QMainWindow</code> 是 <code>QWidget</code> 的子类，提供了更丰富的窗口功能和特性。</li>
<li><strong>功能</strong>: <code>QMainWindow</code> 是设计用于主窗口的类，它提供了菜单栏、工具栏、状态栏和中央窗口区域的支持。这使得它特别适合用于主应用窗口的设计。</li>
<li><strong>布局管理</strong>: <code>QMainWindow</code> 提供了特定的布局区域，如菜单栏、工具栏、状态栏和中央部件区域。你可以使用这些功能来创建更复杂的应用程序界面。</li>
<li><strong>使用场景</strong>: 当你需要一个具有菜单栏、工具栏和状态栏的主窗口时，<code>QMainWindow</code> 是一个理想的选择。它适合用于具有复杂界面的桌面应用程序。</li>
</ul>
<h3 id="主要区别总结"><a href="#主要区别总结" class="headerlink" title="主要区别总结"></a>主要区别总结</h3><ol>
<li><strong>功能扩展</strong>:<ul>
<li><code>QWidget</code>: 基础窗口部件，功能较少，适合用于创建简单的窗口或部件。</li>
<li><code>QMainWindow</code>: 提供额外的功能，如菜单栏、工具栏和状态栏，适合用于主应用窗口。</li>
</ul>
</li>
<li><strong>使用场景</strong>:<ul>
<li><code>QWidget</code>: 适合用作对话框、工具条、或简单的窗口部件。</li>
<li><code>QMainWindow</code>: 适合用于需要复杂用户界面的主窗口。</li>
</ul>
</li>
<li><strong>布局支持</strong>:<ul>
<li><code>QWidget</code>: 你需要手动设置布局。</li>
<li><code>QMainWindow</code>: 提供了内置的菜单栏、工具栏、状态栏和中央部件区域，可以直接使用这些功能来设计主窗口界面。</li>
</ul>
</li>
</ol>
<p>connect(menu, &amp;QMenu::triggered, this, &amp;Widget::onMenuTriggered); 为什么QMenu* menu;时不报错 当QMenu  menu;时报错:No matching member function for call to ‘connect’</p>
<p>在 Qt 中，<code>connect</code> 函数的作用是将一个信号与一个槽函数连接起来。它依赖于信号发射的对象和槽函数的对象都是有效的，并且能够正确识别和匹配。</p>
<h3 id="使用-QMenu-menu"><a href="#使用-QMenu-menu" class="headerlink" title="使用 QMenu* menu"></a>使用 <code>QMenu* menu</code></h3><div class="language-cpp"><button title="Copy code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">QMenu</span><span style="color: #89DDFF">*</span><span style="color: #BABED8"> menu </span><span style="color: #89DDFF">=</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">new</span><span style="color: #BABED8"> </span><span style="color: #82AAFF">QMenu</span><span style="color: #89DDFF">();</span></span>
<span class="line"><span style="color: #82AAFF">connect</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">menu</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">QMenu</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">triggered</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">this,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">Widget</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">onMenuTriggered</span><span style="color: #89DDFF">);</span></span></code></pre></div><ul>
<li>这里，<code>menu</code> 是一个指向 <code>QMenu</code> 对象的指针。</li>
<li><code>connect</code> 函数可以使用 <code>menu</code> 指针来连接信号和槽，因为 <code>QMenu</code> 对象在堆上分配，并且其生命周期由指针管理。</li>
<li><code>QMenu</code> 的实例通过指针能够正确地传递给 <code>connect</code>，并且 <code>QMenu</code> 的成员函数和信号可以被正确识别。</li>
</ul>
<h3 id="使用-QMenu-menu-1"><a href="#使用-QMenu-menu-1" class="headerlink" title="使用 QMenu menu"></a>使用 <code>QMenu menu</code></h3><div class="language-cpp"><button title="Copy code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">QMenu menu</span><span style="color: #89DDFF">;</span></span>
<span class="line"><span style="color: #82AAFF">connect</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">menu</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">QMenu</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">triggered</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">this,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">Widget</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">onMenuTriggered</span><span style="color: #89DDFF">);</span></span></code></pre></div><ul>
<li>这里，<code>menu</code> 是一个栈上的 <code>QMenu</code> 对象。</li>
<li>栈上的对象在 <code>connect</code> 时会导致问题，因为 <code>connect</code> 期望信号发射对象在其生命周期内有效。栈上的对象会在超出作用域时被销毁。</li>
<li>在这个情况下，<code>menu</code> 可能在连接信号和槽时已经过早销毁，导致 <code>connect</code> 函数找不到有效的信号源。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>QMenu* menu</code>：指针允许动态管理对象的生命周期，<code>connect</code> 可以正常工作。</li>
<li><code>QMenu menu</code>：栈上的对象在超出作用域时可能被销毁，导致 <code>connect</code> 函数不能正确地处理信号和槽。</li>
</ul>
<p>因此，使用指针确保 <code>QMenu</code> 对象在 <code>connect</code> 调用期间有效。</p>
<p><img src="/../images/image-20240823104744847.png" alt="image-20240823104744847"></p>
<p><img src="/../images/image-20240823104804653.png" alt="image-20240823104804653"></p>
<p>定义对象的指针，让widght来管理对象的生命周期，要是直接定义对象，可能不知道什么时候对象就被销毁了，有些用到这些对象的函数就可能报错，因为在栈上找不到他了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Qt.html" data-id="cm040gf6300012ucx6mgg6k5d" data-title="Qt" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-risc-v" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/risc-v.html" class="article-date">
  <time class="dt-published" datetime="2024-06-18T04:31:10.000Z" itemprop="datePublished">2024-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/risc-v.html">risc_v</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240618123232143.png" alt="image-20240618123232143"></p>
<p>在RISC-V架构中，IF_ID和ID_EX是两个流水线寄存器，用于在指令执行过程中传递数据。</p>
<ol>
<li>IF_ID（Instruction Fetch to Instruction Decode）：IF_ID流水线寄存器用于在指令提取阶段（Instruction Fetch）和指令解码阶段（Instruction Decode）之间传递数据。它保存了从指令缓存中提取的指令，并将其传递给下一个阶段进行解码。</li>
<li>ID_EX（Instruction Decode to Execute）：ID_EX流水线寄存器用于在指令解码阶段（Instruction Decode）和指令执行阶段（Execute）之间传递数据。它保存了从IF_ID寄存器中解码得到的指令信息，包括操作码、寄存器地址等，并将这些信息传递给下一个阶段进行执行。</li>
</ol>
<p>通过使用这些流水线寄存器，RISC-V架构可以实现指令流水线的并行执行，提高指令的执行效率。</p>
<ol>
<li><strong>IF (Instruction Fetch) 取指</strong>：<ul>
<li>这一阶段的主要任务是从内存中的指令缓存或主存中取回当前要执行的指令。</li>
<li>在这个阶段，程序计数器（PC，Program Counter）会指向当前要取的指令地址。</li>
<li>CPU将该地址发给指令缓存，读取该地址处的指令，并将其存储到流水线寄存器（如IF&#x2F;ID寄存器）中，以便在下一阶段使用。</li>
</ul>
</li>
<li><strong>ID (Instruction Decode) 译码</strong>：<ul>
<li>这一阶段的主要任务是对取回的指令进行解码，即解析指令的操作码和操作数。</li>
<li>具体来说，CPU会读取并识别指令的操作码（Opcode），确定这条指令的类型和需要执行的操作。</li>
<li>同时，CPU还会确定指令所涉及的源操作数和目标寄存器。如果需要从寄存器文件中读取操作数，这一阶段也会执行这些操作。</li>
<li>解码后的信息会存储在流水线寄存器（如ID&#x2F;EX寄存器）中，以便在后续的执行阶段使用。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/risc-v.html" data-id="cm03k1yqc0001gycx8zxxb5cx" data-title="risc_v" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-raytracing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/raytracing.html" class="article-date">
  <time class="dt-published" datetime="2024-06-12T08:08:14.000Z" itemprop="datePublished">2024-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/raytracing.html">raytracing</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 C++ 中，冒号（<code>:</code>）用于初始化类的成员变量或调用父类的构造函数。这种语法称为成员初始化列表（member initialization list），它允许在构造函数体执行之前对成员变量进行初始化。</p>
<p>在这里，<code>vec3() : e&#123;0,0,0&#125; &#123;&#125;</code> 中的冒号后面就是成员初始化列表。<code>: e&#123;0,0,0&#125;</code> 表示对类的成员变量 <code>e</code> 进行初始化，其中 <code>&#123;0,0,0&#125;</code> 是对数组 <code>e</code> 的初始化值。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">double&amp; operator[](int i) &#123; return e[i]; &#125;</span></span></code></pre></div><p><strong><code>double&amp;</code></strong>:</p>
<ul>
<li>返回类型是 <code>double&amp;</code>，即返回一个 <code>double</code> 类型的左值引用。</li>
<li>左值引用允许函数返回一个可修改的元素，这样调用者可以直接修改这个元素。</li>
</ul>
<h3 id="左值和右值的定义"><a href="#左值和右值的定义" class="headerlink" title="左值和右值的定义"></a>左值和右值的定义</h3><ul>
<li><strong>左值（lvalue）</strong>: 可以取地址的值，通常表示内存中的一个位置。例如，变量、数组元素、对象成员等都是左值。</li>
<li><strong>右值（rvalue）</strong>: 不存在明确地址的临时值，通常是表达式的结果或者字面量。例如，字面量、临时对象、运算结果等。</li>
</ul>
<p>引用和原变量本质上是同一个东西，对引用的修改就是对原变量的修改</p>
<p><code>double&amp;</code> 表示引用</p>
<p><code>inline</code> 关键字在C++中用于建议编译器将某个函数的代码在每次调用时直接插入到调用处，而不是进行常规的函数调用。从而可以减少函数调用的开销，尤其是当函数体非常小、调用频繁时，这种优化可能会带来性能提升。</p>
<p><code>using color = vec3;</code> 这行代码是一个类型别名（type alias）的定义，将 <code>vec3</code> 类型重命名为 <code>color</code> 类型。也就是说，使用 <code>color</code> 关键字可以代替 <code>vec3</code> 类型的使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/raytracing.html" data-id="clxbjvuxs000j61cxdrun7t8l" data-title="raytracing" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-FOC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/FOC.html" class="article-date">
  <time class="dt-published" datetime="2024-05-28T23:30:54.000Z" itemprop="datePublished">2024-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/FOC.html">FOC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>可以看出，我们只需要像步进电机那样不断的重复这六部换向就可以让BLDC转动起来，甚至会产生一种错觉，是不是我们换向越快电机转的越快呢？答案是:否，这里我们一定要认识到，是当转子处于特定位置时才去触发换向操作，换向是被动换向，想要提高转速一定是要提高电流，让定子产生的磁场更强，让转子更快的达到目标点然后触发换向</p>
<p>如何获得转子角度？<br>我们已经知道了要先检测角度再去换向，那么如何检测当前角度呢？，有以下三种方式。<br>1.通过安装编码器来计算出当前角度。<br>2.通过安装霍尔元件计算当前角度。<br>3.通过检测电流来计算当前角度</p>
<p>编码器方式获取电机当前角度<br>编码器方式分为两种，增量式编码器和绝对式编码器。<br>增量式编码器：<br>每次启动之气都需要做一次校准，而且为了防止单片机性能问题导致脉冲丢失，还需要对编码器每圈校准一次。因此经常使用ABZ三轴编码器，AB输出正交信号，Z轴输出中断。<br>绝对式编码器：<br>只需要在出厂之前做一次校准，之后如果没有拆机便不需要校准，通讯方式一般是SPI和IIC,需要考虑通讯时间对系统的影响。<br>为什么要对编码器进行校准？<br>因为我们无法保证在安装的时候让编码器的0°（机械角度）刚好对应电机绕组的0°（电气角度）</p>
<p><img src="/../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTQ3MzI5,size_16,color_FFFFFF,t_70#pic_center.png" alt="img"></p>
<p>伸开左手，使拇指与其他四指垂直且在一个平面内，让磁感线从手心流入，四指指向电流方向，大拇指指向的就是安培力方向（即导体受力方向）</p>
<p><img src="/../images/resize,m_lfit,limit_1,w_536.jpeg" alt="img"></p>
<p>右手平展，使大拇指与其余四指垂直，并且都跟手掌在一个平面内。把右手放入磁场中，让<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=526702&ss_c=ssc.citiao.link">磁感线</a>从掌心进入（当磁感线为直线时，相当于手心面向N极），大拇指指向导线运动方向，则四指所指方向为导线中感应电流（动生电动势）的方向。</p>
<p><img src="/../images/image-20240529094507089.png" alt="image-20240529094507089"></p>
<p>根据想得到的电流矢量到u1,u2,u3上投影的正负，来判断在哪个扇区里，u1,u2,u3可由u_alpha,u_beta表示出</p>
<p><img src="/../images/image-20240529130329149.png" alt="image-20240529130329149"></p>
<p><img src="/../images/image-20240529130513189.png" alt="image-20240529130513189"></p>
<p><img src="/../images/image-20240529144317410.png" alt="image-20240529144317410"></p>
<p><img src="/../images/image-20240529144120858.png" alt="image-20240529144120858"></p>
<p><img src="/../images/image-20240529144220989.png" alt="image-20240529144220989"></p>
<p><img src="/../images/image-20240530115230681.png" alt="image-20240530115230681"></p>
<p>从定子来计算</p>
<p><img src="/../images/image-20240530115639643.png" alt="image-20240530115639643">可以计算出反电动势，进而计算转子的速度和位置（无感)</p>
<p>当变压器的初级绕组通电后，线圈所产生的磁通在铁心流动，因为铁心本身也是导体（由硅钢片制成），在垂直于磁力线的平面上就会感应电势，这个电势在铁心的断面上形成闭合回路并产生电流，好象一个旋涡所以称为“涡流”。这个“涡流”使变压器的损耗增加，并且使变压器的铁心发热变压器的温升增加。由“涡流”所产生的损耗我们称为“铁损”。<br>另外要绕制变压器需要用大量的铜线，这些铜导线存在着电阻，电流流过时这电阻会消耗一定的功率，这部分损耗往往变成热量而消耗，我们称这种损耗为“铜损”。<br>铁损等于铜损时，变压器效率最高。大概就是变压器额定负荷的0.65倍左右。</p>
<p>从绕组来计算（d,q,轴的电压方程）</p>
<p><img src="/../images/image-20240530130008389.png" alt="image-20240530130008389"></p>
<p>由于定子自感的属性，电流会滞后电压90度</p>
<p><img src="/../images/image-20240530180512850.png" alt="image-20240530180512850"></p>
<p><img src="/../images/image-20240530180534254.png" alt="image-20240530180534254"></p>
<p>要等幅变换，所以要乘（2&#x2F;3）</p>
<p>如果遇到乘(根号下2&#x2F;3),是等功率变换</p>
<p><img src="/../images/image-20240530181152049.png" alt="image-20240530181152049"></p>
<p><img src="/../images/image-20240530193807755.png" alt="image-20240530193807755"></p>
<p><img src="/../images/image-20240530193832651.png" alt="image-20240530193832651"></p>
<p>反帕克变换就是对帕克变换旋转矩阵求逆</p>
<p>MOS管是电压驱动型，三极管是电流驱动型</p>
<p><img src="/../images/image-20240531080240566.png" alt="image-20240531080240566"></p>
<p><img src="/../images/image-20240531102816686.png" alt="image-20240531102816686"></p>
<p>电角度&#x3D;极对数（或者<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%A7%E6%95%B0&spm=1001.2101.3001.7020">级数</a>&#x2F;2）*机械角度</p>
<p><img src="/../images/image-20240531110753146.png" alt="image-20240531110753146"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/FOC.html" data-id="clxbjvuxp000761cx4xv48vr8" data-title="FOC" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-openmv" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/openmv.html" class="article-date">
  <time class="dt-published" datetime="2024-05-20T06:46:47.000Z" itemprop="datePublished">2024-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/openmv.html">openmv</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240520144720306.png" alt="image-20240520144720306"></p>
<p><img src="/../images/image-20240520144755468.png" alt="image-20240520144755468"></p>
<p>安装库<strong>libxcb-cursor.so.0，</strong></p>
<div class="language-bash"><button title="Copy code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #FFCB6B">sudo</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">apt</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">install</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">libxcb-cursor0</span></span></code></pre></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/openmv.html" data-id="clxbjvuxr000h61cxfy7lffir" data-title="openmv" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OpenGL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/OpenGL.html" class="article-date">
  <time class="dt-published" datetime="2024-05-17T08:51:10.000Z" itemprop="datePublished">2024-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/OpenGL.html">OpenGL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240517165248939.png" alt="image-20240517165248939"></p>
<p><img src="/../images/image-20240517165400128.png" alt="image-20240517165400128"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiujiubashiyi/p/16429717.html">https://www.cnblogs.com/jiujiubashiyi/p/16429717.html</a></p>
<p>GLFW,GLAD,opengl是什么，有什么联系</p>
<p>GLFW、GLAD和OpenGL是计算机图形学中常用的三个库，它们之间存在着紧密的联系：</p>
<ol>
<li><strong>OpenGL</strong>：是一个跨语言、跨平台的编程接口，用于渲染2D、3D向量图形。它是由硅谷图形公司（Silicon Graphics,  SGI）在1992年开发的。OpenGL是图形硬件制造商的标准，也是创作高质量计算机图形的基本工具。OpenGL提供了一个非常灵活的编程接口，让开发者能够利用它来渲染图形。</li>
<li><strong>GLFW</strong>：是一个跨平台的OpenGL应用程序接口（API）的多线程窗口和输入管理器。简单来说，GLFW用来创建窗口、处理输入事件（如键盘、鼠标点击等），并管理OpenGL上下文。它使得开发者可以比较容易地创建一个OpenGL环境，因为它简化了OpenGL程序中许多繁琐的设置步骤。</li>
<li><strong>GLAD</strong>：是一个自动生成OpenGL函数指针的库。在OpenGL中，许多操作需要通过指针来调用函数，而在不同的操作系统和硬件平台上，这些函数指针的位置可能会有所不同。GLAD就是用来处理这些函数指针的，它会根据当前的平台和OpenGL的版本自动生成对应的函数指针。这为开发者减少了处理这些底层细节的麻烦。</li>
</ol>
<p><strong>它们之间的联系</strong>：</p>
<ul>
<li>使用OpenGL之前，需要创建一个OpenGL环境，这个环境包括一个窗口以及一个上下文，这是通过GLFW来完成的。</li>
<li>GLAD用来确保所有的OpenGL函数调用都能够正确地指向相应的函数，这样开发者就不需要手动查找和设置这些函数指针了。</li>
<li>通常，一个OpenGL程序的设置流程是这样的：首先初始化GLFW，然后使用GLFW创建一个窗口和OpenGL上下文，接着使用GLAD自动加载OpenGL函数，最后就可以开始使用OpenGL进行绘图了。</li>
</ul>
<p>综上，GLFW和GLAD都是帮助开发者更简单、更有效地使用OpenGL的辅助工具。通过它们，开发者可以专注于图形内容的创作，而不必担心底层的细节问题。</p>
<p>glfwMakeContextCurrent(window);是什么意思</p>
<p><code>glfwMakeContextCurrent(window);</code> 是一行来自 GLFW（OpenGL Framework）库的代码。GLFW 是一个跨平台的库，用于窗口和输入处理，它使得创建 OpenGL 应用程序变得更加容易。</p>
<p>这句代码的作用是将 OpenGL 渲染上下文关联到由 <code>window</code> 参数指定的窗口。在 OpenGL 中，渲染上下文是用来进行图形绘制的环境，它定义了一系列可以用来配置和控制渲染行为的设置。</p>
<p>在创建窗口之后，必须调用 <code>glfwMakeContextCurrent</code> 函数来指定哪个窗口的上下文将被当前的线程使用。只有当前上下文中的 OpenGL 调用才会对指定的窗口产生影响。如果没有激活任何上下文，任何 OpenGL 调用都会导致错误。</p>
<p>简单来说，当你想要在特定的窗口上绘制图形时，你需要确保该窗口的 OpenGL 上下文被设置为当前上下文。这就是 <code>glfwMakeContextCurrent(window);</code> 这行代码的目的。</p>
<p>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress) 是什么意思</p>
<p><code>gladLoadGLLoader</code> 是一个函数，通常在 C 或 C++ 程序中使用，用于初始化 OpenGL 函数指针。OpenGL 是一个用于渲染2D和3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。<code>gladLoadGLLoader</code> 函数是 GLAD 库的一部分，GLAD 是一个小型且易于使用的库，它负责在每次调用 OpenGL 函数之前，动态地加载和绑定正确的 OpenGL 函数指针。</p>
<p><code>glfwGetProcAddress</code> 是另一个函数，属于 GLFW 库（一个用于创建窗口、输入处理等的前端库，常与OpenGL一起使用）。<code>glfwGetProcAddress</code> 的作用是获取指向特定OpenGL函数的指针，该函数在OpenGL核心或者扩展中定义。</p>
<pre><code>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)
</code></pre>
<p>这表示在初始化GLAD库时，它将使用GLFW库提供的函数指针来加载OpenGL函数。这允许应用程序使用OpenGL函数，而不需要关心底层的具体实现细节。</p>
<p>这种机制的好处是，应用程序只需要链接到一个库（比如GLFW），而GLFW会负责查找和加载正确的OpenGL函数。这样做可以简化应用程序的编写和维护工作，同时也确保了应用程序可以轻松地与不同平台的OpenGL版本兼容。</p>
<p><strong>双缓冲(Double Buffer)</strong></p>
<p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p>
<ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li>
</ul>
<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素.3D坐标转为2D坐标的处理过程是由OpenGL的<strong>图形渲染管线</strong>（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。(图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出)</p>
<p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做<strong>着色器</strong>(Shader)。</p>
<p><strong>OpenGL着色器</strong>是用OpenGL着色器语言(OpenGL Shading Language, <strong>GLSL</strong>)写成的</p>
<p><img src="/../images/pipeline.png" alt="img"></p>
<p>为了让OpenGL知道我们的<strong>坐标和颜色值</strong>构成的到底是什么，OpenGL需要你去指定这些数据所表示的<strong>渲染类型</strong>。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做**图元(Primitive)**，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</p>
<p><strong>图形渲染管线的第一个部分</strong>—-<strong>顶点着色器</strong></p>
<p>把3D坐标转为另一种3D坐标</p>
<p><strong>几何着色器</strong></p>
<p>一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状</p>
<p><strong>图元装配</strong></p>
<p>将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状</p>
<p><strong>光栅化阶段</strong></p>
<p>把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的**片段(Fragment)**。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<p>OpenGL中的一个<strong>片段</strong>是OpenGL渲染一个像素所需的所有数据</p>
<p><strong>片段着色器</strong></p>
<p>片段着色器的主要目的是计算一个像素的最终颜色</p>
<p><strong>Alpha测试和混合(Blending)阶段</strong></p>
<p>这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同</p>
<p><code>GL_ARRAY_BUFFER</code>目标用于表示顶点属性数据的缓冲区对象</p>
<p>在OpenGL中，VAO（Vertex Array Object）和VBO（Vertex Buffer Object）是用于管理顶点数据的重要概念，并且它们之间存在一定的关系。</p>
<ol>
<li>VAO（Vertex Array Object）：<ul>
<li>VAO是OpenGL中用于存储顶点属性状态的对象。它包含了多个指向VBO的指针，用于指定顶点属性数据的格式、排列方式等。</li>
<li>VAO可以看作是对VBO的管理器，它记录了OpenGL如何解释顶点数据，包括顶点的位置、颜色、法线等信息。通过绑定VAO，可以轻松地切换顶点属性的设置，从而简化渲染流程。</li>
</ul>
</li>
<li>VBO（Vertex Buffer Object）：<ul>
<li>VBO是用于存储顶点数据的缓冲区对象。它可以存储顶点的位置、颜色、纹理坐标等信息。</li>
<li>通过将顶点数据存储在VBO中，可以有效地管理和传输大量的顶点数据，而不必反复传输到GPU。</li>
</ul>
</li>
</ol>
<p>关系：</p>
<ul>
<li>VBO存储了实际的顶点数据，例如顶点的位置、颜色、纹理坐标等。</li>
<li>VAO描述了顶点数据的格式和布局，它指明了如何从VBO中读取顶点数据以供渲染使用。</li>
<li>通常情况下，我们先创建和绑定VAO，然后配置相应的VBO，并将VBO与VAO关联。这样，在渲染时只需绑定相应的VAO即可，OpenGL就会根据VAO中的配置自动获取正确的顶点数据进行渲染。</li>
</ul>
<p>总结来说，VAO用于管理顶点属性状态，而VBO用于存储实际的顶点数据。它们共同协作，使得在OpenGL中管理和使用顶点数据变得更加灵活和高效。</p>
<p>我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）</p>
<p>着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p>
<p>Uniform是另一种从我们的应用程序在 CPU 上传递数据到 GPU 上的着色器的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>
<p>在OpenGL中，VBO（Vertex Buffer Object）和VAO（Vertex Array Object）都是用于管理顶点数据的对象。它们之间的联系和区别如下：</p>
<p>联系：</p>
<ul>
<li>VBO和VAO都是用于管理顶点属性数据的对象。</li>
<li>它们都可以通过OpenGL API进行创建、绑定、更新和删除等操作。</li>
<li>VAO可以保存多个VBO的绑定状态，使得我们在绘制时只需绑定VAO即可同时启用多个顶点属性数组。</li>
</ul>
<p>区别：</p>
<ul>
<li>VBO是用于存储和管理顶点数据的缓冲对象，包括顶点位置、法线、颜色、纹理坐标等属性数据。它能够提高渲染效率，因为可以将这些数据上传到显卡内存中，而不需要每次绘制时都从系统内存中获取。</li>
<li>VAO是用于管理VBO的绑定状态的对象，它记录了VBO的绑定状态以及每个属性在VBO中的偏移量、类型等信息。VAO可以看作是一组VBO的绑定描述符，它规定了如何从VBO中获取顶点属性数据。</li>
</ul>
<p>总体来说，VBO和VAO在OpenGL中都扮演着非常重要的角色，它们都可以提高渲染效率，使得开发者可以更加方便地管理和操作顶点属性数据。其中，VBO主要用于存储和管理顶点数据，而VAO则是用于在绘制时快速激活和绑定多个顶点属性数组。</p>
<p>把两个角度都发送</p>
<p>试一下发后两个数据，看看是不是数据的问题</p>
<p>试试发5个</p>
<p><img src="/../images/image-20240603155209855.png" alt="image-20240603155209855">2024.6.3.15.52Matlab报错，遂改，无用！！！！</p>
<p>艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节.这样就可以让物体非常精细而不用指定额外的顶点</p>
<p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p>
<p>使用 Xlib 来获取窗口大小需要一些底层的操作，但可以通过以下步骤来实现：</p>
<p>首先，你需要安装 <code>python-xlib</code> 库。你可以使用以下命令在 Ubuntu 上安装：</p>
<pre><code class="bash">sudo apt-get install python-xlib
</code></pre>
<p>然后，你可以使用下面的代码来获取当前活动窗口的大小：</p>
<pre><code class="python">from Xlib import display

def get_screen_size():
    disp = display.Display()
    screen = disp.screen()
    root_win = screen.root
    windowID = root_win.get_full_property(disp.intern_atom(&#39;_NET_ACTIVE_WINDOW&#39;), 0).value[0]
    window = disp.create_resource_object(&#39;window&#39;, windowID)
    geometry = window.get_geometry()
    return geometry.width, geometry.height

width, height = get_screen_size()
print(&quot;Window size: &#123;&#125; x &#123;&#125;&quot;.format(width, height))
</code></pre>
<p>这段代码中，我们首先创建了一个 <code>Display</code> 对象，然后获取了当前活动窗口的 ID。接着，我们使用这个窗口 ID 创建了一个 <code>window</code> 对象，并通过这个对象的 <code>get_geometry</code> 方法获取了窗口的宽度和高度。</p>
<p>请注意，使用 Xlib 需要对 X 窗口系统有一定的了解，因为它是一个底层的库，直接和 X 服务器进行交互。希望这个示例能够帮助你开始使用 Xlib 来获取窗口大小。</p>
<ul>
<li><code>layout(location=0)</code>: 这是一个着色器布局限定符（layout qualifier），用于指定顶点属性在输入阶段的位置。在这里，<code>location=0</code> 表示顶点属性的位置索引为 0。这个位置索引将与顶点数组对象（VAO）中的对应属性绑定，以确保正确地将顶点数据传递给顶点着色器。</li>
<li><code>in</code>: 这是一个输入变量修饰符，用于指示这个变量是从外部传递给顶点着色器的。</li>
<li><code>vec3</code>: 这是指定变量类型的关键字，表示这个变量是一个三维向量。</li>
<li><code>in_position</code>: 这是变量的名称，用于在顶点着色器中引用这个输入变量。在这里，<code>in_position</code> 可能表示顶点的位置信息。</li>
</ul>
<p>在OpenGL中，<code>gl_Position</code>是一个内置的变量，用于表示顶点着色器（Vertex Shader）输出的顶点位置。它是一个四维向量（<code>vec4</code>），表示顶点的齐次坐标（Homogeneous Coordinates），通常用于表示三维空间中的点。齐次坐标是四维的，其中前三个分量表示点的位置，而第四个分量通常被用于表示点的类型或者进行透视除法（Perspective Division）。在顶点着色器中，对 <code>gl_Position</code> 的设置将影响后续的图元装配（Primitive Assembly）和光栅化（Rasterization）阶段，最终确定绘制的像素位置。因此，正确设置 <code>gl_Position</code> 是绘制正确图形的关键。</p>
<p>[[ 0.5  0.5  0.   0.   1.   0. ]<br> [-0.5  0.5  0.   1.   0.   0. ]<br> [-0.5 -0.5  0.   0.   0.   1. ]<br> [ 0.5  0.5  0.   0.   1.   0. ]<br> [-0.5 -0.5  0.   0.   0.   1. ]<br> [ 0.5 -0.5  0.   1.   0.   0. ]]</p>
<pre><code>layout(location=0) in vec3 in_position;
layout(location=1) in vec3 in_color;
</code></pre>
<pre><code>self.vbo_format = &#39;3f 3f&#39;
self.attrs = (&#39;in_position&#39;, &#39;in_color&#39;)
</code></pre>
<pre><code>vertex_data = np.hstack([vertices_array, colors_array])
</code></pre>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p><img src="/../images/image-20240608192337289.png" alt="image-20240608192337289"></p>
<h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p><img src="/../images/image-20240608192358635.png" alt="image-20240608192358635"></p>
<p>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p>
<ul>
<li>弧度转角度：<code>角度 = 弧度 * (180.0f / PI)</code></li>
<li>角度转弧度：<code>弧度 = 角度 * (PI / 180.0f)</code></li>
</ul>
<p><img src="/../images/image-20240608192525938.png" alt="image-20240608192525938"></p>
<p>我这一辈子，抠抠搜搜的花了很多钱，精精明明的上了很多当。骂骂咧咧的干了很多活，小心翼翼的闯了很多祸。精打细算的欠了一屁股帐。认认真真的范了很多错。掏心掏肺的结了很多仇。不明不白的吃了很多亏。窝窝囊囊的活了几十年。</p>
<ol>
<li><code>glm::mat4 trans;</code>：首先声明了一个4x4的矩阵trans，用于表示变换矩阵。</li>
<li><code>trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));</code>：这一行代码对trans进行了旋转变换。使用了glm库中的rotate函数，将trans矩阵绕Z轴旋转90度（使用radians函数将角度转换为弧度），并将结果赋值给trans本身。</li>
<li><code>trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));</code>：接着对trans进行了缩放变换。使用了glm库中的scale函数，将trans矩阵沿着X、Y、Z三个轴分别缩放0.5倍，并将结果再次赋值给trans本身。</li>
</ol>
<ul>
<li>局部空间(Local Space，或者称为物体空间(Object Space))</li>
<li>世界空间(World Space)</li>
<li>观察空间(View Space，或者称为视觉空间(Eye Space))</li>
<li>裁剪空间(Clip Space)</li>
<li>屏幕空间(Screen Space)</li>
</ul>
<p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕</p>
<p>坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p>
<p><img src="/../images/coordinate_systems.png" alt="coordinate_systems"></p>
<ol>
<li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li>
<li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li>
<li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>
<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li>
<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li>
</ol>
<p>你可能已经大致了解了每个坐标空间的作用。我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。</p>
<h2 id="局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间-摄像机空间-———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间"><a href="#局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间-摄像机空间-———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间" class="headerlink" title="局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间"></a>局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间</h2><p><img src="/../images/image-20240609164419389.png" alt="image-20240609164419389"></p>
<p><img src="/../images/image-20240609164929887.png" alt="image-20240609164929887"></p>
<p><img src="/../images/image-20240609165058873.png" alt="image-20240609165058873"></p>
<p><img src="/../images/image-20240609211854570.png" alt="image-20240609211854570"></p>
<p><img src="/../images/image-20240609212927721.png" alt="image-20240609212927721"></p>
<p><img src="/../images/image-20240609213514370.png" alt="image-20240609213514370"></p>
<p>glm::LookAt函数需要一个位置、目标和上向量。它会创建一个观察矩阵。</p>
<p>为了改变摄像机方向</p>
<p><img src="/../images/image-20240609221012736.png" alt="image-20240609221012736"></p>
<p><code>self.m_projection=glm.perspective(V_FOV,ASPECT_RATIO,NEARPLANE,FARPLANE)</code></p>
<p>使用 GLM 库中的 <code>glm::perspective()</code> 函数创建了一个投影矩阵（projection matrix）.会根据给定的参数创建一个透视投影矩阵，并返回这个矩阵。这个投影矩阵描述了从摄像机位置观察场景时的投影效果，将三维场景转换为二维屏幕空间</p>
<p><img src="/../images/image-20240610000155256.png" alt="image-20240610000155256"></p>
<p>对连续时间正弦信号考虑下面表示式：<br>x ( t ) &#x3D; s i n ( 2 π f 0 t + φ )<br>可以按抽样频率 fs&#x3D;1&#x2F;Ts对 x(t)抽样来获得离散时间信号<br>x [ n ] &#x3D; x ( t )|t &#x3D;nTs       &#x3D;  x ( t ) |t&#x3D;n &#x2F; fs &#x3D; s i n ( 2 πf0 &#x2F;fsn + φ ),<br>f0 &#x3D;500Hz， fs 取 100Hz， 绘出 x[n]及其 DTFT</p>
<p><img src="/../images/image-20240611133720092.png" alt="image-20240611133720092"></p>
<p><img src="/../images/image-20240611133805550.png" alt="image-20240611133805550"></p>
<p><img src="/../images/image-20240611133838091.png" alt="image-20240611133838091"></p>
<p><img src="/../images/image-20240611140046801.png" alt="image-20240611140046801"></p>
<p>以 5000HZ 和 1000HZ 分别对其采样得到 x1(n)， x2(n)；画出它们的 DTFT 并比较</p>
<p><img src="/../images/image-20240611140651535.png" alt="image-20240611140651535"></p>
<p><img src="/../images/image-20240611141635271.png" alt="image-20240611141635271"></p>
<p>我们可以从第一个方程中直接得到 A 和 φ 的关系：</p>
<p><img src="/../images/image-20240611141659727.png" alt="image-20240611141659727"></p>
<p>φ ！&#x3D;π&#x2F;2+kπ</p>
<p>x(t)&#x3D;2cos(π&#x2F;3 *t)</p>
<p><img src="/../images/image-20240611143342649.png" alt="image-20240611143342649"></p>
<p><img src="/../images/image-20240611143614094.png" alt="image-20240611143614094"></p>
<p><img src="/../images/image-20240611144943071.png" alt="image-20240611144943071"></p>
<p><img src="/../images/image-20240611145404898.png" alt="image-20240611145404898"></p>
<p>现实中无法实现理想低通滤波器。然而，可以按下面的方法计算由理想低通滤波器产生的<br>波形：理想低通运算相当于信号频谱与频域的矩形函数相乘，这对应于信号与通过傅里叶逆变<br>换得到的时域 sinc 函数的卷积。当其应用于点样本时，卷积和为 sinc 函数内插：</p>
<p>xa(t)&#x3D;sum_{n&#x3D;-无穷}^{正无穷} [xa(nt) sin(π(t-nTs)&#x2F;Ts)&#x2F;(π(t-nTs)&#x2F;Ts)]</p>
<p>(3.18)<br>其中，样本 xa(nt)取自 t&#x3D; nTs处。<br>a. 假设只有有限数量的信号样本是非零值，且只需在有限时间区间上进行信号重建，写出<br>基于(3.18)式的 sinc 内插表示式。</p>
<p><code>syms t n Ts xa;</code></p>
<p><code>xa_t = symsum(xa * sin(pi*(t-n*Ts)/Ts)/(pi*(t-n*Ts)/Ts), n, -inf, inf);</code></p>
<p><img src="/../images/image-20240611153315884.png" alt="image-20240611153315884"></p>
<p>C：<br><img src="/../images/image-20240611155005492.png" alt="image-20240611155005492"></p>
<p>根据奈奎斯特采样定理，要求 fs≥2fbfs≥2fb 以避免混叠现象。因此，fb&lt;fs2fb&lt;2fs 是满足采样定理的条件。</p>
<p><img src="/../images/image-20240613162635475.png" alt="image-20240613162635475"></p>
<p>45HZ，基本周期 T是 1&#x2F;45</p>
<p><img src="/../images/image-20240613160828062.png" alt="image-20240613160828062"></p>
<h3 id="结果分析与总结"><a href="#结果分析与总结" class="headerlink" title="结果分析与总结"></a>结果分析与总结</h3><ol>
<li><strong>分析长度 ( 0.5T_p &#x3D; 0.1 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率较低，频率成分不清晰，可能会导致频率混淆。</li>
<li>由于分析长度小于一个周期，频谱分析结果可能包含较多的谐波失真和旁瓣效应。</li>
</ul>
</li>
<li><strong>分析长度 ( 1.5T_p &#x3D; 0.3 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率有所提高，主要频率成分变得更加明显。</li>
<li>由于分析长度超过一个周期，频谱分析结果更加准确，频率成分容易识别。</li>
</ul>
</li>
<li><strong>分析长度 ( 2T_p &#x3D; 0.4 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率进一步提高，主要频率成分非常清晰。</li>
<li>更长的分析长度提供了更好的频率分辨率，但同时也增加了计算时间和资源需求。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>选择合适的分析长度</strong>：分析长度可以通过基本周期 ( T_p ) 的整数倍来选择。一般来说，分析长度至少应等于或大于一个周期 ( T_p )，这样可以确保频谱分析结果的准确性。</li>
<li><strong>平衡分辨率和计算复杂度</strong>：较长的分析长度提供更好的频率分辨率，但也会增加计算时间和资源。在实际应用中，需要在频率分辨率和计算复杂度之间取得平衡。</li>
<li><strong>避免过短的分析长度</strong>：过短的分析长度（例如小于一个周期）可能导致频谱结果混乱，难以准确识别主要频率成分</li>
</ul>
<p><img src="/../images/image-20240613161203147.png" alt="image-20240613161203147"></p>
<p>你可以看到，白色的阳光实际上是所有可见颜色的集合，物体吸收了其中的大部分颜色。它仅反射了代表物体颜色的部分，被反射颜色的组合就是我们所感知到的颜色（此例中为珊瑚红）。</p>
<p>这些颜色反射的定律被直接地运用在图形领域。当我们在OpenGL中创建一个光源时，我们希望给光源一个颜色。在上一段中我们有一个白色的太阳，所以我们也将光源设置为白色。当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色（也就是我们所感知到的颜色）。让我们再次审视我们的玩具（这一次它还是珊瑚红），看看如何在图形学中计算出它的反射颜色。我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量了：</p>
<pre><code class="c++">glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
glm::vec3 toyColor(1.0f, 0.5f, 0.31f);
glm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f);
</code></pre>
<p>我们可以看到玩具的颜色<strong>吸收</strong>了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，我们可以定义物体的颜色为&#x3D;&#x3D;<strong>物体从一个光源反射各个颜色分量的大小</strong>。&#x3D;&#x3D;</p>
<p>**现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为冯氏光照模型(Phong Lighting Model)。冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。下面这张图展示了这些光照分量看起来的样子：</p>
<p><img src="/../images/basic_lighting_phong.png" alt="img"></p>
<ul>
<li>环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li>
<li>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。</li>
<li>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>
</ul>
<p>在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体进行任何缩放操作，所以我们并不真的需要使用一个法线矩阵，而是仅以模型矩阵乘以法线就可以。但是如果你会进行不等比缩放，使用法线矩阵去乘以法向量就是必须的了。</p>
<p><img src="/../images/image-20240618134143162.png" alt="image-20240618134143162"></p>
<p><img src="/../images/image-20240618134913056.png" alt="image-20240618134913056"></p>
<p><img src="/../images/image-20240618135228887.png" alt="image-20240618135228887"></p>
<p><img src="/../images/image-20240618135413787.png" alt="image-20240618135413787"></p>
<p>已知周期信号 <em>x</em>(<em>t</em>) &#x3D; 0.75 + 3.4 cos 2πft + 2.7 cos 4<em>π</em> <em>ft</em> +1.5sin 3.5<em>π</em> <em>ft</em> + 2.5sin 7<em>π</em> <em>ft</em>  ，其<br>中 25&#x2F;16Hz,若截断时间长度分别为信号周期的 0.9 和 1.1 倍，试分别绘制这八种窗函数<br>提取的 x(t)的频谱。</p>
<p><img src="/../images/image-20240618141855717.png" alt="image-20240618141855717"></p>
<p>根据下列指标采用窗函数法设计低通数字滤波器， 通带截止频率wp&#x3D; 0.2π ，阻带截止频率</p>
<p>ws &#x3D; 0.3π，通带最大衰减 0.25dB，阻带最小衰减 50dB。</p>
<p>（1） 分别利用汉明窗、布莱克曼窗和凯泽窗设计该滤波器，且滤波器具有线性相位。绘出脉冲响应 h(n)及滤波器的频率响应；</p>
<p>（2） 增加 N，观察过渡带和最大肩峰值的变化。</p>
<p>利用汉明窗设计数字微分器</p>
<p>Hd(e^jw)&#x3D;</p>
<p>jw,0&lt;w&lt;π;</p>
<p>-jw,-π&lt;w&lt;0.</p>
<p>要求 <em>N</em> &#x3D; 21，且滤波器具有线性相位。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/OpenGL.html" data-id="clxbjvuxq000c61cx46uggxj5" data-title="OpenGL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CUDA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/CUDA.html" class="article-date">
  <time class="dt-published" datetime="2024-05-14T04:45:58.000Z" itemprop="datePublished">2024-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/CUDA.html">CUDA</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240514124728144.png" alt="image-20240514124728144"></p>
<p>PCIe传输速率比较慢</p>
<p><img src="/../images/image-20240514125248067.png" alt="image-20240514125248067"></p>
<p><img src="/../images/image-20240514134619194.png" alt="image-20240514134619194"></p>
<p><img src="/../images/image-20240514163840122.png" alt="image-20240514163840122"></p>
<p><img src="/../images/image-20240514164819180.png" alt="image-20240514164819180"></p>
<p>CPU启动核函数之后，由这个核函数在GPU设备里产生的所有的线程构成了一个grid(网格)</p>
<p>而一个grid又由多个线程块（block）组成，一个线程块里包含一组线程（thread）</p>
<p>进行CUDA编程时，要做的就是减少计算核心空闲的时间，让计算核心一直处于计算中</p>
<p>CPU，GPU在进行内存相互访问的时候，会很耗时</p>
<p><img src="/../images/image-20240514170821304.png" alt="image-20240514170821304"></p>
<p><img src="/../images/image-20240514200242464.png" alt="image-20240514200242464"></p>
<p><img src="/../images/image-20240514200453776.png" alt="image-20240514200453776"></p>
<p>一维：</p>
<p><img src="/../images/image-20240514215215578.png" alt="image-20240514215215578"></p>
<p><img src="/../images/image-20240514214149999.png" alt="image-20240514214149999"></p>
<p>二维：</p>
<p><img src="/../images/image-20240514214513695.png" alt="image-20240514214513695"></p>
<p>三维：<br><img src="/../images/image-20240515094438706.png" alt="image-20240515094438706"></p>
<p><img src="/../images/image-20240515094525884.png" alt="image-20240515094525884"></p>
<p><img src="/../images/image-20240515095616319.png" alt="image-20240515095616319"></p>
<p>-arch和-code 都与GPU的兼容性有关，在指定计算能力的时候，GPU的真实架构计算能力一定要大于虚拟架构计算能力的</p>
<p><img src="/../images/image-20240515100052890.png" alt="image-20240515100052890"></p>
<p><img src="/../images/image-20240515100901251.png" alt="image-20240515100901251"></p>
<p><img src="/../images/image-20240515101949472.png" alt="image-20240515101949472"></p>
<p><img src="/../images/image-20240515102254655.png" alt="image-20240515102254655"></p>
<p><img src="/../images/image-20240515104802323.png" alt="image-20240515104802323"></p>
<p>即时编译，增加兼容性：</p>
<p><img src="/../images/image-20240515104350368.png" alt="image-20240515104350368"></p>
<p>两个都是compute_XY(虚拟)</p>
<p><img src="/../images/image-20240518093831448.png" alt="image-20240518093831448"></p>
<p><img src="/../images/image-20240518094156107.png" alt="image-20240518094156107"></p>
<p>在C++中，<code>exit(-1)</code> 和 <code>return -1</code> 都可以用来表示程序的异常退出或者返回一个错误码，但它们之间有一些重要的区别：</p>
<ol>
<li><code>exit(-1)</code> 是一个系统调用，它会立即终止整个程序的执行，并返回一个指定的退出码给操作系统。这会终止程序的执行并进行清理工作（如关闭文件、释放内存等），然后返回退出码。<code>exit</code> 函数是C标准库中的函数，定义在 <code>&lt;cstdlib&gt;</code> 头文件中。</li>
<li><code>return -1</code> 通常出现在函数中，用于从当前函数中返回一个指定的值。当函数的返回类型是整型时，<code>return -1</code> 将会将 -1 这个值返回给调用该函数的地方。如果 <code>-1</code> 是 <code>main</code> 函数的返回值，那么它会被返回给操作系统作为程序的退出码。</li>
</ol>
<p>因此，<code>exit(-1)</code> 会立即终止整个程序的执行，而 <code>return -1</code> 只是从当前函数中返回一个值。</p>
<p><img src="/../images/image-20240518101534052.png" alt="image-20240518101534052"></p>
<p><img src="/../images/image-20240518102522434.png" alt="image-20240518102522434">双指针</p>
<p><img src="/../images/image-20240518102902454.png" alt="image-20240518102902454"></p>
<p><img src="/../images/image-20240518103123516.png" alt="image-20240518103123516"></p>
<p><img src="/../images/image-20240518103306357.png" alt="image-20240518103306357"></p>
<p><code>cudaDeviceReset()</code>函数用于重置当前设备上的所有状态信息。它会清除当前设备上的所有内存分配和设备端的运行时状态，释放所有CUDA资源，并将设备状态恢复到初始化时的状态。这个函数通常在程序结束前被调用，以确保释放所有CUDA资源并将GPU状态还原到初始状态。</p>
<p>调用<code>cudaDeviceReset()</code>函数可以帮助确保程序结束时释放了所有CUDA资源，从而避免内存泄漏和其他问题。</p>
<p>在CUDA中，核函数（kernel function）和设备函数（device function）是两个不同的概念。</p>
<ol>
<li>核函数（Kernel Function）：<ul>
<li>核函数是在GPU上执行的并行函数，由关键字<code>__global__</code>声明。它们可以被从CPU代码调用，并在GPU上并行执行。在CUDA中，核函数通常用于执行大规模数据并行计算。</li>
</ul>
</li>
<li>设备函数（Device Function）：<ul>
<li>设备函数是在GPU上执行的函数，但它们只能被其他设备函数调用，不能从CPU代码中直接调用。设备函数通常用于封装重复使用的代码逻辑，以便在核函数中进行调用，以提高代码复用性和可读性。</li>
</ul>
</li>
</ol>
<p>虽然它们都是在GPU上执行的函数，但核函数和设备函数在调用方式、用途和作用域上有明显的区别。核函数是CUDA程序中由CPU代码调用的入口点，而设备函数是为了在核函数内部使用而设计的。</p>
<p><img src="/../images/image-20240518143353274.png" alt="image-20240518143353274"></p>
<p><img src="/../images/image-20240518145238232.png" alt="image-20240518145238232"></p>
<p><img src="/../images/image-20240518145441046.png" alt="image-20240518145441046"></p>
<p><code>__FILE__</code> 和 <code>__LINE__</code> 是C&#x2F;C++中的预定义宏，它们分别代表当前源文件的文件名和行号</p>
<p><img src="/../images/image-20240518152527144.png" alt="image-20240518152527144"></p>
<p><img src="/../images/image-20240524144504885.png" alt="image-20240524144504885"></p>
<p><code>%g</code> 是 C++ 语言中的格式化输出控制符之一，用于打印浮点数。它根据浮点数的值自动选择 <code>%f</code> 或 <code>%e</code> 中较短的一个输出形式来打印。</p>
<p>具体来说：</p>
<ul>
<li>如果浮点数的绝对值小于 0.0001 或者大于等于 10^6，<code>%g</code> 就会采用 <code>%e</code> 的输出形式，用科学计数法表示浮点数。</li>
<li>否则，<code>%g</code> 会采用 <code>%f</code> 的输出形式，用普通的小数形式表示浮点数。</li>
</ul>
<p>在 CUDA 编程中，<code>cudaEventQuery(start)</code> 表示查询事件 <code>start</code> 的状态。具体来说，它用于检查事件是否已经被记录。如果事件已经被记录，那么 <code>cudaEventQuery</code> 将立即返回。如果事件还没有被记录，那么 <code>cudaEventQuery</code> 将等待事件被记录后才返回。</p>
<p>在上述代码中，<code>cudaEventQuery(start)</code> 的目的可能是为了确保在记录 <code>stop</code> 事件之前，<code>start</code> 事件已经被成功记录。这样可以确保测量的时间间隔准确，避免了 <code>start</code> 事件尚未记录就立即记录 <code>stop</code> 事件的情况。</p>
<p><img src="/../images/image-20240524163028697.png" alt="image-20240524163028697"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/CUDA.html" data-id="clxbjvuxn000361cxbiegh8zs" data-title="CUDA" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Algo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Algo.html" class="article-date">
  <time class="dt-published" datetime="2024-04-26T01:35:42.000Z" itemprop="datePublished">2024-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Algo.html">Algo</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>由于实际测试具有较大的局限性，因此我们考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p>
<ul>
<li>“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。</li>
<li>“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。</li>
<li>“时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“<strong>快慢</strong>”。</li>
</ul>
<p>迭代（iteration）</p>
<p>递归（recursion）,通过函数调用自身来解决问题:（“将问题分解为更小子问题”）</p>
<ol>
<li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li>
<li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li>
</ol>
<p>而从实现的角度看，递归代码主要包含三个要素。</p>
<ol>
<li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li>
<li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li>
<li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li>
</ol>
<p>虽然从计算角度看，迭代与递归可以得到相同的结果，<strong>但它们代表了两种完全不同的思考和解决问题的范式</strong>。</p>
<ul>
<li><strong>迭代</strong>：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。</li>
<li><strong>递归</strong>：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。</li>
</ul>
<p>过深的递归可能导致栈溢出错误</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>有趣的是，<strong>如果函数在返回前的最后一步才进行递归调用</strong>，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。</p>
<ul>
<li><p><strong>普通递归</strong>：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。</p>
</li>
<li><p><strong>尾递归</strong>：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。</p>
<p>例如：</p>
<p>&#x2F;* 尾递归 *&#x2F;<br>int tailRecur(int n, int res) {<br>&#x2F;&#x2F; 终止条件<br>if (n &#x3D;&#x3D; 0)<br>    return res;<br>&#x2F;&#x2F; 尾递归调用<br>return tailRecur(n - 1, res + n);<br>}</p>
</li>
</ul>
<p><strong>普通递归</strong>：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">python</span></span>
<span class="line"><span style="color: #babed8">def factorial(n):</span></span>
<span class="line"><span style="color: #babed8">    if n == 0:</span></span>
<span class="line"><span style="color: #babed8">        return 1</span></span>
<span class="line"><span style="color: #babed8">    else:</span></span>
<span class="line"><span style="color: #babed8">        return n * factorial(n - 1)</span></span></code></pre></div><p>在普通递归中，递归调用 <code>factorial(n - 1)</code> 发生在函数的末尾，并且返回值被乘以 <code>n</code> 后再返回。</p>
<p><strong>尾递归</strong>：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">python</span></span>
<span class="line"><span style="color: #babed8">def factorial_tail(n, accumulator=1):</span></span>
<span class="line"><span style="color: #babed8">    if n == 0:</span></span>
<span class="line"><span style="color: #babed8">        return accumulator</span></span>
<span class="line"><span style="color: #babed8">    else:</span></span>
<span class="line"><span style="color: #babed8">        return factorial_tail(n - 1, accumulator * n)</span></span></code></pre></div><p>以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p>
<p>事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。</p>
<ol>
<li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。</li>
<li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li>
</ol>
<p>时间复杂度分析统计的不是算法运行时间，<strong>而是算法运行时间随着数据量变大时的增长趋势</strong>。</p>
<p><img src="/../images/time_complexity_simple_example.png" alt="img"></p>
<p><img src="/../images/image-20240426102948646.png" alt="image-20240426102948646"></p>
<p>在计算机科学中，”渐近上界” 是一种用于分析算法性能的概念，特别是与时间复杂度和空间复杂度相关。在时间复杂度分析中，渐近上界的目的在于确定算法在数据规模趋于无穷大时的最坏性能表现。为了更好地理解这一概念，可以从几个角度来探讨：</p>
<h3 id="1-什么是渐近上界？"><a href="#1-什么是渐近上界？" class="headerlink" title="1. 什么是渐近上界？"></a>1. 什么是渐近上界？</h3><p>渐近上界指的是某个函数在趋于某个极限（例如，无限大）时，其增长速率的上限。它通常用于描述算法的最坏情况性能，表示随着输入规模增加，算法的运行时间或使用的资源上限。</p>
<h6 id="2-大-O-表示法"><a href="#2-大-O-表示法" class="headerlink" title="2. 大-O 表示法"></a>2. 大-O 表示法</h6><p>在算法分析中，渐近上界最常用的表示法是大-O 表示法。用 <code>O(f(n))</code> 表示某个算法的时间复杂度，意味着这个算法的运行时间在最坏情况下不会超过某个函数 <code>f(n)</code> 的增长速率。</p>
<p>例如，若算法的时间复杂度是 <code>O(n^2)</code>，表示无论最坏情况下发生了什么，这个算法的运行时间最多是某个常数与 <code>n^2</code> 的乘积。这里 <code>n</code> 是输入数据的规模。</p>
<h6 id="3-用途"><a href="#3-用途" class="headerlink" title="3. 用途"></a>3. 用途</h6><p>渐近上界有助于比较不同算法的性能，并帮助工程师选择适当的算法。在设计和优化算法时，了解渐近上界也有助于避免性能陷阱。</p>
<h6 id="4-如何理解渐近上界？"><a href="#4-如何理解渐近上界？" class="headerlink" title="4. 如何理解渐近上界？"></a>4. 如何理解渐近上界？</h6><p>渐近上界在数学上是严格定义的。函数 <code>T(n)</code> 的渐近上界是 <code>f(n)</code>，如果存在常数 <code>c</code> 和 <code>n_0</code> 使得对于所有 <code>n ≥ n_0</code>，都有 <code>T(n) ≤ c * f(n)</code>。这意味着当 <code>n</code> 足够大时，<code>T(n)</code> 不会超过 <code>c * f(n)</code>，即使在最坏情况下。</p>
<h6 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h6><p>考虑一个算法的时间复杂度是 <code>3n^2 + 2n + 7</code>。这个算法的渐近上界是 <code>O(n^2)</code>，因为当 <code>n</code> 足够大时，<code>3n^2</code> 是增长最快的项，其他项的影响可以忽略。</p>
<p><img src="/../images/image-20240426103209429.png" alt="image-20240426103209429"></p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 指数阶（递归实现） */</span></span>
<span class="line"><span style="color: #babed8">int expRecur(int n) &#123;</span></span>
<span class="line"><span style="color: #babed8">    if (n == 1)</span></span>
<span class="line"><span style="color: #babed8">        return 1;</span></span>
<span class="line"><span style="color: #babed8">    return expRecur(n - 1) + expRecur(n - 1) + 1;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/*对数阶*/</span></span>
<span class="line"><span style="color: #babed8">int linearLogRecur(int n) &#123;</span></span>
<span class="line"><span style="color: #babed8">    if (n &lt;= 1)</span></span>
<span class="line"><span style="color: #babed8">        return 1;</span></span>
<span class="line"><span style="color: #babed8">    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">    return count;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 线性对数阶 */</span></span>
<span class="line"><span style="color: #babed8">int linearLogRecur(int n) &#123;</span></span>
<span class="line"><span style="color: #babed8">    if (n &lt;= 1)</span></span>
<span class="line"><span style="color: #babed8">        return 1;</span></span>
<span class="line"><span style="color: #babed8">    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);</span></span>
<span class="line"><span style="color: #babed8">    for (int i = 0; i &lt; n; i++) &#123;</span></span>
<span class="line"><span style="color: #babed8">        count++;</span></span>
<span class="line"><span style="color: #babed8">    &#125;</span></span>
<span class="line"><span style="color: #babed8">    return count;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p><img src="/../images/image-20240426120004603.png" alt="image-20240426120004603"></p>
<p>算法在运行过程中使用的内存空间主要包括以下几种。</p>
<ul>
<li><strong>输入空间</strong>：用于存储算法的输入数据。</li>
<li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li>
<li><strong>输出空间</strong>：用于存储算法的输出数据。</li>
</ul>
<p>一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">struct Node &#123;</span></span>
<span class="line"><span style="color: #babed8">    int val;</span></span>
<span class="line"><span style="color: #babed8">    Node *next;</span></span>
<span class="line"><span style="color: #babed8">    Node(int x) : val(x), next(nullptr) &#123;&#125;</span></span>
<span class="line"><span style="color: #babed8">&#125;;</span></span></code></pre></div><p><code>Node(int x) : val(x), next(nullptr)</code> 是一个构造函数的定义</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">int func() &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 执行某些操作</span></span>
<span class="line"><span style="color: #babed8">    return 0;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8">/* 循环的空间复杂度为 O(1) */</span></span>
<span class="line"><span style="color: #babed8">void loop(int n) &#123;</span></span>
<span class="line"><span style="color: #babed8">    for (int i = 0; i &lt; n; i++) &#123;</span></span>
<span class="line"><span style="color: #babed8">        func();</span></span>
<span class="line"><span style="color: #babed8">    &#125;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8">/* 递归的空间复杂度为 O(n) */</span></span>
<span class="line"><span style="color: #babed8">void recur(int n) &#123;</span></span>
<span class="line"><span style="color: #babed8">    if (n == 1) return;</span></span>
<span class="line"><span style="color: #babed8">    return recur(n - 1);</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 </p>
<p> ，但空间复杂度不同。</p>
<ul>
<li>函数 <code>loop()</code> 在循环中调用了</li>
</ul>
<p> 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 </p>
<p> 。</p>
<p>递归函数 <code>recur()</code> 在运行过程中会同时存在 </p>
<p> 个未返回的 <code>recur()</code> ，从而占用  的栈帧空间。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 线性阶 */</span></span>
<span class="line"><span style="color: #babed8">void linear(int n) &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 长度为 n 的数组占用 O(n) 空间</span></span>
<span class="line"><span style="color: #babed8">    vector&lt;int&gt; nums(n);</span></span>
<span class="line"><span style="color: #babed8">    // 长度为 n 的列表占用 O(n) 空间</span></span>
<span class="line"><span style="color: #babed8">    vector&lt;ListNode&gt; nodes;</span></span>
<span class="line"><span style="color: #babed8">    for (int i = 0; i &lt; n; i++) &#123;</span></span>
<span class="line"><span style="color: #babed8">        nodes.push_back(ListNode(i));</span></span>
<span class="line"><span style="color: #babed8">    &#125;</span></span>
<span class="line"><span style="color: #babed8">    // 长度为 n 的哈希表占用 O(n) 空间</span></span>
<span class="line"><span style="color: #babed8">    unordered_map&lt;int, string&gt; map;</span></span>
<span class="line"><span style="color: #babed8">    for (int i = 0; i &lt; n; i++) &#123;</span></span>
<span class="line"><span style="color: #babed8">        map[i] = to_string(i);</span></span>
<span class="line"><span style="color: #babed8">    &#125;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 线性阶（递归实现） */</span></span>
<span class="line"><span style="color: #babed8">void linearRecur(int n) &#123;</span></span>
<span class="line"><span style="color: #babed8">    cout &lt;&lt; &quot;递归 n = &quot; &lt;&lt; n &lt;&lt; endl;</span></span>
<span class="line"><span style="color: #babed8">    if (n == 1)</span></span>
<span class="line"><span style="color: #babed8">        return;</span></span>
<span class="line"><span style="color: #babed8">    linearRecur(n - 1);</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8"></span></span></code></pre></div><p><strong>Q</strong>：函数和方法这两个术语的区别是什么？</p>
<p>函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。</p>
<p>下面以几种常见的编程语言为例来说明。</p>
<ul>
<li>C 语言是过程式编程语言，没有面向对象的概念，所以只有函数。但我们可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他编程语言中的方法。</li>
<li>Java 和 C# 是面向对象的编程语言，代码块（方法）通常作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量。</li>
<li>C++ 和 Python 既支持过程式编程（函数），也支持面向对象编程（方法）。</li>
</ul>
<p>常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。</p>
<h2 id="逻辑结构：线性与非线性"><a href="#逻辑结构：线性与非线性" class="headerlink" title="逻辑结构：线性与非线性"></a>逻辑结构：线性与非线性</h2><p><strong>逻辑结构揭示了数据元素之间的逻辑关系</strong>。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。</p>
<p>如图 3-1 所示，逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。</p>
<ul>
<li><strong>线性数据结构</strong>：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。</li>
<li><strong>非线性数据结构</strong>：树、堆、图、哈希表。</li>
</ul>
<p>非线性数据结构可以进一步划分为树形结构和网状结构。</p>
<ul>
<li><strong>树形结构</strong>：树、堆、哈希表，元素之间是一对多的关系。</li>
<li><strong>网状结构</strong>：图，元素之间是多对多的关系。</li>
</ul>
<p>内存是所有程序的共享资源，当某块内存被某个程序占用时，则无法被其他程序同时使用了。<strong>因此在数据结构与算法的设计中，内存资源是一个重要的考虑因素</strong>。比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。</p>
<p>如图 3-3 所示，<strong>物理结构反映了数据在计算机内存中的存储方式</strong>，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p>
<p><img src="/../images/classification_phisical_structure.png" alt="连续空间存储与分散空间存储"></p>
<p>值得说明的是，<strong>所有数据结构都是基于数组、链表或二者的组合实现的</strong>。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p>
<p>链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。</p>
<p><strong>基本数据类型是 CPU 可以直接进行运算的类型</strong>，在算法中直接被使用，主要包括以下几种。</p>
<ul>
<li>整数类型 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 。</li>
<li>浮点数类型 <code>float</code>、<code>double</code> ，用于表示小数。</li>
<li>字符类型 <code>char</code> ，用于表示各种语言的字母、标点符号甚至表情符号等。</li>
<li>布尔类型 <code>bool</code> ，用于表示“是”与“否”判断。</li>
</ul>
<p><strong>基本数据类型以二进制的形式存储在计算机中</strong>。一个二进制位即为 1比特。在绝大多数现代操作系统中，1字节（byte）由 8比特（bit）组成。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 初始化数组 */</span></span>
<span class="line"><span style="color: #babed8">// 存储在栈上</span></span>
<span class="line"><span style="color: #babed8">int arr[5];</span></span>
<span class="line"><span style="color: #babed8">int nums[5] = &#123; 1, 3, 2, 5, 4 &#125;;</span></span>
<span class="line"><span style="color: #babed8">// 存储在堆上（需要手动释放空间）</span></span>
<span class="line"><span style="color: #babed8">int* arr1 = new int[5];</span></span>
<span class="line"><span style="color: #babed8">int* nums1 = new int[5] &#123; 1, 3, 2, 5, 4 &#125;;</span></span></code></pre></div><p>在C++中，将数据存储在栈上和堆上有以下区别：</p>
<ol>
<li><strong>存储位置</strong>：<ul>
<li><strong>栈上</strong>：栈上的数据存储在程序的栈内存中，它们的分配和释放由编译器自动管理。栈上的数据通常具有较短的生命周期，当函数执行结束时，其内部的局部变量就会被自动释放。</li>
<li><strong>堆上</strong>：堆上的数据存储在程序的堆内存中，它们的分配和释放通常由程序员手动管理。堆上的数据可以具有较长的生命周期，直到显式释放内存或程序终止时才会被释放。</li>
</ul>
</li>
<li><strong>动态性</strong>：<ul>
<li><strong>栈上</strong>：栈上的内存分配是静态的，大小在编译时确定，并且通常比较有限。由于栈上的内存分配由编译器管理，所以分配和释放速度较快。</li>
<li><strong>堆上</strong>：堆上的内存分配是动态的，大小可以在运行时确定，并且可以根据需要动态增长。由于堆上的内存分配由程序员管理，因此可能会产生内存泄漏或内存碎片等问题。</li>
</ul>
</li>
<li><strong>访问方式</strong>：<ul>
<li><strong>栈上</strong>：栈上的数据访问速度通常比较快，因为它们存储在内存中的连续位置上，并且可以直接通过指针或引用进行访问。</li>
<li><strong>堆上</strong>：堆上的数据访问速度可能比较慢，因为它们存储在内存中的不同位置上，并且需要通过指针间接访问。</li>
</ul>
</li>
</ol>
<p>在实际编程中，选择栈上或堆上的存储方式取决于数据的生命周期、大小和访问方式等因素。</p>
<p>Q:把数组存储在堆，栈上，那堆栈是什么</p>
<p>A：在计算机科学中，”堆栈”通常指的是”栈”和”堆”这两种不同的内存分配区域，它们用于存储程序运行时所需的数据和内存。这两者虽然名字相似，但是在内存管理和使用方面有着不同的作用和特点：</p>
<ol>
<li><strong>栈（Stack）</strong>：<ul>
<li>栈是一种内存分配区域，用于存储函数调用时的局部变量、函数参数、函数返回地址等信息。</li>
<li>栈上的内存分配由编译器<strong>自动管理</strong>，通常采用后进先出（LIFO）的方式进行操作。函数调用时，会将局部变量等信息压入栈中，函数返回时则将其弹出。</li>
<li>栈上的内存分配<strong>速度快</strong>，但是空间有限，通常用于存储函数调用时所需的临时数据。</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：<ul>
<li>堆是另一种内存分配区域，用于存储程序运行时动态分配的内存，例如使用<code>new</code>和<code>delete</code>操作符创建和释放的对象。</li>
<li>堆上的内存分配由程序员<strong>手动管理</strong>，它的大小和生命周期可以动态确定。堆上的内存通常用于存储程序运行时动态产生的数据结构、对象等。</li>
<li>堆上的内存分配速度<strong>相对较慢</strong>，因为需要进行动态分配和释放，并且可能产生内存碎片等问题。</li>
</ul>
</li>
</ol>
<p>总的来说，栈和堆是程序运行时两种不同的内存分配区域，它们有着不同的管理方式、分配速度和用途，程序员可以根据需要选择合适的内存分配方式来管理程序的数据和内存。</p>
<p>Q ：存储在堆上，是要求定义为指针吗</p>
<p>A : 在C++中，使用<code>new</code>操作符分配内存时，返回的是指向分配内存的指针。因此，存储在堆上的数据需要定义为指针类型，以便程序员能够通过指针来访问和操作这些数据，并在适当的时候手动释放内存空间，以避免内存泄漏。</p>
<p>以下是一个简单的示例，演示如何声明和使用函数指针：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">cpp</span></span>
<span class="line"><span style="color: #babed8">#include &lt;iostream&gt;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">// 声明一个接受两个整数参数并返回它们之和的函数</span></span>
<span class="line"><span style="color: #babed8">int add(int a, int b) &#123;</span></span>
<span class="line"><span style="color: #babed8">    return a + b;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">// 声明一个接受两个整数参数并返回它们之差的函数</span></span>
<span class="line"><span style="color: #babed8">int subtract(int a, int b) &#123;</span></span>
<span class="line"><span style="color: #babed8">    return a - b;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">int main() &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 声明一个指向函数的指针，该函数接受两个整数参数并返回一个整数</span></span>
<span class="line"><span style="color: #babed8">    int (*operation)(int, int);</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">    // 将函数 add 的地址赋值给指针变量 operation</span></span>
<span class="line"><span style="color: #babed8">    operation = add;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">    // 使用指针调用函数 add</span></span>
<span class="line"><span style="color: #babed8">    int result1 = operation(10, 5);</span></span>
<span class="line"><span style="color: #babed8">    std::cout &lt;&lt; &quot;Result of add: &quot; &lt;&lt; result1 &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">    // 将函数 subtract 的地址赋值给指针变量 operation</span></span>
<span class="line"><span style="color: #babed8">    operation = subtract;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">    // 使用指针调用函数 subtract</span></span>
<span class="line"><span style="color: #babed8">    int result2 = operation(10, 5);</span></span>
<span class="line"><span style="color: #babed8">    std::cout &lt;&lt; &quot;Result of subtract: &quot; &lt;&lt; result2 &lt;&lt; std::endl;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">    return 0;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>在这个示例中，<code>int (*operation)(int, int);</code> 声明了一个名为 <code>operation</code> 的函数指针，它指向一个接受两个整数参数并返回一个整数的函数。然后，通过将函数的地址赋值给指针变量 <code>operation</code>，可以使用该指针来调用不同的函数。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 扩展数组长度 */</span></span>
<span class="line"><span style="color: #babed8">int *extend(int *nums, int size, int enlarge) &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 初始化一个扩展长度后的数组</span></span>
<span class="line"><span style="color: #babed8">    int *res = new int[size + enlarge];</span></span>
<span class="line"><span style="color: #babed8">    // 将原数组中的所有元素复制到新数组</span></span>
<span class="line"><span style="color: #babed8">    for (int i = 0; i &lt; size; i++) &#123;</span></span>
<span class="line"><span style="color: #babed8">        res[i] = nums[i];</span></span>
<span class="line"><span style="color: #babed8">    &#125;</span></span>
<span class="line"><span style="color: #babed8">    // 释放内存</span></span>
<span class="line"><span style="color: #babed8">    delete[] nums;</span></span>
<span class="line"><span style="color: #babed8">    // 返回扩展后的新数组</span></span>
<span class="line"><span style="color: #babed8">    return res;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>返回类型为 <code>int *</code>，意味着该函数返回的是一个指向整数类型的指针，即指向数组的指针。</p>
<h2 id="数组的优点与局限性"><a href="#数组的优点与局限性" class="headerlink" title="数组的优点与局限性"></a>数组的优点与局限性</h2><p>数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。</p>
<ul>
<li><p><strong>空间效率高</strong>：数组为数据分配了连续的内存块，无须额外的结构开销。</p>
</li>
<li><p><strong>支持随机访问</strong>：数组允许在 </p>
</li>
<li><p>时间内访问任何元素。</p>
</li>
<li><p><strong>缓存局部性</strong>：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。</p>
</li>
</ul>
<p>连续空间存储是一把双刃剑，其存在以下局限性。</p>
<ul>
<li><p><strong>插入与删除效率低</strong>：当数组中元素较多时，插入与删除操作需要移动大量的元素。</p>
</li>
<li><p><strong>长度不可变</strong>：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</p>
</li>
<li><p><strong>空间浪费</strong>：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</p>
</li>
<li><p><code>delete</code> 用于释放通过 <code>new</code> 分配的单个对象的内存。</p>
</li>
<li><p><code>delete[]</code> 用于释放通过 <code>new[]</code> 分配的数组的内存。</p>
</li>
</ul>
<h2 id="数组典型应用"><a href="#数组典型应用" class="headerlink" title="数组典型应用"></a>数组典型应用</h2><p>数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。</p>
<ul>
<li><strong>随机访问</strong>：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。</li>
<li><strong>排序和搜索</strong>：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。</li>
<li><strong>查找表</strong>：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。</li>
<li><strong>机器学习</strong>：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。</li>
<li><strong>数据结构实现</strong>：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。</li>
</ul>
<p><strong>存储数组的内存空间必须是连续的</strong></p>
<p>链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。</p>
<ul>
<li>链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。</li>
<li>尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 <code>null</code>、<code>nullptr</code> 和 <code>None</code> 。</li>
<li>在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 链表节点结构体 */</span></span>
<span class="line"><span style="color: #babed8">struct ListNode &#123;</span></span>
<span class="line"><span style="color: #babed8">    int val;         // 节点值</span></span>
<span class="line"><span style="color: #babed8">    ListNode *next;  // 指向下一节点的指针</span></span>
<span class="line"><span style="color: #babed8">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;  // 构造函数</span></span>
<span class="line"><span style="color: #babed8">&#125;;</span></span></code></pre></div><p>为什么结构体也有构造函数:</p>
<p>在C++中，结构体（struct）和类（class）都可以拥有构造函数。构造函数用于初始化对象的数据成员，在创建对象时自动调用。</p>
<p>单向链表通常用于实现栈、队列、哈希表和图等数据结构。</p>
<ul>
<li><strong>栈与队列</strong>：当插入和删除操作都在链表的一端进行时，它表现出先进后出的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。</li>
<li><strong>哈希表</strong>：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</li>
<li><strong>图</strong>：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</li>
</ul>
<p>双向链表常用于需要快速查找前一个和后一个元素的场景。</p>
<ul>
<li><strong>高级数据结构</strong>：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</li>
<li><strong>浏览器历史</strong>：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</li>
<li><strong>LRU 算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</li>
</ul>
<p>环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。</p>
<ul>
<li><strong>时间片轮转调度算法</strong>：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。</li>
<li><strong>数据缓冲区</strong>：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。</li>
</ul>
<p>可以使用动态数组（dynamic array）来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。</p>
<p>实际上，<strong>许多编程语言中的标准库提供的列表是基于动态数组实现的</strong>，例如 Python 中的 <code>list</code> 、Java 中的 <code>ArrayList</code> 、C++ 中的 <code>vector</code> 和 C# 中的 <code>List</code> 等。接下来，我们将把“列表”和“动态数组”视为等同的概念。</p>
<h2 id="数据结构的缓存效率"><a href="#数据结构的缓存效率" class="headerlink" title="数据结构的缓存效率"></a>数据结构的缓存效率</h2><p>缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据。</p>
<p>为了尽可能达到更高的效率，缓存会采取以下数据加载机制。</p>
<ul>
<li><strong>缓存行</strong>：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效。</li>
<li><strong>预取机制</strong>：处理器会尝试预测数据访问模式（例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。</li>
<li><strong>空间局部性</strong>：如果一个数据被访问，那么它附近的数据可能近期也会被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率。</li>
<li><strong>时间局部性</strong>：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率。</li>
</ul>
<p>栈（stack）是一种遵循先入后出逻辑的线性数据结构。</p>
<p>如图 5-1 所示，我们把堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫作“入栈”，删除<strong>栈顶元素</strong>的操作叫作“出栈”。因此我们只能在栈顶添加或删除元素,然而，数组和链表都可以在任意位置添加和删除元素，<strong>因此栈可以视为一种受限制的数组或链表</strong>。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">基于数组实现的栈</span></span>
<span class="line"><span style="color: #babed8">vector&lt;int&gt; stack;</span></span>
<span class="line"><span style="color: #babed8">/* 获取栈的长度 */</span></span>
<span class="line"><span style="color: #babed8">stack.size()</span></span>
<span class="line"><span style="color: #babed8">入栈</span></span>
<span class="line"><span style="color: #babed8">stack.push_back(num);</span></span>
<span class="line"><span style="color: #babed8">出栈</span></span>
<span class="line"><span style="color: #babed8">stack.pop_back();</span></span>
<span class="line"><span style="color: #babed8">访问栈顶元素</span></span>
<span class="line"><span style="color: #babed8">stack.back();</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">back就是栈顶的位置</span></span></code></pre></div><div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">有专用的栈方法</span></span>
<span class="line"><span style="color: #babed8">stack&lt;int&gt; stack;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 元素入栈 */</span></span>
<span class="line"><span style="color: #babed8">stack.push(1);</span></span>
<span class="line"><span style="color: #babed8">stack.push(3);</span></span>
<span class="line"><span style="color: #babed8">stack.push(2);</span></span>
<span class="line"><span style="color: #babed8">stack.push(5);</span></span>
<span class="line"><span style="color: #babed8">stack.push(4);</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 访问栈顶元素 */</span></span>
<span class="line"><span style="color: #babed8">int top = stack.top();</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 元素出栈 */</span></span>
<span class="line"><span style="color: #babed8">stack.pop(); // 无返回值</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 获取栈的长度 */</span></span>
<span class="line"><span style="color: #babed8">int size = stack.size();</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 判断是否为空 */</span></span>
<span class="line"><span style="color: #babed8">bool empty = stack.empty();</span></span></code></pre></div><p>队列（queue）是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 初始化队列 */</span></span>
<span class="line"><span style="color: #babed8">queue&lt;int&gt; queue;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 元素入队 */</span></span>
<span class="line"><span style="color: #babed8">queue.push(1);</span></span>
<span class="line"><span style="color: #babed8">queue.push(3);</span></span>
<span class="line"><span style="color: #babed8">queue.push(2);</span></span>
<span class="line"><span style="color: #babed8">queue.push(5);</span></span>
<span class="line"><span style="color: #babed8">queue.push(4);</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 访问队首元素 */</span></span>
<span class="line"><span style="color: #babed8">int front = queue.front();</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 元素出队 */</span></span>
<span class="line"><span style="color: #babed8">queue.pop();</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 获取队列的长度 */</span></span>
<span class="line"><span style="color: #babed8">int size = queue.size();</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 判断队列是否为空 */</span></span>
<span class="line"><span style="color: #babed8">bool empty = queue.empty();</span></span></code></pre></div><p>添加队尾，删除队首—–先来后到</p>
<p><strong>双向队列</strong>：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 初始化双向队列 */</span></span>
<span class="line"><span style="color: #babed8">deque&lt;int&gt; deque;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 元素入队 */</span></span>
<span class="line"><span style="color: #babed8">deque.push_back(2);   // 添加至队尾</span></span>
<span class="line"><span style="color: #babed8">deque.push_back(5);</span></span>
<span class="line"><span style="color: #babed8">deque.push_back(4);</span></span>
<span class="line"><span style="color: #babed8">deque.push_front(3);  // 添加至队首</span></span>
<span class="line"><span style="color: #babed8">deque.push_front(1);</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 访问元素 */</span></span>
<span class="line"><span style="color: #babed8">int front = deque.front(); // 队首元素</span></span>
<span class="line"><span style="color: #babed8">int back = deque.back();   // 队尾元素</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 元素出队 */</span></span>
<span class="line"><span style="color: #babed8">deque.pop_front();  // 队首元素出队</span></span>
<span class="line"><span style="color: #babed8">deque.pop_back();   // 队尾元素出队</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 获取双向队列的长度 */</span></span>
<span class="line"><span style="color: #babed8">int size = deque.size();</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 判断双向队列是否为空 */</span></span>
<span class="line"><span style="color: #babed8">bool empty = deque.empty();</span></span></code></pre></div><p><code>DoublyListNode *pre, *cur = front;</code> 确实是一个比较容易产生误解的地方，但实际上这行代码并不是同时给 <code>pre</code> 和 <code>cur</code> 赋值为 <code>front</code>。这行代码实际上相当于两行分开的声明和初始化：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">cpp</span></span>
<span class="line"><span style="color: #babed8">DoublyListNode *pre; // 声明一个指向 DoublyListNode 类型的指针 pre</span></span>
<span class="line"><span style="color: #babed8">DoublyListNode *cur = front; // 声明一个指向 DoublyListNode 类型的指针 cur，并将其初始化为 front</span></span></code></pre></div><p>这里的 <code>pre</code> 只是声明了一个指针，但并没有初始化，所以它的值是未定义的，你需要在后续代码中对其进行初始化。而 <code>cur</code> 在声明时已经被初始化为 <code>front</code>。</p>
<p>哈希表（hash table），又称散列表，它通过建立键 <code>key</code> 与值 <code>value</code> 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 <code>key</code> ，则可以在  O(1)时间内获取对应的值 <code>value</code> 。</p>
<p><code>unordered_map</code> 是 C++ 标准库中的一种关联容器（Associative Container），它提供了快速的键值对存储和检索功能。它是通过<strong>哈希表</strong>实现的，因此提供了高效的插入、删除和查找操作。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 初始化哈希表 */</span></span>
<span class="line"><span style="color: #babed8">unordered_map&lt;int, string&gt; map;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 添加操作 */</span></span>
<span class="line"><span style="color: #babed8">// 在哈希表中添加键值对 (key, value)</span></span>
<span class="line"><span style="color: #babed8">map[12836] = &quot;小哈&quot;;</span></span>
<span class="line"><span style="color: #babed8">map[15937] = &quot;小啰&quot;;</span></span>
<span class="line"><span style="color: #babed8">map[16750] = &quot;小算&quot;;</span></span>
<span class="line"><span style="color: #babed8">map[13276] = &quot;小法&quot;;</span></span>
<span class="line"><span style="color: #babed8">map[10583] = &quot;小鸭&quot;;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 查询操作 */</span></span>
<span class="line"><span style="color: #babed8">// 向哈希表中输入键 key ，得到值 value</span></span>
<span class="line"><span style="color: #babed8">string name = map[15937];</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 删除操作 */</span></span>
<span class="line"><span style="color: #babed8">// 在哈希表中删除键值对 (key, value)</span></span>
<span class="line"><span style="color: #babed8">map.erase(10583);</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 遍历哈希表 */</span></span>
<span class="line"><span style="color: #babed8">// 遍历键值对 key-&gt;value</span></span>
<span class="line"><span style="color: #babed8">for (auto kv: map) &#123;</span></span>
<span class="line"><span style="color: #babed8">    cout &lt;&lt; kv.first &lt;&lt; &quot; -&gt; &quot; &lt;&lt; kv.second &lt;&lt; endl;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8">// 使用迭代器遍历 key-&gt;value</span></span>
<span class="line"><span style="color: #babed8">for (auto iter = map.begin(); iter != map.end(); iter++) &#123;</span></span>
<span class="line"><span style="color: #babed8">    cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>我们先考虑最简单的情况，<strong>仅用一个数组来实现哈希表</strong>。在哈希表中，我们将数组中的每个空位称为桶（bucket），每个桶可存储一个键值对。因此，查询操作就是找到 <code>key</code> 对应的桶，并在桶中获取 <code>value</code> 。</p>
<p>那么，如何基于 <code>key</code> 定位对应的桶呢？这是通过哈希函数（hash function）实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 <code>key</code> ，输出空间是所有桶（数组索引）。换句话说，输入一个 <code>key</code> ，<strong>我们可以通过哈希函数得到该 <code>key</code> 对应的键值对在数组中的存储位置</strong>。</p>
<p>输入一个 <code>key</code> ，哈希函数的计算过程分为以下两步。</p>
<ol>
<li>通过某种哈希算法 <code>hash()</code> 计算得到哈希值。</li>
<li>将哈希值对桶数量（数组长度）<code>capacity</code> 取模，从而获取该 <code>key</code> 对应的数组索引 <code>index</code> 。</li>
</ol>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">index = hash(key) % capacity</span></span></code></pre></div><p><code>&lt;Pair *&gt;</code> 表示这个 <code>vector</code> 存储的是指向 <code>Pair</code> 类型对象的指针。</p>
<p><code>vector&lt;Pair *&gt;</code> 创建了一个存储指向 <code>Pair</code> 结构的指针的动态数组，即每个元素都是指向 <code>Pair</code> 结构的指针。</p>
<p>我们将多个输入对应同一输出的情况称为哈希冲突（hash collision）。</p>
<p><strong>我们可以通过扩容哈希表来减少哈希冲突</strong>。类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 <code>capacity</code> 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。</p>
<p>负载因子（load factor）是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，<strong>也常作为哈希表扩容的触发条件</strong>。例如在 Java 中，当负载因子超过  时，系统会将哈希表扩容至原先的 2倍。</p>
<p>但此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。</p>
<ol>
<li>改良哈希表数据结构，<strong>使得哈希表可以在出现哈希冲突时正常工作</strong>。</li>
<li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li>
</ol>
<p>哈希表的结构改良方法主要包括“<strong>链式地址</strong>”和“<strong>开放寻址</strong>”。</p>
<h2 id="链式地址"><a href="#链式地址" class="headerlink" title="链式地址"></a>链式地址</h2><p>在原始哈希表中，每个桶仅能存储一个键值对。链式地址（separate chaining）将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。图 6-5 展示了一个链式地址哈希表的例子。</p>
<p><a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_hashing/hash_collision.assets/hash_table_chaining.png"><img src="/../images/hash_table_chaining.png" alt="链式地址哈希表"></a></p>
<p> 图 6-5  链式地址哈希表 </p>
<p>基于链式地址实现的哈希表的操作方法发生了以下变化。</p>
<ul>
<li><strong>查询元素</strong>：输入 <code>key</code> ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 <code>key</code> 以查找目标键值对。</li>
<li><strong>添加元素</strong>：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。</li>
<li><strong>删除元素</strong>：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。</li>
</ul>
<p>链式地址存在以下局限性。</p>
<ul>
<li><strong>占用空间增大</strong>：链表包含节点指针，它相比数组更加耗费内存空间。</li>
<li><strong>查询效率降低</strong>：因为需要线性遍历链表来查找对应元素。</li>
</ul>
<h2 id="开放寻址"><a href="#开放寻址" class="headerlink" title="开放寻址"></a>开放寻址</h2><p>开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。</p>
<p>线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。</p>
<ul>
<li><p><strong>插入元素</strong>：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 </p>
</li>
<li><p>），直至找到空桶，将元素插入其中。</p>
</li>
<li><p><strong>查找元素</strong>：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 <code>value</code> 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 <code>None</code> 。</p>
</li>
</ul>
<p>图 6-6 展示了开放寻址（线性探测）哈希表的键值对分布。根据此哈希函数，最后两位相同的 <code>key</code> 都会被映射到相同的桶。而通过线性探测，它们被依次存储在该桶以及之下的桶中。</p>
<p><a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_hashing/hash_collision.assets/hash_table_linear_probing.png"><img src="/../images/hash_table_linear_probing.png" alt="开放寻址（线性探测）哈希表的键值对分布"></a></p>
<p> 值得注意的是，<strong>我们不能在开放寻址哈希表中直接删除元素</strong>。这是因为删除元素会在数组内产生一个空桶 <code>None</code> ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在</p>
<p>为了解决该问题，我们可以采用懒删除（lazy deletion）机制：它不直接从哈希表中移除元素，<strong>而是利用一个常量 <code>TOMBSTONE</code> 来标记这个桶</strong>。在该机制下，<code>None</code> 和 <code>TOMBSTONE</code> 都代表空桶，都可以放置键值对。但不同的是，线性探测到 <code>TOMBSTONE</code> 时应该继续遍历，因为其之下可能还存在键值对。</p>
<p>然而，<strong>懒删除可能会加速哈希表的性能退化</strong>。这是因为每次删除操作都会产生一个删除标记，随着 <code>TOMBSTONE</code> 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 <code>TOMBSTONE</code> 才能找到目标元素。</p>
<p>为此，考虑在线性探测中记录遇到的首个 <code>TOMBSTONE</code> 的索引，并将搜索到的目标元素与该 <code>TOMBSTONE</code> 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。</p>
<h3 id="平方探测"><a href="#平方探测" class="headerlink" title="平方探测"></a>平方探测</h3><p>平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 </p>
<p> 步。</p>
<p>平方探测主要具有以下优势。</p>
<ul>
<li>平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。</li>
<li>平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。</li>
</ul>
<p>然而，平方探测并不是完美的。</p>
<ul>
<li>仍然存在聚集现象，即某些位置比其他位置更容易被占用。</li>
<li>由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。</li>
</ul>
<p><img src="/../images/image-20240428082152341.png" alt="image-20240428082152341"></p>
<p>二叉树的常用术语如图所示。</p>
<ul>
<li>根节点（root node）：位于二叉树顶层的节点，没有父节点。</li>
<li>叶节点（leaf node）：没有子节点的节点，其两个指针均指向 <code>None</code> 。</li>
<li>边（edge）：连接两个节点的线段，即节点引用（指针）。</li>
<li>节点所在的层（level）：从顶至底递增，根节点所在层为 1 。</li>
<li>节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</li>
<li>二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量。</li>
<li>节点的深度（depth）：从根节点到该节点所经过的边的数量。</li>
<li>节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量。</li>
</ul>
<p><img src="/../images/binary_tree_terminology.png" alt="img"></p>
<h2 id="常见二叉树类型"><a href="#常见二叉树类型" class="headerlink" title="常见二叉树类型"></a>常见二叉树类型</h2><h3 id="完美二叉树"><a href="#完美二叉树" class="headerlink" title="完美二叉树"></a>完美二叉树</h3><p>所有层的节点都被完全填满。</p>
<p><img src="/../images/perfect_binary_tree.png" alt="img"></p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>只有最底层的节点未被填满，且最底层节点尽量靠左填充。</p>
<p><img src="/../images/complete_binary_tree.png" alt="img"></p>
<h3 id="完满二叉树"><a href="#完满二叉树" class="headerlink" title="完满二叉树"></a>完满二叉树</h3><p>除了叶节点之外，其余所有节点都有两个子节点。</p>
<p><img src="/../images/full_binary_tree.png" alt="img"></p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>任意节点的左子树和右子树的高度之差的绝对值不超过 1 。</p>
<p>[<img src="/../images/balanced_binary_tree.png" alt="平衡二叉树"></p>
<p>理想结构与退化结构</p>
<p>二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。</p>
<p>完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。</p>
<p>链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n)</p>
<p><img src="/../images/binary_tree_best_worst_cases.png" alt="img"></p>
<h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><p>从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助<strong>搜索算法</strong>来实现。</p>
<p>二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和后序遍历等。</p>
<p>层序遍历</p>
<p>从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。</p>
<p>层序遍历本质上属于广度优先遍历（breadth-first traversal），也称广度优先搜索（breadth-first search, BFS），它体现了一种“一圈一圈向外扩展”的逐层遍历方式。</p>
<p><img src="/../images/binary_tree_bfs.png" alt="img"></p>
<p>广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 层序遍历 */</span></span>
<span class="line"><span style="color: #babed8">vector&lt;int&gt; levelOrder(TreeNode *root) &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 初始化队列，加入根节点</span></span>
<span class="line"><span style="color: #babed8">    queue&lt;TreeNode *&gt; queue;</span></span>
<span class="line"><span style="color: #babed8">    queue.push(root);</span></span>
<span class="line"><span style="color: #babed8">    // 初始化一个列表，用于保存遍历序列</span></span>
<span class="line"><span style="color: #babed8">    vector&lt;int&gt; vec;</span></span>
<span class="line"><span style="color: #babed8">    while (!queue.empty()) &#123;</span></span>
<span class="line"><span style="color: #babed8">        TreeNode *node = queue.front();</span></span>
<span class="line"><span style="color: #babed8">        queue.pop();              // 队列出队</span></span>
<span class="line"><span style="color: #babed8">        vec.push_back(node-&gt;val); // 保存节点值</span></span>
<span class="line"><span style="color: #babed8">        if (node-&gt;left != nullptr)</span></span>
<span class="line"><span style="color: #babed8">            queue.push(node-&gt;left); // 左子节点入队</span></span>
<span class="line"><span style="color: #babed8">        if (node-&gt;right != nullptr)</span></span>
<span class="line"><span style="color: #babed8">            queue.push(node-&gt;right); // 右子节点入队</span></span>
<span class="line"><span style="color: #babed8">    &#125;</span></span>
<span class="line"><span style="color: #babed8">    return vec;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p><img src="/../images/image-20240429132637500.png" alt="image-20240429132637500"></p>
<p>前序、中序和后序遍历都属于深度优先遍历（depth-first traversal），也称深度优先搜索（depth-first search, DFS），它体现了一种“先走到尽头，再回溯继续”的遍历方式。</p>
<p><img src="/../images/binary_tree_dfs.png" alt="img"></p>
<p>前序、中序和后序遍历是针对二叉树的三种不同的遍历方式，它们的区别在于遍历节点的顺序：</p>
<ol>
<li><strong>前序遍历（Preorder Traversal）</strong>：<ul>
<li>遍历顺序：根节点 -&gt; 左子树 -&gt; 右子树</li>
<li>具体操作：先访问根节点，然后递归地对左子树进行前序遍历，最后递归地对右子树进行前序遍历。</li>
</ul>
</li>
<li><strong>中序遍历（Inorder Traversal）</strong>：<ul>
<li>遍历顺序：左子树 -&gt; 根节点 -&gt; 右子树</li>
<li>具体操作：先递归地对左子树进行中序遍历，然后访问根节点，最后递归地对右子树进行中序遍历。</li>
</ul>
</li>
<li><strong>后序遍历（Postorder Traversal）</strong>：<ul>
<li>遍历顺序：左子树 -&gt; 右子树 -&gt; 根节点</li>
<li>具体操作：先递归地对左子树进行后序遍历，然后递归地对右子树进行后序遍历，最后访问根节点。</li>
</ul>
</li>
</ol>
<p>总的来说，这三种遍历方式主要区别在于根节点的访问顺序与左右子树的递归顺序。</p>
<p>深度优先搜索通常基于递归实现：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 前序遍历 */</span></span>
<span class="line"><span style="color: #babed8">void preOrder(TreeNode *root) &#123;</span></span>
<span class="line"><span style="color: #babed8">    if (root == nullptr)</span></span>
<span class="line"><span style="color: #babed8">        return;</span></span>
<span class="line"><span style="color: #babed8">    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span>
<span class="line"><span style="color: #babed8">    vec.push_back(root-&gt;val);</span></span>
<span class="line"><span style="color: #babed8">    preOrder(root-&gt;left);</span></span>
<span class="line"><span style="color: #babed8">    preOrder(root-&gt;right);</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 中序遍历 */</span></span>
<span class="line"><span style="color: #babed8">void inOrder(TreeNode *root) &#123;</span></span>
<span class="line"><span style="color: #babed8">    if (root == nullptr)</span></span>
<span class="line"><span style="color: #babed8">        return;</span></span>
<span class="line"><span style="color: #babed8">    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span>
<span class="line"><span style="color: #babed8">    inOrder(root-&gt;left);</span></span>
<span class="line"><span style="color: #babed8">    vec.push_back(root-&gt;val);</span></span>
<span class="line"><span style="color: #babed8">    inOrder(root-&gt;right);</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">/* 后序遍历 */</span></span>
<span class="line"><span style="color: #babed8">void postOrder(TreeNode *root) &#123;</span></span>
<span class="line"><span style="color: #babed8">    if (root == nullptr)</span></span>
<span class="line"><span style="color: #babed8">        return;</span></span>
<span class="line"><span style="color: #babed8">    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span>
<span class="line"><span style="color: #babed8">    postOrder(root-&gt;left);</span></span>
<span class="line"><span style="color: #babed8">    postOrder(root-&gt;right);</span></span>
<span class="line"><span style="color: #babed8">    vec.push_back(root-&gt;val);</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><ol>
<li>“递”表示开启新方法，程序在此过程中访问下一个节点。</li>
<li>“归”表示函数返回，代表当前节点已经访问完毕。</li>
</ol>
<p><img src="/../images/image-20240429134503523.png" alt="image-20240429134503523"></p>
<h1 id="二叉树数组表示"><a href="#二叉树数组表示" class="headerlink" title="二叉树数组表示"></a>二叉树数组表示</h1><p>用数组来表示二叉树</p>
<h2 id="表示完美二叉树"><a href="#表示完美二叉树" class="headerlink" title="表示完美二叉树"></a>表示完美二叉树</h2><p>给定一棵完美二叉树，我们将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一的数组索引。</p>
<p>根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：<strong>若某节点的索引为</strong>i  <strong>，则该节点的左子节点索引为</strong>2i+1  <strong>，右子节点索引为</strong>2i+2 </p>
<p><img src="/../images/array_representation_binary_tree.png" alt="img"><strong>映射公式的角色相当于链表中的节点引用（指针）</strong>。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的左（右)子节点。</p>
<h2 id="表示任意二叉树"><a href="#表示任意二叉树" class="headerlink" title="表示任意二叉树"></a>表示任意二叉树</h2><p>完美二叉树是一个特例，在二叉树的中间层通常存在许多 <code>None</code> 。由于层序遍历序列并不包含这些 <code>None</code> ，因此我们无法仅凭该序列来推测 <code>None</code> 的数量和分布位置。<strong>这意味着存在多种二叉树结构都符合该层序遍历序列</strong>。</p>
<p><img src="/../images/array_representation_without_empty.png" alt="img"></p>
<p>为了解决此问题，<strong>我们可以考虑在层序遍历序列中显式地写出所有 <code>None</code></strong> 。如图 7-14 所示，这样处理后，层序遍历序列就可以唯一表示二叉树了</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">/* 二叉树的数组表示 */</span></span>
<span class="line"><span style="color: #babed8">// 使用 int 最大值 INT_MAX 标记空位</span></span>
<span class="line"><span style="color: #babed8">vector&lt;int&gt; tree = &#123;1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15&#125;;</span></span></code></pre></div><p><img src="/../images/array_representation_with_empty.png" alt="img"></p>
<p><strong>完全二叉树</strong>:只有最底层的节点未被填满，且最底层节点尽量靠左填充。</p>
<p><strong>完全二叉树非常适合使用数组来表示</strong>。回顾完全二叉树的定义，<code>None</code> 只出现在最底层且靠右的位置，<strong>因此所有 <code>None</code> 一定出现在层序遍历序列的末尾</strong>。这意味着使用数组表示完全二叉树时，可以省略存储所有 <code>None</code> ，非常方便.</p>
<p><img src="/../images/array_representation_complete_binary_tree.png" alt="img"></p>
<h2 id="优点与局限性"><a href="#优点与局限性" class="headerlink" title="优点与局限性"></a>优点与局限性</h2><p>二叉树的数组表示主要有以下优点。</p>
<ul>
<li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。</li>
<li>不需要存储指针，比较节省空间。</li>
<li>允许随机访问节点。</li>
</ul>
<p>然而，数组表示也存在一些局限性。</p>
<ul>
<li>数组存储需要连续内存空间，因此不适合存储数据量过大的树。</li>
<li>增删节点需要通过数组插入与删除操作实现，效率较低。</li>
<li>当二叉树中存在大量 <code>None</code> 时，数组中包含的节点数据比重较低，空间利用率较低。</li>
</ul>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>二叉搜索树（binary search tree）满足以下条件:</p>
<p>1.对于根节点，左子树中所有节点的值&lt;根节点的值&lt;右子树中所有节点的值。</p>
<p>2,任意节点的左、右子树也是二叉搜索树，即同样满足条件 <code>1.</code> 。</p>
<p><img src="/../images/binary_search_tree.png" alt="img"></p>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>给定一个待插入元素 <code>num</code> ，为了保持二叉搜索树“左子树 &lt; 根节点 &lt; 右子树”的性质,</p>
<ol>
<li><strong>查找插入位置</strong>：与查找操作相似，从根节点出发，根据当前节点值和 <code>num</code> 的大小关系循环向下搜索，直到越过叶节点（遍历至 <code>None</code> ）时跳出循环。</li>
<li><strong>在该位置插入节点</strong>：初始化节点 <code>num</code> ，将该节点置于 <code>None</code> 的位置。</li>
</ol>
<p><img src="/../images/bst_insert.png" alt="img"></p>
<p><strong>只能插在NONE节点处</strong>,即*pre &#x3D; nullptr</p>
<ul>
<li>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。</li>
<li>为了实现插入节点，我们需要借助节点 <code>pre</code> 保存上一轮循环的节点。这样在遍历至 <code>None</code> 时，我们可以获取到其父节点，从而完成节点插入操作。</li>
</ul>
<p>删除节点</p>
<p>当待删除节点的度为2时，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左子树 &lt;根节点 &lt;右子树”的性质，<strong>因此这个节点可以是右子树的最小节点或左子树的最大节点</strong>。</p>
<ol>
<li>找到待删除节点在“中序遍历序列”中的下一个节点，记为 <code>tmp</code> 。</li>
<li>用 <code>tmp</code> 的值覆盖待删除节点的值，并在树中递归删除节点 <code>tmp</code> 。</li>
</ol>
<p><img src="/../images/bst_remove_case1.png" alt="img"></p>
<p><img src="/../images/bst_remove_case2.png" alt="img"></p>
<p><img src="/../images/bst_remove_case3_step4.png" alt="img"></p>
<p>二叉树的中序遍历遵循“左  根  右”的遍历顺序，而二叉搜索树满足“左子节点  根节点  右子节点”的大小关系。</p>
<p>这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：<strong>二叉搜索树的中序遍历序列是升序的</strong>。</p>
<p>利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需O(n)时间，无须进行额外的排序操作，非常高效。</p>
<p><img src="/../images/bst_inorder_traversal.png" alt="img"></p>
<p><code>int val&#123;&#125;;</code> 是C++中的变量声明语句，其中 <code>int</code> 表示变量的类型为整数类型，<code>val</code> 是变量名，<code>&#123;&#125;</code> 表示进行了值初始化。</p>
<p>在C++11及其之后的标准中，使用 <code>&#123;&#125;</code> 进行初始化被称为列表初始化或者统一初始化。对于内置类型（如 <code>int</code>、<code>float</code>、<code>double</code> 等），使用 <code>&#123;&#125;</code> 进行初始化时，如果未提供初始值，则会将变量初始化为零值，即 <code>0</code>。这种初始化方式也可以保证初始化的一致性，并且在某些情况下可以避免隐式类型转换带来的问题。</p>
<h1 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h1><p>在多次插入和删除操作后，二叉搜索树可能退化为链表。在这种情况下，所有操作的时间复杂度将从</p>
<p>O(log  n)劣化成O(n)</p>
<p>AVL 树既是二叉搜索树，也是平衡二叉树，同时满足这两类二叉树的所有性质，因此是一种平衡二叉搜索树（balanced binary search tree）。</p>
<p>节点的平衡因子（balance factor）定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为0  。</p>
<p><strong>AVL 树旋转</strong></p>
<p>AVL 树的特点在于“旋转”操作，它能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，<strong>旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”</strong>。</p>
<p>我们将平衡因子绝对值&gt;1的节点称为“失衡节点”。根据节点失衡情况的不同，旋转操作分为四种：右旋、左旋、先右旋后左旋、先左旋后右旋。</p>
<h3 id="1-右旋"><a href="#1-右旋" class="headerlink" title="1.  右旋"></a>1.  右旋</h3><p><img src="/../images/avltree_right_rotate_step1.png" alt="img"><img src="/../images/avltree_right_rotate_step3.png" alt="avltree_right_rotate_step3"></p>
<p><img src="/../images/avltree_right_rotate_step4.png" alt="avltree_right_rotate_step4"></p>
<p>当节点 <code>child</code> 有右子节点（记为 <code>grand_child</code> ）时，需要在右旋中添加一步：将 <code>grand_child</code> 作为 <code>node</code> 的左子节点。</p>
<p><img src="/../images/avltree_right_rotate_with_grandchild.png" alt="有 grand_child 的右旋操作"></p>
<p><strong>右旋和左旋操作在逻辑上是镜像对称的，它们分别解决的两种失衡情况也是对称的</strong>。基于对称性，我们只需将右旋的实现代码中的所有的 <code>left</code> 替换为 <code>right</code> ，将所有的 <code>right</code> 替换为 <code>left</code> ，即可得到左旋的实现代码</p>
<h3 id="先左旋后右旋"><a href="#先左旋后右旋" class="headerlink" title="先左旋后右旋"></a>先左旋后右旋</h3><p><img src="/../images/avltree_left_right_rotate.png" alt="先左旋后右旋"></p>
<h3 id="先右旋后左旋"><a href="#先右旋后左旋" class="headerlink" title="先右旋后左旋"></a>先右旋后左旋</h3><p><img src="/../images/avltree_right_left_rotate.png" alt="先右旋后左旋"></p>
<p><img src="/../images/avltree_rotation_cases.png" alt="AVL 树的四种旋转情况"><img src="/../images/image-20240430092611363.png" alt="image-20240430092611363"></p>
<p>DFS（深度优先搜索）遍历二叉树是一种遍历或搜索算法，用来访问二叉树中的所有节点，其目的是尽可能深地访问树的分支。DFS在二叉树中常用的有三种遍历方式：前序遍历（Pre-order）、中序遍历（In-order）和后序遍历（Post-order）。下面详细解释这三种遍历方式：</p>
<ol>
<li><strong>前序遍历（Pre-order Traversal）</strong>：<ul>
<li>访问顺序：先访问根节点，然后递归地进行前序遍历左子树，接着递归地进行前序遍历右子树。</li>
<li>应用：前序遍历常用于打印树的结构，复制树结构。</li>
</ul>
</li>
<li><strong>中序遍历（In-order Traversal）</strong>：<ul>
<li>访问顺序：先递归地进行中序遍历左子树，然后访问根节点，最后递归地进行中序遍历右子树。</li>
<li>应用：对于二叉搜索树（BST），中序遍历可以得到一个有序的数据序列。</li>
</ul>
</li>
<li><strong>后序遍历（Post-order Traversal）</strong>：<ul>
<li>访问顺序：先递归地进行后序遍历左子树，然后递归地进行后序遍历右子树，最后访问根节点。</li>
<li>应用：后序遍历常用于访问节点后再执行操作的场景，如计算一个文件夹的总大小时。</li>
</ul>
</li>
</ol>
<p>DFS 遍历的核心在于使用递归（或显式使用栈）来实现持续深入每个分支直到达到叶子节点或满足某些条件后回溯到上一节点。这种方式非常适合处理具有层级关系的数据，如文件系统的目录结构、组织结构等。在二叉树的上下文中，DFS遍历可以帮助理解和操作树的结构。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">visited.count(adjVet)</span></span></code></pre></div><p><code>count</code> 是 <code>unordered_set</code> 提供的的一个成员函数，它返回集合中指定元素的数量。如果 <code>adjVet</code> 是指向图中的一个顶点的指针，并且这个顶点已经被添加到 <code>visited</code> 集合中，那么 <code>visited.count(adjVet)</code> 将返回 <code>1</code>，表示该顶点已经被访问过。如果 <code>adjVet</code> 不在 <code>visited</code> 集合中，那么返回 <code>0</code>，表示该顶点还没有被访问过。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">visited.emplace(adjVet);</span></span></code></pre></div><p><code>emplace</code> 是一个函数，它用于在容器中直接构造并插入元素，而不需要创建元素的副本</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Algo.html" data-id="clxbjvuxl000161cxd1ygg6br" data-title="Algo" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-FPGA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/FPGA.html" class="article-date">
  <time class="dt-published" datetime="2024-04-24T03:03:09.000Z" itemprop="datePublished">2024-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/FPGA.html">FPGA</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>assign</code> 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在always块中）不同，后者在某种事件或条件发生时才更新值。</p>
<p>assign temp2 &#x3D; {32{1’b0}}; 是什么意思?</p>
<p>在Verilog中，<code>assign temp2 = &#123;32&#123;1&#39;b0&#125;&#125;;</code> 这行代码声明了一个连续赋值，将 <code>temp2</code> 这个线网的值设置为一个32位的全0值。</p>
<p>这里的 <code>&#123;32&#123;1&#39;b0&#125;&#125;</code> 是一个重复拼接操作，含义如下：</p>
<ul>
<li><code>1&#39;b0</code> 是一个二进制数，表示一个位宽为1的数值，值为0。</li>
<li><code>&#123;32&#123;1&#39;b0&#125;&#125;</code> 表示将 <code>1&#39;b0</code> 这个值重复32次。</li>
</ul>
<h6 id="Verilog-数据类型"><a href="#Verilog-数据类型" class="headerlink" title="Verilog 数据类型"></a>Verilog 数据类型</h6><p>Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。</p>
<p><strong>整数（integer）</strong>   reg 型变量为无符号数，而 integer 型变量为有符号数</p>
<p><strong>实数（real）</strong></p>
<p>在Verilog中，<code>real</code> 和 <code>integer</code> 是数据类型关键字，分别用于声明实数类型和整数类型的变量。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">real data1;</span></span>
<span class="line"><span style="color: #babed8">integer temp;</span></span>
<span class="line"><span style="color: #babed8">initial begin</span></span>
<span class="line"><span style="color: #babed8">    data1 = 2e3;</span></span>
<span class="line"><span style="color: #babed8">    data1 = 3.75;</span></span>
<span class="line"><span style="color: #babed8">end</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">initial begin</span></span>
<span class="line"><span style="color: #babed8">    temp = data1; //temp 值的大小为3</span></span>
<span class="line"><span style="color: #babed8">end</span></span></code></pre></div><p>这段代码包含两个 <code>initial</code> 块，它们在仿真开始时执行一次。</p>
<p>第一个 <code>initial</code> 块中：</p>
<ol>
<li><code>data1</code> 被初始化为实数类型 <code>real</code>。</li>
<li><code>data1</code> 被赋值为 <code>2e3</code>，这意味着 <code>data1</code> 现在的值是2000.0。</li>
<li>随后，<code>data1</code> 被更新为 <code>3.75</code>。</li>
</ol>
<p>第二个 <code>initial</code> 块中：</p>
<ol>
<li><code>temp</code> 被初始化为整数类型 <code>integer</code>。</li>
<li><code>temp</code> 被赋值为 <code>data1</code> 的值。由于 <code>data1</code> 当前是 <code>3.75</code>，这个赋值会将实数转换为整数。在Verilog中，实数赋值给整数时，会进行取整操作，保留数值的整数部分，忽略小数部分。因此，<code>temp</code> 的值将是3。</li>
</ol>
<p>需要注意的是，您的注释 <code>//temp 值的大小为3</code> 是正确的，因为 <code>data1</code> 的值 <code>3.75</code> 在赋值给 <code>temp</code> 时会被取整为3。</p>
<p><strong>时间（time）</strong></p>
<p>Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间。例如：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">time current_time;</span></span>
<span class="line"><span style="color: #babed8">initial begin</span></span>
<span class="line"><span style="color: #babed8">    #100;</span></span>
<span class="line"><span style="color: #babed8">    current_time = $time; //current_time 的大小为 100</span></span>
<span class="line"><span style="color: #babed8">end</span></span></code></pre></div><p>这段代码包含一个 <code>initial</code> 块，它在仿真开始时执行一次。</p>
<p>在 <code>initial</code> 块中：</p>
<ol>
<li><code>current_time</code> 被初始化为时间类型 <code>time</code>。</li>
<li><code>#100;</code> 是一个延迟语句，它会使仿真暂停100个时间单位。在Verilog中，<code>#</code> 后面跟一个数字表示延迟的时间量。</li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>存储器</p>
<h6 id="参数-参数用来表示常量，用关键字-parameter-声明，只能赋值一次"><a href="#参数-参数用来表示常量，用关键字-parameter-声明，只能赋值一次" class="headerlink" title="参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次"></a>参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次</h6><p><strong>parameter</strong>    data_width &#x3D; 10’d32 ;</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。</p>
<p>字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0  来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”,  需要 14*8bit 的存储单元：</p>
<p><strong>reg</strong> [0: 14*8-1]    str ;<br> <strong>initial</strong> <strong>begin</strong><br>   str &#x3D; “run.runoob.com”;<br> <strong>end</strong>  </p>
<p><img src="/../images/IMG_20240424_115210.jpg" alt="IMG_20240424_115210"></p>
<p><img src="/../images/IMG_20240424_115158.jpg" alt="IMG_20240424_115158"></p>
<p><img src="/../images/IMG_20240424_115542.jpg" alt="IMG_20240424_115542"></p>
<p><img src="/../images/IMG_20240424_115525.jpg" alt="IMG_20240424_115525"></p>
<p><img src="/../images/IMG_20240424_115506.jpg" alt="IMG_20240424_115506"></p>
<h2 id="2-4-Verilog-表达式"><a href="#2-4-Verilog-表达式" class="headerlink" title="2.4 Verilog 表达式"></a>2.4 Verilog 表达式</h2><p>表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。</p>
<p> a^b ;      <em>&#x2F;&#x2F;a与b进行异或操作</em><br> address[9:0] + 10’b1 ;  <em>&#x2F;&#x2F;地址累加</em><br> flag1 &amp;&amp; flag2 ;  <em>&#x2F;&#x2F;逻辑与操作</em></p>
<p><em>always块里赋值对象不能是wire型</em></p>
<p>同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">//自右向左关联，两种写法等价</span></span>
<span class="line"><span style="color: #babed8">A+B-C ;</span></span>
<span class="line"><span style="color: #babed8">(A+B）-C ;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">//自右向左关联，两种写法等价，结果为 B、D 或 F</span></span>
<span class="line"><span style="color: #babed8">A ? B : C ? D : F ;</span></span>
<span class="line"><span style="color: #babed8">A ? B : (C ? D : F) ;</span></span></code></pre></div><p>求幂（**）、取模（%）</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">b = 4&#39;b100x;</span></span></code></pre></div><p><code>x</code> 是一个表示未知或不可确定状态的字符。它用于在仿真中表示一个位的值是未知的，这通常发生在综合过程中，当某些逻辑路径没有被明确赋值时，或者在设计中的某些部分还没有完全定义时。</p>
<p>无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和</p>
<p><strong>reg</strong> [3:0]     mula ;<br> <strong>reg</strong> [1:0]     mulb;<br> <strong>reg</strong> [5:0]     res ;<br> mula &#x3D; 4’he  ;<br> mulb &#x3D; 2’h3  ;<br> res  &#x3D; mula * mulb ; <em>&#x2F;&#x2F;结果为res&#x3D;6’h2a, 数据结果没有丢失位数</em></p>
<p>逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）</p>
<p>按位操作符包括：取反(<del>)，与（&amp;），或（|），异或（^），同或（</del>^）</p>
<p>按位操作符对 2 个操作数的每 1bit 数据进行按位操作,如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。</p>
<h3 id="归约操作符"><a href="#归约操作符" class="headerlink" title="归约操作符"></a>归约操作符</h3><p>归约操作符包括：归约与（&amp;），归约与非（<del>&amp;），归约或（|），归约或非（</del>|），归约异或（^），归约同或（~^）。</p>
<p>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</p>
<p>逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">A = 4&#39;b1010 ;</span></span>
<span class="line"><span style="color: #babed8">&amp;A ;      //结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#39;b0，可用来判断变量A是否全1</span></span>
<span class="line"><span style="color: #babed8">~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1&#39;b0, 可用来判断变量A是否为全0</span></span>
<span class="line"><span style="color: #babed8">^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1&#39;b0</span></span></code></pre></div><h3 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h3><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p>
<p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p>
<p>算术左移和逻辑左移时，右边低位会补 0。</p>
<p>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>A &#x3D; 4’b1100 ;<br> B &#x3D; 4’b0010 ;<br> A &#x3D; A &gt;&gt; 2 ;     <em>&#x2F;&#x2F;结果为 4’b0011</em><br> A &#x3D; A &lt;&lt; 1;     *&#x2F;&#x2F;结果为 4’b1000*<br> A &#x3D; A &lt;&lt;&lt; 1 ;    *&#x2F;&#x2F;结果为 4’b1000*<br> C &#x3D; B + (A&gt;&gt;&gt;2);   <em>&#x2F;&#x2F;结果为 2 + (-4&#x2F;4) &#x3D; 1, 4’b0001</em></p>
<h3 id="define-undef"><a href="#define-undef" class="headerlink" title="define, undef"></a><code>define, </code>undef</h3><p>在编译阶段，&#96;define 用于文本替换，类似于 C 语言中的 <strong>#define</strong>。</p>
<p>&#96;undef 用来取消之前的宏定义</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`ifdef       MCU51</span></span>
<span class="line"><span style="color: #babed8">    parameter DATA_DW = 8   ;</span></span>
<span class="line"><span style="color: #babed8">`elsif       WINDOW</span></span>
<span class="line"><span style="color: #babed8">    parameter DATA_DW = 64  ;</span></span>
<span class="line"><span style="color: #babed8">`else</span></span>
<span class="line"><span style="color: #babed8">    parameter DATA_DW = 32  ;</span></span>
<span class="line"><span style="color: #babed8">`endif</span></span></code></pre></div><h3 id="include"><a href="#include" class="headerlink" title="&#96;include"></a>&#96;include</h3><p>使用 &#96;include 可以在编译时将一个 Verilog 文件内嵌到另一个 Verilog 文件中，作用类似于 C 语言中的 #include 结构。</p>
<h3 id="timescale"><a href="#timescale" class="headerlink" title="timescale"></a>timescale</h3><p>在 Verilog 模型中，时延有具体的单位时间表述，并用 &#96;timescale 编译指令将时间单位与实际时间相关联。</p>
<p>该指令用于定义时延、仿真的单位和精度，格式为：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`timescale      time_unit / time_precision</span></span></code></pre></div><p>time_unit 表示时间单位，time_precision 表示时间精度，它们均是由数字以及单位  s（秒），ms（毫秒），us（微妙），ns（纳秒），ps（皮秒）和  fs（飞秒）组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小，例如下面例子中，输出端 Z 会延迟 5.21ns 输出  A&amp;B 的结果。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><code>timescale 1ns/100ps   *//时间单位为1ns，精度为100ps，合法*  *//</code>timescale 100ps&#x2F;1ns  &#x2F;&#x2F;不合法*<br> <strong>module</strong> AndFunc(Z, A, B);<br>   <strong>output</strong> Z;<br>   <strong>input</strong> A, B ;<br>   <strong>assign</strong> #5.207 Z &#x3D; A &amp; B<br> <strong>endmodule</strong></p>
<p>在编译过程中，<code>timescale 指令会影响后面所有模块中的时延值，直至遇到另一个 </code>timescale 指令或 &#96;resetall 指令。 </p>
<p>由于在 Verilog 中没有默认的 <code>timescale，如果没有指定 </code>timescale，Verilog 模块就有会继承前面编译模块的 &#96;timescale 参数。有可能导致设计出错。</p>
<p>如果一个设计中的多个模块都带有 &#96;timescale 时，模拟器总是定位在所有模块的最小时延精度上，并且所有时延都相应地换算为最小时延精度</p>
<h3 id="default-nettype"><a href="#default-nettype" class="headerlink" title="&#96;default_nettype"></a>&#96;default_nettype</h3><p>该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`default_nettype wand </span></span></code></pre></div><p>该实例定义的缺省的线网为线与类型。因此，如果在此指令后面的任何模块中的连线没有说明，那么该线网被假定为线与类型。  </p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`default_nettype none</span></span></code></pre></div><p>该实例定义后，将不再自动产生 wire 型变量。</p>
<h3 id="celldefine-endcelldefine"><a href="#celldefine-endcelldefine" class="headerlink" title="celldefine, endcelldefine"></a><code>celldefine, </code>endcelldefine</h3><p>这两个程序指令用于将模块标记为单元模块，他们包含模块的定义。例如一些与、或、非门，一些 PLL 单元，PAD 模型，以及一些 Analog IP 等。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><code>celldefine  **module** (    **input**    clk,    **input**    rst,    **output**   clk_pll,    **output**   flag);      ……  **endmodule**  </code>endcelldefine</p>
<h3 id="unconnected-drive-nounconnected-drive"><a href="#unconnected-drive-nounconnected-drive" class="headerlink" title="unconnected_drive, nounconnected_drive"></a><code>unconnected_drive, </code>nounconnected_drive</h3><p>在模块实例化中，出现在这两个编译指令间的任何未连接的输入端口，为正偏电路状态或者为反偏电路状态。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">assign</span></span></code></pre></div><p>用于对 wire 型变量进行赋值,不对寄存器赋值</p>
<p>进位输出（Carry  out，通常表示为Co或Cout）是全加器的一个输出，它表示在两个二进制位相加时是否产生了进位。在二进制加法中，当两个加数位（A和B）的和大于或等于2时，就会产生进位，因为二进制中的每一位只能表示0或1。进位输出就是用来表示这个进位的。</p>
<p><strong>module</strong> full_adder1(<br>   <strong>input</strong>   Ai, Bi, Ci,<br>   <strong>output</strong>  So, Co);</p>
<p>   <strong>assign</strong> So &#x3D; Ai ^ Bi ^ Ci ;<br>   <strong>assign</strong> Co &#x3D; (Ai &amp; Bi) | (Ci &amp; (Ai | Bi));<br> <strong>endmodule</strong></p>
<p>更简单的：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">module full_adder1(</span></span>
<span class="line"><span style="color: #babed8">    input Ai, Bi, Ci,</span></span>
<span class="line"><span style="color: #babed8">    output So, Co);</span></span>
<span class="line"><span style="color: #babed8">    </span></span>
<span class="line"><span style="color: #babed8">    assign &#123;Co, So&#125; = Ai + Bi + Ci;</span></span>
<span class="line"><span style="color: #babed8">endmodule</span></span></code></pre></div><p><em>&#x2F;&#x2F;普通时延，A&amp;B计算结果延时10个时间单位赋值给Z</em><br> <strong>wire</strong> Z, A, B ;<br> <strong>assign</strong> #10   Z &#x3D; A &amp; B ;</p>
<p> <em>&#x2F;&#x2F;隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。</em><br> <strong>wire</strong> A, B;<br> <strong>wire</strong> #10     Z &#x3D; A &amp; B;</p>
<p> <em>&#x2F;&#x2F;声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。</em><br> <strong>wire</strong> A, B;<br> <strong>wire</strong> #10 Z ;<br> <strong>assign</strong>      Z &#x3D;A &amp; B</p>
<h2 id="Verilog-过程结构"><a href="#Verilog-过程结构" class="headerlink" title="Verilog 过程结构"></a>Verilog 过程结构</h2><p>过程结构语句有 2 种，initial 与 always 语句</p>
<p>一个模块中可以包含多个 initial 和 always 语句，但 2 种语句不能嵌套使用。</p>
<p>但是 initial 语句或 always 语句内部可以理解为是顺序执行的（非阻塞赋值除外）。</p>
<h3 id="initial语句"><a href="#initial语句" class="headerlink" title="initial语句"></a>initial语句</h3><p>initial 语句从 0 时刻开始执行，只执行一次，多个 initial 块之间是相互独立的。</p>
<p>如果 initial 块内包含多个语句，需要使用关键字 begin 和 end 组成一个块语句。</p>
<p>如果 initial 块内只要一条语句，关键字 begin 和 end 可使用也可不使用。</p>
<p>initial 理论上来讲是不可综合的，多用于初始化、信号检测等。</p>
<h4 id="这些语句在模块间并行执行，与其在模块的前后顺序没有关系"><a href="#这些语句在模块间并行执行，与其在模块的前后顺序没有关系" class="headerlink" title="这些语句在模块间并行执行，与其在模块的前后顺序没有关系"></a>这些语句在模块间并行执行，与其在模块的前后顺序没有关系</h4><h3 id="always-语句"><a href="#always-语句" class="headerlink" title="always 语句"></a>always 语句</h3><p>与 initial 语句相反，always 语句是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。</p>
<p>由于循环执行的特点，always 语句多用于仿真时钟的产生，信号行为的检测等。   </p>
<h6 id="parameter-关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。"><a href="#parameter-关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。" class="headerlink" title="parameter 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。"></a><code>parameter</code> 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。</h6><p>连续性赋值使用assign语句，而过程性赋值使用always块。</p>
<p>阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。</p>
<p>阻塞赋值语句使用等号 &#x3D; 作为赋值符。</p>
<p>非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。</p>
<p>非阻塞赋值语句使用小于等于号 &lt;&#x3D; 作为赋值符。</p>
<p>如下所示，2 个 always 块中语句并行执行，赋值操作右端操作数使用的是上一个时钟周期的旧值，此时 a&lt;&#x3D;b 与 b&lt;&#x3D;a 就可以相互不干扰的执行，达到交换寄存器值的目的。</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><p><strong>always</strong> @(<strong>posedge</strong> clk) <strong>begin</strong><br>   a &lt;&#x3D; b ;<br> <strong>end</strong></p>
<p> <strong>always</strong> @(<strong>posedge</strong> clk) <strong>begin</strong><br>   b &lt;&#x3D; a;<br> <strong>end</strong></p>
<h2 id="Verilog-时序控制"><a href="#Verilog-时序控制" class="headerlink" title="Verilog 时序控制"></a>Verilog 时序控制</h2><p>Verilog 提供了 2 大类时序控制方法：时延控制和事件控制。事件控制主要分为边沿触发事件控制与电平敏感事件控制</p>
<h3 id="时延控制-根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。"><a href="#时延控制-根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。" class="headerlink" title="时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。"></a>时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。</h3><p><strong>常规时延</strong></p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">reg  value_test ;</span></span>
<span class="line"><span style="color: #babed8">reg  value_general ;</span></span>
<span class="line"><span style="color: #babed8">#10  value_general    = value_test ;</span></span></code></pre></div><p>或：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">#10 ;</span></span>
<span class="line"><span style="color: #babed8">value_ single         = value_test ;</span></span></code></pre></div><p><strong>内嵌时延</strong></p>
<p>遇到内嵌延时时，该语句先将计算结果保存，然后等待一定的时间后赋值给目标信号。</p>
<p>内嵌时延控制加在赋值号之后。例如：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">reg  value_test ;</span></span>
<span class="line"><span style="color: #babed8">reg  value_embed ;</span></span>
<span class="line"><span style="color: #babed8">value_embed        = #10 value_test ;</span></span></code></pre></div><p>需要说明的是，这 2 种时延控制方式的效果是有所不同的。</p>
<p>当延时语句的赋值符号右端是常量时，2 种时延控制都能达到相同的延时赋值效果。</p>
<p>当延时语句的赋值符号右端是变量时，2 种时延控制可能会产生不同的延时赋值效果。</p>
<h3 id="边沿触发事件控制"><a href="#边沿触发事件控制" class="headerlink" title="边沿触发事件控制"></a>边沿触发事件控制</h3><p>在 Verilog 中，事件是指某一个 reg 或 wire 型变量发生了值的变化。事件控制用符号 @ 表示。</p>
<p><strong>设计</strong>：根据需求编写硬件描述语言（如Verilog或VHDL）代码来描述设计的功能和行为</p>
<p>synthesize综合，合成：综合代码，检查语法是否有错误,将高级的逻辑描述代码转换为逻辑门级别的网表或等效的门级电路</p>
<p>FloorPlanner 是 FPGA 设计流程中的一个重要工具，用于执行布局（Place）阶段的子任务，即对设计中的逻辑电路进行布局安置。在 FPGA 设计流程中，FloorPlanner 的地位如下：</p>
<ol>
<li><strong>布局规划</strong>：FloorPlanner 负责规划 FPGA 芯片上各个逻辑模块的布局位置，以最大程度地满足设计的性能和资源利用率要求。它会考虑逻辑模块之间的布线延迟、信号传输路径长度等因素，以优化整体的布局结构。</li>
<li><strong>资源分配</strong>：FloorPlanner 还负责将设计中的逻辑模块分配到 FPGA 芯片的不同区域，并且合理利用芯片上的资源（如片上存储器、DSP模块等），以满足设计对资源的需求。</li>
<li><strong>时序约束</strong>：在布局过程中，FloorPlanner 还会考虑时序约束，确保设计中的时序要求能够得到满足。它会尽可能减少逻辑模块之间的传输延迟，以确保时序性能。</li>
<li><strong>优化布局</strong>：FloorPlanner 通过对设计进行优化布局，以降低布线延迟、减少时序问题和功耗等方面的优化。这可以提高设计的性能、可靠性和功耗效率。</li>
</ol>
<p>在 FPGA 设计流程中，FloorPlanner 位于布局（Place）阶段之前，它为后续的布线（Route）阶段提供了优化的布局结果，从而帮助实现设计的最终映射和部署。</p>
<p><strong>Place&amp;Route</strong> ：</p>
<p>开发流程中的 Place &amp; Route 是指在将设计映射到 FPGA 芯片时的一个重要步骤。下面解释一下它的含义和作用：</p>
<ol>
<li><strong>Place（放置）</strong>：Place 指的是将设计中的逻辑元素（如逻辑门、寄存器等）放置到 FPGA 芯片的物理位置上。这一步骤考虑了芯片内部的布局和连接资源，以尽可能地优化性能和资源利用率。放置的目标是最小化延迟、最大化时序性能，并且尽量减少芯片内的布线冲突。</li>
<li><strong>Route（布线）</strong>：Route 是指将设计中的逻辑元素之间的连接关系转化为芯片内部的实际物理连线。这一步骤考虑了芯片内部的连线资源、信号传输延迟等因素，以确保逻辑元素之间的连接能够有效地建立并满足时序要求。布线的目标是尽可能地降低信号传输延迟、最小化信号干扰，同时满足设计的时序约束。</li>
</ol>
<p>在 Verilog 中，<code>reg</code> 类型通常用于表示存储元素（如寄存器），而不是直接连接到模块的输出端口。输出端口通常使用 <code>output</code> 或 <code>inout</code> 声明，并且通常需要与 <code>wire</code> 类型一起使用。</p>
<p><code>reg</code> 类型在 Verilog 中表示的是寄存器类型，它在 <code>always</code> 块中使用，存储状态或信号。而 <code>output</code> 端口应该使用 <code>wire</code> 类型来表示，因为它们不会存储状态，只是将信号传递给其他部件。</p>
<p>因此，你在模块顶层中使用 <code>output reg</code> 是不符合常规的 Verilog 设计习惯的，通常应该使用 <code>output wire</code>。</p>
<p><img src="/../images/image-20240427142422285.png" alt="image-20240427142422285"></p>
<p>半加器（Half Adder）和全加器（Full Adder）是数字电路中用于执行二进制加法的基本组件。它们的主要区别在于它们处理的输入数量和功能。</p>
<p>半加器： 半加器是一个组合逻辑电路，它接受两个二进制位作为输入，并产生两个输出：和（Sum）和进位（Carry）。半加器只处理两个输入位的加法，不考虑来自较低位的进位。半加器的输出进位只能表示当前两个输入位相加是否产生了进位。</p>
<p>半加器的逻辑可以表示为：</p>
<ul>
<li><p>•</p>
<p>和（Sum） &#x3D; A XOR B</p>
</li>
<li><p>•</p>
<p>进位（Carry） &#x3D; A AND B</p>
</li>
</ul>
<p>其中，A和B是两个输入位，XOR表示异或门，AND表示与门。</p>
<p>全加器： 全加器也是一个组合逻辑电路，它接受三个二进制位作为输入，并产生两个输出：和（Sum）和进位（Carry）。全加器的三个输入包括两个加数位（A和B）以及来自较低位的进位（Carry-in）。全加器能够处理包括进位在内的三个位的加法。</p>
<p>全加器的逻辑可以表示为：</p>
<ul>
<li><p>•</p>
<p>和（Sum） &#x3D; (A XOR B) XOR Carry-in</p>
</li>
<li><p>•</p>
<p>进位（Carry） &#x3D; (A AND B) OR (Carry-in AND (A XOR B))</p>
</li>
</ul>
<p>其中，Carry-in是来自较低位的进位，OR表示或门。</p>
<p>区别：</p>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<p>  输入数量：半加器有两个输入，全加器有三个输入。</p>
<ol start="2">
<li><ol start="2">
<li></li>
</ol>
</li>
</ol>
<p>  功能：半加器只计算两个输入位的和和进位，而全加器计算三个输入位（包括来自较低位的进位）的和和进位。</p>
<ol start="3">
<li><ol start="3">
<li></li>
</ol>
</li>
</ol>
<p>  应用：半加器通常用于构建更复杂的加法器电路，如全加器。全加器则用于实现多位二进制数的加法，因为它能够处理进位。</p>
<p>在实际的数字电路设计中，全加器更为常用，因为它可以级联（Cascade）起来构成多位加法器，如4位、8位、16位等，从而实现更复杂的算术运算。</p>
<p>在Verilog中，<code>parameter</code>是一个关键字，用于定义模块（module）的参数</p>
<p><code>parameter</code>定义的值在模块的整个实例化过程中都是固定的，不能被重新赋值。这意味着一旦定义了<code>parameter</code>，它的值在整个模块中都是不变的。</p>
<p>Assignment 赋值</p>
<p>SP代表single port单端口模式，即同一时钟控制读写，同一时间只能写或者度</p>
<p>在您提供的 Verilog 代码片段中，<code>ram_inst</code> 是一个实例化语句，用于创建一个 RAM 模块的实例。这个实例使用了多个引脚（pins），这些引脚定义了模块的输入和输出接口。下面是每个引脚的详细解释：</p>
<ul>
<li><p>•</p>
<p><code>.dout(dout_o)</code>：这是 RAM 模块的输出引脚，名为 <code>dout</code>，它是一个 8 位宽度的输出信号。在这个实例中，它被连接到了一个名为 <code>dout_o</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.clk(clk)</code>：这是 RAM 模块的时钟输入引脚，用于同步数据写入和读取操作。它被连接到了一个名为 <code>clk</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.oce(oce_i)</code>：这是 RAM 模块的输出使能输入引脚，用于控制 <code>dout</code> 信号是否输出数据。它被连接到了一个名为 <code>oce_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.ce(ce_i)</code>：这是 RAM 模块的芯片使能输入引脚，用于控制 RAM 是否可以进行读写操作。它被连接到了一个名为 <code>ce_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.reset(reset_i)</code>：这是 RAM 模块的复位输入引脚，用于将 RAM 恢复到初始状态。它被连接到了一个名为 <code>reset_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.wre(wre_i)</code>：这是 RAM 模块的写使能输入引脚，用于控制是否可以写入数据到 RAM。它被连接到了一个名为 <code>wre_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.ad(addr)</code>：这是 RAM 模块的地址输入引脚，用于指定要读取或写入的 RAM 单元的地址。它被连接到了一个名为 <code>addr</code> 的信号，该信号是 11 位宽度的。</p>
</li>
<li><p>•</p>
<p><code>.din(data_i)</code>：这是 RAM 模块的数据输入引脚，用于写入数据到 RAM。它被连接到了一个名为 <code>data_i</code> 的信号，该信号是 8 位宽度的。</p>
</li>
</ul>
<p>每个引脚都是 RAM 模块与其外部接口之间的连接点，它们定义了模块如何与外部信号交互。在实际的设计中，您需要确保这些引脚被正确地连接到相应的信号，并且信号的类型和宽度与 RAM 模块的要求相匹配。</p>
<p>FPGA中BRAM和DRAM的区别</p>
<p>FPGA（现场可编程门阵列）中的BRAM（块RAM）和DRAM（动态RAM）是两种不同类型的存储器，它们在设计和使用上有着显著的区别：</p>
<ol>
<li><strong>类型和用途</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：是静态RAM（SRAM）的一种形式，通常集成在FPGA芯片内部。它提供快速的存储解决方案，适用于需要高速、小容量存储的应用，如缓存、缓冲区或FPGA内部的数据存储。</li>
<li><strong>DRAM</strong>：是一种动态RAM，与FPGA芯片外部连接。它具有更高的存储密度，但速度较BRAM慢。DRAM适用于需要大容量存储的应用，如图像处理、视频缓冲和大量数据存储。</li>
</ul>
<ol start="2">
<li><strong>存储机制</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：作为静态RAM，它不需要刷新电路来维持数据。每个存储单元都使用六晶体管（6T）的SRAM细胞结构，这意味着它可以无限期地保持数据，直到被写入新数据。</li>
<li><strong>DRAM</strong>：作为动态RAM，它需要定期刷新来维持数据。每个存储单元通常由一个电容器和一个晶体管组成，因此它的密度可以更高，但速度较慢，并且需要更复杂的控制逻辑。</li>
</ul>
<ol start="3">
<li><strong>性能特点</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：提供单周期访问时间，这意味着访问数据几乎立即完成，适用于要求严格实时性能的应用。</li>
<li><strong>DRAM</strong>：由于其刷新要求，访问速度较慢，通常需要多个时钟周期来访问数据。</li>
</ul>
<ol start="4">
<li><strong>集成度</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：在FPGA芯片内部，与逻辑元素紧密集成，可以提供非常低的延迟访问。</li>
<li><strong>DRAM</strong>：通常作为外部组件连接到FPGA，通过内存接口（如DDR）进行通信。</li>
</ul>
<ol start="5">
<li><strong>功耗</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：由于其简单性和快速访问能力，通常功耗较低。</li>
<li><strong>DRAM</strong>：由于需要刷新和复杂的控制逻辑，功耗通常更高。</li>
</ul>
<p>在选择使用BRAM还是DRAM时，设计者需要根据应用需求、性能要求、成本考虑和功耗限制来做出决策。对于需要高速、小容量存储的应用，BRAM通常是更好的选择；而对于需要大容量存储的应用，DRAM可能是更合适的选择。</p>
<p>在FPGA中，BRAM（块RAM）可以被配置为单端口模式或双端口模式，这两种模式在数据访问方式上有所不同：</p>
<ol>
<li><strong>单端口模式</strong>：</li>
</ol>
<ul>
<li>在单端口模式下，BRAM有一个数据访问端口，即地址和数据线是共用的。</li>
<li>在任何给定的时间，单端口BRAM只能进行一次读操作或写操作。如果在一个时钟周期内同时尝试进行读和写操作，通常会发生冲突，除非特定的FPGA具有特殊的管理机制。</li>
<li>单端口模式适用于那些不需要同时进行读写操作的应用场景，或者那些可以接受顺序访问的应用场景。</li>
</ul>
<ol start="2">
<li><strong>双端口模式</strong>：</li>
</ol>
<ul>
<li>双端口模式允许BRAM同时通过两个独立的端口进行访问，每个端口都有自己的地址线、数据线和控制线。</li>
<li>这意味着双端口BRAM可以在同一时钟周期内进行一次读操作和一次写操作，或者同时进行两次读操作，访问不同的地址。</li>
<li>双端口模式适用于需要同时或并行访问存储器中不同位置的应用场景，如图像处理、缓存和乒乓缓冲等。</li>
</ul>
<p>在某些FPGA中，BRAM还可以配置为更高级的端口模式，如四端口模式，这允许更多的并行访问。设计者根据具体应用的需求来选择最合适的端口模式，以优化性能和资源利用。</p>
<p>十六进制数系统中的每个数字代表4位二进制数</p>
<p>在Verilog中，<code>defparam</code>是一个编译器指令，用于在模块实例化时重定义参数的值。这条指令可以用来改变模块实例化时参数的默认值。</p>
<p>在Verilog中，<code>localparam</code>关键字用于声明一个模块内部的参数，这个参数在模块的整个作用域内都是常量。<code>localparam</code>声明的参数是不可变的，它们的值在编译时就已经确定了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/FPGA.html" data-id="clxbjvuxp000861cxbhoich4q" data-title="FPGA" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Android-Kotlin" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Android-Kotlin.html" class="article-date">
  <time class="dt-published" datetime="2024-04-21T12:52:23.000Z" itemprop="datePublished">2024-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Android-Kotlin.html">Android_Kotlin</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`class FirstActivity : AppCompatActivity() &#123;`</span></span>
<span class="line"><span style="color: #babed8">`override fun onCreate(savedInstanceState: Bundle?) &#123;`</span></span>
<span class="line"><span style="color: #babed8">`super.onCreate(savedInstanceState)`</span></span>
<span class="line"><span style="color: #babed8">`&#125;`</span></span>
<span class="line"><span style="color: #babed8">`&#125;`</span></span></code></pre></div><p>这段代码是使用 Kotlin 语言编写的 Android 应用程序中的一个活动（Activity）类。让我逐步解释其中的内容：</p>
<ol>
<li><code>class FirstActivity : AppCompatActivity()</code>：这是一个类的声明，类名为 <code>FirstActivity</code>，并且继承自 <code>AppCompatActivity</code> 类。<code>AppCompatActivity</code> 是 Android 开发中常用的一个基类，用于支持应用程序在较旧的 Android 版本上提供向后兼容性。</li>
<li><code>override fun onCreate(savedInstanceState: Bundle?)</code>：这是 <code>FirstActivity</code> 类中的一个方法 <code>onCreate()</code> 的重写。在 Android 中，<code>onCreate()</code> 方法是活动生命周期的一部分，在活动第一次创建时被调用。<code>savedInstanceState</code> 参数是一个 <code>Bundle</code> 对象，其中包含了之前保存的活动状态信息，可以用于在活动重新创建时恢复状态。</li>
<li><code>super.onCreate(savedInstanceState)</code>：这是调用父类 <code>AppCompatActivity</code> 中的 <code>onCreate()</code> 方法，确保父类中的初始化工作得以执行。</li>
</ol>
<p>因此，这段代码定义了一个名为 <code>FirstActivity</code> 的活动类，当该活动第一次创建时，会调用父类的 <code>onCreate()</code> 方法进行初始化。</p>
<p>在声明 <code>savedInstanceState</code> 参数时，如果在类型后面添加了 <code>?</code>，则表示该参数可以接受 <code>null</code> 值。</p>
<p>这样做的目的是为了允许 <code>savedInstanceState</code> 参数在某些情况下为 null，例如当活动或片段首次创建时，<code>savedInstanceState</code> 可能为 null，因为此时还没有保存任何状态信息。</p>
<p>在 Kotlin 中，如果没有使用 <code>?</code>，则表示该参数不接受 null 值，如果在实际使用中传递了 null 值，编译器将会报错。而使用了 <code>?</code> 后，表示该参数可以接受 null 值，编译器将不会报错。</p>
<p>因此，在 <code>override fun onCreate(savedInstanceState: Bundle?)</code> 中，<code>Bundle?</code> 表示 <code>savedInstanceState</code> 参数可以接受 null 值，即在某些情况下，<code>savedInstanceState</code> 可能为 null。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span></span>
<span class="line"><span style="color: #babed8">android:orientation=&quot;vertical&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_width=&quot;match_parent&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_height=&quot;match_parent&quot;&gt;</span></span>
<span class="line"><span style="color: #babed8">&lt;Button</span></span>
<span class="line"><span style="color: #babed8">android:id=&quot;@+id/button1&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_width=&quot;match_parent&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_height=&quot;wrap_content&quot;</span></span>
<span class="line"><span style="color: #babed8">android:text=&quot;Button 1&quot;</span></span>
<span class="line"><span style="color: #babed8">/&gt;</span></span>
<span class="line"><span style="color: #babed8">&lt;/LinearLayout&gt;</span></span></code></pre></div><p>这段代码是一个简单的 Android 布局文件，使用 XML 格式描述了一个线性布局（LinearLayout）以及一个按钮（Button）的布局和属性。</p>
<p>让我解释其中的一些关键部分：</p>
<ul>
<li><code>&lt;LinearLayout&gt;</code>：这是一个布局容器，用于在垂直方向排列其子视图（例如按钮）。<code>xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</code> 是 XML 命名空间声明，它使得可以在 XML 文件中使用 Android 提供的属性和元素。</li>
<li><code>android:orientation=&quot;vertical&quot;</code>：这个属性指定了线性布局的方向，即垂直方向。这意味着其中的子视图（此处为按钮）将会按照垂直方向排列。</li>
<li><code>android:layout_width=&quot;match_parent&quot;</code> 和 <code>android:layout_height=&quot;match_parent&quot;</code>：这两个属性指定了布局的宽度和高度。<code>match_parent</code> 表示该布局将会填充其父容器的宽度或高度，以占据尽可能多的空间。</li>
<li><code>&lt;Button&gt;</code>：这是一个按钮视图，在布局中用于响应用户的点击事件。</li>
<li><code>android:id=&quot;@+id/button1&quot;</code>：这个属性为按钮指定了一个唯一的标识符，可以在 Java 代码中使用这个标识符来查找和操作这个按钮。</li>
<li><code>wrap_content</code> 属性可以使得布局更加灵活，可以根据内容的大小动态调整视图的尺寸，而不是固定为特定的尺寸。</li>
<li><code>android:text=&quot;Button 1&quot;</code>：这个属性为按钮设置了显示的文本内容为 “Button 1”。</li>
</ul>
<p>因此，这段代码描述了一个垂直排列的线性布局，其中包含一个按钮，按钮显示文本为 “Button 1”。按钮的宽度会填充父容器的宽度，而高度则根据按钮文本的大小动态调整。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">class FirstActivity : AppCompatActivity() &#123;</span></span>
<span class="line"><span style="color: #babed8">override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span>
<span class="line"><span style="color: #babed8">super.onCreate(savedInstanceState)</span></span>
<span class="line"><span style="color: #babed8">setContentView(R.layout.first_layout)</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>首先调用了 <code>super.onCreate(savedInstanceState)</code>，以确保调用了父类的 <code>onCreate()</code> 方法，以便执行必要的初始化操作。</p>
<p>接着调用了 <code>setContentView(R.layout.first_layout)</code> 方法，这个方法用于设置该活动所使用的布局文件。在这里，<code>first_layout</code> 是指定的布局资源文件的名称，这个布局文件定义了活动的界面布局结构。</p>
<p>因此，这段代码的作用是在 <code>FirstActivity</code> 中设置了一个布局文件 <code>first_layout</code> 作为活动的界面布局，并在活动创建时加载该布局。</p>
<p><code>R.layout</code> 是一个自动生成的资源标识符类，它包含了项目中所有布局文件的引用。在 Android 开发中，资源文件（如布局文件、字符串、图像等）都需要通过资源标识符来访问和引用。</p>
<p>当你在项目中创建布局文件时，每个布局文件都会被编译成一个资源标识符，以便在代码中进行引用。这些资源标识符都会被统一放置在 <code>R</code> 类的内部静态类中，而 <code>R.layout</code> 则是其中用于引用布局文件的子类之一。</p>
<p>Intent—&gt;用于通信的消息对象</p>
<p>在 Android 中，Intent 是一种用于在不同组件之间进行通信的对象。它可以用于启动活动（Activity）、启动服务（Service）、发送广播（Broadcast）以及执行其他各种操作。Intent 提供了一种在不同组件之间传递数据和执行操作的机制。</p>
<p>Intent 本质上是一个消息对象，用于指示想要执行的操作。它可以包含以下信息：</p>
<ol>
<li><strong>操作（Action）</strong>：指示要执行的操作，如启动活动、启动服务、发送广播等。常见的操作包括 <code>android.intent.action.VIEW</code>（查看操作）、<code>android.intent.action.SEND</code>（发送操作）、<code>android.intent.action.MAIN</code>（主操作）等。</li>
<li><strong>数据（Data）</strong>：用于指定操作的数据，可以是 URI、文件路径、文本等。例如，如果要查看网页，可以将网页的 URL 作为数据传递给 Intent。</li>
<li><strong>类别（Category）</strong>：用于指定操作的类别，如 <code>android.intent.category.LAUNCHER</code>（启动器类别）、<code>android.intent.category.BROWSABLE</code>（可浏览类别）等。</li>
<li><strong>附加信息（Extras）</strong>：用于传递额外的数据给目标组件。Extras 是键值对的形式，可以包含各种数据类型，如字符串、整数、布尔值等。</li>
</ol>
<p>Intent 可以分为两种类型：</p>
<ul>
<li><strong>显式 Intent</strong>：明确定义了目标组件的类名，用于启动特定的组件。</li>
<li><strong>隐式 Intent</strong>：没有明确指定目标组件，而是根据 Intent 的操作、数据等信息由系统来匹配合适的组件。</li>
</ul>
<p>通过使用 Intent，Android 应用程序可以实现各种功能，例如启动新的活动、执行后台任务、发送广播等，从而实现各种复杂的交互和功能。</p>
<p>Kotlin直接可以：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span>
<span class="line"><span style="color: #babed8">super.onCreate(savedInstanceState)</span></span>
<span class="line"><span style="color: #babed8">setContentView(R.layout.first_layout)</span></span>
<span class="line"><span style="color: #babed8">button1.setOnClickListener &#123;</span></span>
<span class="line"><span style="color: #babed8">Toast.makeText(this, &quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show()</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>在 Kotlin 中，函数声明的语法是：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">fun 函数名(参数列表): 返回值类型 &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 函数体</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>其中，返回值类型在函数名和参数列表之后，使用冒号 <code>:</code> 来标识。在这个语法中，返回值类型是必须的，但在某些情况下，如果函数没有返回值，可以将返回值类型指定为 <code>Unit</code>，或者省略返回值类型（在这种情况下，编译器会自动推断返回值类型为 <code>Unit</code>）。例如：</p>
<div class="language-kotlin"><button title="Copy code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">kotlin</span></span>
<span class="line"><span style="color: #C792EA">fun</span><span style="color: #BABED8"> </span><span style="color: #82AAFF">greet</span><span style="color: #BABED8">(name: </span><span style="color: #FFCB6B">String</span><span style="color: #BABED8">): </span><span style="color: #FFCB6B">Unit</span><span style="color: #BABED8"> &#123;</span></span>
<span class="line"><span style="color: #BABED8">    </span><span style="color: #82AAFF">println</span><span style="color: #BABED8">(</span><span style="color: #C3E88D">&quot;Hello, </span><span style="color: #BABED8">$name</span><span style="color: #C3E88D">!&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #BABED8">&#125;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #676E95; font-style: italic">// 或者省略返回值类型，编译器会自动推断为 Unit</span></span>
<span class="line"><span style="color: #C792EA">fun</span><span style="color: #BABED8"> </span><span style="color: #82AAFF">greet</span><span style="color: #BABED8">(name: </span><span style="color: #FFCB6B">String</span><span style="color: #BABED8">) &#123;</span></span>
<span class="line"><span style="color: #BABED8">    </span><span style="color: #82AAFF">println</span><span style="color: #BABED8">(</span><span style="color: #C3E88D">&quot;Hello, </span><span style="color: #BABED8">$name</span><span style="color: #C3E88D">!&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #BABED8">&#125;</span></span></code></pre></div><div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">override fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;</span></span>
<span class="line"><span style="color: #babed8">menuInflater.inflate(R.menu.main, menu)</span></span>
<span class="line"><span style="color: #babed8">return true</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p><code>menuInflater</code> 是 Android 开发中的一个类，用于从 XML 文件中创建菜单对象。在 Android 中，通常使用 XML 文件定义应用程序中的菜单，然后通过 <code>MenuInflater</code> 类将这些 XML 文件中定义的菜单加载到应用程序中的菜单对象中，以供在用户界面中显示和操作。</p>
<p>具体来说，<code>menuInflater.inflate()</code> 方法用于将一个 XML 文件中定义的菜单资源加载到一个 <code>Menu</code> 对象中，这样就可以在应用程序的用户界面中显示这个菜单。</p>
<p>在 Android 应用程序中，Activity 和 Fragment 是两种重要的组件，用于构建用户界面和处理用户交互。它们都可以包含用户界面的布局，并且可以响应用户的输入事件（如点击、滑动等）。</p>
<p>下面是关于 Activity 和 Fragment 的简要介绍：</p>
<h3 id="Activity（活动）"><a href="#Activity（活动）" class="headerlink" title="Activity（活动）"></a>Activity（活动）</h3><ol>
<li><strong>定义</strong>：Activity 是 Android 应用中的一个基本组件，代表一个单独的用户界面屏幕，通常是一个窗口、一个对话框或全屏显示的窗口。</li>
<li><strong>作用</strong>：Activity 主要负责管理用户与应用程序之间的交互，包括接收用户输入、处理用户操作，并在屏幕上显示相应的界面。</li>
<li><strong>生命周期</strong>：Activity 具有丰富的生命周期方法，如 <code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code> 等，开发者可以根据需要重写这些方法来执行相应的操作。</li>
<li><strong>布局</strong>：Activity 可以通过设置布局文件（XML 文件）来定义用户界面的外观和行为，也可以通过代码动态地创建和管理用户界面。</li>
</ol>
<h3 id="Fragment（片段）"><a href="#Fragment（片段）" class="headerlink" title="Fragment（片段）"></a>Fragment（片段）</h3><ol>
<li><strong>定义</strong>：Fragment 是 Android 应用中的另一个基本组件，代表了一个可复用的用户界面模块，可以在一个 Activity 中嵌套多个 Fragment。</li>
<li><strong>作用</strong>：Fragment 主要用于构建灵活的用户界面，允许开发者将应用程序的功能拆分成可重用的模块，并在不同的屏幕尺寸和设备方向下进行适配。</li>
<li><strong>生命周期</strong>：Fragment 也有自己的生命周期方法，与 Activity 的生命周期方法类似，包括 <code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code> 等。</li>
<li><strong>布局</strong>：Fragment 可以拥有自己的布局文件（XML 文件），也可以在宿主 Activity 中动态添加到布局中，允许开发者在运行时动态地添加、替换和移除 Fragment。</li>
</ol>
<p>总的来说，Activity 通常代表一个完整的屏幕，而 Fragment 则是 Activity 中一个可重用的组成部分，可以在一个 Activity 中组合多个 Fragment 来构建复杂的用户界面。在实际开发中，Activity 和 Fragment 经常一起使用，以实现灵活和高效的用户界面设计。</p>
<p>在 Kotlin 中，<code>?.</code> 是安全调用运算符，用于在对象为非空时调用其方法或访问其属性。如果对象为 null，则安全调用运算符会短路并返回 null，而不会抛出空指针异常。</p>
<p>在你提供的代码中，<code>data?.getStringExtra(&quot;data_return&quot;)</code> 的意思是，如果 <code>data</code> 不为 null，则调用 <code>getStringExtra(&quot;data_return&quot;)</code> 方法来获取名为 “data_return” 的额外数据，否则返回 null。这种写法可以避免在 <code>data</code> 为 null 时引发空指针异常。</p>
<p><code>registerForActivityResult(...)</code>：这是一个用于注册 Activity Result 的函数。它接受一个 <code>ActivityResultContract</code> 对象作为参数，并返回一个 <code>ActivityResultLauncher</code> 对象。<code>ActivityResultContract</code> 是一个接口，用于定义活动启动和结果处理之间的合同。</p>
<p>Activity类中定义了7个回调方法，覆盖了Activity生命周期的每一个环节:</p>
<ul>
<li><p>onCreate() 在Activity第一次被创建时调用</p>
</li>
<li><p>onStart() 由不可见到可见时调用</p>
</li>
<li><p>onResume()。这个方法在Activity准备好和用户进行交互的时候调用。此时的Activity一</p>
<p>定位于返回栈的栈顶，并且处于运行状态。</p>
</li>
<li><p>onPause()。这个方法在系统准备去启动或者恢复另一个Activity的时候调用。我们通常</p>
<p>会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执</p>
<p>行速度一定要快，不然会影响到新的栈顶Activity的使用。</p>
</li>
<li><p>onStop()。这个方法在Activity完全不可见的时候调用。它和onPause()方法的主要区</p>
<p>别在于，如果启动的新Activity是一个对话框式的Activity，那么onPause()方法会得到执行，而onStop()方法并不会执行。</p>
</li>
<li><p>onDestroy()。这个方法在Activity被销毁之前调用，之后Activity的状态将变为销毁状态。</p>
</li>
<li><p>onRestart()。这个方法在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。</p>
</li>
</ul>
<p><code>onPause()</code> 方法是 Android Activity 生命周期中的一个回调方法，用于指示当前 Activity 正在失去焦点并即将暂停其可见性。当某些事件发生时，系统会调用 <code>onPause()</code> 方法，这些事件包括：</p>
<ol>
<li>启动另一个 Activity：当用户启动另一个 Activity 并且当前 Activity 失去焦点时，系统会调用 <code>onPause()</code> 方法。例如，当用户点击应用中的按钮，打开新的 Activity 时，当前 Activity 将暂停。</li>
<li>打开对话框或弹出窗口：如果当前 Activity 打开了对话框、弹出了一个窗口或者其他部分覆盖了当前 Activity 但不完全遮挡，系统也会调用 <code>onPause()</code> 方法。</li>
<li>接收到来电或其他中断：当用户接收到来电、收到短信或者其他中断事件时，当前 Activity 也会暂停，系统会调用 <code>onPause()</code> 方法。</li>
<li>用户按下 Home 键或切换到最近任务列表：当用户按下 Home 键返回桌面或切换到最近任务列表时，当前 Activity 也会暂停，系统会调用 <code>onPause()</code> 方法。</li>
</ol>
<p>总之，<code>onPause()</code> 方法的调用情况涵盖了当前 Activity 失去焦点并即将暂停可见性的各种情况。</p>
<p><code>onStart()</code> 是 Android 活动生命周期中的一个方法，用于指示活动即将变为可见状态。当活动首次启动或从停止状态恢复到活动栈时，系统会调用 <code>onStart()</code> 方法。</p>
<p>具体情况下，<code>onStart()</code> 方法会在以下几种情况下被调用：</p>
<ol>
<li><strong>当活动首次启动</strong>：当用户启动应用程序并打开了包含该活动的界面时，系统会调用活动的 <code>onStart()</code> 方法。此时，活动将从不可见状态转变为可见状态。</li>
<li><strong>当活动从暂停状态恢复</strong>：如果一个活动从 <code>onPause()</code> 状态恢复到前台状态，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。</li>
</ol>
<p>在 <code>onStart()</code> 方法中，通常执行一些与界面相关的初始化操作，比如恢复 UI 状态、注册广播接收器或者启动一些后台任务。需要注意的是，尽管活动已经变为可见状态，但此时活动并未处于用户的焦点下，用户可能无法与其进行交互。</p>
<p><code>onResume()</code> 是 Android 活动生命周期中的一个方法，用于指示活动即将成为用户焦点并开始与用户进行交互。当活动从不可见状态变为可见状态，并且用户可以开始与其进行交互时，系统会调用 <code>onResume()</code> 方法。</p>
<p>具体情况下，<code>onResume()</code> 方法会在以下几种情况下被调用：</p>
<ol>
<li><strong>当活动首次启动</strong>：当用户首次启动应用程序并打开了包含该活动的界面时，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。此时，活动将从不可见状态转变为可见状态，并且用户可以开始与其进行交互。</li>
<li><strong>当活动从暂停状态恢复</strong>：如果一个活动从 <code>onPause()</code> 状态恢复到前台状态，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。</li>
<li><strong>当活动从停止状态恢复</strong>：如果一个活动从 <code>onStop()</code> 状态恢复到前台状态，系统会依次调用 <code>onRestart()</code>、<code>onStart()</code> 和 <code>onResume()</code> 方法。这种情况通常发生在用户按下 Home 键后再次打开应用程序的情况下。</li>
</ol>
<p>在 <code>onResume()</code> 方法中，通常执行一些与活动生命周期相关的操作，比如恢复用户的输入状态、启动动画效果或者连接到一些外部服务。需要注意的是，当活动处于 <code>onResume()</code> 状态时，它已经成为了用户焦点下的活动，并且用户可以直接与其进行交互。</p>
<p><img src="/../images/image-20240422135757284.png" alt="image-20240422135757284"></p>
<p>当将视图或布局的尺寸设置为 “wrap_content” 时，系统会根据其内容自动调整视图或布局的尺寸，以便刚好容纳其内</p>
<p>在 Android 的清单文件（AndroidManifest.xml）中声明活动（Activity）时，可以使用两种方式：</p>
<ol>
<li><code>&lt;activity&gt;...&lt;/activity&gt;</code>：这是一种传统的 XML 标签方式，用于定义活动的属性和行为。在 <code>&lt;activity&gt;</code> 标签中，可以指定活动的各种属性，例如名称、图标、主题等，并且可以包含其他标签和属性以提供更详细的配置。通常情况下，你可以在 <code>&lt;activity&gt;</code> 标签内部设置更多的属性，包括活动的名称、图标、主题等，以及与活动相关的其他设置。</li>
<li><code>&lt;activity/&gt;</code>：这是一种自闭合的 XML 标签方式，用于简单地声明一个活动而不指定任何属性或配置。这种方式适用于简单的活动声明，当你不需要指定任何属性或配置时，可以使用这种方式。例如，如果你的活动只需要基本的声明，而不需要指定任何其他属性或配置，你可以使用 <code>&lt;activity/&gt;</code> 标签。</li>
</ol>
<p>因此，你应该根据活动的具体需求和配置选择适当的方式。如果需要指定活动的各种属性和配置，可以使用 <code>&lt;activity&gt;...&lt;/activity&gt;</code> 标签；如果活动只需要基本的声明而不需要指定任何其他属性或配置，可以使用 <code>&lt;activity/&gt;</code> 标签。</p>
<p><code>@style/Theme.AppCompat.Dialog</code> 是指在 Android 应用程序中使用的一个预定义的对话框主题样式。这个样式通常用于创建对话框，即弹出式窗口，以在应用程序中显示临时信息、接受用户输入或执行其他操作。</p>
<p>这个主题样式基于 AppCompat 库提供的默认对话框主题进行定义，并且与 AppCompat 库中其他主题一样，它提供了跨不同 Android 版本的一致外观和行为。这样，你的应用程序就可以在不同版本的 Android 上保持一致的外观和用户体验。</p>
<p><code>android:exported=&quot;false&quot;</code> 是 Android 清单文件中 <code>&lt;activity&gt;</code> 元素的一个属性，用于指定该活动是否能够被其他应用程序组件或者系统组件访问。具体含义如下：</p>
<ul>
<li>如果 <code>android:exported=&quot;false&quot;</code>，则表示该活动不会被其他应用程序或系统组件调用。这意味着该活动只能被声明它的应用程序内部的组件所访问，其他应用程序或系统组件无法直接启动或与其交互。</li>
<li>如果 <code>android:exported=&quot;true&quot;</code>，则表示该活动可以被其他应用程序或系统组件调用。这意味着其他应用程序可以使用显式或隐式意图启动该活动，并且与其进行交互。</li>
</ul>
<p>在你的示例中，<code>android:exported=&quot;false&quot;</code> 意味着 <code>DialogActivity</code> 这个活动不会被其他应用程序或系统组件访问。它只能被声明它的应用程序内部的组件所访问，其他应用程序无法直接启动或与其交互。这通常用于内部使用的活动，例如只在应用程序内部使用的对话框或者配置界面。</p>
<p>在 Android 开发中，<code>Intent</code>（意图）是用于在不同组件之间传递数据或执行操作的对象。它是一种在 Android 应用程序中实现组件之间通信的重要机制。</p>
<p><code>Intent</code> 主要有两种类型：显式 Intent 和隐式 Intent。</p>
<ol>
<li><p><strong>显式 Intent</strong>：用于启动应用程序内部的组件，例如启动另一个活动（Activity）、启动服务（Service）等。显式 Intent 通过指定目标组件的类名来明确指示要执行的操作。</p>
<p>示例：</p>
</li>
</ol>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">Intent intent = new Intent(this, AnotherActivity.class);</span></span>
<span class="line"><span style="color: #babed8">startActivity(intent);</span></span></code></pre></div><p><strong>隐式 Intent</strong>：用于启动应用程序内或其他应用程序中具有特定功能的组件，而不需要指定目标组件的类名。隐式 Intent 根据指定的动作（Action）、数据（Data）等信息来寻找合适的组件执行操作。</p>
<p>示例：</p>
<ol>
<li><div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.example.com&quot;));</span></span>
<span class="line"><span style="color: #babed8">startActivity(intent);</span></span></code></pre></div></li>
</ol>
<p><code>Intent</code> 的主要作用包括但不限于：</p>
<ul>
<li>启动活动、服务或广播接收器等组件。</li>
<li>在组件之间传递数据，例如在不同活动之间传递参数。</li>
<li>执行一些系统级别的操作，例如拨打电话、发送短信、打开网页等。</li>
</ul>
<p>总之，<code>Intent</code> 是 Android 应用程序中用于实现组件之间通信和执行操作的重要机制。</p>
<p>在 Android 中，<code>Bundle</code> 是一个用来存储键值对数据的容器类。它通常被用于在不同的组件（如活动、片段）之间传递数据，或者在组件销毁和重新创建时保存和恢复数据的状态。</p>
<p>在 <code>onCreate()</code> 方法中，<code>Bundle</code> 参数 <code>savedInstanceState</code> 表示上一个实例状态的数据。当活动被销毁并重新创建时（例如，由于设备旋转或内存紧张），Android 系统会调用 <code>onSaveInstanceState()</code> 方法来保存当前的状态数据，并将其存储在 <code>Bundle</code> 中。然后，在活动重新创建时，系统会将之前保存的状态数据传递给 <code>onCreate()</code> 方法的 <code>savedInstanceState</code> 参数。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">Log.d(&quot;FirstActivity&quot;, this.toString())</span></span></code></pre></div><p><code>this.toString()</code> 是调用当前对象的 <code>toString()</code> 方法。在 Java 中，几乎所有的对象都继承自 <code>Object</code> 类，而 <code>Object</code> 类中有一个 <code>toString()</code> 方法，用于返回对象的字符串表示形式</p>
<p>当你调用 <code>this.toString()</code> 时，它会返回当前对象的字符串表示形式</p>
<p>Activity的启动模式:</p>
<ul>
<li>standard</li>
<li>singleTop  单栈顶</li>
<li>singleTask   单任务</li>
<li>singleInstance  单实例</li>
</ul>
<p>在 Kotlin 中，<code>object</code> 关键字用于定义单例对象。单例对象是指在程序运行期间只有一个实例存在的对象。在给定的作用域内，单例对象只能有一个实例，因此它们非常适合用于管理全局状态或提供全局访问点。</p>
<p>关闭所有活动并不等同于关闭应用程序的进程。在 Android 应用程序中，当你调用 <code>finish()</code> 方法结束一个活动时，这个活动会被销毁，但应用程序的进程仍然在运行。即使所有活动都被销毁，应用程序的进程仍然存在于系统中。</p>
<p>为了完全退出应用程序，有时需要调用 <code>System.exit(0)</code> 或者 <code>Process.killProcess(Process.myPid())</code> 这样的方法来结束应用程序的进程。这样做可以确保应用程序的所有组件都被终止，包括活动、服务、广播接收器等，从而实现应用程序的完全退出。</p>
<p>然而，这种做法通常被视为不推荐的，因为它可能会导致用户体验上的问题，以及系统资源的浪费。通常情况下，Android 系统会自动管理应用程序的进程，并在必要时终止它们，而不需要手动干预。因此，大多数情况下，关闭所有活动即可满足应用程序退出的需求，而无需手动杀死进程。</p>
<p>在 Kotlin 中，<code>companion object</code>（伴生对象）具有以下作用：</p>
<ol>
<li><strong>静态成员访问</strong>：伴生对象中的成员可以直接通过类名访问，就像 Java 中的静态成员一样。这使得可以在不创建类的实例的情况下访问这些成员。</li>
<li><strong>工厂方法</strong>：可以在伴生对象中定义工厂方法，用于创建类的实例。这种方法通常用于隐藏类的构造函数，提供一种更灵活的方式来创建实例。</li>
<li><strong>共享代码</strong>：伴生对象可以包含在类的所有实例之间共享的代码或常量。这些代码或常量对于类的所有实例都是相同的，可以方便地通过伴生对象访问。</li>
<li><strong>扩展方法</strong>：在伴生对象中还可以定义扩展方法，这些方法可以为类添加额外的功能，而无需继承或修改类的源代码。</li>
</ol>
<p>总的来说，伴生对象提供了一种在 Kotlin 中实现类级别功能的方式，它可以用于静态成员访问、工厂方法、共享代码和扩展方法等场景。</p>
<p>StringBuilder是Java中的一个类，用于处理字符串。它允许你在不创建新的String对象的情况下进行字符串的修改和操作，这样可以提高性能并节省内存。</p>
<p>当你需要对字符串进行频繁的修改时，使用StringBuilder通常比直接使用String更高效。这是因为String是不可变的，每次对String进行修改都会创建一个新的String对象，而StringBuilder允许你在同一个对象上执行多次修改操作。</p>
<p>你可以使用StringBuilder的append()方法来添加字符串，使用delete()方法来删除字符串，使用insert()方法来在指定位置插入字符串，使用replace()方法来替换字符串等等。最后，你可以使用toString()方法将StringBuilder对象转换为String对象，以便进行进一步的操作或输出。</p>
<p><code>val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val builder = StringBuilder() builder.append(&quot;Start eating fruits.\n&quot;) for (fruit in list) &#123; builder.append(fruit).append(&quot;\n&quot;) &#125; builder.append(&quot;Ate all fruits.&quot;) val result = builder.toString() println(result) 为什么最后要调用builder.toString()</code>，不能直接打印吗</p>
<p>在上面的代码中，builder是一个StringBuilder对象，而println函数通常接受String类型的参数来进行输出。而builder对象是一个StringBuilder类型的对象，不是String类型的对象，因此无法直接传递给println函数。</p>
<p>调用builder.toString()方法将StringBuilder对象转换为String类型的对象，这样就可以将其作为参数传递给println函数，从而实现输出。toString()方法会返回StringBuilder对象中包含的所有字符序列作为一个字符串。</p>
<p>因此，为了能够正确地输出builder对象中的内容，需要先调用toString()方法将其转换为String类型的对象，然后再传递给println函数进行打印。</p>
<p><code>with</code> 是 Kotlin 的一个标准库函数，它提供了一种简洁的方式来执行针对特定对象的一系列操作，并返回最后一个表达式的结果。</p>
<p><code>AlertDialog.Builder(this).apply &#123; setTitle(&quot;This is Dialog&quot;) setMessage(&quot;Something important.&quot;) setCancelable(false) setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; &#125; setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; &#125; show()</code> 是什么意思</p>
<p>这段代码是使用 Kotlin 的标准库函数 <code>apply</code> 来构建一个 <code>AlertDialog</code> 对话框，并设置其标题、消息、按钮等属性。下面是代码的解释：</p>
<ol>
<li><code>AlertDialog.Builder(this)</code>：创建了一个 <code>AlertDialog.Builder</code> 的实例，这个实例用于构建一个对话框。</li>
<li><code>apply &#123; ... &#125;</code>：<code>apply</code> 是一个 Kotlin 标准库函数，它接收一个 lambda 表达式作为参数，并在 lambda 表达式的作用域内执行一系列操作。在这个例子中，<code>apply</code> 函数被调用后，会将调用者对象（即 <code>AlertDialog.Builder</code> 的实例）作为参数传递给 lambda 表达式，并在 lambda 表达式内部执行一系列设置操作。</li>
<li><code>setTitle(&quot;This is Dialog&quot;)</code>：在 lambda 表达式中调用 <code>setTitle</code> 方法，设置对话框的标题为 “This is Dialog”。</li>
<li><code>setMessage(&quot;Something important.&quot;)</code>：在 lambda 表达式中调用 <code>setMessage</code> 方法，设置对话框的消息内容为 “Something important.”。</li>
<li><code>setCancelable(false)</code>：在 lambda 表达式中调用 <code>setCancelable</code> 方法，设置对话框为不可取消状态，即用户点击对话框外部或返回键时不会关闭对话框。</li>
<li><code>setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; ... &#125;</code>：在 lambda 表达式中调用 <code>setPositiveButton</code> 方法，设置对话框的确定按钮文本为 “OK”，并设置点击事件处理器。在这里，<code>&#123; dialog, which -&gt; ... &#125;</code> 是一个 lambda 表达式，表示当用户点击确定按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。</li>
<li><code>setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; ... &#125;</code>：在 lambda 表达式中调用 <code>setNegativeButton</code> 方法，设置对话框的取消按钮文本为 “Cancel”，并设置点击事件处理器。同样，<code>&#123; dialog, which -&gt; ... &#125;</code> 是一个 lambda 表达式，表示当用户点击取消按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。</li>
<li><code>show()</code>：在所有设置完成后，调用 <code>show</code> 方法显示对话框。</li>
</ol>
<p>因此，这段代码的作用是创建一个带有标题、消息、确定按钮和取消按钮的对话框，并将其显示在界面上。</p>
<p>三种基本布局：</p>
<ul>
<li>LinearLayout垂直排布</li>
<li>RelativeLayout相对布局</li>
<li>FrameLayout帧布局</li>
</ul>
<p><img src="/../images/image-20240423231325479.png" alt="image-20240423231325479"></p>
<p><code>override fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123; val view = LayoutInflater.from(context).inflate(resourceId, parent, false) val fruitImage: ImageView = view.findViewById(R.id.fruitImage) val fruitName: TextView = view.findViewById(R.id.fruitName) val fruit = getItem(position) // 获取当前项的Fruit实例 if (fruit != null) &#123; fruitImage.setImageResource(fruit.imageId) fruitName.text = fruit.name &#125; return view &#125;</code></p>
<p>其中：val view &#x3D; LayoutInflater.from(context).inflate(resourceId, parent, false)</p>
<p>作用是从 XML 布局文件中创建一个视图对象，并将其添加到指定的父视图中。</p>
<p>解释每个参数的含义：</p>
<ul>
<li><code>context</code>: 表示当前的上下文环境，通常是一个 Activity 或 Fragment 的实例。</li>
<li><code>resourceId</code>: 表示要加载的布局文件的资源 ID，即 XML 文件的唯一标识符。</li>
<li><code>parent</code>: 表示要将创建的视图添加到的父视图，通常是一个 ViewGroup，比如一个 LinearLayout 或者一个 RecyclerView。</li>
<li><code>false</code>: 表示在加载布局文件时，不将其添加到父视图中。这个参数设置为 <code>false</code> 表示我们会手动将视图添加到父视图中，而不是在加载时自动添加。</li>
</ul>
<p>接口在编程中有多种作用，包括但不限于以下几个方面：</p>
<ol>
<li><strong>定义约束和契约</strong>：接口定义了一组方法或属性的规范，实现该接口的类必须提供这些方法或属性的具体实现。这种约束和契约使得代码更加清晰，使得不同的类可以共享相同的行为规范。</li>
<li><strong>实现多态</strong>：通过接口，可以实现多态，即在不同的类中使用相同的方法名，但实际调用的是各自类的具体实现。这样可以提高代码的灵活性和可扩展性。</li>
<li><strong>代码重用</strong>：接口可以用于定义通用的行为规范，使得多个类可以共享相同的接口定义，从而实现代码的重用。当多个类具有相似的行为或功能时，可以通过接口来统一定义这些行为或功能，避免重复编写代码。</li>
<li><strong>降低耦合性</strong>：通过接口，类与类之间的耦合度可以降低，因为类之间通过接口进行交互，而不是直接依赖于具体的实现。这样，当一个类的实现发生变化时，只需要修改实现该接口的类，而不需要修改其他使用该类的代码。</li>
<li><strong>接口委托</strong>：接口支持委托，一个接口可以通过另一个对象来实现其方法，这种方式称为接口委托。这种机制可以进一步提高代码的灵活性和可复用性。</li>
</ol>
<p>总的来说，接口是一种重要的编程工具，可以帮助程序员设计出更加灵活、可扩展和易于维护的代码结构。</p>
<p>interface接口</p>
<p>sealed class密封类</p>
<p><img src="/../images/image-20240429211327595.png" alt="image-20240429211327595"></p>
<p><code>companion object</code> 是 Kotlin 中的一个关键字，它用于创建一个伴随对象。伴随对象是类中的一个单例对象，可以通过类名直接访问其中的属性和方法</p>
<p>news_content_frag.xml——–&gt;NewsContentFragment类———–&gt;NewsContentActivity</p>
<p>news_item.xml——–&gt;news_title_frag.xml———&gt;NewsTitleFragment类———-&gt;</p>
<p>layout&#x2F;activity_main.xml——-&gt;单页模式;</p>
<p>NewsTitleFragment类————&gt;</p>
<p>​														layout-sw600dp&#x2F;activity_main.xml——–&gt;双页模式;</p>
<p>NewsContentFragment类——-&gt;</p>
<p>在NewsTitleFragment类中通过RecyclerView将新闻列表展示出来</p>
<p>在 Kotlin 中，<code>open</code> 关键字用于声明一个类、方法或属性是可以被继承或覆盖的。具体来说：</p>
<ul>
<li><strong>类（Class）</strong>：在类声明前加上 <code>open</code> 关键字，表示这个类是可以被其他类继承的。如果不加 <code>open</code> 关键字，则默认情况下类是 <code>final</code> 的，不能被继承。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">kotlin</span></span>
<span class="line"><span style="color: #babed8">open class BaseActivity : AppCompatActivity() &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 可以被继承的类</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><ul>
<li><strong>方法（Method）</strong>：在方法声明前加上 <code>open</code> 关键字，表示这个方法是可以被子类覆盖（重写）的。如果不加 <code>open</code> 关键字，则默认情况下方法是 <code>final</code> 的，不能被子类覆盖。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">kotlin</span></span>
<span class="line"><span style="color: #babed8">open fun someMethod() &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 可以被子类重写的方法</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><ul>
<li><strong>属性（Property）</strong>：在属性声明前加上 <code>open</code> 关键字，表示这个属性是可以被子类覆盖的。如果不加 <code>open</code> 关键字，则默认情况下属性是 <code>final</code> 的，不能被子类覆盖。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">kotlin</span></span>
<span class="line"><span style="color: #babed8">open val someProperty: Int = 0</span></span></code></pre></div><p>使用 <code>open</code> 关键字可以让类的设计更加灵活，允许其他类继承并重写其中的方法，或者覆盖属性的行为。</p>
<p><code>val square: (Int) -&gt; Int = &#123; x: Int -&gt; x * x &#125;</code></p>
<p>square是(Int) -&gt; Int函数类型的变量，表示接受一个 <code>Int</code> 类型的参数，并返回一个 <code>Int</code> 类型的结果。</p>
<p>Lambda 表达式 <code>&#123; x: Int -&gt; x * x &#125;</code> 被赋给了这个变量</p>
<p><code>fun save(inputText: String) &#123;</code><br><code>try &#123;</code><br><code>val output = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE)</code><br><code>val writer = BufferedWriter(OutputStreamWriter(output))</code><br><code>writer.use &#123;</code><br><code>it.write(inputText)</code><br><code>&#125;</code><br><code>&#125; catch (e: IOException) &#123;</code><br><code>e.printStackTrace()</code><br><code>&#125;</code><br><code>&#125;</code></p>
<p>这段代码定义了一个名为 <code>save</code> 的函数，它接受一个 <code>inputText</code> 参数，类型为 <code>String</code>。函数的作用是将输入的文本内容保存到文件中。让我解释一下代码的逻辑：</p>
<ol>
<li><code>openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE)</code>: 这行代码打开一个名为 “data” 的文件，并返回一个 <code>FileOutputStream</code> 对象。这个文件将会存储在应用的内部存储空间中，因为使用了 <code>Context.MODE_PRIVATE</code> 参数，表示只有当前应用可以访问这个文件，并且会覆盖掉同名的文件（如果存在）。</li>
<li><code>val writer = BufferedWriter(OutputStreamWriter(output))</code>: 这行代码创建了一个 <code>BufferedWriter</code> 对象，并将其包装在一个 <code>OutputStreamWriter</code> 中，以便将文本写入到 <code>output</code> 中。</li>
<li><code>writer.use &#123; it.write(inputText) &#125;</code>: 这行代码使用 Kotlin 的 <code>use</code> 函数，确保在使用结束后正确关闭 <code>writer</code>，以释放资源。在 <code>use</code> 函数的 lambda 表达式中，调用了 <code>write</code> 方法，将 <code>inputText</code> 写入到文件中。</li>
<li><code>catch (e: IOException) &#123; e.printStackTrace() &#125;</code>: 这是一个异常处理块，如果在保存文件时发生了 <code>IOException</code> 异常，程序将会打印异常的堆栈信息。</li>
</ol>
<p>将委托功能分为了两种：类委托和委托属性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Android-Kotlin.html" data-id="clxbjvuxm000261cx1h1s1bu0" data-title="Android_Kotlin" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/" rel="tag">C++STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PNC/" rel="tag">PNC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/esp32/" rel="tag">esp32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robot-kinematics/" rel="tag">robot_kinematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yolo/" rel="tag">yolo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-STL/" style="font-size: 10px;">C++STL</a> <a href="/tags/Embedded/" style="font-size: 10px;">Embedded</a> <a href="/tags/PNC/" style="font-size: 10px;">PNC</a> <a href="/tags/esp32/" style="font-size: 10px;">esp32</a> <a href="/tags/robot-kinematics/" style="font-size: 10px;">robot_kinematics</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6.html">图形学</a>
          </li>
        
          <li>
            <a href="/post/motion-planning.html">motion_planning</a>
          </li>
        
          <li>
            <a href="/post/Realsense.html">Realsense</a>
          </li>
        
          <li>
            <a href="/post/C-STL.html">C++STL</a>
          </li>
        
          <li>
            <a href="/post/kinematics.html">kinematics</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>