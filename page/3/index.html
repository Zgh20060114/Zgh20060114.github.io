<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Zgh&#39;s</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Zgh的个人站">
<meta property="og:type" content="website">
<meta property="og:title" content="Zgh&#39;s">
<meta property="og:url" content="http://zgh20060114.github.io/page/3/index.html">
<meta property="og:site_name" content="Zgh&#39;s">
<meta property="og:description" content="Zgh的个人站">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Zgh's" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zgh&#39;s</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Zgh20060114.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-FPGA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/FPGA.html" class="article-date">
  <time class="dt-published" datetime="2024-04-24T03:03:09.000Z" itemprop="datePublished">2024-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/FPGA.html">FPGA</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>assign</code> 关键字用于对线网（wire）或变量（var）进行连续赋值。连续赋值意味着一旦右侧的表达式发生变化，赋值就会立即更新左侧的值，这与过程赋值（在always块中）不同，后者在某种事件或条件发生时才更新值。</p>
<p>assign temp2 &#x3D; {32{1’b0}}; 是什么意思?</p>
<p>在Verilog中，<code>assign temp2 = &#123;32&#123;1&#39;b0&#125;&#125;;</code> 这行代码声明了一个连续赋值，将 <code>temp2</code> 这个线网的值设置为一个32位的全0值。</p>
<p>这里的 <code>&#123;32&#123;1&#39;b0&#125;&#125;</code> 是一个重复拼接操作，含义如下：</p>
<ul>
<li><code>1&#39;b0</code> 是一个二进制数，表示一个位宽为1的数值，值为0。</li>
<li><code>&#123;32&#123;1&#39;b0&#125;&#125;</code> 表示将 <code>1&#39;b0</code> 这个值重复32次。</li>
</ul>
<h6 id="Verilog-数据类型"><a href="#Verilog-数据类型" class="headerlink" title="Verilog 数据类型"></a>Verilog 数据类型</h6><p>Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。</p>
<p><strong>整数（integer）</strong>   reg 型变量为无符号数，而 integer 型变量为有符号数</p>
<p><strong>实数（real）</strong></p>
<p>在Verilog中，<code>real</code> 和 <code>integer</code> 是数据类型关键字，分别用于声明实数类型和整数类型的变量。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">real data1;</span></span>
<span class="line"><span style="color: #babed8">integer temp;</span></span>
<span class="line"><span style="color: #babed8">initial begin</span></span>
<span class="line"><span style="color: #babed8">    data1 = 2e3;</span></span>
<span class="line"><span style="color: #babed8">    data1 = 3.75;</span></span>
<span class="line"><span style="color: #babed8">end</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">initial begin</span></span>
<span class="line"><span style="color: #babed8">    temp = data1; //temp 值的大小为3</span></span>
<span class="line"><span style="color: #babed8">end</span></span></code></pre></div><p>这段代码包含两个 <code>initial</code> 块，它们在仿真开始时执行一次。</p>
<p>第一个 <code>initial</code> 块中：</p>
<ol>
<li><code>data1</code> 被初始化为实数类型 <code>real</code>。</li>
<li><code>data1</code> 被赋值为 <code>2e3</code>，这意味着 <code>data1</code> 现在的值是2000.0。</li>
<li>随后，<code>data1</code> 被更新为 <code>3.75</code>。</li>
</ol>
<p>第二个 <code>initial</code> 块中：</p>
<ol>
<li><code>temp</code> 被初始化为整数类型 <code>integer</code>。</li>
<li><code>temp</code> 被赋值为 <code>data1</code> 的值。由于 <code>data1</code> 当前是 <code>3.75</code>，这个赋值会将实数转换为整数。在Verilog中，实数赋值给整数时，会进行取整操作，保留数值的整数部分，忽略小数部分。因此，<code>temp</code> 的值将是3。</li>
</ol>
<p>需要注意的是，您的注释 <code>//temp 值的大小为3</code> 是正确的，因为 <code>data1</code> 的值 <code>3.75</code> 在赋值给 <code>temp</code> 时会被取整为3。</p>
<p><strong>时间（time）</strong></p>
<p>Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间。例如：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">time current_time;</span></span>
<span class="line"><span style="color: #babed8">initial begin</span></span>
<span class="line"><span style="color: #babed8">    #100;</span></span>
<span class="line"><span style="color: #babed8">    current_time = $time; //current_time 的大小为 100</span></span>
<span class="line"><span style="color: #babed8">end</span></span></code></pre></div><p>这段代码包含一个 <code>initial</code> 块，它在仿真开始时执行一次。</p>
<p>在 <code>initial</code> 块中：</p>
<ol>
<li><code>current_time</code> 被初始化为时间类型 <code>time</code>。</li>
<li><code>#100;</code> 是一个延迟语句，它会使仿真暂停100个时间单位。在Verilog中，<code>#</code> 后面跟一个数字表示延迟的时间量。</li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>存储器</p>
<h6 id="参数-参数用来表示常量，用关键字-parameter-声明，只能赋值一次"><a href="#参数-参数用来表示常量，用关键字-parameter-声明，只能赋值一次" class="headerlink" title="参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次"></a>参数  参数用来表示常量，用关键字 parameter 声明，只能赋值一次</h6><p><strong>parameter</strong>    data_width &#x3D; 10’d32 ;</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。</p>
<p>字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0  来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”,  需要 14*8bit 的存储单元：</p>
<p><strong>reg</strong> [0: 14*8-1]    str ;<br> <strong>initial</strong> <strong>begin</strong><br>   str &#x3D; “run.runoob.com”;<br> <strong>end</strong>  </p>
<p><img src="/../images/IMG_20240424_115210.jpg" alt="IMG_20240424_115210"></p>
<p><img src="/../images/IMG_20240424_115158.jpg" alt="IMG_20240424_115158"></p>
<p><img src="/../images/IMG_20240424_115542.jpg" alt="IMG_20240424_115542"></p>
<p><img src="/../images/IMG_20240424_115525.jpg" alt="IMG_20240424_115525"></p>
<p><img src="/../images/IMG_20240424_115506.jpg" alt="IMG_20240424_115506"></p>
<h2 id="2-4-Verilog-表达式"><a href="#2-4-Verilog-表达式" class="headerlink" title="2.4 Verilog 表达式"></a>2.4 Verilog 表达式</h2><p>表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。</p>
<p> a^b ;      <em>&#x2F;&#x2F;a与b进行异或操作</em><br> address[9:0] + 10’b1 ;  <em>&#x2F;&#x2F;地址累加</em><br> flag1 &amp;&amp; flag2 ;  <em>&#x2F;&#x2F;逻辑与操作</em></p>
<p><em>always块里赋值对象不能是wire型</em></p>
<p>同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">//自右向左关联，两种写法等价</span></span>
<span class="line"><span style="color: #babed8">A+B-C ;</span></span>
<span class="line"><span style="color: #babed8">(A+B）-C ;</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">//自右向左关联，两种写法等价，结果为 B、D 或 F</span></span>
<span class="line"><span style="color: #babed8">A ? B : C ? D : F ;</span></span>
<span class="line"><span style="color: #babed8">A ? B : (C ? D : F) ;</span></span></code></pre></div><p>求幂（**）、取模（%）</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">b = 4&#39;b100x;</span></span></code></pre></div><p><code>x</code> 是一个表示未知或不可确定状态的字符。它用于在仿真中表示一个位的值是未知的，这通常发生在综合过程中，当某些逻辑路径没有被明确赋值时，或者在设计中的某些部分还没有完全定义时。</p>
<p>无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和</p>
<p><strong>reg</strong> [3:0]     mula ;<br> <strong>reg</strong> [1:0]     mulb;<br> <strong>reg</strong> [5:0]     res ;<br> mula &#x3D; 4’he  ;<br> mulb &#x3D; 2’h3  ;<br> res  &#x3D; mula * mulb ; <em>&#x2F;&#x2F;结果为res&#x3D;6’h2a, 数据结果没有丢失位数</em></p>
<p>逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）</p>
<p>按位操作符包括：取反(<del>)，与（&amp;），或（|），异或（^），同或（</del>^）</p>
<p>按位操作符对 2 个操作数的每 1bit 数据进行按位操作,如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。</p>
<h3 id="归约操作符"><a href="#归约操作符" class="headerlink" title="归约操作符"></a>归约操作符</h3><p>归约操作符包括：归约与（&amp;），归约与非（<del>&amp;），归约或（|），归约或非（</del>|），归约异或（^），归约同或（~^）。</p>
<p>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</p>
<p>逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">A = 4&#39;b1010 ;</span></span>
<span class="line"><span style="color: #babed8">&amp;A ;      //结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#39;b0，可用来判断变量A是否全1</span></span>
<span class="line"><span style="color: #babed8">~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1&#39;b0, 可用来判断变量A是否为全0</span></span>
<span class="line"><span style="color: #babed8">^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1&#39;b0</span></span></code></pre></div><h3 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h3><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p>
<p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p>
<p>算术左移和逻辑左移时，右边低位会补 0。</p>
<p>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>A &#x3D; 4’b1100 ;<br> B &#x3D; 4’b0010 ;<br> A &#x3D; A &gt;&gt; 2 ;     <em>&#x2F;&#x2F;结果为 4’b0011</em><br> A &#x3D; A &lt;&lt; 1;     *&#x2F;&#x2F;结果为 4’b1000*<br> A &#x3D; A &lt;&lt;&lt; 1 ;    *&#x2F;&#x2F;结果为 4’b1000*<br> C &#x3D; B + (A&gt;&gt;&gt;2);   <em>&#x2F;&#x2F;结果为 2 + (-4&#x2F;4) &#x3D; 1, 4’b0001</em></p>
<h3 id="define-undef"><a href="#define-undef" class="headerlink" title="define, undef"></a><code>define, </code>undef</h3><p>在编译阶段，&#96;define 用于文本替换，类似于 C 语言中的 <strong>#define</strong>。</p>
<p>&#96;undef 用来取消之前的宏定义</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`ifdef       MCU51</span></span>
<span class="line"><span style="color: #babed8">    parameter DATA_DW = 8   ;</span></span>
<span class="line"><span style="color: #babed8">`elsif       WINDOW</span></span>
<span class="line"><span style="color: #babed8">    parameter DATA_DW = 64  ;</span></span>
<span class="line"><span style="color: #babed8">`else</span></span>
<span class="line"><span style="color: #babed8">    parameter DATA_DW = 32  ;</span></span>
<span class="line"><span style="color: #babed8">`endif</span></span></code></pre></div><h3 id="include"><a href="#include" class="headerlink" title="&#96;include"></a>&#96;include</h3><p>使用 &#96;include 可以在编译时将一个 Verilog 文件内嵌到另一个 Verilog 文件中，作用类似于 C 语言中的 #include 结构。</p>
<h3 id="timescale"><a href="#timescale" class="headerlink" title="timescale"></a>timescale</h3><p>在 Verilog 模型中，时延有具体的单位时间表述，并用 &#96;timescale 编译指令将时间单位与实际时间相关联。</p>
<p>该指令用于定义时延、仿真的单位和精度，格式为：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`timescale      time_unit / time_precision</span></span></code></pre></div><p>time_unit 表示时间单位，time_precision 表示时间精度，它们均是由数字以及单位  s（秒），ms（毫秒），us（微妙），ns（纳秒），ps（皮秒）和  fs（飞秒）组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小，例如下面例子中，输出端 Z 会延迟 5.21ns 输出  A&amp;B 的结果。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><code>timescale 1ns/100ps   *//时间单位为1ns，精度为100ps，合法*  *//</code>timescale 100ps&#x2F;1ns  &#x2F;&#x2F;不合法*<br> <strong>module</strong> AndFunc(Z, A, B);<br>   <strong>output</strong> Z;<br>   <strong>input</strong> A, B ;<br>   <strong>assign</strong> #5.207 Z &#x3D; A &amp; B<br> <strong>endmodule</strong></p>
<p>在编译过程中，<code>timescale 指令会影响后面所有模块中的时延值，直至遇到另一个 </code>timescale 指令或 &#96;resetall 指令。 </p>
<p>由于在 Verilog 中没有默认的 <code>timescale，如果没有指定 </code>timescale，Verilog 模块就有会继承前面编译模块的 &#96;timescale 参数。有可能导致设计出错。</p>
<p>如果一个设计中的多个模块都带有 &#96;timescale 时，模拟器总是定位在所有模块的最小时延精度上，并且所有时延都相应地换算为最小时延精度</p>
<h3 id="default-nettype"><a href="#default-nettype" class="headerlink" title="&#96;default_nettype"></a>&#96;default_nettype</h3><p>该指令用于为隐式的线网变量指定为线网类型，即将没有被声明的连线定义为线网类型。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`default_nettype wand </span></span></code></pre></div><p>该实例定义的缺省的线网为线与类型。因此，如果在此指令后面的任何模块中的连线没有说明，那么该线网被假定为线与类型。  </p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`default_nettype none</span></span></code></pre></div><p>该实例定义后，将不再自动产生 wire 型变量。</p>
<h3 id="celldefine-endcelldefine"><a href="#celldefine-endcelldefine" class="headerlink" title="celldefine, endcelldefine"></a><code>celldefine, </code>endcelldefine</h3><p>这两个程序指令用于将模块标记为单元模块，他们包含模块的定义。例如一些与、或、非门，一些 PLL 单元，PAD 模型，以及一些 Analog IP 等。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><code>celldefine  **module** (    **input**    clk,    **input**    rst,    **output**   clk_pll,    **output**   flag);      ……  **endmodule**  </code>endcelldefine</p>
<h3 id="unconnected-drive-nounconnected-drive"><a href="#unconnected-drive-nounconnected-drive" class="headerlink" title="unconnected_drive, nounconnected_drive"></a><code>unconnected_drive, </code>nounconnected_drive</h3><p>在模块实例化中，出现在这两个编译指令间的任何未连接的输入端口，为正偏电路状态或者为反偏电路状态。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">assign</span></span></code></pre></div><p>用于对 wire 型变量进行赋值,不对寄存器赋值</p>
<p>进位输出（Carry  out，通常表示为Co或Cout）是全加器的一个输出，它表示在两个二进制位相加时是否产生了进位。在二进制加法中，当两个加数位（A和B）的和大于或等于2时，就会产生进位，因为二进制中的每一位只能表示0或1。进位输出就是用来表示这个进位的。</p>
<p><strong>module</strong> full_adder1(<br>   <strong>input</strong>   Ai, Bi, Ci,<br>   <strong>output</strong>  So, Co);</p>
<p>   <strong>assign</strong> So &#x3D; Ai ^ Bi ^ Ci ;<br>   <strong>assign</strong> Co &#x3D; (Ai &amp; Bi) | (Ci &amp; (Ai | Bi));<br> <strong>endmodule</strong></p>
<p>更简单的：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">module full_adder1(</span></span>
<span class="line"><span style="color: #babed8">    input Ai, Bi, Ci,</span></span>
<span class="line"><span style="color: #babed8">    output So, Co);</span></span>
<span class="line"><span style="color: #babed8">    </span></span>
<span class="line"><span style="color: #babed8">    assign &#123;Co, So&#125; = Ai + Bi + Ci;</span></span>
<span class="line"><span style="color: #babed8">endmodule</span></span></code></pre></div><p><em>&#x2F;&#x2F;普通时延，A&amp;B计算结果延时10个时间单位赋值给Z</em><br> <strong>wire</strong> Z, A, B ;<br> <strong>assign</strong> #10   Z &#x3D; A &amp; B ;</p>
<p> <em>&#x2F;&#x2F;隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。</em><br> <strong>wire</strong> A, B;<br> <strong>wire</strong> #10     Z &#x3D; A &amp; B;</p>
<p> <em>&#x2F;&#x2F;声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。</em><br> <strong>wire</strong> A, B;<br> <strong>wire</strong> #10 Z ;<br> <strong>assign</strong>      Z &#x3D;A &amp; B</p>
<h2 id="Verilog-过程结构"><a href="#Verilog-过程结构" class="headerlink" title="Verilog 过程结构"></a>Verilog 过程结构</h2><p>过程结构语句有 2 种，initial 与 always 语句</p>
<p>一个模块中可以包含多个 initial 和 always 语句，但 2 种语句不能嵌套使用。</p>
<p>但是 initial 语句或 always 语句内部可以理解为是顺序执行的（非阻塞赋值除外）。</p>
<h3 id="initial语句"><a href="#initial语句" class="headerlink" title="initial语句"></a>initial语句</h3><p>initial 语句从 0 时刻开始执行，只执行一次，多个 initial 块之间是相互独立的。</p>
<p>如果 initial 块内包含多个语句，需要使用关键字 begin 和 end 组成一个块语句。</p>
<p>如果 initial 块内只要一条语句，关键字 begin 和 end 可使用也可不使用。</p>
<p>initial 理论上来讲是不可综合的，多用于初始化、信号检测等。</p>
<h4 id="这些语句在模块间并行执行，与其在模块的前后顺序没有关系"><a href="#这些语句在模块间并行执行，与其在模块的前后顺序没有关系" class="headerlink" title="这些语句在模块间并行执行，与其在模块的前后顺序没有关系"></a>这些语句在模块间并行执行，与其在模块的前后顺序没有关系</h4><h3 id="always-语句"><a href="#always-语句" class="headerlink" title="always 语句"></a>always 语句</h3><p>与 initial 语句相反，always 语句是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。</p>
<p>由于循环执行的特点，always 语句多用于仿真时钟的产生，信号行为的检测等。   </p>
<h6 id="parameter-关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。"><a href="#parameter-关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。" class="headerlink" title="parameter 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。"></a><code>parameter</code> 关键字用于定义模块的参数。参数是一种可以在模块实例化时或在模块内部使用，但不一定要在模块的所有复制中传递的常数。简单地说，参数类似于函数或算法中的变量，它们在模块的复制品之间共享。</h6><p>连续性赋值使用assign语句，而过程性赋值使用always块。</p>
<p>阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。</p>
<p>阻塞赋值语句使用等号 &#x3D; 作为赋值符。</p>
<p>非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。</p>
<p>非阻塞赋值语句使用小于等于号 &lt;&#x3D; 作为赋值符。</p>
<p>如下所示，2 个 always 块中语句并行执行，赋值操作右端操作数使用的是上一个时钟周期的旧值，此时 a&lt;&#x3D;b 与 b&lt;&#x3D;a 就可以相互不干扰的执行，达到交换寄存器值的目的。</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><p><strong>always</strong> @(<strong>posedge</strong> clk) <strong>begin</strong><br>   a &lt;&#x3D; b ;<br> <strong>end</strong></p>
<p> <strong>always</strong> @(<strong>posedge</strong> clk) <strong>begin</strong><br>   b &lt;&#x3D; a;<br> <strong>end</strong></p>
<h2 id="Verilog-时序控制"><a href="#Verilog-时序控制" class="headerlink" title="Verilog 时序控制"></a>Verilog 时序控制</h2><p>Verilog 提供了 2 大类时序控制方法：时延控制和事件控制。事件控制主要分为边沿触发事件控制与电平敏感事件控制</p>
<h3 id="时延控制-根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。"><a href="#时延控制-根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。" class="headerlink" title="时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。"></a>时延控制:根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延。</h3><p><strong>常规时延</strong></p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">reg  value_test ;</span></span>
<span class="line"><span style="color: #babed8">reg  value_general ;</span></span>
<span class="line"><span style="color: #babed8">#10  value_general    = value_test ;</span></span></code></pre></div><p>或：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">#10 ;</span></span>
<span class="line"><span style="color: #babed8">value_ single         = value_test ;</span></span></code></pre></div><p><strong>内嵌时延</strong></p>
<p>遇到内嵌延时时，该语句先将计算结果保存，然后等待一定的时间后赋值给目标信号。</p>
<p>内嵌时延控制加在赋值号之后。例如：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">reg  value_test ;</span></span>
<span class="line"><span style="color: #babed8">reg  value_embed ;</span></span>
<span class="line"><span style="color: #babed8">value_embed        = #10 value_test ;</span></span></code></pre></div><p>需要说明的是，这 2 种时延控制方式的效果是有所不同的。</p>
<p>当延时语句的赋值符号右端是常量时，2 种时延控制都能达到相同的延时赋值效果。</p>
<p>当延时语句的赋值符号右端是变量时，2 种时延控制可能会产生不同的延时赋值效果。</p>
<h3 id="边沿触发事件控制"><a href="#边沿触发事件控制" class="headerlink" title="边沿触发事件控制"></a>边沿触发事件控制</h3><p>在 Verilog 中，事件是指某一个 reg 或 wire 型变量发生了值的变化。事件控制用符号 @ 表示。</p>
<p><strong>设计</strong>：根据需求编写硬件描述语言（如Verilog或VHDL）代码来描述设计的功能和行为</p>
<p>synthesize综合，合成：综合代码，检查语法是否有错误,将高级的逻辑描述代码转换为逻辑门级别的网表或等效的门级电路</p>
<p>FloorPlanner 是 FPGA 设计流程中的一个重要工具，用于执行布局（Place）阶段的子任务，即对设计中的逻辑电路进行布局安置。在 FPGA 设计流程中，FloorPlanner 的地位如下：</p>
<ol>
<li><strong>布局规划</strong>：FloorPlanner 负责规划 FPGA 芯片上各个逻辑模块的布局位置，以最大程度地满足设计的性能和资源利用率要求。它会考虑逻辑模块之间的布线延迟、信号传输路径长度等因素，以优化整体的布局结构。</li>
<li><strong>资源分配</strong>：FloorPlanner 还负责将设计中的逻辑模块分配到 FPGA 芯片的不同区域，并且合理利用芯片上的资源（如片上存储器、DSP模块等），以满足设计对资源的需求。</li>
<li><strong>时序约束</strong>：在布局过程中，FloorPlanner 还会考虑时序约束，确保设计中的时序要求能够得到满足。它会尽可能减少逻辑模块之间的传输延迟，以确保时序性能。</li>
<li><strong>优化布局</strong>：FloorPlanner 通过对设计进行优化布局，以降低布线延迟、减少时序问题和功耗等方面的优化。这可以提高设计的性能、可靠性和功耗效率。</li>
</ol>
<p>在 FPGA 设计流程中，FloorPlanner 位于布局（Place）阶段之前，它为后续的布线（Route）阶段提供了优化的布局结果，从而帮助实现设计的最终映射和部署。</p>
<p><strong>Place&amp;Route</strong> ：</p>
<p>开发流程中的 Place &amp; Route 是指在将设计映射到 FPGA 芯片时的一个重要步骤。下面解释一下它的含义和作用：</p>
<ol>
<li><strong>Place（放置）</strong>：Place 指的是将设计中的逻辑元素（如逻辑门、寄存器等）放置到 FPGA 芯片的物理位置上。这一步骤考虑了芯片内部的布局和连接资源，以尽可能地优化性能和资源利用率。放置的目标是最小化延迟、最大化时序性能，并且尽量减少芯片内的布线冲突。</li>
<li><strong>Route（布线）</strong>：Route 是指将设计中的逻辑元素之间的连接关系转化为芯片内部的实际物理连线。这一步骤考虑了芯片内部的连线资源、信号传输延迟等因素，以确保逻辑元素之间的连接能够有效地建立并满足时序要求。布线的目标是尽可能地降低信号传输延迟、最小化信号干扰，同时满足设计的时序约束。</li>
</ol>
<p>在 Verilog 中，<code>reg</code> 类型通常用于表示存储元素（如寄存器），而不是直接连接到模块的输出端口。输出端口通常使用 <code>output</code> 或 <code>inout</code> 声明，并且通常需要与 <code>wire</code> 类型一起使用。</p>
<p><code>reg</code> 类型在 Verilog 中表示的是寄存器类型，它在 <code>always</code> 块中使用，存储状态或信号。而 <code>output</code> 端口应该使用 <code>wire</code> 类型来表示，因为它们不会存储状态，只是将信号传递给其他部件。</p>
<p>因此，你在模块顶层中使用 <code>output reg</code> 是不符合常规的 Verilog 设计习惯的，通常应该使用 <code>output wire</code>。</p>
<p><img src="/../images/image-20240427142422285.png" alt="image-20240427142422285"></p>
<p>半加器（Half Adder）和全加器（Full Adder）是数字电路中用于执行二进制加法的基本组件。它们的主要区别在于它们处理的输入数量和功能。</p>
<p>半加器： 半加器是一个组合逻辑电路，它接受两个二进制位作为输入，并产生两个输出：和（Sum）和进位（Carry）。半加器只处理两个输入位的加法，不考虑来自较低位的进位。半加器的输出进位只能表示当前两个输入位相加是否产生了进位。</p>
<p>半加器的逻辑可以表示为：</p>
<ul>
<li><p>•</p>
<p>和（Sum） &#x3D; A XOR B</p>
</li>
<li><p>•</p>
<p>进位（Carry） &#x3D; A AND B</p>
</li>
</ul>
<p>其中，A和B是两个输入位，XOR表示异或门，AND表示与门。</p>
<p>全加器： 全加器也是一个组合逻辑电路，它接受三个二进制位作为输入，并产生两个输出：和（Sum）和进位（Carry）。全加器的三个输入包括两个加数位（A和B）以及来自较低位的进位（Carry-in）。全加器能够处理包括进位在内的三个位的加法。</p>
<p>全加器的逻辑可以表示为：</p>
<ul>
<li><p>•</p>
<p>和（Sum） &#x3D; (A XOR B) XOR Carry-in</p>
</li>
<li><p>•</p>
<p>进位（Carry） &#x3D; (A AND B) OR (Carry-in AND (A XOR B))</p>
</li>
</ul>
<p>其中，Carry-in是来自较低位的进位，OR表示或门。</p>
<p>区别：</p>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<p>  输入数量：半加器有两个输入，全加器有三个输入。</p>
<ol start="2">
<li><ol start="2">
<li></li>
</ol>
</li>
</ol>
<p>  功能：半加器只计算两个输入位的和和进位，而全加器计算三个输入位（包括来自较低位的进位）的和和进位。</p>
<ol start="3">
<li><ol start="3">
<li></li>
</ol>
</li>
</ol>
<p>  应用：半加器通常用于构建更复杂的加法器电路，如全加器。全加器则用于实现多位二进制数的加法，因为它能够处理进位。</p>
<p>在实际的数字电路设计中，全加器更为常用，因为它可以级联（Cascade）起来构成多位加法器，如4位、8位、16位等，从而实现更复杂的算术运算。</p>
<p>在Verilog中，<code>parameter</code>是一个关键字，用于定义模块（module）的参数</p>
<p><code>parameter</code>定义的值在模块的整个实例化过程中都是固定的，不能被重新赋值。这意味着一旦定义了<code>parameter</code>，它的值在整个模块中都是不变的。</p>
<p>Assignment 赋值</p>
<p>SP代表single port单端口模式，即同一时钟控制读写，同一时间只能写或者度</p>
<p>在您提供的 Verilog 代码片段中，<code>ram_inst</code> 是一个实例化语句，用于创建一个 RAM 模块的实例。这个实例使用了多个引脚（pins），这些引脚定义了模块的输入和输出接口。下面是每个引脚的详细解释：</p>
<ul>
<li><p>•</p>
<p><code>.dout(dout_o)</code>：这是 RAM 模块的输出引脚，名为 <code>dout</code>，它是一个 8 位宽度的输出信号。在这个实例中，它被连接到了一个名为 <code>dout_o</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.clk(clk)</code>：这是 RAM 模块的时钟输入引脚，用于同步数据写入和读取操作。它被连接到了一个名为 <code>clk</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.oce(oce_i)</code>：这是 RAM 模块的输出使能输入引脚，用于控制 <code>dout</code> 信号是否输出数据。它被连接到了一个名为 <code>oce_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.ce(ce_i)</code>：这是 RAM 模块的芯片使能输入引脚，用于控制 RAM 是否可以进行读写操作。它被连接到了一个名为 <code>ce_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.reset(reset_i)</code>：这是 RAM 模块的复位输入引脚，用于将 RAM 恢复到初始状态。它被连接到了一个名为 <code>reset_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.wre(wre_i)</code>：这是 RAM 模块的写使能输入引脚，用于控制是否可以写入数据到 RAM。它被连接到了一个名为 <code>wre_i</code> 的信号。</p>
</li>
<li><p>•</p>
<p><code>.ad(addr)</code>：这是 RAM 模块的地址输入引脚，用于指定要读取或写入的 RAM 单元的地址。它被连接到了一个名为 <code>addr</code> 的信号，该信号是 11 位宽度的。</p>
</li>
<li><p>•</p>
<p><code>.din(data_i)</code>：这是 RAM 模块的数据输入引脚，用于写入数据到 RAM。它被连接到了一个名为 <code>data_i</code> 的信号，该信号是 8 位宽度的。</p>
</li>
</ul>
<p>每个引脚都是 RAM 模块与其外部接口之间的连接点，它们定义了模块如何与外部信号交互。在实际的设计中，您需要确保这些引脚被正确地连接到相应的信号，并且信号的类型和宽度与 RAM 模块的要求相匹配。</p>
<p>FPGA中BRAM和DRAM的区别</p>
<p>FPGA（现场可编程门阵列）中的BRAM（块RAM）和DRAM（动态RAM）是两种不同类型的存储器，它们在设计和使用上有着显著的区别：</p>
<ol>
<li><strong>类型和用途</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：是静态RAM（SRAM）的一种形式，通常集成在FPGA芯片内部。它提供快速的存储解决方案，适用于需要高速、小容量存储的应用，如缓存、缓冲区或FPGA内部的数据存储。</li>
<li><strong>DRAM</strong>：是一种动态RAM，与FPGA芯片外部连接。它具有更高的存储密度，但速度较BRAM慢。DRAM适用于需要大容量存储的应用，如图像处理、视频缓冲和大量数据存储。</li>
</ul>
<ol start="2">
<li><strong>存储机制</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：作为静态RAM，它不需要刷新电路来维持数据。每个存储单元都使用六晶体管（6T）的SRAM细胞结构，这意味着它可以无限期地保持数据，直到被写入新数据。</li>
<li><strong>DRAM</strong>：作为动态RAM，它需要定期刷新来维持数据。每个存储单元通常由一个电容器和一个晶体管组成，因此它的密度可以更高，但速度较慢，并且需要更复杂的控制逻辑。</li>
</ul>
<ol start="3">
<li><strong>性能特点</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：提供单周期访问时间，这意味着访问数据几乎立即完成，适用于要求严格实时性能的应用。</li>
<li><strong>DRAM</strong>：由于其刷新要求，访问速度较慢，通常需要多个时钟周期来访问数据。</li>
</ul>
<ol start="4">
<li><strong>集成度</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：在FPGA芯片内部，与逻辑元素紧密集成，可以提供非常低的延迟访问。</li>
<li><strong>DRAM</strong>：通常作为外部组件连接到FPGA，通过内存接口（如DDR）进行通信。</li>
</ul>
<ol start="5">
<li><strong>功耗</strong>：</li>
</ol>
<ul>
<li><strong>BRAM</strong>：由于其简单性和快速访问能力，通常功耗较低。</li>
<li><strong>DRAM</strong>：由于需要刷新和复杂的控制逻辑，功耗通常更高。</li>
</ul>
<p>在选择使用BRAM还是DRAM时，设计者需要根据应用需求、性能要求、成本考虑和功耗限制来做出决策。对于需要高速、小容量存储的应用，BRAM通常是更好的选择；而对于需要大容量存储的应用，DRAM可能是更合适的选择。</p>
<p>在FPGA中，BRAM（块RAM）可以被配置为单端口模式或双端口模式，这两种模式在数据访问方式上有所不同：</p>
<ol>
<li><strong>单端口模式</strong>：</li>
</ol>
<ul>
<li>在单端口模式下，BRAM有一个数据访问端口，即地址和数据线是共用的。</li>
<li>在任何给定的时间，单端口BRAM只能进行一次读操作或写操作。如果在一个时钟周期内同时尝试进行读和写操作，通常会发生冲突，除非特定的FPGA具有特殊的管理机制。</li>
<li>单端口模式适用于那些不需要同时进行读写操作的应用场景，或者那些可以接受顺序访问的应用场景。</li>
</ul>
<ol start="2">
<li><strong>双端口模式</strong>：</li>
</ol>
<ul>
<li>双端口模式允许BRAM同时通过两个独立的端口进行访问，每个端口都有自己的地址线、数据线和控制线。</li>
<li>这意味着双端口BRAM可以在同一时钟周期内进行一次读操作和一次写操作，或者同时进行两次读操作，访问不同的地址。</li>
<li>双端口模式适用于需要同时或并行访问存储器中不同位置的应用场景，如图像处理、缓存和乒乓缓冲等。</li>
</ul>
<p>在某些FPGA中，BRAM还可以配置为更高级的端口模式，如四端口模式，这允许更多的并行访问。设计者根据具体应用的需求来选择最合适的端口模式，以优化性能和资源利用。</p>
<p>十六进制数系统中的每个数字代表4位二进制数</p>
<p>在Verilog中，<code>defparam</code>是一个编译器指令，用于在模块实例化时重定义参数的值。这条指令可以用来改变模块实例化时参数的默认值。</p>
<p>在Verilog中，<code>localparam</code>关键字用于声明一个模块内部的参数，这个参数在模块的整个作用域内都是常量。<code>localparam</code>声明的参数是不可变的，它们的值在编译时就已经确定了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/FPGA.html" data-id="clxbjvuxp000861cxbhoich4q" data-title="FPGA" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Android-Kotlin" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Android-Kotlin.html" class="article-date">
  <time class="dt-published" datetime="2024-04-21T12:52:23.000Z" itemprop="datePublished">2024-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Android-Kotlin.html">Android_Kotlin</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">`class FirstActivity : AppCompatActivity() &#123;`</span></span>
<span class="line"><span style="color: #babed8">`override fun onCreate(savedInstanceState: Bundle?) &#123;`</span></span>
<span class="line"><span style="color: #babed8">`super.onCreate(savedInstanceState)`</span></span>
<span class="line"><span style="color: #babed8">`&#125;`</span></span>
<span class="line"><span style="color: #babed8">`&#125;`</span></span></code></pre></div><p>这段代码是使用 Kotlin 语言编写的 Android 应用程序中的一个活动（Activity）类。让我逐步解释其中的内容：</p>
<ol>
<li><code>class FirstActivity : AppCompatActivity()</code>：这是一个类的声明，类名为 <code>FirstActivity</code>，并且继承自 <code>AppCompatActivity</code> 类。<code>AppCompatActivity</code> 是 Android 开发中常用的一个基类，用于支持应用程序在较旧的 Android 版本上提供向后兼容性。</li>
<li><code>override fun onCreate(savedInstanceState: Bundle?)</code>：这是 <code>FirstActivity</code> 类中的一个方法 <code>onCreate()</code> 的重写。在 Android 中，<code>onCreate()</code> 方法是活动生命周期的一部分，在活动第一次创建时被调用。<code>savedInstanceState</code> 参数是一个 <code>Bundle</code> 对象，其中包含了之前保存的活动状态信息，可以用于在活动重新创建时恢复状态。</li>
<li><code>super.onCreate(savedInstanceState)</code>：这是调用父类 <code>AppCompatActivity</code> 中的 <code>onCreate()</code> 方法，确保父类中的初始化工作得以执行。</li>
</ol>
<p>因此，这段代码定义了一个名为 <code>FirstActivity</code> 的活动类，当该活动第一次创建时，会调用父类的 <code>onCreate()</code> 方法进行初始化。</p>
<p>在声明 <code>savedInstanceState</code> 参数时，如果在类型后面添加了 <code>?</code>，则表示该参数可以接受 <code>null</code> 值。</p>
<p>这样做的目的是为了允许 <code>savedInstanceState</code> 参数在某些情况下为 null，例如当活动或片段首次创建时，<code>savedInstanceState</code> 可能为 null，因为此时还没有保存任何状态信息。</p>
<p>在 Kotlin 中，如果没有使用 <code>?</code>，则表示该参数不接受 null 值，如果在实际使用中传递了 null 值，编译器将会报错。而使用了 <code>?</code> 后，表示该参数可以接受 null 值，编译器将不会报错。</p>
<p>因此，在 <code>override fun onCreate(savedInstanceState: Bundle?)</code> 中，<code>Bundle?</code> 表示 <code>savedInstanceState</code> 参数可以接受 null 值，即在某些情况下，<code>savedInstanceState</code> 可能为 null。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span></span>
<span class="line"><span style="color: #babed8">android:orientation=&quot;vertical&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_width=&quot;match_parent&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_height=&quot;match_parent&quot;&gt;</span></span>
<span class="line"><span style="color: #babed8">&lt;Button</span></span>
<span class="line"><span style="color: #babed8">android:id=&quot;@+id/button1&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_width=&quot;match_parent&quot;</span></span>
<span class="line"><span style="color: #babed8">android:layout_height=&quot;wrap_content&quot;</span></span>
<span class="line"><span style="color: #babed8">android:text=&quot;Button 1&quot;</span></span>
<span class="line"><span style="color: #babed8">/&gt;</span></span>
<span class="line"><span style="color: #babed8">&lt;/LinearLayout&gt;</span></span></code></pre></div><p>这段代码是一个简单的 Android 布局文件，使用 XML 格式描述了一个线性布局（LinearLayout）以及一个按钮（Button）的布局和属性。</p>
<p>让我解释其中的一些关键部分：</p>
<ul>
<li><code>&lt;LinearLayout&gt;</code>：这是一个布局容器，用于在垂直方向排列其子视图（例如按钮）。<code>xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</code> 是 XML 命名空间声明，它使得可以在 XML 文件中使用 Android 提供的属性和元素。</li>
<li><code>android:orientation=&quot;vertical&quot;</code>：这个属性指定了线性布局的方向，即垂直方向。这意味着其中的子视图（此处为按钮）将会按照垂直方向排列。</li>
<li><code>android:layout_width=&quot;match_parent&quot;</code> 和 <code>android:layout_height=&quot;match_parent&quot;</code>：这两个属性指定了布局的宽度和高度。<code>match_parent</code> 表示该布局将会填充其父容器的宽度或高度，以占据尽可能多的空间。</li>
<li><code>&lt;Button&gt;</code>：这是一个按钮视图，在布局中用于响应用户的点击事件。</li>
<li><code>android:id=&quot;@+id/button1&quot;</code>：这个属性为按钮指定了一个唯一的标识符，可以在 Java 代码中使用这个标识符来查找和操作这个按钮。</li>
<li><code>wrap_content</code> 属性可以使得布局更加灵活，可以根据内容的大小动态调整视图的尺寸，而不是固定为特定的尺寸。</li>
<li><code>android:text=&quot;Button 1&quot;</code>：这个属性为按钮设置了显示的文本内容为 “Button 1”。</li>
</ul>
<p>因此，这段代码描述了一个垂直排列的线性布局，其中包含一个按钮，按钮显示文本为 “Button 1”。按钮的宽度会填充父容器的宽度，而高度则根据按钮文本的大小动态调整。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">class FirstActivity : AppCompatActivity() &#123;</span></span>
<span class="line"><span style="color: #babed8">override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span>
<span class="line"><span style="color: #babed8">super.onCreate(savedInstanceState)</span></span>
<span class="line"><span style="color: #babed8">setContentView(R.layout.first_layout)</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>首先调用了 <code>super.onCreate(savedInstanceState)</code>，以确保调用了父类的 <code>onCreate()</code> 方法，以便执行必要的初始化操作。</p>
<p>接着调用了 <code>setContentView(R.layout.first_layout)</code> 方法，这个方法用于设置该活动所使用的布局文件。在这里，<code>first_layout</code> 是指定的布局资源文件的名称，这个布局文件定义了活动的界面布局结构。</p>
<p>因此，这段代码的作用是在 <code>FirstActivity</code> 中设置了一个布局文件 <code>first_layout</code> 作为活动的界面布局，并在活动创建时加载该布局。</p>
<p><code>R.layout</code> 是一个自动生成的资源标识符类，它包含了项目中所有布局文件的引用。在 Android 开发中，资源文件（如布局文件、字符串、图像等）都需要通过资源标识符来访问和引用。</p>
<p>当你在项目中创建布局文件时，每个布局文件都会被编译成一个资源标识符，以便在代码中进行引用。这些资源标识符都会被统一放置在 <code>R</code> 类的内部静态类中，而 <code>R.layout</code> 则是其中用于引用布局文件的子类之一。</p>
<p>Intent—&gt;用于通信的消息对象</p>
<p>在 Android 中，Intent 是一种用于在不同组件之间进行通信的对象。它可以用于启动活动（Activity）、启动服务（Service）、发送广播（Broadcast）以及执行其他各种操作。Intent 提供了一种在不同组件之间传递数据和执行操作的机制。</p>
<p>Intent 本质上是一个消息对象，用于指示想要执行的操作。它可以包含以下信息：</p>
<ol>
<li><strong>操作（Action）</strong>：指示要执行的操作，如启动活动、启动服务、发送广播等。常见的操作包括 <code>android.intent.action.VIEW</code>（查看操作）、<code>android.intent.action.SEND</code>（发送操作）、<code>android.intent.action.MAIN</code>（主操作）等。</li>
<li><strong>数据（Data）</strong>：用于指定操作的数据，可以是 URI、文件路径、文本等。例如，如果要查看网页，可以将网页的 URL 作为数据传递给 Intent。</li>
<li><strong>类别（Category）</strong>：用于指定操作的类别，如 <code>android.intent.category.LAUNCHER</code>（启动器类别）、<code>android.intent.category.BROWSABLE</code>（可浏览类别）等。</li>
<li><strong>附加信息（Extras）</strong>：用于传递额外的数据给目标组件。Extras 是键值对的形式，可以包含各种数据类型，如字符串、整数、布尔值等。</li>
</ol>
<p>Intent 可以分为两种类型：</p>
<ul>
<li><strong>显式 Intent</strong>：明确定义了目标组件的类名，用于启动特定的组件。</li>
<li><strong>隐式 Intent</strong>：没有明确指定目标组件，而是根据 Intent 的操作、数据等信息由系统来匹配合适的组件。</li>
</ul>
<p>通过使用 Intent，Android 应用程序可以实现各种功能，例如启动新的活动、执行后台任务、发送广播等，从而实现各种复杂的交互和功能。</p>
<p>Kotlin直接可以：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">override fun onCreate(savedInstanceState: Bundle?) &#123;</span></span>
<span class="line"><span style="color: #babed8">super.onCreate(savedInstanceState)</span></span>
<span class="line"><span style="color: #babed8">setContentView(R.layout.first_layout)</span></span>
<span class="line"><span style="color: #babed8">button1.setOnClickListener &#123;</span></span>
<span class="line"><span style="color: #babed8">Toast.makeText(this, &quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show()</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>在 Kotlin 中，函数声明的语法是：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">fun 函数名(参数列表): 返回值类型 &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 函数体</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p>其中，返回值类型在函数名和参数列表之后，使用冒号 <code>:</code> 来标识。在这个语法中，返回值类型是必须的，但在某些情况下，如果函数没有返回值，可以将返回值类型指定为 <code>Unit</code>，或者省略返回值类型（在这种情况下，编译器会自动推断返回值类型为 <code>Unit</code>）。例如：</p>
<div class="language-kotlin"><button title="Copy code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">kotlin</span></span>
<span class="line"><span style="color: #C792EA">fun</span><span style="color: #BABED8"> </span><span style="color: #82AAFF">greet</span><span style="color: #BABED8">(name: </span><span style="color: #FFCB6B">String</span><span style="color: #BABED8">): </span><span style="color: #FFCB6B">Unit</span><span style="color: #BABED8"> &#123;</span></span>
<span class="line"><span style="color: #BABED8">    </span><span style="color: #82AAFF">println</span><span style="color: #BABED8">(</span><span style="color: #C3E88D">&quot;Hello, </span><span style="color: #BABED8">$name</span><span style="color: #C3E88D">!&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #BABED8">&#125;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #676E95; font-style: italic">// 或者省略返回值类型，编译器会自动推断为 Unit</span></span>
<span class="line"><span style="color: #C792EA">fun</span><span style="color: #BABED8"> </span><span style="color: #82AAFF">greet</span><span style="color: #BABED8">(name: </span><span style="color: #FFCB6B">String</span><span style="color: #BABED8">) &#123;</span></span>
<span class="line"><span style="color: #BABED8">    </span><span style="color: #82AAFF">println</span><span style="color: #BABED8">(</span><span style="color: #C3E88D">&quot;Hello, </span><span style="color: #BABED8">$name</span><span style="color: #C3E88D">!&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #BABED8">&#125;</span></span></code></pre></div><div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">override fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;</span></span>
<span class="line"><span style="color: #babed8">menuInflater.inflate(R.menu.main, menu)</span></span>
<span class="line"><span style="color: #babed8">return true</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><p><code>menuInflater</code> 是 Android 开发中的一个类，用于从 XML 文件中创建菜单对象。在 Android 中，通常使用 XML 文件定义应用程序中的菜单，然后通过 <code>MenuInflater</code> 类将这些 XML 文件中定义的菜单加载到应用程序中的菜单对象中，以供在用户界面中显示和操作。</p>
<p>具体来说，<code>menuInflater.inflate()</code> 方法用于将一个 XML 文件中定义的菜单资源加载到一个 <code>Menu</code> 对象中，这样就可以在应用程序的用户界面中显示这个菜单。</p>
<p>在 Android 应用程序中，Activity 和 Fragment 是两种重要的组件，用于构建用户界面和处理用户交互。它们都可以包含用户界面的布局，并且可以响应用户的输入事件（如点击、滑动等）。</p>
<p>下面是关于 Activity 和 Fragment 的简要介绍：</p>
<h3 id="Activity（活动）"><a href="#Activity（活动）" class="headerlink" title="Activity（活动）"></a>Activity（活动）</h3><ol>
<li><strong>定义</strong>：Activity 是 Android 应用中的一个基本组件，代表一个单独的用户界面屏幕，通常是一个窗口、一个对话框或全屏显示的窗口。</li>
<li><strong>作用</strong>：Activity 主要负责管理用户与应用程序之间的交互，包括接收用户输入、处理用户操作，并在屏幕上显示相应的界面。</li>
<li><strong>生命周期</strong>：Activity 具有丰富的生命周期方法，如 <code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code> 等，开发者可以根据需要重写这些方法来执行相应的操作。</li>
<li><strong>布局</strong>：Activity 可以通过设置布局文件（XML 文件）来定义用户界面的外观和行为，也可以通过代码动态地创建和管理用户界面。</li>
</ol>
<h3 id="Fragment（片段）"><a href="#Fragment（片段）" class="headerlink" title="Fragment（片段）"></a>Fragment（片段）</h3><ol>
<li><strong>定义</strong>：Fragment 是 Android 应用中的另一个基本组件，代表了一个可复用的用户界面模块，可以在一个 Activity 中嵌套多个 Fragment。</li>
<li><strong>作用</strong>：Fragment 主要用于构建灵活的用户界面，允许开发者将应用程序的功能拆分成可重用的模块，并在不同的屏幕尺寸和设备方向下进行适配。</li>
<li><strong>生命周期</strong>：Fragment 也有自己的生命周期方法，与 Activity 的生命周期方法类似，包括 <code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code> 等。</li>
<li><strong>布局</strong>：Fragment 可以拥有自己的布局文件（XML 文件），也可以在宿主 Activity 中动态添加到布局中，允许开发者在运行时动态地添加、替换和移除 Fragment。</li>
</ol>
<p>总的来说，Activity 通常代表一个完整的屏幕，而 Fragment 则是 Activity 中一个可重用的组成部分，可以在一个 Activity 中组合多个 Fragment 来构建复杂的用户界面。在实际开发中，Activity 和 Fragment 经常一起使用，以实现灵活和高效的用户界面设计。</p>
<p>在 Kotlin 中，<code>?.</code> 是安全调用运算符，用于在对象为非空时调用其方法或访问其属性。如果对象为 null，则安全调用运算符会短路并返回 null，而不会抛出空指针异常。</p>
<p>在你提供的代码中，<code>data?.getStringExtra(&quot;data_return&quot;)</code> 的意思是，如果 <code>data</code> 不为 null，则调用 <code>getStringExtra(&quot;data_return&quot;)</code> 方法来获取名为 “data_return” 的额外数据，否则返回 null。这种写法可以避免在 <code>data</code> 为 null 时引发空指针异常。</p>
<p><code>registerForActivityResult(...)</code>：这是一个用于注册 Activity Result 的函数。它接受一个 <code>ActivityResultContract</code> 对象作为参数，并返回一个 <code>ActivityResultLauncher</code> 对象。<code>ActivityResultContract</code> 是一个接口，用于定义活动启动和结果处理之间的合同。</p>
<p>Activity类中定义了7个回调方法，覆盖了Activity生命周期的每一个环节:</p>
<ul>
<li><p>onCreate() 在Activity第一次被创建时调用</p>
</li>
<li><p>onStart() 由不可见到可见时调用</p>
</li>
<li><p>onResume()。这个方法在Activity准备好和用户进行交互的时候调用。此时的Activity一</p>
<p>定位于返回栈的栈顶，并且处于运行状态。</p>
</li>
<li><p>onPause()。这个方法在系统准备去启动或者恢复另一个Activity的时候调用。我们通常</p>
<p>会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执</p>
<p>行速度一定要快，不然会影响到新的栈顶Activity的使用。</p>
</li>
<li><p>onStop()。这个方法在Activity完全不可见的时候调用。它和onPause()方法的主要区</p>
<p>别在于，如果启动的新Activity是一个对话框式的Activity，那么onPause()方法会得到执行，而onStop()方法并不会执行。</p>
</li>
<li><p>onDestroy()。这个方法在Activity被销毁之前调用，之后Activity的状态将变为销毁状态。</p>
</li>
<li><p>onRestart()。这个方法在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。</p>
</li>
</ul>
<p><code>onPause()</code> 方法是 Android Activity 生命周期中的一个回调方法，用于指示当前 Activity 正在失去焦点并即将暂停其可见性。当某些事件发生时，系统会调用 <code>onPause()</code> 方法，这些事件包括：</p>
<ol>
<li>启动另一个 Activity：当用户启动另一个 Activity 并且当前 Activity 失去焦点时，系统会调用 <code>onPause()</code> 方法。例如，当用户点击应用中的按钮，打开新的 Activity 时，当前 Activity 将暂停。</li>
<li>打开对话框或弹出窗口：如果当前 Activity 打开了对话框、弹出了一个窗口或者其他部分覆盖了当前 Activity 但不完全遮挡，系统也会调用 <code>onPause()</code> 方法。</li>
<li>接收到来电或其他中断：当用户接收到来电、收到短信或者其他中断事件时，当前 Activity 也会暂停，系统会调用 <code>onPause()</code> 方法。</li>
<li>用户按下 Home 键或切换到最近任务列表：当用户按下 Home 键返回桌面或切换到最近任务列表时，当前 Activity 也会暂停，系统会调用 <code>onPause()</code> 方法。</li>
</ol>
<p>总之，<code>onPause()</code> 方法的调用情况涵盖了当前 Activity 失去焦点并即将暂停可见性的各种情况。</p>
<p><code>onStart()</code> 是 Android 活动生命周期中的一个方法，用于指示活动即将变为可见状态。当活动首次启动或从停止状态恢复到活动栈时，系统会调用 <code>onStart()</code> 方法。</p>
<p>具体情况下，<code>onStart()</code> 方法会在以下几种情况下被调用：</p>
<ol>
<li><strong>当活动首次启动</strong>：当用户启动应用程序并打开了包含该活动的界面时，系统会调用活动的 <code>onStart()</code> 方法。此时，活动将从不可见状态转变为可见状态。</li>
<li><strong>当活动从暂停状态恢复</strong>：如果一个活动从 <code>onPause()</code> 状态恢复到前台状态，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。</li>
</ol>
<p>在 <code>onStart()</code> 方法中，通常执行一些与界面相关的初始化操作，比如恢复 UI 状态、注册广播接收器或者启动一些后台任务。需要注意的是，尽管活动已经变为可见状态，但此时活动并未处于用户的焦点下，用户可能无法与其进行交互。</p>
<p><code>onResume()</code> 是 Android 活动生命周期中的一个方法，用于指示活动即将成为用户焦点并开始与用户进行交互。当活动从不可见状态变为可见状态，并且用户可以开始与其进行交互时，系统会调用 <code>onResume()</code> 方法。</p>
<p>具体情况下，<code>onResume()</code> 方法会在以下几种情况下被调用：</p>
<ol>
<li><strong>当活动首次启动</strong>：当用户首次启动应用程序并打开了包含该活动的界面时，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。此时，活动将从不可见状态转变为可见状态，并且用户可以开始与其进行交互。</li>
<li><strong>当活动从暂停状态恢复</strong>：如果一个活动从 <code>onPause()</code> 状态恢复到前台状态，系统会先调用 <code>onStart()</code> 方法，然后调用 <code>onResume()</code> 方法。这种情况通常发生在用户按下返回按钮、活动恢复到前台、或者其他活动被移除而当前活动重新进入前台的情况下。</li>
<li><strong>当活动从停止状态恢复</strong>：如果一个活动从 <code>onStop()</code> 状态恢复到前台状态，系统会依次调用 <code>onRestart()</code>、<code>onStart()</code> 和 <code>onResume()</code> 方法。这种情况通常发生在用户按下 Home 键后再次打开应用程序的情况下。</li>
</ol>
<p>在 <code>onResume()</code> 方法中，通常执行一些与活动生命周期相关的操作，比如恢复用户的输入状态、启动动画效果或者连接到一些外部服务。需要注意的是，当活动处于 <code>onResume()</code> 状态时，它已经成为了用户焦点下的活动，并且用户可以直接与其进行交互。</p>
<p><img src="/../images/image-20240422135757284.png" alt="image-20240422135757284"></p>
<p>当将视图或布局的尺寸设置为 “wrap_content” 时，系统会根据其内容自动调整视图或布局的尺寸，以便刚好容纳其内</p>
<p>在 Android 的清单文件（AndroidManifest.xml）中声明活动（Activity）时，可以使用两种方式：</p>
<ol>
<li><code>&lt;activity&gt;...&lt;/activity&gt;</code>：这是一种传统的 XML 标签方式，用于定义活动的属性和行为。在 <code>&lt;activity&gt;</code> 标签中，可以指定活动的各种属性，例如名称、图标、主题等，并且可以包含其他标签和属性以提供更详细的配置。通常情况下，你可以在 <code>&lt;activity&gt;</code> 标签内部设置更多的属性，包括活动的名称、图标、主题等，以及与活动相关的其他设置。</li>
<li><code>&lt;activity/&gt;</code>：这是一种自闭合的 XML 标签方式，用于简单地声明一个活动而不指定任何属性或配置。这种方式适用于简单的活动声明，当你不需要指定任何属性或配置时，可以使用这种方式。例如，如果你的活动只需要基本的声明，而不需要指定任何其他属性或配置，你可以使用 <code>&lt;activity/&gt;</code> 标签。</li>
</ol>
<p>因此，你应该根据活动的具体需求和配置选择适当的方式。如果需要指定活动的各种属性和配置，可以使用 <code>&lt;activity&gt;...&lt;/activity&gt;</code> 标签；如果活动只需要基本的声明而不需要指定任何其他属性或配置，可以使用 <code>&lt;activity/&gt;</code> 标签。</p>
<p><code>@style/Theme.AppCompat.Dialog</code> 是指在 Android 应用程序中使用的一个预定义的对话框主题样式。这个样式通常用于创建对话框，即弹出式窗口，以在应用程序中显示临时信息、接受用户输入或执行其他操作。</p>
<p>这个主题样式基于 AppCompat 库提供的默认对话框主题进行定义，并且与 AppCompat 库中其他主题一样，它提供了跨不同 Android 版本的一致外观和行为。这样，你的应用程序就可以在不同版本的 Android 上保持一致的外观和用户体验。</p>
<p><code>android:exported=&quot;false&quot;</code> 是 Android 清单文件中 <code>&lt;activity&gt;</code> 元素的一个属性，用于指定该活动是否能够被其他应用程序组件或者系统组件访问。具体含义如下：</p>
<ul>
<li>如果 <code>android:exported=&quot;false&quot;</code>，则表示该活动不会被其他应用程序或系统组件调用。这意味着该活动只能被声明它的应用程序内部的组件所访问，其他应用程序或系统组件无法直接启动或与其交互。</li>
<li>如果 <code>android:exported=&quot;true&quot;</code>，则表示该活动可以被其他应用程序或系统组件调用。这意味着其他应用程序可以使用显式或隐式意图启动该活动，并且与其进行交互。</li>
</ul>
<p>在你的示例中，<code>android:exported=&quot;false&quot;</code> 意味着 <code>DialogActivity</code> 这个活动不会被其他应用程序或系统组件访问。它只能被声明它的应用程序内部的组件所访问，其他应用程序无法直接启动或与其交互。这通常用于内部使用的活动，例如只在应用程序内部使用的对话框或者配置界面。</p>
<p>在 Android 开发中，<code>Intent</code>（意图）是用于在不同组件之间传递数据或执行操作的对象。它是一种在 Android 应用程序中实现组件之间通信的重要机制。</p>
<p><code>Intent</code> 主要有两种类型：显式 Intent 和隐式 Intent。</p>
<ol>
<li><p><strong>显式 Intent</strong>：用于启动应用程序内部的组件，例如启动另一个活动（Activity）、启动服务（Service）等。显式 Intent 通过指定目标组件的类名来明确指示要执行的操作。</p>
<p>示例：</p>
</li>
</ol>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">Intent intent = new Intent(this, AnotherActivity.class);</span></span>
<span class="line"><span style="color: #babed8">startActivity(intent);</span></span></code></pre></div><p><strong>隐式 Intent</strong>：用于启动应用程序内或其他应用程序中具有特定功能的组件，而不需要指定目标组件的类名。隐式 Intent 根据指定的动作（Action）、数据（Data）等信息来寻找合适的组件执行操作。</p>
<p>示例：</p>
<ol>
<li><div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.example.com&quot;));</span></span>
<span class="line"><span style="color: #babed8">startActivity(intent);</span></span></code></pre></div></li>
</ol>
<p><code>Intent</code> 的主要作用包括但不限于：</p>
<ul>
<li>启动活动、服务或广播接收器等组件。</li>
<li>在组件之间传递数据，例如在不同活动之间传递参数。</li>
<li>执行一些系统级别的操作，例如拨打电话、发送短信、打开网页等。</li>
</ul>
<p>总之，<code>Intent</code> 是 Android 应用程序中用于实现组件之间通信和执行操作的重要机制。</p>
<p>在 Android 中，<code>Bundle</code> 是一个用来存储键值对数据的容器类。它通常被用于在不同的组件（如活动、片段）之间传递数据，或者在组件销毁和重新创建时保存和恢复数据的状态。</p>
<p>在 <code>onCreate()</code> 方法中，<code>Bundle</code> 参数 <code>savedInstanceState</code> 表示上一个实例状态的数据。当活动被销毁并重新创建时（例如，由于设备旋转或内存紧张），Android 系统会调用 <code>onSaveInstanceState()</code> 方法来保存当前的状态数据，并将其存储在 <code>Bundle</code> 中。然后，在活动重新创建时，系统会将之前保存的状态数据传递给 <code>onCreate()</code> 方法的 <code>savedInstanceState</code> 参数。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">Log.d(&quot;FirstActivity&quot;, this.toString())</span></span></code></pre></div><p><code>this.toString()</code> 是调用当前对象的 <code>toString()</code> 方法。在 Java 中，几乎所有的对象都继承自 <code>Object</code> 类，而 <code>Object</code> 类中有一个 <code>toString()</code> 方法，用于返回对象的字符串表示形式</p>
<p>当你调用 <code>this.toString()</code> 时，它会返回当前对象的字符串表示形式</p>
<p>Activity的启动模式:</p>
<ul>
<li>standard</li>
<li>singleTop  单栈顶</li>
<li>singleTask   单任务</li>
<li>singleInstance  单实例</li>
</ul>
<p>在 Kotlin 中，<code>object</code> 关键字用于定义单例对象。单例对象是指在程序运行期间只有一个实例存在的对象。在给定的作用域内，单例对象只能有一个实例，因此它们非常适合用于管理全局状态或提供全局访问点。</p>
<p>关闭所有活动并不等同于关闭应用程序的进程。在 Android 应用程序中，当你调用 <code>finish()</code> 方法结束一个活动时，这个活动会被销毁，但应用程序的进程仍然在运行。即使所有活动都被销毁，应用程序的进程仍然存在于系统中。</p>
<p>为了完全退出应用程序，有时需要调用 <code>System.exit(0)</code> 或者 <code>Process.killProcess(Process.myPid())</code> 这样的方法来结束应用程序的进程。这样做可以确保应用程序的所有组件都被终止，包括活动、服务、广播接收器等，从而实现应用程序的完全退出。</p>
<p>然而，这种做法通常被视为不推荐的，因为它可能会导致用户体验上的问题，以及系统资源的浪费。通常情况下，Android 系统会自动管理应用程序的进程，并在必要时终止它们，而不需要手动干预。因此，大多数情况下，关闭所有活动即可满足应用程序退出的需求，而无需手动杀死进程。</p>
<p>在 Kotlin 中，<code>companion object</code>（伴生对象）具有以下作用：</p>
<ol>
<li><strong>静态成员访问</strong>：伴生对象中的成员可以直接通过类名访问，就像 Java 中的静态成员一样。这使得可以在不创建类的实例的情况下访问这些成员。</li>
<li><strong>工厂方法</strong>：可以在伴生对象中定义工厂方法，用于创建类的实例。这种方法通常用于隐藏类的构造函数，提供一种更灵活的方式来创建实例。</li>
<li><strong>共享代码</strong>：伴生对象可以包含在类的所有实例之间共享的代码或常量。这些代码或常量对于类的所有实例都是相同的，可以方便地通过伴生对象访问。</li>
<li><strong>扩展方法</strong>：在伴生对象中还可以定义扩展方法，这些方法可以为类添加额外的功能，而无需继承或修改类的源代码。</li>
</ol>
<p>总的来说，伴生对象提供了一种在 Kotlin 中实现类级别功能的方式，它可以用于静态成员访问、工厂方法、共享代码和扩展方法等场景。</p>
<p>StringBuilder是Java中的一个类，用于处理字符串。它允许你在不创建新的String对象的情况下进行字符串的修改和操作，这样可以提高性能并节省内存。</p>
<p>当你需要对字符串进行频繁的修改时，使用StringBuilder通常比直接使用String更高效。这是因为String是不可变的，每次对String进行修改都会创建一个新的String对象，而StringBuilder允许你在同一个对象上执行多次修改操作。</p>
<p>你可以使用StringBuilder的append()方法来添加字符串，使用delete()方法来删除字符串，使用insert()方法来在指定位置插入字符串，使用replace()方法来替换字符串等等。最后，你可以使用toString()方法将StringBuilder对象转换为String对象，以便进行进一步的操作或输出。</p>
<p><code>val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val builder = StringBuilder() builder.append(&quot;Start eating fruits.\n&quot;) for (fruit in list) &#123; builder.append(fruit).append(&quot;\n&quot;) &#125; builder.append(&quot;Ate all fruits.&quot;) val result = builder.toString() println(result) 为什么最后要调用builder.toString()</code>，不能直接打印吗</p>
<p>在上面的代码中，builder是一个StringBuilder对象，而println函数通常接受String类型的参数来进行输出。而builder对象是一个StringBuilder类型的对象，不是String类型的对象，因此无法直接传递给println函数。</p>
<p>调用builder.toString()方法将StringBuilder对象转换为String类型的对象，这样就可以将其作为参数传递给println函数，从而实现输出。toString()方法会返回StringBuilder对象中包含的所有字符序列作为一个字符串。</p>
<p>因此，为了能够正确地输出builder对象中的内容，需要先调用toString()方法将其转换为String类型的对象，然后再传递给println函数进行打印。</p>
<p><code>with</code> 是 Kotlin 的一个标准库函数，它提供了一种简洁的方式来执行针对特定对象的一系列操作，并返回最后一个表达式的结果。</p>
<p><code>AlertDialog.Builder(this).apply &#123; setTitle(&quot;This is Dialog&quot;) setMessage(&quot;Something important.&quot;) setCancelable(false) setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; &#125; setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; &#125; show()</code> 是什么意思</p>
<p>这段代码是使用 Kotlin 的标准库函数 <code>apply</code> 来构建一个 <code>AlertDialog</code> 对话框，并设置其标题、消息、按钮等属性。下面是代码的解释：</p>
<ol>
<li><code>AlertDialog.Builder(this)</code>：创建了一个 <code>AlertDialog.Builder</code> 的实例，这个实例用于构建一个对话框。</li>
<li><code>apply &#123; ... &#125;</code>：<code>apply</code> 是一个 Kotlin 标准库函数，它接收一个 lambda 表达式作为参数，并在 lambda 表达式的作用域内执行一系列操作。在这个例子中，<code>apply</code> 函数被调用后，会将调用者对象（即 <code>AlertDialog.Builder</code> 的实例）作为参数传递给 lambda 表达式，并在 lambda 表达式内部执行一系列设置操作。</li>
<li><code>setTitle(&quot;This is Dialog&quot;)</code>：在 lambda 表达式中调用 <code>setTitle</code> 方法，设置对话框的标题为 “This is Dialog”。</li>
<li><code>setMessage(&quot;Something important.&quot;)</code>：在 lambda 表达式中调用 <code>setMessage</code> 方法，设置对话框的消息内容为 “Something important.”。</li>
<li><code>setCancelable(false)</code>：在 lambda 表达式中调用 <code>setCancelable</code> 方法，设置对话框为不可取消状态，即用户点击对话框外部或返回键时不会关闭对话框。</li>
<li><code>setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; ... &#125;</code>：在 lambda 表达式中调用 <code>setPositiveButton</code> 方法，设置对话框的确定按钮文本为 “OK”，并设置点击事件处理器。在这里，<code>&#123; dialog, which -&gt; ... &#125;</code> 是一个 lambda 表达式，表示当用户点击确定按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。</li>
<li><code>setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; ... &#125;</code>：在 lambda 表达式中调用 <code>setNegativeButton</code> 方法，设置对话框的取消按钮文本为 “Cancel”，并设置点击事件处理器。同样，<code>&#123; dialog, which -&gt; ... &#125;</code> 是一个 lambda 表达式，表示当用户点击取消按钮时执行的操作。在本例中，lambda 表达式为空，即不执行任何操作。</li>
<li><code>show()</code>：在所有设置完成后，调用 <code>show</code> 方法显示对话框。</li>
</ol>
<p>因此，这段代码的作用是创建一个带有标题、消息、确定按钮和取消按钮的对话框，并将其显示在界面上。</p>
<p>三种基本布局：</p>
<ul>
<li>LinearLayout垂直排布</li>
<li>RelativeLayout相对布局</li>
<li>FrameLayout帧布局</li>
</ul>
<p><img src="/../images/image-20240423231325479.png" alt="image-20240423231325479"></p>
<p><code>override fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123; val view = LayoutInflater.from(context).inflate(resourceId, parent, false) val fruitImage: ImageView = view.findViewById(R.id.fruitImage) val fruitName: TextView = view.findViewById(R.id.fruitName) val fruit = getItem(position) // 获取当前项的Fruit实例 if (fruit != null) &#123; fruitImage.setImageResource(fruit.imageId) fruitName.text = fruit.name &#125; return view &#125;</code></p>
<p>其中：val view &#x3D; LayoutInflater.from(context).inflate(resourceId, parent, false)</p>
<p>作用是从 XML 布局文件中创建一个视图对象，并将其添加到指定的父视图中。</p>
<p>解释每个参数的含义：</p>
<ul>
<li><code>context</code>: 表示当前的上下文环境，通常是一个 Activity 或 Fragment 的实例。</li>
<li><code>resourceId</code>: 表示要加载的布局文件的资源 ID，即 XML 文件的唯一标识符。</li>
<li><code>parent</code>: 表示要将创建的视图添加到的父视图，通常是一个 ViewGroup，比如一个 LinearLayout 或者一个 RecyclerView。</li>
<li><code>false</code>: 表示在加载布局文件时，不将其添加到父视图中。这个参数设置为 <code>false</code> 表示我们会手动将视图添加到父视图中，而不是在加载时自动添加。</li>
</ul>
<p>接口在编程中有多种作用，包括但不限于以下几个方面：</p>
<ol>
<li><strong>定义约束和契约</strong>：接口定义了一组方法或属性的规范，实现该接口的类必须提供这些方法或属性的具体实现。这种约束和契约使得代码更加清晰，使得不同的类可以共享相同的行为规范。</li>
<li><strong>实现多态</strong>：通过接口，可以实现多态，即在不同的类中使用相同的方法名，但实际调用的是各自类的具体实现。这样可以提高代码的灵活性和可扩展性。</li>
<li><strong>代码重用</strong>：接口可以用于定义通用的行为规范，使得多个类可以共享相同的接口定义，从而实现代码的重用。当多个类具有相似的行为或功能时，可以通过接口来统一定义这些行为或功能，避免重复编写代码。</li>
<li><strong>降低耦合性</strong>：通过接口，类与类之间的耦合度可以降低，因为类之间通过接口进行交互，而不是直接依赖于具体的实现。这样，当一个类的实现发生变化时，只需要修改实现该接口的类，而不需要修改其他使用该类的代码。</li>
<li><strong>接口委托</strong>：接口支持委托，一个接口可以通过另一个对象来实现其方法，这种方式称为接口委托。这种机制可以进一步提高代码的灵活性和可复用性。</li>
</ol>
<p>总的来说，接口是一种重要的编程工具，可以帮助程序员设计出更加灵活、可扩展和易于维护的代码结构。</p>
<p>interface接口</p>
<p>sealed class密封类</p>
<p><img src="/../images/image-20240429211327595.png" alt="image-20240429211327595"></p>
<p><code>companion object</code> 是 Kotlin 中的一个关键字，它用于创建一个伴随对象。伴随对象是类中的一个单例对象，可以通过类名直接访问其中的属性和方法</p>
<p>news_content_frag.xml——–&gt;NewsContentFragment类———–&gt;NewsContentActivity</p>
<p>news_item.xml——–&gt;news_title_frag.xml———&gt;NewsTitleFragment类———-&gt;</p>
<p>layout&#x2F;activity_main.xml——-&gt;单页模式;</p>
<p>NewsTitleFragment类————&gt;</p>
<p>​														layout-sw600dp&#x2F;activity_main.xml——–&gt;双页模式;</p>
<p>NewsContentFragment类——-&gt;</p>
<p>在NewsTitleFragment类中通过RecyclerView将新闻列表展示出来</p>
<p>在 Kotlin 中，<code>open</code> 关键字用于声明一个类、方法或属性是可以被继承或覆盖的。具体来说：</p>
<ul>
<li><strong>类（Class）</strong>：在类声明前加上 <code>open</code> 关键字，表示这个类是可以被其他类继承的。如果不加 <code>open</code> 关键字，则默认情况下类是 <code>final</code> 的，不能被继承。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">kotlin</span></span>
<span class="line"><span style="color: #babed8">open class BaseActivity : AppCompatActivity() &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 可以被继承的类</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><ul>
<li><strong>方法（Method）</strong>：在方法声明前加上 <code>open</code> 关键字，表示这个方法是可以被子类覆盖（重写）的。如果不加 <code>open</code> 关键字，则默认情况下方法是 <code>final</code> 的，不能被子类覆盖。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">kotlin</span></span>
<span class="line"><span style="color: #babed8">open fun someMethod() &#123;</span></span>
<span class="line"><span style="color: #babed8">    // 可以被子类重写的方法</span></span>
<span class="line"><span style="color: #babed8">&#125;</span></span></code></pre></div><ul>
<li><strong>属性（Property）</strong>：在属性声明前加上 <code>open</code> 关键字，表示这个属性是可以被子类覆盖的。如果不加 <code>open</code> 关键字，则默认情况下属性是 <code>final</code> 的，不能被子类覆盖。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">kotlin</span></span>
<span class="line"><span style="color: #babed8">open val someProperty: Int = 0</span></span></code></pre></div><p>使用 <code>open</code> 关键字可以让类的设计更加灵活，允许其他类继承并重写其中的方法，或者覆盖属性的行为。</p>
<p><code>val square: (Int) -&gt; Int = &#123; x: Int -&gt; x * x &#125;</code></p>
<p>square是(Int) -&gt; Int函数类型的变量，表示接受一个 <code>Int</code> 类型的参数，并返回一个 <code>Int</code> 类型的结果。</p>
<p>Lambda 表达式 <code>&#123; x: Int -&gt; x * x &#125;</code> 被赋给了这个变量</p>
<p><code>fun save(inputText: String) &#123;</code><br><code>try &#123;</code><br><code>val output = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE)</code><br><code>val writer = BufferedWriter(OutputStreamWriter(output))</code><br><code>writer.use &#123;</code><br><code>it.write(inputText)</code><br><code>&#125;</code><br><code>&#125; catch (e: IOException) &#123;</code><br><code>e.printStackTrace()</code><br><code>&#125;</code><br><code>&#125;</code></p>
<p>这段代码定义了一个名为 <code>save</code> 的函数，它接受一个 <code>inputText</code> 参数，类型为 <code>String</code>。函数的作用是将输入的文本内容保存到文件中。让我解释一下代码的逻辑：</p>
<ol>
<li><code>openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE)</code>: 这行代码打开一个名为 “data” 的文件，并返回一个 <code>FileOutputStream</code> 对象。这个文件将会存储在应用的内部存储空间中，因为使用了 <code>Context.MODE_PRIVATE</code> 参数，表示只有当前应用可以访问这个文件，并且会覆盖掉同名的文件（如果存在）。</li>
<li><code>val writer = BufferedWriter(OutputStreamWriter(output))</code>: 这行代码创建了一个 <code>BufferedWriter</code> 对象，并将其包装在一个 <code>OutputStreamWriter</code> 中，以便将文本写入到 <code>output</code> 中。</li>
<li><code>writer.use &#123; it.write(inputText) &#125;</code>: 这行代码使用 Kotlin 的 <code>use</code> 函数，确保在使用结束后正确关闭 <code>writer</code>，以释放资源。在 <code>use</code> 函数的 lambda 表达式中，调用了 <code>write</code> 方法，将 <code>inputText</code> 写入到文件中。</li>
<li><code>catch (e: IOException) &#123; e.printStackTrace() &#125;</code>: 这是一个异常处理块，如果在保存文件时发生了 <code>IOException</code> 异常，程序将会打印异常的堆栈信息。</li>
</ol>
<p>将委托功能分为了两种：类委托和委托属性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Android-Kotlin.html" data-id="clxbjvuxm000261cx1h1s1bu0" data-title="Android_Kotlin" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Inference-Framework" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Inference-Framework.html" class="article-date">
  <time class="dt-published" datetime="2024-04-13T09:01:40.000Z" itemprop="datePublished">2024-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Inference-Framework.html">Inference_Framework</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>PNNX<br>PNNX项目 PyTorch Neural Network eXchange（PNNX）是PyTorch模型互操作性的开放标准。PNNX为PyTorch提供了一种开源的模型格式，它定义了与Pytorch相匹配的数据流图和运算图，我们的框架在PNNX之上封装了一层更加易用和简单的计算图格式。pytorch训练好一个模型之后，然后模型需要转换到pnnx格式，然后pnnx格式我们再去读取，形成计算图.</p>
<p>pytorch到我们计算图？</p>
<p>PNNX帮我做了很多的图优化、算子融合的工作，所以底层的用它PNNX的话，我们可以吸收图优化的结果，后面推理更快.</p>
<p>但是不直接在项目中用PNNX，因为别人的工作和自己推理框架开发思路总是有不同的。所以在这上面封装，又快速又好用方便，符合自己的使用习惯。</p>
<p>我们只是去读取PNNX产物，然后构建自己一种易用的计算图结构。</p>
<p>产物：resnet18.pnnx.param PNNX graph definition 结构定义</p>
<p>resnet18.pnnx.bin PNNX model weight 权重</p>
<p>PNNX的格式定义:</p>
<p>PNNX由操作数operand(运算数)和operator(运算符号)，PNNX::Graph用来管理和操作这两者。</p>
<p>操作数(operand)，也可以通过操作数来方向访问到这个数字的产生者和使用者Customer</p>
<p>Operand有以下几个部分组成:</p>
<p>Producer: 类型是operator, 表示产生了这个操作数的运算符(operator). 也就是说这个操作数(operand)是Producer的输出. Producer这个操作符号产生了当前的Operand<br>Customer:类型是operator, 表示需要这个操作数下一个操作的的运算符(operator)，也就是说这个操作数(operand)作为Customer的输入存在.</p>
<p>Name: 类型是std::string, 表示这个操作数的名称.Values<br>Shape: 类型是std::vector<int> , 用来表示操作数的大小,</p>
<p><code>this</code>：指针，指向当前对象的地址。在类的成员函数中，<code>this</code>关键字指向当前对象。</p>
<p><code>-&gt;</code>：成员访问运算符，用来访问类的成员变量或成员函数。</p>
<p>在 C++11 中，使用 <code>new</code> 创建动态分配的对象并不安全，因为需要手动管理资源的释放，容易出现内存泄漏或者忘记释放资源导致的内存泄漏。为了更加安全和方便地管理动态分配的对象，C++11 引入了智能指针，其中 <code>std::unique_ptr</code> 是一种独占所有权的智能指针，它负责在对象不再需要时释放所占用的内存。</p>
<p>图（graph） 节点（vertex）  边（edge）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Inference-Framework.html" data-id="clxbjvuxp000961cxbv4a8nqq" data-title="Inference_Framework" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-电路Learning" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/%E7%94%B5%E8%B7%AFLearning.html" class="article-date">
  <time class="dt-published" datetime="2024-04-13T02:08:03.000Z" itemprop="datePublished">2024-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/%E7%94%B5%E8%B7%AFLearning.html">电路Learning</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/Screenshot_20240413_081729_com.able.wisdomtree_ed.jpg" alt="Screenshot_20240413_081729_com.able.wisdomtree_ed"></p>
<p><img src="/../images/IMG_20240413_100936-17129742375431.jpg" alt="IMG_20240413_100936"></p>
<p><img src="/../images/IMG_20240413_100941.jpg" alt="IMG_20240413_100941"></p>
<p>一阶电路三要素法：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/367671862">https://zhuanlan.zhihu.com/p/367671862</a></p>
<p>续流二极管的作用：当输入电压由变+VCC为0V时，三极管由饱和变为截止，这样继电器电感线圈中的电流突然失去了流通通路，若无续流二极管D将在线圈两端产生较大的反向电动势，极性为下正上负，电压值可达一百多伏，这个电压加上电源电压作用在三极管的集电极上足以损坏三极管。故续流二极管D的作用是将这个反向电动势通过图中箭头所指方向放电，使三极管集电极对地的电压最高不超过+VCC +0.7V。</p>
<p><img src="/../images/image-20240415081034319.png" alt="image-20240415081034319"></p>
<h1 id="桥式全波整流电路"><a href="#桥式全波整流电路" class="headerlink" title="桥式全波整流电路"></a>桥式全波整流电路</h1><p><img src="/../images/v2-53ff055afc53560a36d90954265d9cdd_720w.webp" alt="img"></p>
<p><img src="/../images/v2-ecfac816feb4eb7f7d63addbd5af0312_720w.webp" alt="img"></p>
<p><img src="/../images/v2-1fb0684d0ccd97010d40625037937ce6_r.jpg" alt="img"></p>
<p><img src="/../images/image-20240527141313565.png" alt="image-20240527141313565"></p>
<p><img src="/../images/image-20240527141401386.png" alt="image-20240527141401386"></p>
<p>衰减电阻网络需要搭配上电容来进行补偿是什么意思</p>
<p>在电子电路中，衰减电阻网络通常是指由电阻组成的网络，用于降低信号的电压或电流。而提到衰减电阻网络需要搭配电容来进行补偿，这通常是指在某些电路设计中，为了改善电路的性能，需要在不改变电路基本功能的前提下，通过添加电容元件来修正或改善电路的某些特性。<br>补偿电容的作用可能包括：</p>
<ol>
<li>改善频率响应：在某些电路中，电阻网络可能会引入一定的相位偏移，导致电路在高频工作时性能变差。添加电容可以补偿这种相位偏移，从而改善电路的带宽和频率响应。</li>
<li>减少噪声：电容可以起到滤波的作用，减少电路中的噪声成分，使输出信号更干净。</li>
<li>改善稳定性：在某些电路中，电容可以用来改善系统的稳定性，例如在反馈电路中，适当的电容值可以帮助电路更快地稳定在工作点。</li>
<li>消除振荡：如果电路中存在不需要的振荡，适当的电容值可以用来消除这些振荡。</li>
<li>定时作用：在某些振荡电路中，电容与电阻配合使用，可以决定振荡频率。<br>补偿电容的值和位置需要根据具体的电路设计和所需的性能来确定。通常，电路设计者会根据电路的频率特性、相位特性以及所需的带宽等因素来选择合适的电容类型和值。</li>
</ol>
<p>为什么添加电容可以补偿这种相位偏移</p>
<p>在电路中，电阻和电容都会引入相位偏移。电阻器的相位偏移通常与频率成正比，而电容器则与频率成反比.为了补偿这种相位偏移，电路设计者会在电路中添加电容器，以便在高频应用中提供额外的相位移动，从而抵消电阻引起的相位偏移。通过这种方式，电路可以在整个频率范围内保持稳定的相位响应，从而提高电路的整体性能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/%E7%94%B5%E8%B7%AFLearning.html" data-id="clxbjvuxt000o61cx0c6p3qb1" data-title="电路Learning" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pcl" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/pcl.html" class="article-date">
  <time class="dt-published" datetime="2024-01-31T02:04:42.000Z" itemprop="datePublished">2024-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/pcl.html">pcl</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>&#96;&#96;c make -DCMAKE_BUILD_TYPE&#x3D;None `<br>      <code>-DCMAKE_INSTALL_PREFIX=/home/zgh/pcl_1.9.1_compile \</code><br>      <code>-DBUILD_GPU=ON \</code><br>      <code>-DBUILD_apps=ON \</code><br>      <code>-DBUILD_examples=ON</code></p>
<p><code>-DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-12.2 \</code></p>
<p><code>-DCUDA_ARCH_BIN=8.6 \</code></p>
<p><code>-DCUDA_ARCH_PTX=8.6 ..</code></p>
<div class="language-cmake"><button title="Copy code" class="copy"></button><span class="lang">cmake</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #89DDFF">  if</span><span style="color: #BABED8">(</span><span style="color: #89DDFF">NOT</span><span style="color: #BABED8"> $&#123;CUDA_VERSION_STRING&#125; </span><span style="color: #89DDFF">VERSION_LESS</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">&quot;10.0&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">    set</span><span style="color: #BABED8">(__cuda_arch_bin </span><span style="color: #C3E88D">&quot;3.0 3.5 5.0 5.2 5.3 6.0 6.1 7.0 7.2 7.5&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">  elseif</span><span style="color: #BABED8">(</span><span style="color: #89DDFF">NOT</span><span style="color: #BABED8"> $&#123;CUDA_VERSION_STRING&#125; </span><span style="color: #89DDFF">VERSION_LESS</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">&quot;9.1&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">    set</span><span style="color: #BABED8">(__cuda_arch_bin </span><span style="color: #C3E88D">&quot;3.0 3.5 5.0 5.2 5.3 6.0 6.1 7.0 7.2&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">  elseif</span><span style="color: #BABED8">(</span><span style="color: #89DDFF">NOT</span><span style="color: #BABED8"> $&#123;CUDA_VERSION_STRING&#125; </span><span style="color: #89DDFF">VERSION_LESS</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">&quot;9.0&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">    set</span><span style="color: #BABED8">(__cuda_arch_bin </span><span style="color: #C3E88D">&quot;3.0 3.5 5.0 5.2 5.3 6.0 6.1 7.0&quot;</span><span style="color: #BABED8">)  </span></span>
<span class="line"><span style="color: #89DDFF">  elseif</span><span style="color: #BABED8">(</span><span style="color: #89DDFF">NOT</span><span style="color: #BABED8"> $&#123;CUDA_VERSION_STRING&#125; </span><span style="color: #89DDFF">VERSION_LESS</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">&quot;8.0&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">    set</span><span style="color: #BABED8">(__cuda_arch_bin </span><span style="color: #C3E88D">&quot;2.0 2.1(2.0) 3.0 3.5 5.0 5.2 5.3 6.0 6.1&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">  elseif</span><span style="color: #BABED8">(</span><span style="color: #89DDFF">NOT</span><span style="color: #BABED8"> $&#123;CUDA_VERSION_STRING&#125; </span><span style="color: #89DDFF">VERSION_LESS</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">&quot;6.5&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">    set</span><span style="color: #BABED8">(__cuda_arch_bin </span><span style="color: #C3E88D">&quot;2.0 2.1(2.0) 3.0 3.5 5.0 5.2&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">  elseif</span><span style="color: #BABED8">(</span><span style="color: #89DDFF">NOT</span><span style="color: #BABED8"> $&#123;CUDA_VERSION_STRING&#125; </span><span style="color: #89DDFF">VERSION_LESS</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">&quot;6.0&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">    set</span><span style="color: #BABED8">(__cuda_arch_bin </span><span style="color: #C3E88D">&quot;2.0 2.1(2.0) 3.0 3.5 5.0&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">  elseif</span><span style="color: #BABED8">(</span><span style="color: #89DDFF">NOT</span><span style="color: #BABED8"> $&#123;CUDA_VERSION_STRING&#125; </span><span style="color: #89DDFF">VERSION_LESS</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">&quot;5.0&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">    set</span><span style="color: #BABED8">(__cuda_arch_bin </span><span style="color: #C3E88D">&quot;2.0 2.1(2.0) 3.0 3.5&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">  elseif</span><span style="color: #BABED8">($&#123;CUDA_VERSION_STRING&#125; </span><span style="color: #89DDFF">VERSION_GREATER</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">&quot;4.1&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">    set</span><span style="color: #BABED8">(__cuda_arch_bin </span><span style="color: #C3E88D">&quot;2.0 2.1(2.0) 3.0&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">  else</span><span style="color: #BABED8">()</span></span>
<span class="line"><span style="color: #89DDFF">    set</span><span style="color: #BABED8">(__cuda_arch_bin </span><span style="color: #C3E88D">&quot;2.0 2.1(2.0)&quot;</span><span style="color: #BABED8">)</span></span>
<span class="line"><span style="color: #89DDFF">  endif</span><span style="color: #BABED8">()</span></span></code></pre></div><p>NXHAY2OW76-eyJsaWNlbnNlSWQiOiJOWEhBWTJPVzc2IiwibGljZW5zZWVOYW1lIjoiSHVuYW4gSW5zdGl0dXRlIG9mIFNjaWVuY2UgYW5kIFRlY2hub2xvZ3kiLCJsaWNlbnNlZVR5cGUiOiJDTEFTU1JPT00iLCJhc3NpZ25lZU5hbWUiOiJ0bXUgaXRtYW5hZ2VyIiwiYXNzaWduZWVFbWFpbCI6InRtdWl0bWFuYWdlckBvdXRsb29rLmNvbSIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU0MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRTIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNWIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQU0kiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUENXTVAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiRFAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjMxMTA5TFBBQTAwOTAwNyIsImhhc2giOiI0MjU0OTY3OS8xMzU2NTA1OTotNDU5NTIyNTciLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwidHJpYWwiOmZhbHNlLCJhaUFsbG93ZWQiOnRydWV9-t3Mcnh+cc&#x2F;DF5z54xXxQ1wh2DTHULDDp0xl9P1s3jRugff7MKaHhYu8MFuKB8smfDaUysLfs94WjunQJeCc4L&#x2F;gMi024G9o&#x2F;O2yBx4&#x2F;Ho9yU7SeYOvnuMqPwwpczR&#x2F;U2JcIZAhH9YPdOo5E7CEtPEW5cq774wN7MrXnHK+LPN6uE4asZ&#x2F;Qk3g3TyqpD3R7ubTmtkAx8JF6iWrezyLNngezgq3NkSE+3LZFuOLep6EKsOJeuaPCKD1uSFJZK7yzUkcLq+H&#x2F;AZDOPZ+Gk9ZTl+P8TlRw3DIA1WDMORmycx5Q4mG+y2cNJoj9r0gfZPiw8OcmcQI8icyF2yTLnWOopRUg&#x3D;&#x3D;-MIIETDCCAjSgAwIBAgIBDzANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMTAxMDE2MDU0NFoXDTI0MTAxMTE2MDU0NFowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMjEwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC&#x2F;W3uCpU5M2y48rUR&#x2F;3fFR6y4xj1nOm3rIuGp2brELVGzdgK2BezjnDXpAxVDw5657hBkAUMoyByiDs2MgmVi9IcqdAwpk988&#x2F;Daaajq9xuU1of59jH9eQ9c3BmsEtdA4boN3VpenYKATwmpKYkJKVc07ZKoXL6kSyZuF7Jq7HoQZcclChbF75QJPGbri3cw9vDk&#x2F;e46kuzfwpGftvl6+vKibpInO6Dv0ocwImDbOutyZC7E+BwpEm1TJZW4XovMBegHhWC04cJvpH1u98xoR94ichw0jKhdppywARe43rGU96163RckIuFmFDQKZV9SMUrwpQFu4Z2D5yTNqnlLRfAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQU5FZqQ4gnVc+inIeZF+o3ID+VhcEwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBANLG1anEKid4W87vQkqWaQTkRtFKJ2GFtBeMhvLhIyM6Cg3FdQnMZr0qr9mlV0w289pf&#x2F;+M14J7S7SgsfwxMJvFbw9gZlwHvhBl24N349GuthshGO9P9eKmNPgyTJzTtw6FedXrrHV99nC7spaY84e+DqfHGYOzMJDrg8xHDYLLHk5Q2z5TlrztXMbtLhjPKrc2+ZajFFshgE5eowfkutSYxeX8uA5czFNT1ZxmDwX1KIelbqhh6XkMQFJui8v8Eo396&#x2F;sN3RAQSfvBd7Syhch2vlaMP4FAB11AlMKO2x&#x2F;1hoKiHBU3oU3OKRTfoUTfy1uH3T+t03k1Qkr0dqgHLxiv6QU5WrarR9tx&#x2F;dapqbsSmrYapmJ7S5+ghc4FTWxXJB1cjJRh3X+gwJIHjOVW+5ZVqXTG2s2Jwi2daDt6XYeigxgL2SlQpeL5kvXNCcuSJurJVcRZFYUkzVv85XfDauqGxYqaehPcK2TzmcXOUWPfxQxLJd2TrqSiO+mseqqkNTb3ZDiYS&#x2F;ZqdQoGYIUwJqXo+EDgqlmuWUhkWwCkyo4rtTZeAj+nP00v3n8JmXtO30Fip+lxpfsVR3tO1hk4Vi2kmVjXyRkW2G7D7WAVt+91ahFoSeRWlKyb4KcvGvwUaa43fWLem2hyI4di2pZdr3fcYJ3xvL5ejL3m14bKsfoOv</p>
<p><code>pcl::PointCloud</code> 和 <code>pcl::PCLPointCloud2</code> 是 PCL 中两种不同的点云数据结构，它们之间的主要区别在于数据的组织形式和灵活性：</p>
<ol>
<li><code>pcl::PointCloud</code>：<ul>
<li><code>pcl::PointCloud</code> 是 PCL 中用于表示点云的模板类。</li>
<li>它是一种比较高级的数据结构，已经预定义了点云中每个点的字段（如坐标、法向量等）以及数据类型（如PointXYZ、Normal等）。</li>
<li>使用 <code>pcl::PointCloud</code> 可以更方便地访问和处理点云数据，因为它提供了成员函数来操作点云中的点，如添加、删除、修改等操作。</li>
</ul>
</li>
<li><code>pcl::PCLPointCloud2</code>：<ul>
<li><code>pcl::PCLPointCloud2</code> 是 PCL 中用于表示点云的更底层、更通用的数据结构。</li>
<li>它是一种更灵活的数据结构，可以容纳任意类型和数量的字段，适合表示各种形式的点云数据。</li>
<li>使用 <code>pcl::PCLPointCloud2</code> 需要通过字段的偏移量和数据类型来手动解析和访问点云数据，相对复杂一些。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>pcl::PointCloud</code> 更适合处理已知结构和类型的点云数据，而 <code>pcl::PCLPointCloud2</code> 则更适合处理未知结构或需要更大灵活性的点云数据。在实际应用中，根据具体需求选择合适的数据结构进行点云数据的处理和操作。</p>
<p><code>std::cerr</code> 通常用于输出程序运行时的错误信息、警告信息等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/pcl.html" data-id="clxbjvuxr000i61cx5be7h30f" data-title="pcl" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Embedded" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Embedded.html" class="article-date">
  <time class="dt-published" datetime="2023-12-25T00:29:56.000Z" itemprop="datePublished">2023-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Embedded.html">Embedded</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>为什么原理图里的stm32f4的VCAP1引脚要接一个4.7微法的电容，再接地呢</p>
<p>2023&#x2F;12&#x2F;25 08:23:32</p>
<p>STM32F4芯片的VCAP1引脚是芯片内部电容的引出端，用于连接外部电容以提供给芯片内部振荡电路使用。在使用高速外设时，由于这些外设需要非常稳定的电源供应，因此需要在VCAP1引脚与地之间连接一个电容来提高芯片的稳定性。</p>
<p>具体来说，连接4.7微法的电容可以起到平滑电压、提高电源噪声抑制能力等作用，从而提高芯片的工作稳定性和可靠性。此外，需要注意电容的选型要符合芯片手册的要求，不能超出规定的范围。</p>
<p>2023&#x2F;12&#x2F;25 08:26:15<br>芯片内部还有电容吗</p>
<p>2023&#x2F;12&#x2F;25 08:26:20</p>
<p>是的，芯片内部通常会包含一些电容。这些内部电容主要用于稳定芯片的电源供应和进行滤波。它们的作用包括：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">电源滤波：在芯片内部集成了一些小型电容器，用于过滤电源中的噪声和干扰，确保芯片正常运行所需的电源干净和稳定。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">芯片电源稳定：芯片内部可能还包含一些供电相关的电容，用于提供瞬态响应和电源稳定性，以确保芯片在各种工作条件下都能正常工作。</span></span></code></pre></div><p>这些内部电容一般由芯片制造商在设计阶段根据具体需求添加，并在芯片手册或参考设计中进行了详细说明。在使用芯片时，我们不需要特别处理这些内部电容，只需按照芯片手册的要求合理连接外部电容即可。</p>
<p>2023&#x2F;12&#x2F;25 08:26:41<br>那为什么还要连接外部电容</p>
<p>2023&#x2F;12&#x2F;25 08:26:48</p>
<p>连接外部电容主要是为了进一步提高芯片的电源稳定性和抑制电磁干扰。虽然芯片内部已经包含了一些电容，但这些电容的容值较小且位置相对固定，可能无法满足某些特殊应用或高要求的电源稳定性。</p>
<p>通过在VCAP1引脚与地之间连接外部电容，可以实现以下效果：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">改善电源噪声抑制能力：外部电容可以提供更大的容值，能够更好地滤除电源中的高频噪声和纹波，从而提供更稳定的电源供应。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">提供额外的瞬态响应：外部电容能够快速响应芯片工作状态的变化，提供更好的瞬态响应能力，尤其在高速外设工作时，可以提供更稳定的电源给这些外设。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">抑制电磁干扰：外部电容能够帮助减少电源线上的电磁辐射和接收到的外界干扰信号，提高系统的抗干扰能力，保证芯片的正常运行。</span></span></code></pre></div><p>需要注意的是，具体的外部电容选型和连接方式应根据芯片厂商提供的参考设计或芯片手册的建议进行，以确保电路的稳定性和可靠性。</p>
<p><img src="/../images/v2-85bf2c8a1398bd5c9772b759d44c6725_r.jpg" alt="img"></p>
<p><img src="/../images/image-20231228133639969.png" alt="image-20231228133639969"></p>
<p><img src="/../images/image-20231228133811569.png" alt="image-20231228133811569">配置通道    具有检测正反插…..等</p>
<p><img src="/../images/image-20231228134014238.png" alt="image-20231228134014238"></p>
<p>边带使用实现…..</p>
<p><img src="/../images/image-20231228134605423.png" alt="image-20231228134605423"></p>
<p><img src="/../images/image-20231228134230069.png" alt="image-20231228134230069"></p>
<p><img src="/../images/image-20231228134310310.png" alt="image-20231228134310310"></p>
<p><img src="/../images/image-20231228142350256.png" alt="image-20231228142350256"></p>
<p><img src="/../images/image-20231228142627629.png" alt="image-20231228142627629"></p>
<p><img src="/../images/image-20231228142731948.png" alt="image-20231228142731948">OSC32IN引脚，用于连接外部低速晶体振荡器（32.768 kHz）。这种振荡器通常用于实时时钟（RTC)的时基。</p>
<p>OSC_IN引脚，用于连接外部高速晶体振荡器（通常在4 MHz到26 MHz之间）。这种振荡器通常用于系统时钟（SYSCLK）的时基。</p>
<p>VBAT代表电池供电引脚（Voltage Battery）。VBAT引脚用于连接外部备用电池，通常是一个小型电池，以提供芯片的备份电源。</p>
<p>VCAP1是指STM32系列芯片上的一个电容滤波器引脚，用于为芯片内部提供稳定的电源环境<br>,用于去除芯片电源中的高频噪声和波动。</p>
<p><img src="/../images/image-20240102113359669.png" alt="image-20240102113359669"></p>
<p><img src="/../images/image-20240102144257554.png" alt="image-20240102144257554">在电路设计中，加入0欧电阻（也称为短接电阻）有以下几个常见的目的：</p>
<ol>
<li>电路连接：0欧电阻可以作为电路的连接点，将不同信号线或电源线连接在一起。它可以提供良好的电气连接，并保持信号或电流的连续性。</li>
<li>信号分配：在复杂的电路板上，使用0欧电阻可以方便地将信号线分配到不同的位置。通过添加或移除0欧电阻，可以改变信号路径，以满足电路的布局要求。</li>
<li>调试和测试：在调试和测试电路时，加入0欧电阻可以方便地连接测试仪器或测量点。它可以用作测试点或测量点的连接线，以便在需要时轻松接入测试设备。</li>
<li>阻抗匹配：在高频电路设计中，0欧电阻可以用于阻抗匹配。通过选择适当的阻值，可以使电路中的阻抗更好地匹配，以最大限度地传输信号或功率。</li>
</ol>
<p>需要注意的是，加入0欧电阻并不会引入电阻本身的阻尼效应。它的主要作用是提供连接和分配功能，而不会对电路的整体电性能产生实质性的影响。</p>
<p><img src="/../images/image-20240103170615099.png" alt="image-20240103170615099"></p>
<p>TPS3823-33DBVR的MR引脚是干什么的</p>
<p>1&#x2F;3&#x2F;2024, 5:11:40 PM</p>
<p>TPS3823-33DBVR是一款超低功耗、微型化的复位监测器。MR引脚是器件的主复位引脚，用于手动地对器件进行复位操作。</p>
<p>当MR引脚被拉低时，TPS3823-33DBVR会立即进行复位操作，并将RST引脚拉低，使被监测的系统或芯片得到重新启动。此外，当MR引脚保持低电平时，TPS3823-33DBVR将始终保持在复位状态，直到MR引脚上升到高电平。</p>
<p>需要注意的是，MR引脚应该在正常工作时保持高电平，并通过一个合适的电阻接到正电源。当需要手动复位时，可以通过连接一个按钮或开关来将MR引脚拉低，从而触发复位操作。</p>
<p>总之，TPS3823-33DBVR的MR引脚是用于手动复位操作的引脚，当MR引脚被拉低时，TPS3823-33DBVR会进行复位操作，从而实现对被监测系统或芯片的重新启动。</p>
<p>1&#x2F;3&#x2F;2024, 5:12:51 PM</p>
<p>TPS3823-33DBVR的WDI引脚是干什么的</p>
<p>1&#x2F;3&#x2F;2024, 5:13:13 PM</p>
<p>TPS3823-33DBVR的WDI引脚是用于喂狗定时器（Watchdog Timer）的输入引脚。</p>
<p>喂狗定时器是一种用于监控系统运行状态的计时器。它需要周期性地接收一个喂狗脉冲来防止系统出现故障或死锁。如果在一定的时间内没有接收到喂狗脉冲，喂狗定时器会触发复位操作，使被监控的系统重新启动。</p>
<p>在TPS3823-33DBVR中，WDI引脚用于接收外部喂狗脉冲。当WDI引脚接收到一个高电平脉冲时，喂狗定时器会被重置，系统继续正常运行。如果在一定时间内未接收到喂狗脉冲，喂狗定时器将超时，并触发复位操作。</p>
<p>通过连接一个外部的喂狗脉冲源（例如微处理器的GPIO引脚），可以周期性地向TPS3823-33DBVR的WDI引脚提供喂狗脉冲。这样可以确保系统持续运行，并在出现故障或死锁时进行自动复位，提高系统的可靠性和稳定性。</p>
<p>总之，TPS3823-33DBVR的WDI引脚用于接收外部喂狗脉冲，用于喂狗定时器的重置操作，以确保系统正常运行并防止故障或死锁。</p>
<p>MPU6050<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52251819/article/details/134957492">https://blog.csdn.net/qq_52251819/article/details/134957492</a></p>
<p><img src="/../images/image-20240103191542473.png" alt="image-20240103191542473"></p>
<p>AHT21</p>
<p><img src="/../images/image-20240103193207567.png" alt="image-20240103193207567"></p>
<p>Vdd_IO和Vdd是两个不同的电源引脚，常见于集成电路或芯片中。</p>
<ol>
<li>Vdd（也称为Vcc）是供电引脚，用于提供主要的电源电压给芯片或集成电路的内部电路。它通常连接到正电源（例如+3.3V或+5V），以供应芯片内部的数字和模拟电路。</li>
<li>Vdd_IO（也称为Vcc_IO或VddIO）是IO供电引脚，用于提供给输入输出（IO）电路的电源电压。它通常连接到较低的电压（例如+1.8V或+3.3V），用于驱动芯片的输入和输出引脚。</li>
</ol>
<p>区别：</p>
<ul>
<li>功能：Vdd提供整个芯片的电源，包括内部逻辑、处理器核心等。Vdd_IO则专门提供给IO电路使用。</li>
<li>电压级别：Vdd通常连接到较高的电压，而Vdd_IO连接到较低的电压。这是为了在现代集成电路中实现低功耗设计和电压兼容性。</li>
</ul>
<p>在 STM32 HAL 库中，xx_MspInit() 和 xx_Init() 函数是针对特定外设的初始化函数。</p>
<ol>
<li><strong>xx_MspInit() 函数</strong>：该函数是外设的底层初始化函数，用于配置外设的时钟、引脚、中断等底层硬件资源。”xx” 是指特定外设的前缀，例如 GPIO、USART、SPI 等。xx_MspInit() 通常在应用程序初始化之前调用，主要目的是配置外设所需的底层硬件资源。</li>
<li><strong>xx_Init() 函数</strong>：该函数是外设的高层初始化函数，用于配置外设的工作模式、时钟频率、中断优先级等高层参数。它会调用底层的 xx_MspInit() 函数来初始化底层硬件资源，并进行一些高层配置。xx_Init() 通常在应用程序初始化阶段调用，用于配置外设的工作模式和参数。</li>
</ol>
<p>HAL_ADC_ConfigChannel()是ADC常规通道配置，一次配置一个通道</p>
<p>HAL_ADC_PollForConversion()是轮询方式等待ADC常规通道转换完成</p>
<p>HAL_ADC_GetValue()读取常规通道转换结果寄存器的数据</p>
<p>HAL_ADC_Start（）以软件方式启动ADC常规转换的通道，然后调用HAL_ADC_PollForConversion()来查询转换是否完成，如果转换完成，使用HAL_ADC_GetValue()读出常规结果寄存器的32位数据</p>
<p>stm32是32位的，所以指针总是32位的</p>
<p><img src="/../images/image-20240322130525454.png" alt="image-20240322130525454"></p>
<p>![(..&#x2F;images&#x2F;image-20240322125751723.png)<img src="/../images/image-20240322130023148.png" alt="image-20240322130023148"></p>
<p><img src="/../images/image-20240322130246888.png" alt="image-20240322130246888"></p>
<p><img src="/../images/image-20240322130635769.png" alt="image-20240322130635769"><img src="/../images/image-20240322195132792.png" alt="image-20240322195132792"></p>
<p><strong>工作模式：</strong></p>
<p><img src="/../images/image-20240322195540298.png" alt="image-20240322195540298"></p>
<p><strong>低功耗模式：</strong></p>
<p><img src="/../images/image-20240322195836292.png" alt="image-20240322195836292"></p>
<p><img src="/../images/image-20240322200333679.png" alt="image-20240322200333679"><img src="/../images/image-20240323090001811.png" alt="image-20240323090001811"></p>
<p>stm32的SPI的Clock Phase(CPHA)设置为2 Edge是什么意思</p>
<p>2024&#x2F;3&#x2F;23 14:29:32</p>
<p>在 STM32 微控制器的 SPI（Serial Peripheral Interface）模块中，Clock Phase（时钟相位，通常用 CPHA 表示）参数用于定义数据采样的时机。当设置为 2 Edge 时，表示数据采样会在时钟的第二个边缘上进行。</p>
<p>在 SPI 通信中，数据传输的时机是由时钟信号决定的。CPHA 参数定义了数据采样的时机相对于时钟信号的边缘。具体来说，CPHA 可以设置为 0 或 1，分别表示：</p>
<ul>
<li>CPHA &#x3D; 0：数据在时钟信号的第一个边缘上进行采样。也就是说，在时钟信号的上升沿或下降沿（取决于时钟极性）开始时采样数据。</li>
<li>CPHA &#x3D; 1：数据在时钟信号的第二个边缘上进行采样。也就是说，在时钟信号的另一个沿（与上升沿或下降沿相反的沿）上采样数据。</li>
</ul>
<p>因此，当将 SPI 的 CPHA 参数设置为 2 Edge 时，表示数据采样会在时钟的第二个边缘上进行，这种设置通常用于特定的 SPI 设备或者通信协议要求，确保数据的正确采样和传输。在实际应用中，需要根据外设设备的要求和通信协议的规范来选择合适的 CPHA 设置，以确保 SPI 数据传输的准确性和稳定性。</p>
<p><img src="/../images/image-20240324102428755.png" alt="image-20240324102428755"><img src="/../images/image-20240324102801798.png" alt="image-20240324102801798"></p>
<p><img src="/../images/image-20240324103200416.png" alt="image-20240324103200416"><img src="/../images/image-20240324103611561.png" alt="image-20240324103611561"><img src="/../images/image-20240324103705403.png" alt="image-20240324103705403"></p>
<p><strong>不使用预装载，设置的新ARR的值立即生效</strong></p>
<p><strong>使用，会在下一个UEV事件生效</strong></p>
<p><strong>PWM波</strong>：</p>
<p><img src="/../images/image-20240324105850607.png" alt="image-20240324105850607"></p>
<p><img src="/../images/image-20240324110915173.png" alt="image-20240324110915173"><img src="/../images/image-20240324115944131.png" alt="image-20240324115944131"></p>
<div class="language-c"><button title="Copy code" class="copy"></button><span class="lang">c</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #82AAFF">HAL_TIM_IC_CaptureCallback</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">htim</span><span style="color: #89DDFF">);</span></span>
<span class="line"><span style="color: #82AAFF">HAL_TIM_OC_DelayElapsedCallback</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">htim</span><span style="color: #89DDFF">);</span></span>
<span class="line"><span style="color: #82AAFF">HAL_TIM_PWM_PulseFinishedCallback</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">htim</span><span style="color: #89DDFF">);</span></span>
<span class="line"><span style="color: #82AAFF">HAL_TIM_PeriodElapsedCallback</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">htim</span><span style="color: #89DDFF">);</span></span>
<span class="line"><span style="color: #82AAFF">HAL_TIM_TriggerCallback</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">htim</span><span style="color: #89DDFF">);</span></span>
<span class="line"><span style="color: #82AAFF">HAL_TIMEx_CommutCallback</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">htim</span><span style="color: #89DDFF">);</span></span></code></pre></div><p><img src="/../images/image-20240324143451922.png" alt="image-20240324143451922"><img src="/../images/image-20240324160106485.png" alt="image-20240324160106485"></p>
<p><img src="/../images/image-20240328093523112.png" alt="image-20240328093523112"></p>
<p>mpu_prototypes.h</p>
<p>mpu_wrappers.h内存保护单元 ,内存保护单元(memory protection unit)，简称：MPU,使用MPU可以设置不同存储区域的存储访问特性（如只支持特权访问或全访问）和存储器属性（如可缓存、可共享），从而提高嵌入式系统的健壮性，使系统更加安全。优先执行mpu_prototypes.h,mpu_wrappers.h里的函数</p>
<p><img src="/../images/image-20240410131546745.png" alt="image-20240410131546745"></p>
<p><img src="/../images/image-20240410131717234.png" alt="image-20240410131717234"></p>
<p><img src="/../images/image-20240410141116783.png" alt="image-20240410141116783"></p>
<p><img src="/../images/image-20240410142357998.png" alt="image-20240410142357998"></p>
<p>MPU：内存保护单元</p>
<p>FPU：浮点数单元</p>
<p>钩子函数类似于回调函数</p>
<p><img src="/../images/image-20240410171152068.png" alt="image-20240410171152068"></p>
<p><img src="/../images/image-20240410171607710.png" alt="image-20240410171607710"></p>
<p><img src="/../images/image-20240410171723221.png" alt="image-20240410171723221"></p>
<p>  <img src="/../images/image-20240410172152947.png" alt="image-20240410172152947"></p>
<p><img src="/../images/image-20240411090500199.png" alt="image-20240411090500199"></p>
<p><img src="/../images/image-20240411090745706.png" alt="image-20240411090745706"></p>
<p>freertos中任何时候都要有一个任务占用CPU，所以就有了空闲任务</p>
<p>systick只有定时中断功能，1ms中断一次</p>
<p>systick定时器不仅可以产生滴答信号，还可以产生任务切换申请</p>
<p><img src="/../images/image-20240411092035829.png" alt="image-20240411092035829"></p>
<p><img src="/../images/image-20240411092600517.png" alt="image-20240411092600517"></p>
<p>所以：Freertos的任务优先级总是低于系统中断的优先级</p>
<p><img src="/../images/image-20240414171100213.png" alt="image-20240414171100213"></p>
<p><img src="/../images/image-20240414172301612.png" alt="image-20240414172301612"></p>
<p>xTaskCreate()创建一个任务，以动态方式来分配内存</p>
<p>xTaskCreateStatic()</p>
<p>vTaskDelete()可以删除当前任务或者另一个任务</p>
<p>vTaskSuspend()可以挂起当前任务或者另一个任务</p>
<p>vTaskResume()恢复另一个挂起的任务的运行</p>
<p>调度器管理的函数：<br>vTaskStartScheduler()开启任务调度器</p>
<p>vTaskSuspendAll()挂起任务调度器，但是不禁用中断，调度器被挂起后，不再进行上下文切换</p>
<p>vTaskResumeAll()恢复调度器的执行，但是不会恢复vTaskSuspend()单独挂起的任务</p>
<p>延时和调度的函数：</p>
<p>中央对齐模式下：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">RCR = 0，更新事件没有延迟；</span></span>
<span class="line"><span style="color: #babed8">RCR = 1，更新事件延后了半个PWM周期；</span></span>
<span class="line"><span style="color: #babed8">RCR = 2, 更新事件延后了一个PWM周期；</span></span>
<span class="line"><span style="color: #babed8">RCR = 3，更新事件延后了 3 2 \cfrac&#123;3&#125;&#123;2&#125; 23个PWM周期；</span></span></code></pre></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Embedded.html" data-id="clxbjvuxn000461cxcnid2q3p" data-title="Embedded" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Esp32" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Esp32.html" class="article-date">
  <time class="dt-published" datetime="2023-12-20T08:57:19.000Z" itemprop="datePublished">2023-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Esp32.html">Esp32</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20231220165744944.png" alt="image-20231220165744944"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Esp32.html" data-id="clxbjvuxn000561cx1s3tboj4" data-title="Esp32" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/esp32/" rel="tag">esp32</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-yolov5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/yolov5.html" class="article-date">
  <time class="dt-published" datetime="2023-12-16T12:04:59.000Z" itemprop="datePublished">2023-12-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/yolov5.html">yolov5</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20231216210026711.png" alt="image-20231216210026711"></p>
<p><img src="/../images/image-20231216210245075.png" alt="image-20231216210245075"></p>
<h4 id="IOU-—-交并比"><a href="#IOU-—-交并比" class="headerlink" title="IOU —-交并比"></a>IOU —-交并比</h4><p><img src="/../images/image-20231216210441830.png" alt="image-20231216210441830"></p>
<p>Lou为1意味着预测边界框和地面真实边界框完全重叠。<br>您可以为LOU设置阈值，以确定对象检测是否有效。<br>假设您将LOU设置为0.5，在这种情况下。<br>·如果LOU≥为0.5，则将目标检测归类为真阳性(TP)。<br>如果LOU&lt;0.5，则为错误检测，并将其归类为假阳性(FP)。<br>当图像中存在地面真实且模型未能检测到目标时，分类。<br>作为假阴性(FN)。<br>真负片(TN)：TN是我们没有预测到物体的图像的每一部分。<br>度量对于目标检测没有用处，因此我们忽略TN。</p>
<p><img src="/../images/image-20231216210636311.png" alt="image-20231216210636311"></p>
<h4 id="AP-MAP"><a href="#AP-MAP" class="headerlink" title="AP,MAP"></a>AP,MAP</h4><p><img src="/../images/image-20231216210923498.png" alt="image-20231216210923498"></p>
<p><img src="/../images/image-20231216211711468.png" alt="image-20231216211711468"></p>
<p><img src="/../images/image-20231216211921852.png" alt="image-20231216211921852"></p>
<p><img src="/../images/image-20231216204704657.png" alt="image-20231216204704657">   </p>
<p><img src="/../images/image-20231216204353728.png" alt="image-20231216204353728"> </p>
<h4 id="网络架构和组件"><a href="#网络架构和组件" class="headerlink" title="网络架构和组件"></a>网络架构和组件</h4><p>单阶段检测器：</p>
<p><img src="/../images/image-20231216205751067.png" alt="image-20231216205751067"></p>
<p>yolov5：（没有划出专门的颈部Neck）</p>
<p><img src="/../images/image-20231216212300844.png" alt="image-20231216212300844"></p>
<p>git clone <a target="_blank" rel="noopener" href="https://github.moeyy.xyz/https://github.com/ultralytics/yolov5.git">https://github.moeyy.xyz/https://github.com/ultralytics/yolov5.git</a></p>
<p><img src="/../images/image-20231217123703969.png" alt="image-20231217123703969"></p>
<ol>
<li><code>nc: 80</code>：这个参数表示模型分类数量（number of classes），默认为 80，对应着 COCO 数据集。</li>
<li><code>depth_multiple: 0.33</code>：这个参数表示模型深度相对于基础版本的倍数。在 YOLOv5 中，有 S、M、L 和 X 四个版本，其中 S 为基础版本，即 <code>depth_multiple: 1.0</code>，而 M、L 和 X 版本为在此基础上分别加深了一定的层数。而 <code>depth_multiple: 0.33</code> 表示在 S 版本的基础上，深度缩小了 3 倍，即变成了 <code>depth_multiple: 0.33</code> × 3 &#x3D; 0.99。</li>
<li><code>width_multiple: 0.50</code>：这个参数表示模型通道宽度相对于基础版本的倍数。与 <code>depth_multiple</code> 类似，S 版本的 <code>width_multiple</code> 是 1.0，而 M、L 和 X 版本则在此基础上分别扩大了一定的倍数。</li>
<li><code>anchors</code>：这是一个锚点数组，用于定义不同尺度下的 anchor boxes。YOLOv5 中使用了三个不同的尺度，每个尺度使用三个不同的 anchor boxes。这些锚点大小是相对于输入图像的，因此不同尺度下的大小会有所差别。</li>
<li><code>backbone</code>：这一部分定义了模型的骨干网络（backbone），包括卷积层、批归一化层和激活函数等。YOLOv5 使用了 CSPDarknet53 这个网络作为基础骨干网络，并在此基础上进行改进。具体而言，YOLOv5 增加了空间注意力机制和SPP模块，以增强特征表达能力。</li>
<li><code>head</code>：这一部分定义了模型的检测头（detection head），包括检测网络和分类网络。YOLOv5 中的检测网络采用了YOLOv3中的FPN结构，并在此基础上加入了PANet模块和SAM模块，以提高检测性能。</li>
</ol>
<p>序列数据的不同采样方法（随机采样和顺序分区）会导致隐状态初始化的差异，原因如下：</p>
<ol>
<li>随机采样： 在随机采样中，我们从序列数据中随机选择一个序列作为训练样本。这意味着每次训练时，我们都使用不同的序列作为输入。由于每个序列可能具有不同的上下文和语义信息，模型在每次训练时都需要重新适应不同的序列特征。因此，随机采样会导致隐状态的初始化与之前的训练批次存在一定差异。</li>
<li>顺序分区： 在顺序分区中，我们按顺序依次读取序列数据进行训练。这意味着模型在每个训练批次中都会接收到相邻的序列数据。由于相邻的序列通常具有相似的上下文和语义信息，模型可以利用之前批次的隐藏状态来帮助理解当前批次的序列。因此，顺序分区会导致隐状态的初始化与之前的训练批次存在一定的相关性。</li>
</ol>
<p>不同的隐状态初始化差异可能会对模型的训练和预测产生影响。随机采样可以增加数据的多样性，帮助模型更好地适应不同的序列特征。然而，随机采样可能也会引入一些噪声，导致训练过程更加不稳定。顺序分区可以利用相邻序列之间的相关性，帮助模型更好地捕捉到序列的上下文信息。然而，顺序分区可能会限制模型对不同序列特征的适应能力。</p>
<p>困惑度（perplexity）是自然语言处理中常用的一个评价指标，主要用于衡量语言模型的预测性能。困惑度越低，表示模型的预测能力越好。</p>
<p>在自然语言处理中，我们通常使用语言模型来计算文本序列的概率。给定一个文本序列 $W&#x3D;w_1,w_2,…,w_n$，其概率可以表示为：</p>
<p>$$<br>P(W)&#x3D;P(w_1)\times P(w_2|w_1) \times … \times P(w_n|w_1,w_2,…,w_{n-1})<br>$$</p>
<p>其中，$P(w_i|w_1,w_2,…,w_{i-1})$ 表示在已知前面 $i-1$ 个词的情况下，第 $i$ 个词的概率。语言模型的目标就是学习这种条件概率分布。在模型训练过程中，我们通常会使用最大似然估计法来估计模型参数。</p>
<p>困惑度是一个数值指标，表示用当前语言模型对一个测试集进行预测时所得到的困惑程度。具体而言，如果测试集包含 $N$ 个词，我们可以计算出每个词的概率 $P(w_i)$，然后将这些概率求倒数并取对数，即：</p>
<p>$$<br>\log \frac{1}{P(w_1)}+\log \frac{1}{P(w_2|w_1)}+…+\log \frac{1}{P(w_N|w_1,w_2,…,w_{N-1})}<br>$$</p>
<p>然后，我们可以将上述结果除以测试集中的词数 $N$，得到平均困惑度。具体而言，平均困惑度的计算公式如下：</p>
<p>$$<br>\text{Perplexity}&#x3D;exp\left(-\frac{1}{N}\sum_{i&#x3D;1}^{N}\log P(w_i)\right)<br>$$</p>
<p>例如，如果我们有一个包含100个句子的测试集，其中总共包含1000个词，我们可以使用语言模型来预测每个词的概率，并计算出平均困惑度。假设我们的模型预测准确率较高，平均每个词的概率为0.9，则平均困惑度为：</p>
<p>$$<br>exp\left(-\frac{1}{1000}\sum_{i&#x3D;1}^{1000}\log 0.9\right) \approx 2.15<br>$$</p>
<p>这表示我们的模型对测试集中的文本序列进行预测时，每个词的平均困惑度为2.15。如果我们使用一个更好的语言模型，其困惑度可能会更低。</p>
<p>用困惑度来评价模型确保了不同长度的序列具有可比性</p>
<h4 id="路径聚合网络模块"><a href="#路径聚合网络模块" class="headerlink" title="路径聚合网络模块"></a>路径聚合网络模块</h4><p><img src="/../images/image-20231219133825543.png" alt="image-20231219133825543"></p>
<h4 id="Focus处理模块"><a href="#Focus处理模块" class="headerlink" title="Focus处理模块"></a>Focus处理模块</h4><p><img src="/../images/image-20231219133907407.png" alt="image-20231219133907407"></p>
<h4 id="空间金字塔池化模块"><a href="#空间金字塔池化模块" class="headerlink" title="空间金字塔池化模块"></a>空间金字塔池化模块</h4><p><img src="/../images/image-20231219134700073.png" alt="image-20231219134700073"></p>
<h4 id="跨阶段局部网络模块"><a href="#跨阶段局部网络模块" class="headerlink" title="跨阶段局部网络模块"></a>跨阶段局部网络模块</h4><p><img src="/../images/image-20231219134949252.png" alt="image-20231219134949252"></p>
<p><img src="/../images/image-20231219135635494.png" alt="image-20231219135635494"></p>
<p>​	</p>
<h1 id="IoU、GIoU、DIoU、CIoU损失函数"><a href="#IoU、GIoU、DIoU、CIoU损失函数" class="headerlink" title="     IoU、GIoU、DIoU、CIoU损失函数         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wujianming-110117/p/13019343.html">     IoU、GIoU、DIoU、CIoU损失函数         </a></h1><p>IoU、GIoU、DIoU、CIoU损失函数</p>
<h1 id="目标检测任务的损失函数由Classificition-Loss和Bounding-Box-Regeression-Loss两部分构成。目标检测任务中近几年来Bounding-Box-Regression-Loss-Function的演进过程，其演进路线是"><a href="#目标检测任务的损失函数由Classificition-Loss和Bounding-Box-Regeression-Loss两部分构成。目标检测任务中近几年来Bounding-Box-Regression-Loss-Function的演进过程，其演进路线是" class="headerlink" title="目标检测任务的损失函数由Classificition Loss和Bounding Box Regeression Loss两部分构成。目标检测任务中近几年来Bounding Box Regression Loss Function的演进过程，其演进路线是"></a>目标检测任务的损失函数由Classificition Loss和Bounding Box Regeression Loss两部分构成。目标检测任务中近几年来Bounding Box Regression Loss Function的演进过程，其演进路线是</h1><h1 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/1251718-20200531153858189-1225302034.png" alt="img"></h1><h1 id="一、IOU-Intersection-over-Union"><a href="#一、IOU-Intersection-over-Union" class="headerlink" title="一、IOU(Intersection over Union)"></a><strong>一、IOU(Intersection over Union)</strong></h1><p><strong>1.</strong> <strong>特性(优点)</strong></p>
<p>IoU就是我们所说的<strong>交并比</strong>，是目标检测中最常用的指标，在anchor-based的方法。作用不仅用来确定正样本和负样本，还可以用来评价输出框（predict box）和ground-truth的距离。</p>
<p> <img src="/../images/1251718-20200531153951865-814017809.png" alt="img"></p>
<p> \1. 可以说<strong>它可以反映预测检测框与真实检测框的检测效果。</strong></p>
<p> \2. 还有一个很好的特性就是<strong>尺度不变性</strong>，也就是对尺度不敏感（scale invariant）， 在regression任务中，判断predict box和gt的距离最直接的指标就是IoU。**(**<strong>满足非负性；同一性；对称性；三角不等性)</strong></p>
<p><img src="/../images/1251718-20200531154027996-533351609.png" alt="img"></p>
<p> <strong>2.</strong> <strong>作为损失函数会出现的问题(缺点)</strong></p>
<p>\1. 如果两个框没有相交，根据定义，IoU&#x3D;0，不能反映两者的距离大小（重合度）。同时因为loss&#x3D;0，没有梯度回传，无法进行学习训练。</p>
<p> \2. IoU无法精确的反映两者的重合度大小。如下图所示，三种情况IoU都相等，但看得出来他们的重合度是不一样的，左边的图回归的效果最好，右边的最差。</p>
<p> <img src="/../images/1251718-20200531154239104-440943615.png" alt="img"></p>
<p> <strong>二、GIOU(Generalized Intersection over Union)</strong></p>
<p><strong>1****、来源</strong></p>
<p>在CVPR2019中，论文</p>
<p>《Generalized Intersection over Union: A Metric and A Loss for Bounding Box Regression》<br> https:arxiv.org&#x2F;abs&#x2F;1902.09630</p>
<p>提出了GIoU的思想。由于IoU是<strong>比值</strong>的概念，对目标物体的scale是不敏感的。然而检测任务中的BBox的回归损失(MSE loss, l1-smooth loss等）优化和IoU优化不是完全等价的，而且 Ln 范数对物体的scale也比较敏感，IoU无法直接优化没有重叠的部分。</p>
<p> <img src="/../images/1251718-20200531154308726-1360939519.png" alt="img"></p>
<p> 这篇论文提出可以直接把IoU设为回归的loss。</p>
<p> <img src="/../images/1251718-20200531154354415-2037289028.png" alt="img"></p>
<p> 上面公式的意思是：先计算两个框的最小闭包区域面积_ _(通俗理解：<strong>同时包含了预测框和真实框</strong>的最小框的面积)，再计算出IoU，再计算闭包区域中不属于两个框的区域占闭包区域的比重，最后用IoU减去这个比重得到GIoU。</p>
<p> 附：<a target="_blank" rel="noopener" href="https://github.com/generalized-iou/g-darknet">https://github.com/generalized-iou/g-darknet</a></p>
<p><strong>2****、 特性</strong>[1]</p>
<p>与IoU相似，GIoU也是一种距离度量，作为损失函数的话， ,满足损失函数的基本要求</p>
<p>GIoU对scale不敏感</p>
<p>GIoU是IoU的下界，在两个框无线重合的情况下，IoU&#x3D;GIoU</p>
<p>IoU取值[0,1]，但GIoU有对称区间，取值范围[-1,1]。在两者重合的时候取最大值1，在两者无交集且无限远的时候取最小值-1，因此GIoU是一个非常好的距离度量指标。</p>
<p>与IoU只关注重叠区域不同，<strong>GIoU****不仅关注重叠区域，还关注其他的非重合区域</strong>，能更好的反映两者的重合度。</p>
<p> <img src="/../images/1251718-20200531154522456-385805448.png" alt="img"></p>
<p> <img src="/../images/1251718-20200531154732786-1909345970.png" alt="img"></p>
<p> <strong>三、DIoU(Distance-IoU)[2]</strong></p>
<p>**1,**<strong>来源</strong></p>
<p>DIoU要比GIou更加符合目标框回归的机制，<strong>将目标与anchor之间的距离，重叠率以及尺度都考虑进去</strong>，使得目标框回归变得更加稳定，不会像IoU和GIoU一样出现训练过程中发散等问题。论文中</p>
<p>Distance-IoU<br> <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1911.08287.pdf">https://arxiv.org/pdf/1911.08287.pdf</a></p>
<p>基于IoU和GIoU存在的问题，作者提出了两个问题：<br> \1. 直接最小化anchor框与目标框之间的归一化距离是否可行，以达到更快的收敛速度？<br> \2. 如何使回归在与目标框有重叠甚至包含时更准确、更快？</p>
<p> <img src="/../images/1251718-20200531154844425-632049559.png" alt="img"></p>
<p> 其中，<img src="/../images/1251718-20200531154815739-471463487.png" alt="img">分别代表了预测框和真实框的中心点，<img src="/../images/1251718-20200531154909041-22064640.png" alt="img">且代表的是计算两个中心点间的欧式距离。c代表的是能够同时包含预测框和真实框的<strong>最小闭包区域</strong>的对角线距离。</p>
<p> <img src="/../images/1251718-20200531154956953-836811449.png" alt="img"></p>
<p> <img src="/../images/1251718-20200531155026159-588849996.png" alt="img"></p>
<p> DIoU中对anchor框和目标框之间的归一化距离进行了建模</p>
<p>附：</p>
<p>YOLOV3 DIoU GitHub项目地址<br> https&#x2F;&#x2F;github.com&#x2F;Zzh-tju&#x2F;DIoU-darknet</p>
<p><strong>2****、优点</strong></p>
<p>与GIoU loss类似，DIoU loss（ ）在与目标框不重叠时，仍然可以为边界框提供移动方向。</p>
<p>DIoU loss可以直接最小化两个目标框的距离，因此比GIoU loss收敛快得多。</p>
<p>对于包含两个框在水平方向和垂直方向上这种情况，DIoU损失可以使回归非常快，而GIoU损失几乎退化为IoU损失。</p>
<p>DIoU还可以替换普通的IoU评价策略，应用于NMS中，使得NMS得到的结果更加合理和有效。</p>
<p>实现代码：[3]</p>
<p> <img src="/../images/1251718-20200531155128579-1060794147.png" alt="img"></p>
<p> <img src="/../images/1251718-20200531155210632-956163178.png" alt="img"></p>
<p> <strong>四、CIoU(Complete-IoU)</strong></p>
<p>论文考虑到bbox回归三要素中的长宽比还没被考虑到计算中，因此，进一步在DIoU的基础上提出了CIoU。其惩罚项如下面公式：</p>
<p> <img src="/../images/1251718-20200531155238128-675856095.png" alt="img"></p>
<p> 实现代码：[5] </p>
<p> <img src="/../images/1251718-20200531155304911-1990080212.png" alt="img"></p>
<p> <img src="/../images/1251718-20200531155316931-2121130060.png" alt="img"></p>
<p> <img src="/../images/1251718-20200531155335490-1670997408.png" alt="img"></p>
<p><img src="/../images/image-20231219142055992.png" alt="image-20231219142055992"></p>
<p><img src="/../images/image-20231219142702047.png" alt="image-20231219142702047"></p>
<h4 id="L-IoU-1-IoU-L-GIoU-1-GIoU"><a href="#L-IoU-1-IoU-L-GIoU-1-GIoU" class="headerlink" title="L(IoU)&#x3D;1-IoU,L(GIoU)&#x3D;1-GIoU"></a>L(IoU)&#x3D;1-IoU,L(GIoU)&#x3D;1-GIoU</h4><p><img src="/../images/image-20231219143118491.png" alt="image-20231219143118491"></p>
<p><img src="/../images/image-20231219143242889.png" alt="image-20231219143242889"></p>
<h4 id="penalty-item-惩罚项"><a href="#penalty-item-惩罚项" class="headerlink" title="penalty item 惩罚项"></a>penalty item 惩罚项</h4><p><img src="/../images/image-20231219143834054.png" alt="image-20231219143834054"></p>
<p><img src="/../images/image-20231219143908214.png" alt="image-20231219143908214"></p>
<p><img src="/../images/image-20231219144615647.png" alt="image-20231219144615647"></p>
<p><img src="/../images/image-20231219144820908.png" alt="image-20231219144820908"></p>
<h4 id="用1替换"><a href="#用1替换" class="headerlink" title="用1替换"></a>用1替换</h4><p><img src="/../images/image-20231220151820969.png" alt="image-20231220151820969"><img src="/../images/image-20231220151851064.png" alt="image-20231220151851064"></p>
<p><img src="/../images/image-20231220151924519.png" alt="image-20231220151924519"></p>
<p><img src="/../images/image-20231220152401000.png" alt="image-20231220152401000"></p>
<p><strong>YOLO训练技巧</strong></p>
<p><strong>1.</strong></p>
<p><img src="/../images/image-20231221102150112.png" alt="image-20231221102150112"></p>
<p><em>2.</em></p>
<p><img src="/../images/image-20231221102343926.png" alt="image-20231221102343926">余弦退火学习率调整的原理是根据余弦函数的形状动态地调整学习率。它通过将学习率从一个较大的初始值逐渐减小到一个较小的最小值来控制训练过程中的学习率变化。</p>
<p>具体实现步骤如下：</p>
<ol>
<li>设置一个最大学习率和最小学习率的范围。</li>
<li>定义一个周期数（通常是训练的总迭代次数）。</li>
<li>对于每个训练迭代，计算当前周期数与总周期数之间的比例。</li>
<li>使用余弦函数来动态计算学习率，公式如下：</li>
</ol>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">lr = lr_min + 0.5 * (lr_max - lr_min) * (1 + cos(epoch / T_total * pi))</span></span></code></pre></div><p>其中，lr表示当前学习率，epoch表示当前周期数，T_total表示总周期数，lr_max表示最大学习率，lr_min表示最小学习率。</p>
<ol start="5">
<li>将计算得到的学习率应用于优化器中进行权重更新。</li>
</ol>
<p>使用余弦退火学习率调整可以在训练初期使用较大的学习率来快速收敛，然后逐渐减小学习率以细化模型的优化过程。这种方法在训练中期能够跳出局部最优解并找到更好的全局最优解，有助于提高模型的泛化性能和训练效果。</p>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p><img src="/../images/image-20231221103518038.png" alt="image-20231221103518038"></p>
<h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><p><img src="/../images/image-20231221103556292.png" alt="image-20231221103556292"></p>
<h4 id="5-遗传算法"><a href="#5-遗传算法" class="headerlink" title="5.遗传算法"></a>5.遗传算法</h4><p><img src="/../images/image-20231221103654283.png" alt="image-20231221103654283"></p>
<h4 id="6-AMP"><a href="#6-AMP" class="headerlink" title="6.AMP"></a>6.AMP</h4><p><img src="/../images/image-20231221103725894.png" alt="image-20231221103725894"></p>
<h4 id="7"><a href="#7" class="headerlink" title="7."></a><img src="/../images/image-20231221103836498.png" alt="image-20231221103836498">7.</h4><p><img src="/../images/image-20231221104450473.png" alt="image-20231221104450473"></p>
<h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p><img src="/../images/image-20231222110059278.png" alt="image-20231222110059278"></p>
<p><img src="/../images/image-20231222110124317.png" alt="image-20231222110124317"></p>
<p><img src="/../images/image-20231222110150825.png" alt="image-20231222110150825"></p>
<p><img src="/../images/image-20231222110400513.png" alt="image-20231222110400513"></p>
<p><img src="/../images/image-20231222111314420.png" alt="image-20231222111314420"></p>
<h4 id="优点：激活区域可以更多样"><a href="#优点：激活区域可以更多样" class="headerlink" title="优点：激活区域可以更多样"></a><img src="/../images/image-20231222111341197.png" alt="image-20231222111341197">优点：激活区域可以更多样</h4><p><img src="/../images/image-20231222111510179.png" alt="image-20231222111510179"></p>
<h4 id="因此，引入了各种方法来压缩神经网络，以使大型模型可以在边缘设备上部署。模型压缩方法可以分为3类：剪枝、量化和知识蒸馏。在剪枝中，移除模型中不重要的冗余参数，以获得稀疏-紧凑的模型结构。量化涉及使用低精度数据类型表示模型的激活和权重。最后，知识蒸馏是指利用大型准确模型作为教师来训练一个小型模型，使用教师模型提供的软标签来进行训练。"><a href="#因此，引入了各种方法来压缩神经网络，以使大型模型可以在边缘设备上部署。模型压缩方法可以分为3类：剪枝、量化和知识蒸馏。在剪枝中，移除模型中不重要的冗余参数，以获得稀疏-紧凑的模型结构。量化涉及使用低精度数据类型表示模型的激活和权重。最后，知识蒸馏是指利用大型准确模型作为教师来训练一个小型模型，使用教师模型提供的软标签来进行训练。" class="headerlink" title="因此，引入了各种方法来压缩神经网络，以使大型模型可以在边缘设备上部署。模型压缩方法可以分为3类：剪枝、量化和知识蒸馏。在剪枝中，移除模型中不重要的冗余参数，以获得稀疏&#x2F;紧凑的模型结构。量化涉及使用低精度数据类型表示模型的激活和权重。最后，知识蒸馏是指利用大型准确模型作为教师来训练一个小型模型，使用教师模型提供的软标签来进行训练。"></a>因此，引入了各种方法来压缩神经网络，以使大型模型可以在边缘设备上部署。模型压缩方法可以分为3类：剪枝、量化和知识蒸馏。在剪枝中，移除模型中不重要的冗余参数，以获得稀疏&#x2F;紧凑的模型结构。量化涉及使用低精度数据类型表示模型的激活和权重。最后，知识蒸馏是指利用大型准确模型作为教师来训练一个小型模型，使用教师模型提供的软标签来进行训练。</h4><p>cmake_minimum_required(VERSION 3.10) project(yolov5) add_definitions(-std&#x3D;c++11) add_definitions(-DAPI_EXPORTS) option(CUDA_USE_STATIC_CUDA_RUNTIME OFF) set(CMAKE_CXX_STANDARD 11) set(CMAKE_BUILD_TYPE Debug) # TODO(Call for PR): make cmake compatible with Windows set(CMAKE_CUDA_COMPILER &#x2F;usr&#x2F;local&#x2F;cuda-12.2&#x2F;bin&#x2F;nvcc) enable_language(CUDA) # include and link dirs of cuda and tensorrt, you need adapt them if yours are different # cuda include_directories(&#x2F;usr&#x2F;local&#x2F;cuda-12.2&#x2F;include) link_directories(&#x2F;usr&#x2F;local&#x2F;cuda-12.2&#x2F;lib64) # tensorrt # TODO(Call for PR): make TRT path configurable from command line include_directories(&#x2F;home&#x2F;nvidia&#x2F;TensorRT-8.2.5.1&#x2F;include&#x2F;) link_directories(&#x2F;home&#x2F;nvidia&#x2F;TensorRT-8.2.5.1&#x2F;lib&#x2F;) include_directories(${PROJECT_SOURCE_DIR}&#x2F;src&#x2F;) include_directories(${PROJECT_SOURCE_DIR}&#x2F;plugin&#x2F;) file(GLOB_RECURSE SRCS ${PROJECT_SOURCE_DIR}&#x2F;src&#x2F;<em>.cpp ${PROJECT_SOURCE_DIR}&#x2F;src&#x2F;</em>.cu) file(GLOB_RECURSE PLUGIN_SRCS ${PROJECT_SOURCE_DIR}&#x2F;plugin&#x2F;*.cu) add_library(myplugins SHARED ${PLUGIN_SRCS}) target_link_libraries(myplugins nvinfer cudart) find_package(OpenCV) include_directories(${OpenCV_INCLUDE_DIRS}) add_executable(yolov5_det yolov5_det.cpp ${SRCS}) target_link_libraries(yolov5_det nvinfer) target_link_libraries(yolov5_det cudart) target_link_libraries(yolov5_det myplugins) target_link_libraries(yolov5_det ${OpenCV_LIBS}) add_executable(yolov5_cls yolov5_cls.cpp ${SRCS}) target_link_libraries(yolov5_cls nvinfer) target_link_libraries(yolov5_cls cudart) target_link_libraries(yolov5_cls myplugins) target_link_libraries(yolov5_cls ${OpenCV_LIBS}) add_executable(yolov5_seg yolov5_seg.cpp ${SRCS}) target_link_libraries(yolov5_seg nvinfer) target_link_libraries(yolov5_seg cudart) target_link_libraries(yolov5_seg myplugins) target_link_libraries(yolov5_seg ${OpenCV_LIBS}) 这是cmakeLists.txt文件 cmake .. 报错： zgh@zgh-Legion-Y7000P-IAH7:~&#x2F;tensorrtx&#x2F;yolov5&#x2F;build$ cmake .. CMake Error at &#x2F;usr&#x2F;local&#x2F;share&#x2F;cmake-3.27&#x2F;Modules&#x2F;CMakeDetermineCUDACompiler.cmake:277 (message):  CMAKE_CUDA_ARCHITECTURES must be non-empty if set. Call Stack (most recent call first):  CMakeLists.txt:13 (enable_language)  – Configuring incomplete, errors occurred!</p>
<p>2024&#x2F;1&#x2F;20 11:33:33</p>
<p>该错误提示是由于没有指定 <code>CMAKE_CUDA_ARCHITECTURES</code> 变量，需要在 <code>CMakeLists.txt</code> 中添加以下语句：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">set(CMAKE_CUDA_ARCHITECTURES &quot;60;61;70;75&quot;)</span></span></code></pre></div><p>其中，<code>CMAKE_CUDA_ARCHITECTURES</code> 指定了支持的 CUDA 架构版本号，这里的值可以根据你的 GPU 型号进行调整。</p>
<p>在添加上述语句后，再次运行 <code>cmake ..</code> 命令即可。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">cmake_minimum_required(VERSION 3.5)</span></span>
<span class="line"><span style="color: #babed8">project(Ball_Det)</span></span>
<span class="line"><span style="color: #babed8">set(CMAKE_CXX_STANDARD 11)</span></span>
<span class="line"><span style="color: #babed8">set(Cudart_LIBS &quot;/usr/local/cuda-12.2/targets/x86_64-linux/lib/libcudart.so&quot;)</span></span>
<span class="line"><span style="color: #babed8">set(CMAKE_CUDA_COMPILER /usr/local/cuda-12.2/bin/nvcc)</span></span>
<span class="line"><span style="color: #babed8">set(CMAKE_CUDA_ARCHITECTURES &quot;80&quot;)</span></span>
<span class="line"><span style="color: #babed8">include_directories(/usr/local/cuda-12.2/include)</span></span>
<span class="line"><span style="color: #babed8">link_directories(/usr/local/cuda-12.2/lib64)</span></span>
<span class="line"><span style="color: #babed8">enable_language(CUDA)</span></span>
<span class="line"><span style="color: #babed8">find_package(CUDA REQUIRED)</span></span>
<span class="line"><span style="color: #babed8">find_package(k4a REQUIRED)</span></span>
<span class="line"><span style="color: #babed8">find_package(OpenCV REQUIRED)</span></span>
<span class="line"><span style="color: #babed8">include_directories(</span></span>
<span class="line"><span style="color: #babed8">       Yolo</span></span>
<span class="line"><span style="color: #babed8">        $&#123;OpenCV_INCLUDE_DIRS&#125;</span></span>
<span class="line"><span style="color: #babed8">       /usr/local/cuda12.2/include</span></span>
<span class="line"><span style="color: #babed8">       $&#123;CMAKE_CURRENT_LIST_DIR&#125;</span></span>
<span class="line"><span style="color: #babed8">)</span></span>
<span class="line"><span style="color: #babed8">add_library(</span></span>
<span class="line"><span style="color: #babed8">       Yolo</span></span>
<span class="line"><span style="color: #babed8">       Yolo/yolov5.cpp</span></span>
<span class="line"><span style="color: #babed8">)</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">cuda_add_library(myplugins SHARED ./Yolo/yololayer.cu)</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">add_executable(Ball_Det</span></span>
<span class="line"><span style="color: #babed8">       Mask_Detection.cpp</span></span>
<span class="line"><span style="color: #babed8">       Yolo/yolov5.cpp</span></span>
<span class="line"><span style="color: #babed8">       main.cpp</span></span>
<span class="line"><span style="color: #babed8">       Ball_Detection.cpp</span></span>
<span class="line"><span style="color: #babed8">       Yolo/calibrator.cpp</span></span>
<span class="line"><span style="color: #babed8">)</span></span>
<span class="line"><span style="color: #babed8">target_link_libraries(</span></span>
<span class="line"><span style="color: #babed8">       Ball_Det</span></span>
<span class="line"><span style="color: #babed8">       nvinfer</span></span>
<span class="line"><span style="color: #babed8">       cudart</span></span>
<span class="line"><span style="color: #babed8">       myplugins</span></span>
<span class="line"><span style="color: #babed8">       /usr/local/cuda12.2/lib64</span></span>
<span class="line"><span style="color: #babed8">       $&#123;Cudart_LIBS&#125;</span></span>
<span class="line"><span style="color: #babed8">       $&#123;OpenCV_LIBS&#125;</span></span>
<span class="line"><span style="color: #babed8">       libk4a.so</span></span>
<span class="line"><span style="color: #babed8">        )</span></span></code></pre></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/yolov5.html" data-id="clxbjvuxs000k61cxc1cqaa16" data-title="yolov5" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/yolo/" rel="tag">yolo</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-deeplearning" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/deeplearning.html" class="article-date">
  <time class="dt-published" datetime="2023-12-16T02:57:26.000Z" itemprop="datePublished">2023-12-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/deeplearning.html">deeplearning</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 Pandas 中，<code>.apply()</code> 是用于对 DataFrame 或 Series 中的元素应用指定函数的方法。</p>
<p>对于 DataFrame，<code>.apply()</code> 可以在行或列方向上应用函数。语法如下：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">DataFrame.apply(func, axis=0)</span></span></code></pre></div><ul>
<li><code>func</code> 是要应用的函数，可以是一个已定义的函数，也可以是一个匿名函数（如 lambda 函数）。</li>
<li><code>axis</code> 是指定应用函数的方向，默认为 0，表示按列应用函数；设置为 1 则表示按行应用函数。</li>
</ul>
<p>对于 Series，<code>.apply()</code> 仅能在元素级别上应用函数，无需指定应用方向。语法如下：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">Series.apply(func)</span></span></code></pre></div><ul>
<li><code>func</code> 是要应用的函数，可以是一个已定义的函数，也可以是一个匿名函数（如 lambda 函数）。</li>
</ul>
<p>在上述代码中，<code>.apply(lambda x: (x - x.mean()) / (x.std()))</code> 就是将匿名函数 <code>lambda x: (x - x.mean()) / (x.std())</code> 应用到 DataFrame 或 Series 中的每个元素上。结果是对 DataFrame 或 Series 中的每个元素进行标准化计算，并返回处理后的结果</p>
<p><img src="/../images/image-20231218090813900.png" alt="image-20231218090813900"></p>
<p>​                                                                                                         右–按照时间线展开图</p>
<p><img src="/../images/image-20231218141358079.png" alt="image-20231218141358079"></p>
<h4 id="查询（自主提示）和键（非自主提示）之间的交互形成了注意力汇聚；注意力汇聚有选择地聚合了值（感官输入）以生成最终的输出。"><a href="#查询（自主提示）和键（非自主提示）之间的交互形成了注意力汇聚；注意力汇聚有选择地聚合了值（感官输入）以生成最终的输出。" class="headerlink" title="查询（自主提示）和键（非自主提示）之间的交互形成了注意力汇聚；注意力汇聚有选择地聚合了值（感官输入）以生成最终的输出。"></a>查询（自主提示）和键（非自主提示）之间的交互形成了注意力汇聚；注意力汇聚有选择地聚合了值（感官输入）以生成最终的输出。</h4><p><code>torch.repeat_interleave()</code> 函数是 PyTorch 中的一个张量操作函数，用于生成一个重复值的张量。它的详细解释如下：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">torch.repeat_interleave(input, repeats, dim=None)</span></span></code></pre></div><p>参数说明：</p>
<ul>
<li><code>input</code>：输入张量。</li>
<li><code>repeats</code>：重复次数，可以是一个整数、一个一维张量或一个与 <code>input</code> 张量形状相匹配的张量。</li>
<li><code>dim</code>（可选）：指定重复操作的维度。</li>
</ul>
<p>函数功能：</p>
<ul>
<li><code>torch.repeat_interleave()</code> 函数将输入张量 <code>input</code> 按指定的重复次数 <code>repeats</code> 进行重复，并生成一个新的张量。</li>
</ul>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">https://zhuanlan.zhihu.com/p/659067322</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">sk-QxaDRZHsiyhtTFpB3JXHMkQ5fiK0AnEQZgM27mbiEIaIkF0G</span></span></code></pre></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/deeplearning.html" data-id="clxbjvuxr000e61cxa8ttcd11" data-title="deeplearning" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Pytorch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Pytorch.html" class="article-date">
  <time class="dt-published" datetime="2023-12-15T14:50:19.000Z" itemprop="datePublished">2023-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Pytorch.html">Pytorch</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 Python 中，lambda 是用来创建匿名函数的关键字。所谓匿名函数，即没有显式定义函数名的函数，通常用于需要临时定义简单函数的场景。</p>
<p>lambda 函数的语法如下：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">lambda arguments: expression</span></span></code></pre></div><p>其中：</p>
<ul>
<li><code>arguments</code> 是函数的参数，可以有多个参数，用逗号隔开。</li>
<li><code>expression</code> 是函数的返回值计算表达式。</li>
</ul>
<p>lambda 函数通常用于需要一个函数，但是又不想正式定义一个函数的场景，比如作为其他函数的参数传递进去，或者在一些函数式编程的场景中使用。</p>
<p>params &#x3D; [W_xh, W_hh, b_h, W_hq, b_q]<br>for param in params:<br>        param.requires_grad_(True)</p>
<p>目的是告诉 PyTorch 在模型训练过程中需要计算这些参数的梯度，并且在反向传播时对其进行更新。</p>
<p><code>Xt*Wxh + Ht−1*Whh=cat(Xt,Ht−1)*cat(Wxh,Whh)</code></p>
<p><code>torch.matmul(X, W_xh) + torch.matmul(H, W_hh)</code></p>
<p><code>torch.matmul(torch.cat((X, H), 1), torch.cat((W_xh, W_hh), 0))</code></p>
<p>当一个类实现了 <code>__call__</code> 方法时，它的实例对象可以像函数一样进行调用。这意味着你可以使用实例对象作为函数来调用，就好像调用一个函数一样。</p>
<p>例如，假设有一个类 <code>MyClass</code>，并且实现了 <code>__call__</code> 方法：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">python</span></span>
<span class="line"><span style="color: #babed8">class MyClass:</span></span>
<span class="line"><span style="color: #babed8">    def __call__(self, x):</span></span>
<span class="line"><span style="color: #babed8">        print(&quot;Calling MyClass with argument:&quot;, x)</span></span></code></pre></div><p>现在，你可以创建一个 <code>MyClass</code> 的实例，并将其作为函数进行调用：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">python</span></span>
<span class="line"><span style="color: #babed8">obj = MyClass()</span></span>
<span class="line"><span style="color: #babed8">obj(10)</span></span></code></pre></div><p>输出结果将是：</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">Calling MyClass with argument: 10</span></span></code></pre></div><p>所以<br><code>class RNNModelScratch: #@save</code><br><code>&quot;&quot;&quot;从零开始实现的循环神经网络模型&quot;&quot;&quot;</code><br><code>def __init__(self, vocab_size, num_hiddens, device,</code><br><code>get_params, init_state, forward_fn):</code><br><code>self.vocab_size, self.num_hiddens = vocab_size, num_hiddens</code><br><code>self.params = get_params(vocab_size, num_hiddens, device)</code><br><code>self.init_state, self.forward_fn = init_state, forward_fn</code><br><code>def __call__(self, X, state):</code><br><code>X = F.one_hot(X.T, self.vocab_size).type(torch.float32)</code><br><code>return self.forward_fn(X, state, self.params)</code></p>
<p>可以这样调用：</p>
<p><code>net = RNNModelScratch(len(vocab), num_hiddens, d2l.try_gpu(), get_params,</code><br><code>init_rnn_state, rnn)</code></p>
<p><code>Y, new_state = net(X.to(d2l.try_gpu()), state)</code></p>
<p><code>**kwargs</code> 是 Python 中的一种特殊语法，用于接收任意数量的关键字参数（keyword arguments）。在函数或方法的定义中，<code>**kwargs</code> 会将传递给函数的未命名关键字参数收集到一个字典中，其中字典的键是参数名，值是参数值。</p>
<p>在这段代码中，<code>**kwargs</code> 被用作 <code>NWKernelRegression</code> 类的初始化方法 <code>__init__</code> 的参数。通过使用 <code>**kwargs</code>，可以接收任意数量的关键字参数，并将它们存储为类的属性。这样做可以使代码更加灵活，允许用户在创建 <code>NWKernelRegression</code> 实例时传递额外的参数。</p>
<p>例如，如果你创建了一个 <code>NWKernelRegression</code> 实例时传递了额外的参数，比如 <code>model = NWKernelRegression(param1=10, param2=&#39;abc&#39;)</code>，那么这些额外的参数会被收集到 <code>kwargs</code> 字典中，字典的键是参数名，值是参数值。你可以根据需要在 <code>__init__</code> 方法中使用这些参数。</p>
<p>总而言之，<code>**kwargs</code> 允许在函数或方法定义中接收任意数量的关键字参数，并将它们保存为字典以供后续使用。</p>
<p>在 PyTorch 中，<code>self.fc1=nn.Linear(16*5*5,120)</code> 定义了一个全连接层（或称为线性层）。具体来说：</p>
<ul>
<li><code>16*5*5</code> 是输入特征的数量，即展平后的张量长度。</li>
<li><code>120</code> 是全连接层输出的特征数量。</li>
</ul>
<p>这个全连接层会将形状为 400400 的输入（展平后的张量）转换为形状为 120120 的输出。这个层的作用是通过一个权重矩阵和偏置向量对输入进行线性变换，以得到最终的输出。</p>
<p>是如何展平的?</p>
<p>展平（Flatten）是将多维张量转换为一维向量的过程。以一个形状为 (16 \times 5 \times 5) 的张量为例，这个过程如下：</p>
<ol>
<li><p><strong>输入张量</strong>：假设有一个张量，其形状为 (16 \times 5 \times 5)，其中 (16) 是通道数，(5) 和 (5) 是每个通道的高和宽。</p>
</li>
<li><p><strong>展平过程</strong>：</p>
<ul>
<li>按照通道、行和列的顺序，将所有元素排列成一个一维向量。</li>
<li>例如，假设张量的元素是 ( \text{A}_{i,j,k} )，展平后你将得到一个长度为 (16 \times 5 \times 5 &#x3D; 400) 的一维向量。</li>
</ul>
</li>
<li><p><strong>展平后的结果</strong>：</p>
<ul>
<li>这个一维向量的长度为 (400)，即将原张量的所有数据连续地排列在一起。</li>
</ul>
</li>
</ol>
<p>在实际代码中，比如在 PyTorch 中，展平通常通过 <code>nn.Flatten()</code> 或者在前向传播方法中使用 <code>torch.flatten()</code> 来完成。</p>
<p>轴心时代</p>
<p>在优化算法中，<code>momentum</code> 是一个技术，用于加速收敛并减少震荡。具体来说：</p>
<ul>
<li><strong><code>momentum</code></strong>: 是一个动量因子，它在更新参数时考虑了之前梯度的影响。它通过引入过去梯度的加权平均来调整当前的梯度更新。</li>
<li><strong>作用</strong>: 它帮助优化过程在高曲率方向上加速，在低曲率方向上减缓，从而使优化过程更稳定，减少了震荡和加速收敛。</li>
</ul>
<p>在 <code>optim.SGD</code> 中，<code>momentum=0.9</code> 表示将前一步梯度的 90% 加入到当前梯度更新中。</p>
<p>ubuntu20.04可以装ROS 2 humble</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Pytorch.html" data-id="clxbjvuxq000d61cx2owx79hb" data-title="Pytorch" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/" rel="tag">C++STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PNC/" rel="tag">PNC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/esp32/" rel="tag">esp32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robot-kinematics/" rel="tag">robot_kinematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yolo/" rel="tag">yolo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%89%E8%B6%B3/" rel="tag">玉足</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-STL/" style="font-size: 10px;">C++STL</a> <a href="/tags/Embedded/" style="font-size: 10px;">Embedded</a> <a href="/tags/PNC/" style="font-size: 10px;">PNC</a> <a href="/tags/esp32/" style="font-size: 10px;">esp32</a> <a href="/tags/robot-kinematics/" style="font-size: 10px;">robot_kinematics</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/%E7%8E%89%E8%B6%B3/" style="font-size: 10px;">玉足</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">计算机图形学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html">流体力学</a>
          </li>
        
          <li>
            <a href="/post/%E5%9B%9B%E8%B6%B3.html">四足</a>
          </li>
        
          <li>
            <a href="/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6.html">图形学</a>
          </li>
        
          <li>
            <a href="/post/motion-planning.html">motion_planning</a>
          </li>
        
          <li>
            <a href="/post/Realsense.html">Realsense</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>