<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Zgh&#39;s</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Zgh的个人站">
<meta property="og:type" content="website">
<meta property="og:title" content="Zgh&#39;s">
<meta property="og:url" content="http://zgh20060114.github.io/index.html">
<meta property="og:site_name" content="Zgh&#39;s">
<meta property="og:description" content="Zgh的个人站">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Zgh's" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zgh&#39;s</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Zgh20060114.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-kinematics" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/kinematics.html" class="article-date">
  <time class="dt-published" datetime="2024-10-07T14:26:21.000Z" itemprop="datePublished">2024-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/kinematics.html">kinematics</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20241009151945396.png" alt="image-20241009151945396"></p>
<p><img src="/../images/image-20241011082114462.png" alt="image-20241011082114462"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/kinematics.html" data-id="cm24he2gj0000pzcx40pwa14w" data-title="kinematics" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/robot-kinematics/" rel="tag">robot_kinematics</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Webots" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Webots.html" class="article-date">
  <time class="dt-published" datetime="2024-10-03T08:34:22.000Z" itemprop="datePublished">2024-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Webots.html">Webots</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>WARNING: To drag this element, first rotate the view so that the horizontal plane is clearly visible.</p>
<p>旋转到水平面上再shift+左键<img src="/../images/image-20241003163738576.png" alt="image-20241003163738576"></p>
<p>右键平移</p>
<p>保存：Ctrl shift s</p>
<p>向导:<br>1.新建项目目录向导（新建场景）</p>
<p>2.新建机器人控制器向导（新建控制器）</p>
<p><img src="/../images/image-20241004122441260.png" alt="image-20241004122441260"></p>
<p>只有机器人节点才能导出urdf文件</p>
<p>转换完后的文件放到protos目录下<br><img src="/../images/image-20241004122612323.png" alt="image-20241004122612323"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Webots.html" data-id="cm1t1isj80000qycx3ovfhwj3" data-title="Webots" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ubuntu-nvidia" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/ubuntu-nvidia.html" class="article-date">
  <time class="dt-published" datetime="2024-10-02T16:44:34.000Z" itemprop="datePublished">2024-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/ubuntu-nvidia.html">ubuntu-nvidia</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>写于2024-10-3-00:46</p>
<p>记录一次把ubnutu20.04de nvidia 驱动搞坏又修复，加上对ubuntu显卡驱动和独显&#x2F;混显，lightdm&#x2F;gdm3桌面管理器的理解。</p>
<p>由于webots仿真卡死崩溃，就找到一篇博客说：</p>
<pre><code>glxinfo | grep OpenGL
</code></pre>
<p>确实opengl输出的是intel集显，使用</p>
<pre><code>sudo prime-select nvidia
</code></pre>
<p>再次查看输出：</p>
<pre><code>zgh@zgh-Legion-Y7000P-IAH7:~$ glxinfo | grep OpenGL
OpenGL vendor string: Mesa/X.org
OpenGL renderer string: llvmpipe (LLVM 12.0.0, 256 bits)
</code></pre>
<p>虽然不是nvidia，但好歹不是intel了，而且仿真不会卡死崩溃了</p>
<pre><code>sudo systemctl restart gdm3

/etc/X11/xorg.conf

xrandr

glxinfo | grep OpenGL

nvidia-settings
</code></pre>
<p>####sudo nvidia-xconfig 不要用这个命令，它会生成什么Xorg的配置文件，把你之前能用的显示配置覆盖掉</p>
<p><code>/etc/X11/xorg.conf</code>内容：</p>
<pre><code> # nvidia-xconfig: X configuration file generated by nvidia-xconfig
# nvidia-xconfig:  version 535.154.05


Section &quot;ServerLayout&quot;
    Identifier     &quot;Layout0&quot;
    Screen      0  &quot;Screen0&quot; 0 0
    InputDevice    &quot;Keyboard0&quot; &quot;CoreKeyboard&quot;
    InputDevice    &quot;Mouse0&quot; &quot;CorePointer&quot;
EndSection

Section &quot;Files&quot;
EndSection

Section &quot;InputDevice&quot;

    # generated from default
    Identifier     &quot;Mouse0&quot;
    Driver         &quot;mouse&quot;
    Option         &quot;Protocol&quot; &quot;auto&quot;
    Option         &quot;Device&quot; &quot;/dev/psaux&quot;
    Option         &quot;Emulate3Buttons&quot; &quot;no&quot;
    Option         &quot;ZAxisMapping&quot; &quot;4 5&quot;
EndSection

Section &quot;InputDevice&quot;

    # generated from default
    Identifier     &quot;Keyboard0&quot;
    Driver         &quot;kbd&quot;
EndSection

Section &quot;Monitor&quot;
    Identifier     &quot;Monitor0&quot;
    VendorName     &quot;Unknown&quot;
    ModelName      &quot;Unknown&quot;
    Option         &quot;DPMS&quot;
EndSection

Section &quot;Device&quot;
    Identifier     &quot;Device0&quot;
    Driver         &quot;nvidia&quot;
    VendorName     &quot;NVIDIA Corporation&quot;
    BusID          &quot;PCI:1:0:0&quot;
EndSection

Section &quot;Screen&quot;
    Identifier     &quot;Screen0&quot;
    Device         &quot;Device0&quot;  #就是要用独立显卡启动
    Monitor        &quot;Monitor0&quot;
    DefaultDepth    24
    SubSection     &quot;Display&quot;
        Depth       24
    EndSubSection
EndSection
</code></pre>
<p>如果这样写：</p>
<pre><code>Section &quot;Device&quot;
    Identifier     &quot;Device0&quot;
    Driver         &quot;nvidia&quot;
    VendorName     &quot;NVIDIA Corporation&quot;
    BusID          &quot;PCI:1:0:0&quot;
EndSection

Section &quot;Screen&quot;
    Identifier     &quot;Screen0&quot;
    Device         &quot;Device1&quot;
    Monitor        &quot;Monitor0&quot;
    DefaultDepth    24
    SubSection     &quot;Display&quot;
        Depth       24
    EndSubSection
EndSection

Section &quot;Device&quot;
        Identifier  &quot;Device1&quot;
        Driver      &quot;intel&quot;
        VendorName  &quot;Intel Corporation&quot;
        Option      &quot;TripleBuffer&quot; &quot;true&quot;
        Option      &quot;TearFree&quot;     &quot;true&quot;
        Option      &quot;DRI&quot;          &quot;false&quot;   #这三条都是为了防止集显显示桌面的时候画面割裂
        BusID       &quot;PCI:0:2:0&quot;
EndSection
</code></pre>
<p>是以Intel集显启动，确实有用</p>
<p>但是此时bios里设置的混合显示，只会使用集显,nvidia-settings内容错误，只能显示笔记本屏幕，无法连接外接显示器。</p>
<p>然后又换lightdm试一试，发现还是只能显示一个，甚至只能显示外接屏幕，拔去外接屏幕，笔记本屏幕也不会亮。</p>
<p>最后又换回了dgm3</p>
<p>##总结：</p>
<h1 id="只有bios独立显卡-etc-X11-xorg-conf使用独立显卡-dgm3才能正常使用。"><a href="#只有bios独立显卡-etc-X11-xorg-conf使用独立显卡-dgm3才能正常使用。" class="headerlink" title="#只有bios独立显卡 +  &#x2F; etc&#x2F;X11&#x2F;xorg.conf使用独立显卡 +dgm3才能正常使用。"></a>#只有bios独立显卡 +  &#x2F; etc&#x2F;X11&#x2F;xorg.conf使用独立显卡 +dgm3才能正常使用。</h1><p>2024-10-3-14:44</p>
<p>这样确实可以用，但是独显功耗太大，而且不知道为什么webots非常卡，看来还是不对</p>
<p>bios混显模式+删除xorg.conf</p>
<p>先修改xorg.conf，把GPU，Intel标清，然后用Intel显示，进入桌面，看到nvidia-settings能选择这三种模式了（这是还不是很对，左面只有一个PRIME Profiles）</p>
<p>重启</p>
<p>在tty里把xorg.conf文件rm掉，</p>
<p>直接reboot</p>
<p>就一切正常了，看一下:</p>
<p><img src="/../images/image-20241003145229468.png" alt="image-20241003145229468"></p>
<p><img src="/../images/image-20241003144809104.png" alt="image-20241003144809104"></p>
<p>nvidia-smi也正常了</p>
<p>2024-10-4-10:29</p>
<pre><code>zgh@zgh-Legion-Y7000P-IAH7:~$ __NV_PRIME_RENDER_OFFLOAD=1 vkcube
zgh@zgh-Legion-Y7000P-IAH7:~$ __NV_PRIME_RENDER_OFFLOAD=1 zed
</code></pre>
<p>这个是nvidia gpu的详细官方文档primerenderoffload</p>
<p>对于on-demand模式无法正常切换的，可以通过命令手动切换，上面的zed就是例子，zed需要用nvidia gpu的vulkan，</p>
<p>这里面有vulkan.opengl等等</p>
<p>###这个文档真的很有用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/ubuntu-nvidia.html" data-id="cm1s3lpib0000fkcxgc9d188z" data-title="ubuntu-nvidia" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ROS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/ROS.html" class="article-date">
  <time class="dt-published" datetime="2024-09-20T23:57:14.000Z" itemprop="datePublished">2024-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/ROS.html">ROS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240921180747237.png" alt="image-20240921180747237"></p>
<p><img src="/../images/image-20240922084731413.png" alt="image-20240922084731413"></p>
<p><em><strong>legged_control</strong></em></p>
<p>基于OCS2和ros-controls的非线性<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MPC&spm=1001.2101.3001.7020">MPC 1</a>与WBC框架</p>
<ul>
<li><strong>docs</strong> - 包含项目文档和说明。</li>
<li><strong>legged_common</strong> - 共享的数据结构和函数库。</li>
<li><strong>legged_control</strong> - 主控制堆栈的源码，实现了NMPC和WBC的核心算法。</li>
<li><strong>legged_controllers</strong> - 控制器的具体实现，如腿部运动模式控制器。</li>
<li><strong>legged_estimation</strong> - 估计相关的组件，可能涉及状态估计或传感器数据处理。</li>
<li><strong>legged_examples</strong> - 示例代码，可能含有特定机器人的示例配置或仿真设置。</li>
<li><strong>legged_gazebo</strong> - Gazebo仿真相关文件，用于虚拟环境中测试机器人。</li>
<li><strong>legged_hw</strong> - 硬件交互层，用于实际机器人的控制。</li>
<li><strong>legged_interface</strong> - 提供与机器人交互的API。</li>
<li><strong>legged_wbc</strong> - Whole Body Control的相关代码。</li>
<li><strong>qpoases_catkin</strong> - 可能是作为依赖项的QPOASES求解器的ROS集成。</li>
</ul>
<p>Ubuntu 20.04    </p>
<p>ROS noetic </p>
<p>catkin</p>
<p><em><strong>OCS2 是一个针对切换系统优化控制的 C++ 工具箱，适用于机器人任务，包括路径约束处理和 URDF 模型支持。它提供了高效算法如 SLQ、iLQR 和 SQP，并具有 ROS 接口。工具箱包含自动微分工具，确保在有限计算能力的机器人应用中实现数值稳定和高效控制。</strong></em></p>
<p>OCS2是一个大型单库项目；请<strong>不要</strong>尝试编译整个仓库。</p>
<p>URDF文件和YAML文件通常在 ROS 启动文件中被调用。具体步骤如下：</p>
<ol>
<li><p><strong>URDF 文件</strong>：</p>
<ul>
<li>在启动文件（<code>.launch</code>）中使用 <code>&lt;param&gt;</code> 标签将 URDF 文件加载到参数服务器：<pre><code class="xml">&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro $(find your_package)/urdf/your_robot.urdf.xacro&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>YAML 文件</strong>：</p>
<ul>
<li>也可以在启动文件中使用 <code>&lt;rosparam&gt;</code> 标签加载 YAML 文件：<pre><code class="xml">&lt;rosparam file=&quot;$(find your_package)/config/your_config.yaml&quot; command=&quot;load&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>节点中访问</strong>：</p>
<ul>
<li>在你的 ROS 节点代码中，可以通过 <code>ros::param::get()</code> 或 <code>ros::NodeHandle</code> 来访问这些参数。</li>
</ul>
</li>
</ol>
<p>这样，URDF 和 YAML 文件就能在你的 ROS 项目中被有效地调用和使用。</p>
<pre><code>&lt;geometry&gt;  &lt;!--几何形状--&gt;
</code></pre>
<pre><code>&lt;inertial&gt;      &lt;!--惯性属性--&gt;
</code></pre>
<pre><code>&lt;joint name=&quot;world_to_slideBar&quot; type=&quot;fixed&quot;&gt;  &lt;!--这个关节用于将 slideBar 固定在世界坐标系中的特定位置，使得它在仿真中保持稳定，提供支撑作用。--&gt;
    &lt;parent link=&quot;world&quot;/&gt;
    &lt;child link=&quot;slideBar&quot;/&gt;
    &lt;origin xyz=&quot;0.0 0.0 2.0&quot;/&gt;
&lt;/joint&gt;
</code></pre>
<pre><code>&lt;gazebo reference=&quot;slideBar&quot;&gt;
</code></pre>
<ul>
<li><strong>Gazebo特定属性</strong>: 用于指定该链接在 Gazebo 中的特性。</li>
</ul>
<p>​     <code>&lt;mass value=&quot;0.1&quot;/&gt;</code></p>
<ul>
<li><strong>质量</strong>: 指定了链接的质量为 0.1 千克</li>
</ul>
<h4 id="位置"><a href="#位置" class="headerlink" title="&lt;origin&gt;  位置"></a><code>&lt;origin&gt;</code>  位置</h4><p><img src="/../images/image-20240924221522926.png" alt="image-20240924221522926"></p>
<p>自由度通俗的讲就是为了唯一确定一个机构的运动状态所必须的独立变量的个数</p>
<p><img src="/../images/image-20240925083033316.png" alt="image-20240925083033316"></p>
<p><img src="/../images/image-20240925085251799.png" alt="image-20240925085251799"></p>
<p>c12&#x3D;cos(seta1+seta2 )</p>
<p><img src="/../images/image-20240925085203224.png" alt="image-20240925085203224"></p>
<p><img src="/../images/image-20240925090201537.png" alt="image-20240925090201537"></p>
<p><img src="/../images/image-20240925091223929.png" alt="image-20240925091223929"></p>
<p><img src="/../images/image-20240925123003125.png" alt="image-20240925123003125"></p>
<pre><code>&lt;joint name=&quot;base_to_plat&quot; type=&quot;prismatic&quot;&gt;
    &lt;axis xyz=&quot;1 0 0&quot;/&gt;
    &lt;origin xyz=&quot;0.0 0.0 0.0&quot;/&gt;
    &lt;parent link=&quot;slideBar&quot;/&gt;
    &lt;child link=&quot;cart&quot;/&gt;
    &lt;limit effort=&quot;100000.0&quot; lower=&quot;-15&quot; upper=&quot;15&quot; velocity=&quot;100&quot;/&gt;
    &lt;dynamics damping=&quot;0.0&quot; friction=&quot;0.0&quot;/&gt;
&lt;/joint&gt;
</code></pre>
<p>是什么意思</p>
<p>这段代码定义了一个名为 <code>base_to_plat</code> 的滑动关节（prismatic joint），其主要功能是让 <code>cart</code> 在 <code>slideBar</code> 上进行线性滑动。以下是对每个部分的详细解释：</p>
<h3 id="1"><a href="#1" class="headerlink" title="1. &lt;joint name=&quot;base_to_plat&quot; type=&quot;prismatic&quot;&gt;"></a>1. <code>&lt;joint name=&quot;base_to_plat&quot; type=&quot;prismatic&quot;&gt;</code></h3><ul>
<li><strong>名称和类型</strong>:<ul>
<li><code>name=&quot;base_to_plat&quot;</code>: 该关节的名称是 <code>base_to_plat</code>。</li>
<li><code>type=&quot;prismatic&quot;</code>: 关节类型为滑动关节，允许连接的部分沿一个轴线性移动。</li>
</ul>
</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2. &lt;axis xyz=&quot;1 0 0&quot;/&gt;"></a>2. <code>&lt;axis xyz=&quot;1 0 0&quot;/&gt;</code></h3><ul>
<li><strong>运动轴</strong>:<ul>
<li><code>xyz=&quot;1 0 0&quot;</code>: 表示滑动关节的运动轴为 X 轴。<code>1</code> 表示在 X 方向上有运动，而 Y 和 Z 方向上没有运动。</li>
</ul>
</li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3. &lt;origin xyz=&quot;0.0 0.0 0.0&quot;/&gt;"></a>3. <code>&lt;origin xyz=&quot;0.0 0.0 0.0&quot;/&gt;</code></h3><ul>
<li><strong>原点位置</strong>:<ul>
<li><code>xyz=&quot;0.0 0.0 0.0&quot;</code>: 该关节的原点位置设置在 (0, 0, 0)，通常是关节的中心点。</li>
</ul>
</li>
</ul>
<h3 id="4"><a href="#4" class="headerlink" title="4. &lt;parent link=&quot;slideBar&quot;/&gt;"></a>4. <code>&lt;parent link=&quot;slideBar&quot;/&gt;</code></h3><ul>
<li><strong>父链接</strong>:<ul>
<li><code>link=&quot;slideBar&quot;</code>: 指定 <code>slideBar</code> 是该关节的父链接。也就是说，<code>cart</code> 相对于 <code>slideBar</code> 移动。</li>
</ul>
</li>
</ul>
<h3 id="5"><a href="#5" class="headerlink" title="5. &lt;child link=&quot;cart&quot;/&gt;"></a>5. <code>&lt;child link=&quot;cart&quot;/&gt;</code></h3><ul>
<li><strong>子链接</strong>:<ul>
<li><code>link=&quot;cart&quot;</code>: 指定 <code>cart</code> 是该关节的子链接。表示 <code>cart</code> 将通过该关节的运动影响到。</li>
</ul>
</li>
</ul>
<h3 id="6"><a href="#6" class="headerlink" title="6. &lt;limit effort=&quot;100000.0&quot; lower=&quot;-15&quot; upper=&quot;15&quot; velocity=&quot;100&quot;/&gt;"></a>6. <code>&lt;limit effort=&quot;100000.0&quot; lower=&quot;-15&quot; upper=&quot;15&quot; velocity=&quot;100&quot;/&gt;</code></h3><ul>
<li><strong>运动限制</strong>:<ul>
<li><code>effort=&quot;100000.0&quot;</code>: 该关节能够承受的最大力为 100,000（单位通常为牛顿）。</li>
<li><code>lower=&quot;-15&quot;</code>: 关节的最小位置限制为 -15（单位通常为米），表示 <code>cart</code> 可以向后滑动的最大距离。</li>
<li><code>upper=&quot;15&quot;</code>: 关节的最大位置限制为 15（单位通常为米），表示 <code>cart</code> 可以向前滑动的最大距离。</li>
<li><code>velocity=&quot;100&quot;</code>: 关节的最大速度为 100（单位通常为米&#x2F;秒），表示 <code>cart</code> 的移动速度限制。</li>
</ul>
</li>
</ul>
<h3 id="7"><a href="#7" class="headerlink" title="7. &lt;dynamics damping=&quot;0.0&quot; friction=&quot;0.0&quot;/&gt;"></a>7. <code>&lt;dynamics damping=&quot;0.0&quot; friction=&quot;0.0&quot;/&gt;</code></h3><ul>
<li><strong>动力学属性</strong>:<ul>
<li><code>damping=&quot;0.0&quot;</code>: 阻尼系数为 0，表示没有额外的阻力影响滑动。</li>
<li><code>friction=&quot;0.0&quot;</code>: 摩擦系数为 0，表示在滑动过程中没有摩擦力。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段代码的主要目的是定义一个滑动关节，使得 <code>cart</code> 可以在 X 轴上滑动，受到的限制和动力学特性被明确设定。这在机器人和机械模拟中是非常重要的，可以精确控制其运动行为。</p>
<pre><code>&lt;transmission name=&quot;tran2&quot;&gt;
    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
    &lt;joint name=&quot;base_to_plat&quot;&gt;
        &lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;
    &lt;/joint&gt;
    &lt;actuator name=&quot;planar_motor_2&quot;&gt;
        &lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;
        &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;
    &lt;/actuator&gt;
&lt;/transmission&gt;
</code></pre>
<p>是什么意思</p>
<p>这段代码定义了一个名为 <code>tran2</code> 的传动系统，主要用于连接一个滑动关节和一个执行器。以下是各部分的解释：</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1. &lt;transmission name=&quot;tran2&quot;&gt;"></a>1. <code>&lt;transmission name=&quot;tran2&quot;&gt;</code></h3><ul>
<li><strong>传动系统名称</strong>: 这个传动系统被命名为 <code>tran2</code>。</li>
</ul>
<h3 id="2-transmission-interface-SimpleTransmission"><a href="#2-transmission-interface-SimpleTransmission" class="headerlink" title="2. &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;"></a>2. <code>&lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;</code></h3><ul>
<li><strong>传动类型</strong>: 使用简单传动接口，表明传动的实现相对直接。</li>
</ul>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3. &lt;joint name=&quot;base_to_plat&quot;&gt;"></a>3. <code>&lt;joint name=&quot;base_to_plat&quot;&gt;</code></h3><ul>
<li><strong>关节连接</strong>: 连接到先前定义的滑动关节 <code>base_to_plat</code>。</li>
</ul>
<h3 id="4-hardware-interface-EffortJointInterface"><a href="#4-hardware-interface-EffortJointInterface" class="headerlink" title="4. &lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;"></a>4. <code>&lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;</code></h3><ul>
<li><strong>硬件接口</strong>: 该关节使用的是努力关节接口，意味着通过施加力来控制关节运动。</li>
</ul>
<h3 id="5-1"><a href="#5-1" class="headerlink" title="5. &lt;actuator name=&quot;planar_motor_2&quot;&gt;"></a>5. <code>&lt;actuator name=&quot;planar_motor_2&quot;&gt;</code></h3><ul>
<li><strong>执行器名称</strong>: 该传动系统连接的执行器名为 <code>planar_motor_2</code>。</li>
</ul>
<h3 id="6-1"><a href="#6-1" class="headerlink" title="6. &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;"></a>6. <code>&lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;</code></h3><ul>
<li><strong>机械减速比</strong>: 设置为 1，表示执行器的输出与输入之间没有减速，直接传递力。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>整体上，这段代码用于定义一个简单的传动系统，将滑动关节和电机连接起来，以便通过施加力来控制滑动运动。</p>
<h5 id="JointState-消息内容"><a href="#JointState-消息内容" class="headerlink" title="JointState 消息内容"></a><code>JointState</code> 消息内容</h5><p><code>JointState</code> 消息通常包含以下字段：</p>
<ul>
<li><strong><code>name</code></strong>: 存储关节名称的字符串数组。</li>
<li><strong><code>position</code></strong>: 存储每个关节当前角度或位置的浮点数数组。</li>
<li><strong><code>velocity</code></strong>: 存储每个关节当前速度的浮点数数组。</li>
<li><strong><code>effort</code></strong>: 存储每个关节当前力矩或用力程度的浮点数数组。</li>
</ul>
<p><img src="/../images/image-20240927144924380.png" alt="image-20240927144924380"></p>
<p>LQR（线性二次调节器，Linear Quadratic Regulator）是一种用于控制系统的优化方法。它旨在通过最小化某个代价函数来设计控制器，通常用于线性动态系统。</p>
<h3 id="LQR-的基本公式"><a href="#LQR-的基本公式" class="headerlink" title="LQR 的基本公式"></a>LQR 的基本公式</h3><p>假设有一个线性系统描述为：<br>$ \dot{x} &#x3D; Ax + Bu $<br>其中：</p>
<ul>
<li>( x ) 是状态向量</li>
<li>( u ) 是控制输入</li>
<li>( A ) 和 ( B ) 是系统矩阵</li>
</ul>
<p>LQR 通过最小化以下代价函数来设计控制器：<br>$ J &#x3D; \int_0^{\infty} (x^T Q x + u^T R u) , dt $<br>其中：</p>
<ul>
<li>( Q ) 是状态权重矩阵，通常是半正定的$(Q \geq 0 )$</li>
<li>( R ) 是控制输入权重矩阵，通常是正定的（$ R &gt; 0 $）</li>
</ul>
<h3 id="最优控制律"><a href="#最优控制律" class="headerlink" title="最优控制律"></a>最优控制律</h3><p>通过求解代价函数的最小值，可以得到最优控制律：<br>$ u &#x3D; -Kx $<br>其中 $K $是增益矩阵，通过以下公式计算：<br>$K &#x3D; R^{-1} B^T P $<br>而$  P $ 是 Riccati 方程的解：<br>$A^T P + PA - PBR^{-1}B^T P + Q &#x3D; 0 $ </p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>LQR 方法通过设计一个控制器，最小化系统状态和控制输入的加权平方和，从而实现对线性系统的有效控制。它广泛应用于工程、自动控制、机器人等领域。</p>
<h3 id="代码实现过程"><a href="#代码实现过程" class="headerlink" title="代码实现过程"></a>代码实现过程</h3><p>在你提供的代码中，LQR控制器的设计过程主要包含以下几个步骤：</p>
<ol>
<li><p><strong>逆矩阵计算</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;double, 1, 1&gt; R_inv = R_.inverse();
</code></pre>
<p>这里计算了控制输入权重矩阵 (R) 的逆。</p>
</li>
<li><p><strong>计算 BRB 项</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;double, 4, 4&gt; BRB = B_ * R_inv(0, 0) * B_.transpose();
</code></pre>
<p>这一步计算了 $BR^{-1}B^T$项，用于构建哈密尔顿矩阵。</p>
</li>
<li><p><strong>构造哈密尔顿矩阵</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;do	uble, 8, 8&gt; H;
H.topLeftCorner(4, 4) = A_;
H.topRightCorner(4, 4) = -BRB;
H.bottomLeftCorner(4, 4) = -Q_;
H.bottomRightCorner(4, 4) = -A_.transpose();
</code></pre>
<p>哈密尔顿矩阵 (H) 是 LQR 解的核心部分，它结合了系统的动态矩阵 (A)、控制输入矩阵 (B) 和权重矩阵 (Q) 和 (R)。</p>
</li>
<li><p><strong>特征值和特征向量计算</strong>：</p>
<pre><code class="cpp">Eigen::ComplexEigenSolver&lt;Eigen::Matrix&lt;double, 8, 8&gt;&gt; ces;
ces.compute(H);
</code></pre>
<p>通过计算哈密尔顿矩阵的特征值和特征向量来获取系统的稳定性信息。</p>
</li>
<li><p><strong>选择稳定特征向量</strong>：</p>
<pre><code class="cpp">for (int i = 0; i &lt; 8; ++i)
&#123;
    if (eigenvalues(i).real() &lt; 0 &amp;&amp; index &lt; 4)
    &#123;
        Vs.col(index) = eigenvectors.col(i);
        ++index;
    &#125;
&#125;
</code></pre>
<p>选择具有负实部的特征值对应的特征向量，以确保系统的稳定性。</p>
</li>
<li><p><strong>解Ricatti方程</strong>：</p>
<pre><code class="cpp">Eigen::MatrixXcd P_c = Vs2 * Vs1.inverse();
Eigen::Matrix4d P = P_c.real(); // Take the real part
</code></pre>
<p>通过特征向量计算 Riccati 方程的解 (P)，这是 LQR 控制中的关键步骤。</p>
</li>
<li><p><strong>计算 LQR 增益矩阵</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;double, 1, 4&gt; K_temp = R_inv(0, 0) * B_.transpose() * P;
return K_temp.transpose();
</code></pre>
<p>最后计算控制增益矩阵 (K)，该矩阵用于生成控制输入。</p>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>LQR 控制器的实现通过构造哈密尔顿矩阵，计算其特征值和特征向量，求解 Riccati 方程，最终得到一个最优控制增益 (K)。通过这种方式，LQR 能够有效地平衡系统的性能和控制输入，以保证系统的稳定性和响应速度。</p>
<p><code>Eigen::MatrixXd</code> 和 <code>Eigen::Matrix4d</code> 是 Eigen 库中用于表示矩阵的两种不同类型。它们的主要区别如下：</p>
<h3 id="1-尺寸"><a href="#1-尺寸" class="headerlink" title="1. 尺寸"></a>1. 尺寸</h3><ul>
<li><strong><code>Eigen::MatrixXd</code></strong>:<ul>
<li>这是一个动态大小的矩阵，表示一个任意大小的矩阵。</li>
<li>在运行时可以根据需要动态调整其行数和列数。</li>
</ul>
</li>
<li><strong><code>Eigen::Matrix4d</code></strong>:<ul>
<li>这是一个固定大小的矩阵，专门表示一个 <strong>4x4</strong> 的矩阵。</li>
<li>行数和列数在编译时就已经确定，不能被更改。</li>
</ul>
</li>
</ul>
<h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><ul>
<li><strong><code>Eigen::MatrixXd</code></strong>:<ul>
<li>由于是动态大小，内存分配通常是在堆上进行管理，可能会有额外的开销。</li>
</ul>
</li>
<li><strong><code>Eigen::Matrix4d</code></strong>:<ul>
<li>由于大小固定，内存分配是静态的，通常在栈上分配，性能更高，尤其在小矩阵操作时。</li>
</ul>
</li>
</ul>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul>
<li><strong><code>Eigen::MatrixXd</code></strong>:<ul>
<li>适合处理不确定大小的矩阵，特别是在算法中需要处理各种尺寸的情况时。</li>
</ul>
</li>
<li><strong><code>Eigen::Matrix4d</code></strong>:<ul>
<li>适合处理明确为 <strong>4x4</strong> 矩阵的场景，如图形变换、旋转矩阵等。</li>
</ul>
</li>
</ul>
<p>###ubuntu上ros与anaconda冲突的最好解决办法：</p>
<pre><code>catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3
</code></pre>
<p>下次再安装ros时，在anaconda环境里安装，要不然python混乱太搞了</p>
<p>现在有更好的方法：</p>
<pre><code class="bash">export PATH=&quot;/usr/bin:$PATH&quot;
</code></pre>
<pre><code class="bash">zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ which python
/usr/local/anaconda3/bin/python
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ which python3
/usr/local/anaconda3/bin/python3
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ sudo vim ~/.bashrc
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ source ~/.bashrc
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ which python3
/usr/bin/python3
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ which python
/usr/bin/python
zgh@zgh-Legion-Y7000P-IAH7:~/ROS_Projects/dog_gazebo$ python -V
Python 3.8.10
</code></pre>
<p>完美解決</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/ROS.html" data-id="cm1bdrnch0001vzcxgetpe45n" data-title="ROS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ODriver" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/ODriver.html" class="article-date">
  <time class="dt-published" datetime="2024-09-06T02:16:53.000Z" itemprop="datePublished">2024-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/ODriver.html">ODriver</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>共有PWM模块、ADC电流采集、定时器编码器配置、SVPWM模块、FOC核心、PID模块、电压限幅模块，其实有了PWM与SVPWM以及一些必要的数学变换，我们就可以开环使电机转起来了，加入电角度与电流采集作为反馈后，我们就能做到电流闭环，再加入速度PID就可以做到速度闭环，其他的模块只是这些目的的辅助手段罢了</p>
<p> 一、编码器的分类</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">按工作原理的不同可分为增量型和绝对值型。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">(1) 增量型 （增量式可以理解为信号即位移的增加，需要参考量）</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8"> 增量式编码器的原理是将位移转换成周期性的电信号，再把这个电信号转变成计数脉冲，用脉冲的个数表示位移的大小。增量式编码器转轴旋转时，有相应的脉冲输出，其旋转方向的判别和脉冲数量的增减借助后部的判向电路和计数器来实现。其计数起点任意设定，可实现多圈无限累加和测量。还可以把每转发出一个脉冲的Z信号，作为参考机械零位。编码器轴转一圈会输出固定的脉冲，脉冲数由编码器光栅的线数决定。需要提高分辨率时，可利用 90 度相位差的 A、B两路信号对原脉冲数进行倍频，或者更换高分辨率编码器。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8"> 简单来说，增量型编码器总共有三种相线输出，A相、B相、Z相。其中电机每转过一定的角度，A相和B相就输出一个脉冲，且A相和B相相互延迟1/4周期，电机的正反转就是根据A相和B相的延迟关系判断的。Z相为单圈脉冲，即每转一圈输出一个脉冲，可以作为参考机械零位。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">(2) 绝对型（直接输出数字量的传感器，不需要参考量）</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">绝对编码器光码盘上有许多道光通道刻线，每道刻线依次以2线、4线、8线、16线编排，这样，在编码器的每一个位置，通过读取每道刻线的通、暗，获得一组从2的零次方到2的n-1次方的唯一的2进制编码（格雷码），这就称为n位绝对编码器。这样的编码器是由光电码盘进行记忆的。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">简单来说，就是对应一圈，电机的每个角度都有一个与该角度对应二进制的数值，且这个数值不会改变，所以称为绝对型编码器。</span></span></code></pre></div><p>二、不同编码器的优缺点及其对应应用范围</p>
<p>   增量型：</p>
<p>增量式编码器十分合适测速度，可无限累加丈量<br>是存在零点累计差错，抗干扰较差，接纳设备的停机需断电回忆<br>增量式编码器的一般应用测速，测转动方向，测移动角度、距离(相对)。</p>
<p>   绝对型：</p>
<p>发生电源故障也不丢失轴位置<br>绝对式编码器十分适合测量位置，可直接输出<br>绝对编码器一般能够以 8 到 12位输出 360 °更精确，但也更昂贵</p>
<h2 id="0、系统配置"><a href="#0、系统配置" class="headerlink" title="0、系统配置"></a>0、系统配置</h2><h2 id="1、电机有力了！（PWM模块）"><a href="#1、电机有力了！（PWM模块）" class="headerlink" title="1、电机有力了！（PWM模块）"></a>1、电机有力了！（PWM模块）</h2><p>高级定时器主要用于产生6路互补的PWM来驱动MOS管，加入死区防止电源导通，本文未使用刹车引脚。高级定时器1通道1、2、3用于产生PWM，通道4用于触发ADC电流采样，根据扇区的位置，灵活设置PWM占空比，进而选择合理的触发点，避免在噪声点采样。引脚配置与PWM极性请根据自己的硬件合理配置，如IR2101是高电平有效，而IR2103则是低端低有效，高端高有效。</p>
<p>定时器从0开始向上计数 当0-t1段,定时器计数器TIMx_CNT值小于CCRx值,输出低电平 t1-t2段,定时器计数器TIMx_CNT值大于CCRx值,输出高电平 当TIMx_CNT值达到ARR时,定时器溢出,重新向上计数…循环此过程 至此一个PWM周期完成</p>
<p>TIMx_ARR寄存器确定PWM频率，<br>TIMx_CCRx寄存器确定占空比</p>
<p><img src="/../images/image-20240907102129162.png" alt="image-20240907102129162"></p>
<p>LED等推挽输出</p>
<p><img src="/../images/image-20240909104907079.png" alt="image-20240909104907079"></p>
<p><img src="/../images/image-20240909105404369.png" alt="image-20240909105404369"></p>
<p><img src="/../images/image-20240909105448227.png" alt="image-20240909105448227"></p>
<p><img src="/../images/image-20240909105833521.png" alt="image-20240909105833521"></p>
<p><img src="/../images/image-20240910132838967.png" alt="image-20240910132838967"></p>
<p><img src="/../images/image-20240910132746715.png" alt="image-20240910132746715"></p>
<p><img src="/../images/image-20240910132952045.png" alt="image-20240910132952045"></p>
<p><img src="/../images/v2-49051363300bd5ea2f30d5391c784ece_720w.webp" alt="img"></p>
<p><img src="/../images/image-20240915213051309.png" alt="image-20240915213051309"></p>
<p><img src="/../images/image-20240915213823875.png" alt="image-20240915213823875"></p>
<p><img src="/../images/image-20240915214652354.png" alt="image-20240915214652354"></p>
<p><img src="/../images/image-20240916160612586.png" alt="image-20240916160612586"></p>
<p><img src="/../images/image-20240916161725535.png" alt="image-20240916161725535"></p>
<p>使用opencv进行颜色识别时受光照影响很大怎么办?<br>1.白平衡算法</p>
<p>2.对于图像数据受到光照度不足或者曝光引起的对比度太小的情况，在图像处理中一般是图像直方图均衡化的方法来处理。直方图均衡化是通过拉伸像素强度分布范围来增强图像对比度的一种方法。例如，更亮的图像将所有像素限制在高值。但是一个好的图像会有来自图像所有区域的像素。因此，我们需要将这个直方图扩展到两端，而这就是直方图均衡化所做的事情(用简单的话来说)。这通常会改善图像的对比度。<br><strong>全局直方图均衡化</strong>,<strong>自适应局部直方图均衡化</strong></p>
<h6 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值?"></a>自适应阈值?</h6><p>- </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/ODriver.html" data-id="cm1bdrncg0000vzcx2kspdeqb" data-title="ODriver" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Cplusplus" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Cplusplus.html" class="article-date">
  <time class="dt-published" datetime="2024-08-21T15:35:17.000Z" itemprop="datePublished">2024-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Cplusplus.html">Cplusplus</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="模版元编程与函数式"><a href="#模版元编程与函数式" class="headerlink" title="模版元编程与函数式"></a>模版元编程与函数式</h3><p><img src="/../images/image-20240808230648900.png" alt="image-20240808230648900"></p>
<p><img src="/../images/image-20240820160811024.png" alt="image-20240820160811024"></p>
<p>template <typename T></p>
<p><img src="/../images/image-20240820162244999.png" alt="image-20240820162244999"></p>
<p><img src="/../images/image-20240820162358151.png" alt="image-20240820162358151"></p>
<p><code>std::enable_if</code> 是 C++ 标准库中的一个模板工具，通常用于实现 SFINAE（Substitution Failure Is Not An Error）技术。它位于 <code>&lt;type_traits&gt;</code> 头文件中，用于在模板编程中根据条件启用或禁用模板的实例化。</p>
<ul>
<li><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>std::enable_if</code> 的基本结构如下：</p>
<pre><code class="cpp">template &lt;bool B, typename T = void&gt;
struct enable_if &#123;
  using type = T;
&#125;;

template &lt;typename T&gt;
struct enable_if&lt;false, T&gt; &#123;
  // 这个结构体是未定义的
&#125;;
</code></pre>
</li>
<li><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3></li>
<li><p><strong><code>std::enable_if</code> 主要有两个模板参数</strong>：</p>
<ul>
<li><code>B</code>：一个布尔值（通常是编译时常量表达式），用于决定 <code>type</code> 成员是否有效。</li>
<li><code>T</code>：一个默认类型（默认为 <code>void</code>），当 <code>B</code> 为真时，<code>type</code> 成员将定义为 <code>T</code>。</li>
</ul>
</li>
<li><p><strong>当 <code>B</code> 为真时</strong>，<code>std::enable_if</code> 的 <code>type</code> 成员被定义为 <code>T</code>。这意味着我们可以使用 <code>std::enable_if</code> 的 <code>type</code> 来在模板中进行条件判断。</p>
</li>
<li><p><strong>当 <code>B</code> 为假时</strong>，<code>std::enable_if</code> 的 <code>type</code> 成员没有定义。尝试使用这种情况下的 <code>type</code> 成员会导致编译错误，从而使得该模板实例化失败。这样可以用来控制模板的选择和重载。</p>
</li>
<li><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个使用 <code>std::enable_if</code> 的示例，演示如何根据类型的特性来启用或禁用函数模板：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

// 用于启用整数类型的模板函数
template&lt;typename T&gt;
typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type
printType() &#123;
  std::cout &lt;&lt; &quot;Integral type\n&quot;;
&#125;

// 用于启用非整数类型的模板函数
template&lt;typename T&gt;
typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value, void&gt;::type
printType() &#123;
  std::cout &lt;&lt; &quot;Non-integral type\n&quot;;
&#125;

int main() &#123;
  printType&lt;int&gt;();    // 输出: Integral type
  printType&lt;double&gt;(); // 输出: Non-integral type
  return 0;
&#125;
</code></pre>
<p>在这个示例中：</p>
</li>
<li><p><code>printType&lt;int&gt;()</code> 会选择第一个模板版本，因为 <code>int</code> 是整数类型。</p>
</li>
<li><p><code>printType&lt;double&gt;()</code> 会选择第二个模板版本，因为 <code>double</code> 不是整数类型。</p>
</li>
<li><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3></li>
<li><p><strong>编译时替换</strong>：<code>std::enable_if</code> 根据布尔表达式 <code>B</code> 的值来决定是否定义 <code>type</code> 成员。</p>
</li>
<li><p><strong>条件启用</strong>：在模板参数中使用 <code>std::enable_if</code> 可以有效地启用或禁用某些模板实例化。</p>
</li>
<li><p><strong>SFINAE</strong>：如果 <code>B</code> 为假，<code>type</code> 成员未定义，尝试实例化使用 <code>type</code> 的模板将导致编译错误，从而引发 SFINAE 机制。</p>
<p>通过这种方式，<code>std::enable_if</code> 可以帮助实现条件模板选择，使得模板编程更加灵活和强大。</p>
<p><img src="/../images/image-20240820163258259.png" alt="image-20240820163258259"></p>
<p>模板的参数可以作为编译器常量，可以自动优化</p>
<p><img src="/../images/image-20240820163542636.png" alt="image-20240820163542636"></p>
<p><img src="/../images/image-20240820163702315.png" alt="image-20240820163702315"></p>
<p><img src="/../images/image-20240820163833807.png" alt="image-20240820163833807"></p>
<p>N变一次，编译器就会重新实例化一遍模版函数，编译就变慢</p>
<p>模版函数必须定义在同一个文件里才能使用（必须是内联的或者在头文件里的），所以模板函数的定义和实现无法分离，因此除非特殊手段，模板函数的定义和实现必须放到头文件里。</p>
<p>模板函数太多会导致头文件非常大。</p>
<p>模板函数内联要加static</p>
<p><img src="/../images/image-20240821074758660.png" alt="image-20240821074758660">{:height 34, :width 232}</p>
<p><img src="/../images/image-20240821075058309.png" alt="image-20240821075058309"></p>
<p><img src="/../images/image-20240821080547610.png" alt="image-20240821080547610"></p>
<p><img src="/../images/image-20240821080851591.png" alt="image-20240821080851591"></p>
<p><code>if constexpr</code> 是 C++17 中引入的一种编译时条件语句。它允许在编译时根据条件选择代码路径，从而避免在运行时进行条件判断。与传统的 <code>if</code> 语句不同，<code>if constexpr</code> 在编译时会根据条件是否为 <code>true</code> 来决定是否编译相应的代码块。</p>
<p>举个例子：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

template &lt;typename T&gt;
void print_type() &#123;
  if constexpr (std::is_integral&lt;T&gt;::value) &#123;
      std::cout &lt;&lt; &quot;Integral type&quot; &lt;&lt; std::endl;
  &#125; else &#123;
      std::cout &lt;&lt; &quot;Non-integral type&quot; &lt;&lt; std::endl;
  &#125;
&#125;

int main() &#123;
  print_type&lt;int&gt;();    // 输出 &quot;Integral type&quot;
  print_type&lt;double&gt;(); // 输出 &quot;Non-integral type&quot;
&#125;
</code></pre>
<p>在这个例子中，<code>if constexpr</code> 会在编译时检查 <code>std::is_integral&lt;T&gt;::value</code> 是否为 <code>true</code>，然后编译对应的代码块。这使得 <code>print_type</code> 函数的行为在编译时就被确定下来，从而避免了在运行时的类型检查。</p>
<p><img src="/../images/image-20240821081339456.png" alt="image-20240821081339456"></p>
<p><img src="/../images/image-20240821082517892.png" alt="image-20240821082517892"></p>
<p><img src="/../images/image-20240821082721689.png" alt="image-20240821082721689"></p>
<p><img src="/../images/image-20240821090104734.png" alt="image-20240821090104734"></p>
<p><img src="/../images/image-20240821090237051.png" alt="image-20240821090237051"></p>
<p><img src="/../images/image-20240821090714458.png" alt="image-20240821090714458">但是这样要把模板实例化的，每一种	情况都声明</p>
<p>所以，尽量不要把模板分离</p>
<p><img src="/../images/image-20240821091734245.png" alt="image-20240821091734245">延迟编译：当一个函数定义在头文件里，可能用不到，可以在前面加 template  <class T = void>这个假模板，只有被调用的时候才会被编译</p>
<p><img src="/../images/image-20240821093416355.png" alt="image-20240821093416355"></p>
<p>可以把函数的信息打印出来</p>
<p><img src="/../images/image-20240821094441153.png" alt="image-20240821094441153"></p>
<p><img src="/../images/image-20240821094522021.png" alt="image-20240821094522021"></p>
<p><img src="/../images/image-20240821094700080.png" alt="image-20240821094700080"></p>
<p><img src="/../images/image-20240821095549768.png" alt="image-20240821095549768"></p>
<p>c++里的引用（int &amp;）相当于C里面的指针（int*）</p>
<p><img src="/../images/image-20240821145117646.png" alt="image-20240821145117646">引用没有空，指针可以空</p>
<p>auto &amp;  auto const &amp; 也可</p>
<p><img src="/../images/image-20240821150609535.png" alt="image-20240821150609535"></p>
<p>懒汉单例模式（Lazy Singleton）是一种设计模式，用于确保一个类只有一个实例，并提供一个全局访问点。与饿汉单例模式不同，懒汉单例模式会在需要实例时才进行初始化，因此被称为“懒汉”模式。</p>
</li>
<li><h3 id="懒汉单例模式的特点"><a href="#懒汉单例模式的特点" class="headerlink" title="懒汉单例模式的特点"></a>懒汉单例模式的特点</h3><ol>
<li><strong>延迟初始化</strong>：单例对象只有在第一次被使用时才会创建。</li>
<li><strong>线程安全问题</strong>：在多线程环境下，需要处理线程安全问题，以确保只有一个实例被创建。</li>
</ol>
</li>
<li><h3 id="懒汉单例模式的实现方式"><a href="#懒汉单例模式的实现方式" class="headerlink" title="懒汉单例模式的实现方式"></a>懒汉单例模式的实现方式</h3><p>下面是一个基本的懒汉单例模式的实现示例（不考虑线程安全）：</p>
<pre><code class="cpp">class Singleton &#123;
public:
  // 获取单例实例的静态方法
  static Singleton* getInstance() &#123;
      if (instance == nullptr) &#123;
          instance = new Singleton();
      &#125;
      return instance;
  &#125;

  // 禁止拷贝构造函数和赋值操作符
  Singleton(const Singleton&amp;) = delete;
  Singleton&amp; operator=(const Singleton&amp;) = delete;

private:
  // 私有构造函数
  Singleton() &#123;&#125;

  // 静态成员变量，用于存储唯一的实例
  static Singleton* instance;
&#125;;

// 静态成员变量的初始化
Singleton* Singleton::instance = nullptr;
</code></pre>
</li>
<li><h3 id="线程安全的实现"><a href="#线程安全的实现" class="headerlink" title="线程安全的实现"></a>线程安全的实现</h3><p>在多线程环境下，上述实现可能会导致线程安全问题，因此需要对其进行改进。可以使用互斥锁（<code>mutex</code>）来确保线程安全：</p>
<pre><code class="cpp">#include &lt;mutex&gt;

class Singleton &#123;
public:
  // 获取单例实例的静态方法
  static Singleton* getInstance() &#123;
      if (instance == nullptr) &#123;
          std::lock_guard&lt;std::mutex&gt; lock(mutex);
          if (instance == nullptr) &#123;
              instance = new Singleton();
          &#125;
      &#125;
      return instance;
  &#125;

  // 禁止拷贝构造函数和赋值操作符
  Singleton(const Singleton&amp;) = delete;
  Singleton&amp; operator=(const Singleton&amp;) = delete;

private:
  // 私有构造函数
  Singleton() &#123;&#125;

  // 静态成员变量，用于存储唯一的实例
  static Singleton* instance;
  // 互斥锁，用于保证线程安全
  static std::mutex mutex;
&#125;;

// 静态成员变量的初始化
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex;
</code></pre>
</li>
<li><h3 id="C-11-及以后的标准"><a href="#C-11-及以后的标准" class="headerlink" title="C++11 及以后的标准"></a>C++11 及以后的标准</h3><p>在C++11及以后的标准中，可以使用<code>std::call_once</code>来确保实例的唯一性，并提高线程安全性：</p>
<pre><code class="cpp">#include &lt;mutex&gt;

class Singleton &#123;
public:
  // 获取单例实例的静态方法
  static Singleton* getInstance() &#123;
      std::call_once(flag, []() &#123;
          instance.reset(new Singleton());
      &#125;);
      return instance.get();
  &#125;

  // 禁止拷贝构造函数和赋值操作符
  Singleton(const Singleton&amp;) = delete;
  Singleton&amp; operator=(const Singleton&amp;) = delete;

private:
  // 私有构造函数
  Singleton() &#123;&#125;

  // 静态成员变量，用于存储唯一的实例
  static std::unique_ptr&lt;Singleton&gt; instance;
  // 静态变量，用于确保单例实例只创建一次
  static std::once_flag flag;
&#125;;

// 静态成员变量的初始化
std::unique_ptr&lt;Singleton&gt; Singleton::instance;
std::once_flag Singleton::flag;
</code></pre>
<p>在这个实现中，<code>std::call_once</code> 和 <code>std::once_flag</code> 确保了即使在多线程环境中，单例对象也只会被创建一次。<code>std::unique_ptr</code> 自动管理内存，避免了手动释放内存的麻烦。</p>
<p>使用互斥锁（mutex）来确保线程安全时为什么只有锁：std::lock_guard<a href="std::mutex">std::mutex</a> lock(mutex); 没有解锁?</p>
<p>在使用 <code>std::lock_guard&lt;std::mutex&gt;</code> 时，解锁是由 <code>std::lock_guard</code> 自动处理的，而不需要显式地调用解锁操作。这是因为 <code>std::lock_guard</code> 是一个RAII（Resource Acquisition Is Initialization）风格的类，它的设计目的是简化互斥锁的管理并自动释放资源。</p>
</li>
<li><h3 id="RAII-和-std-lock-guard"><a href="#RAII-和-std-lock-guard" class="headerlink" title="RAII 和 std::lock_guard"></a>RAII 和 <code>std::lock_guard</code></h3><p>RAII 是一种编程习惯，确保资源（如内存、文件句柄、互斥锁等）的生命周期由对象的生命周期来管理。<code>std::lock_guard</code> 利用 RAII 原则来管理互斥锁的锁定和解锁：</p>
<ol>
<li><strong>构造函数</strong>：当 <code>std::lock_guard</code> 对象被创建时，它会在构造函数中自动锁定传递给它的 <code>std::mutex</code> 对象。</li>
<li><strong>析构函数</strong>：当 <code>std::lock_guard</code> 对象被销毁（即其作用域结束时），它的析构函数会自动释放（解锁）互斥锁。</li>
</ol>
<p>这种设计使得你不需要显式地编写解锁代码，降低了因为遗漏解锁操作而导致的潜在错误。</p>
</li>
<li><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3></li>
<li><p><code>std::lock_guard&lt;std::mutex&gt; lock(mutex);</code></p>
<p>：</p>
<ul>
<li>当执行到这行代码时，<code>lock</code> 对象会在构造函数中自动锁定 <code>mutex</code>。</li>
<li>当 <code>lock</code> 对象超出作用域（例如，<code>getInstance</code> 方法的执行结束时），<code>lock</code> 的析构函数会被调用，从而自动解锁 <code>mutex</code>。</li>
</ul>
</li>
<li><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li>
<li><p><strong>自动解锁</strong>：减少了因为忘记解锁导致的死锁问题。</p>
</li>
<li><p><strong>简化代码</strong>：不需要显式地管理锁的释放，使代码更加简洁和易于维护。</p>
</li>
<li><p><strong>异常安全</strong>：即使在 <code>getInstance</code> 方法中发生异常，<code>std::lock_guard</code> 也会确保互斥锁在 <code>lock</code> 对象被销毁时正确解锁，从而避免死锁。</p>
<p>通过 <code>std::lock_guard</code> 或其他类似的 RAII 风格的工具，C++ 提供了一种简洁而安全的方式来管理互斥锁，帮助程序员编写更健壮的多线程代码。</p>
<p><img src="/../images/image-20240821154750452.png" alt="image-20240821154750452"></p>
<p><img src="/../images/image-20240821155047037.png" alt="image-20240821155047037"></p>
</li>
</ul>
<p><img src="/../images/image-20240822093944038.png" alt="image-20240822093944038"></p>
<p>decltype(auto)和auto的区别</p>
<p><code>decltype(auto)</code> 和 <code>auto</code> 都用于类型推导，但它们有不同的行为：</p>
<ol>
<li><p><strong><code>auto</code></strong>:</p>
<ul>
<li>用于自动推导变量的类型。<code>auto</code> 根据表达式的值推导类型，不会保留表达式的引用性（即 <code>auto</code> 不会推导出引用类型，除非显式指定）。</li>
<li>例如，<code>auto x = 5;</code> 中，<code>x</code> 的类型是 <code>int</code>。</li>
</ul>
</li>
<li><p><strong><code>decltype(auto)</code></strong>:</p>
<ul>
<li>结合 <code>decltype</code> 和 <code>auto</code> 的特性。它推导出表达式的类型，包括引用（<code>decltype</code> 会保留表达式的原始类型）。</li>
<li>例如，<code>decltype(auto) y = (5);</code> 中，<code>y</code> 的类型是 <code>int&amp;</code>，因为 <code>(5)</code> 是一个左值引用。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>:</p>
<ul>
<li>使用 <code>auto</code> 时，结果类型是值类型。</li>
<li>使用 <code>decltype(auto)</code> 时，结果类型保持原表达式的类型，包括引用。</li>
</ul>
<p><img src="/../images/image-20240822094955233.png" alt="image-20240822094955233"></p>
<p><img src="/../images/image-20240822095110135.png" alt="image-20240822095110135"></p>
<p><img src="/../images/image-20240822095353349.png" alt="image-20240822095353349">T1{}创建一个T1的对象</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p><img src="/../images/image-20240822100310129.png" alt="image-20240822100310129"></p>
<p>函数作为参数传入另一个函数，实际传的是这个函数的起始地址</p>
<p><img src="/../images/image-20240822100649562.png" alt="image-20240822100649562"></p>
<p>确实相当于函数指针</p>
<p><img src="/../images/image-20240822100903926.png" alt="image-20240822100903926"></p>
<p><img src="/../images/image-20240822102642020.png" alt="image-20240822102642020"></p>
<p><img src="/../images/image-20240822102841702.png" alt="image-20240822102841702"></p>
<p><img src="/../images/image-20240822103024352.png" alt="image-20240822103024352"></p>
<p><img src="/../images/image-20240822103222797.png" alt="image-20240822103222797"></p>
<p><img src="/../images/image-20240822103620126.png" alt="image-20240822103620126"></p>
<p><img src="/../images/image-20240822103849124.png" alt="image-20240822103849124"></p>
<p><img src="/../images/image-20240822104300564.png" alt="image-20240822104300564"></p>
<p><img src="/../images/image-20240822142510370.png" alt="image-20240822142510370"></p>
<p><img src="/../images/image-20240822142730386.png" alt="image-20240822142730386"></p>
<p>###避免使用模板参数</p>
<p><img src="/../images/image-20240822143331265.png" alt="image-20240822143331265"></p>
<p>类型擦除技术：std::function容器</p>
<p><img src="/../images/image-20240822143825237.png" alt="image-20240822143825237"></p>
<p><img src="/../images/image-20240822145011740.png" alt="image-20240822145011740">但是没办法做部分特例化</p>
<p><img src="/../images/image-20240822145901194.png" alt="image-20240822145901194"></p>
<p><strong>立即调用 Lambda</strong>：在 lambda 表达式的定义后面加上 <code>()</code>，立即调用这个匿名函数。 lambda 表达式的返回值可以用于初始化变量或进行其他操作。</p>
<p><img src="/../images/image-20240822150515258.png" alt="image-20240822150515258"></p>
<p>可以利用return自带的break效果既实现break又赋值的效果</p>
<p><img src="/../images/image-20240822151844264.png" alt="image-20240822151844264"></p>
<p><img src="/../images/image-20240822152541777.png" alt="image-20240822152541777"></p>
<p><img src="/../images/image-20240822152759758.png" alt="image-20240822152759758"></p>
<p><img src="/../images/image-20240822153156878.png" alt="image-20240822153156878"></p>
<p><img src="/../images/image-20240822161836536.png" alt="image-20240822161836536"></p>
<p><img src="/../images/image-20240822162204007.png" alt="image-20240822162204007"></p>
<p>左值持久，右值短暂，左值有持久的状态，而右值要么是字面常量，要么是在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC&spm=1001.2101.3001.7020">表达式求值</a>过程中创建的临时对象(将要被销毁的对象)。</p>
<p>右值引用的好处是减少右值作为参数传递时的复制开销</p>
<p>使用std::move可以获得绑定到一个左值的右值引用</p>
<pre><code class="cpp">int intValue = 10;
int &amp;&amp;intValue3 = std::move(intValue);
</code></pre>
<p><code>decltype(auto)</code> 是 C++11 引入的一种类型推断工具，它结合了 <code>decltype</code> 和 <code>auto</code> 的特性，用于在声明变量时推断其类型。与 <code>auto</code> 不同，<code>decltype(auto)</code> 更精确地推断变量的类型，包括引用性。</p>
<ul>
<li><p><strong>用法</strong>：<code>decltype(auto)</code> 在声明变量时，会推断出表达式的确切类型，包括是否是引用类型。</p>
<pre><code class="cpp">int x = 10;
int&amp; ref = x;
decltype(auto) y = ref; // y 是 int&amp;，与 ref 类型相同
</code></pre>
</li>
<li><p><strong>区别</strong>：<code>auto</code> 只推断值类型，而 <code>decltype(auto)</code> 会保持原有的引用类型或常量性。</p>
<pre><code class="cpp">auto a = x;          // a 是 int
decltype(auto) b = x; // b 是 int，b 不是引用
decltype(auto) c = ref; // c 是 int&amp;，与 ref 类型相同
</code></pre>
</li>
</ul>
<p><strong>总结</strong>：<code>decltype(auto)</code> 在需要精确类型推断，包括引用时非常有用。</p>
<p>但是tuple容器的万能推导由于历史原因，不是decltype(auto),而是auto &amp;&amp;</p>
<p><img src="/../images/image-20240825111507625.png" alt="image-20240825111507625"></p>
<p><img src="/../images/image-20240825111624413.png" alt="image-20240825111624413"></p>
<p>结构化绑定的基本语法如下：</p>
<p>auto [var1, var2, var3] &#x3D; expression;</p>
<p><img src="/../images/image-20240825112136528.png" alt="image-20240825112136528"></p>
<p><img src="/../images/image-20240825154641671.png" alt="image-20240825154641671"></p>
<p><img src="/../images/image-20240825155359129.png" alt="image-20240825155359129"></p>
<p><img src="/../images/image-20240825155541735.png" alt="image-20240825155541735"></p>
<p><img src="/../images/image-20240826130922114.png" alt="image-20240826130922114">optional就像一个更安全的指针</p>
<p>在 C++ 中，<code>union</code> 是一种数据结构，它允许在同一内存位置存储不同的数据类型。<code>union</code> 的所有成员共享同一块内存区域，这意味着在任何给定时刻，<code>union</code> 只能存储一个成员的数据。使用 <code>union</code> 可以节省内存，特别是在需要存储多种不同类型但从不同时存储这些类型时。</p>
<h3 id="union-的基本语法"><a href="#union-的基本语法" class="headerlink" title="union 的基本语法"></a><code>union</code> 的基本语法</h3><pre><code class="cpp">union UnionName &#123;
    type1 member1;
    type2 member2;
    type3 member3;
    // more members
&#125;;
</code></pre>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><p><strong>内存共享</strong>：</p>
<ul>
<li><code>union</code> 中的所有成员共享同一块内存。因此，<code>union</code> 的大小由其最大成员的大小决定。</li>
</ul>
</li>
<li><p><strong>只能存储一个成员</strong>：</p>
<ul>
<li>虽然 <code>union</code> 可以定义多个成员，但在任何时刻只能存储一个成员的数据。写入一个成员会覆盖掉之前写入的成员的数据。</li>
</ul>
</li>
<li><p><strong>节省内存</strong>：</p>
<ul>
<li>因为所有成员共用一块内存，所以 <code>union</code> 可以节省内存，尤其是在只需要存储其中一个成员的数据时。</li>
</ul>
</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code class="cpp">#include &lt;iostream&gt;

union Data &#123;
    int intValue;
    float floatValue;
    char charValue;
&#125;;

int main() &#123;
    Data data;

    data.intValue = 5;
    std::cout &lt;&lt; &quot;intValue: &quot; &lt;&lt; data.intValue &lt;&lt; std::endl;

    data.floatValue = 3.14;
    std::cout &lt;&lt; &quot;floatValue: &quot; &lt;&lt; data.floatValue &lt;&lt; std::endl;

    data.charValue = &#39;A&#39;;
    std::cout &lt;&lt; &quot;charValue: &quot; &lt;&lt; data.charValue &lt;&lt; std::endl;

    // 访问数据会输出不确定的结果，因为各个成员共享同一内存
    std::cout &lt;&lt; &quot;intValue (after modifying to charValue): &quot; &lt;&lt; data.intValue &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p>在上面的示例中，<code>union</code> <code>Data</code> 可以存储 <code>int</code>, <code>float</code>, 和 <code>char</code> 三种数据类型，但它们共享同一块内存。当写入 <code>floatValue</code> 后，之前存储的 <code>intValue</code> 的数据会被覆盖，读取 <code>intValue</code> 会得到不可预测的结果。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p><strong>类型安全</strong>：</p>
<ul>
<li>使用 <code>union</code> 时要注意类型安全。读取当前未写入的成员数据可能会导致未定义的行为。</li>
</ul>
</li>
<li><p><strong>构造和析构</strong>：</p>
<ul>
<li><code>union</code> 允许只有一个成员的构造和析构。C++11 之后，<code>union</code> 可以包含具有非平凡构造函数、析构函数或拷贝&#x2F;移动操作符的成员，但这些操作必须在使用 <code>union</code> 的情况下正确处理。</li>
</ul>
</li>
<li><p><strong><code>std::variant</code> 替代</strong>：</p>
<ul>
<li>C++17 引入了 <code>std::variant</code>，这是一个更安全的替代 <code>union</code>，提供了类型安全的联合体和更丰富的功能。</li>
</ul>
</li>
</ul>
<p>总的来说，<code>union</code> 是一个低级数据结构，用于内存优化和处理不同类型的数据，但在实际编程中需谨慎使用。</p>
<p><img src="/../images/image-20240826131405785.png" alt="image-20240826131405785"></p>
<p><img src="/../images/image-20240826133023527.png" alt="image-20240826133023527"></p>
<p><img src="/../images/image-20240826133352602.png" alt="image-20240826133352602"></p>
<p><img src="/../images/image-20240826134549406.png" alt="image-20240826134549406"></p>
<p><img src="/../images/image-20240826135522792.png" alt="image-20240826135522792"></p>
<ul>
<li>使用 <code>auto</code> 作为参数类型实际上利用了 C++ 的模板机制，因为 <code>auto</code> 类型推断相当于模板类型参数的自动推导。虽然 lambda 本身不是一个模板，但它的参数使用 <code>auto</code> 实际上是利用了模板的类型推断机制。</li>
<li><code>[&amp;] (auto const &amp;t)&#123;&#125;</code> 使用了模板特性中的类型推断机制，通过 <code>auto</code> 使得 lambda 表达式能够处理多种不同类型的参数。这个功能在 C++11 及其后续版本中成为了更灵活、强大的工具，使得代码更加简洁和通用。</li>
</ul>
<p><img src="/../images/image-20240826140520404.png" alt="image-20240826140520404"></p>
<p><img src="/../images/image-20240826140928719.png" alt="image-20240826140928719"></p>
<h1 id="从汇编角度看编译器优化"><a href="#从汇编角度看编译器优化" class="headerlink" title="从汇编角度看编译器优化"></a>从汇编角度看编译器优化</h1><p>编译器是从源代码生成汇编语言</p>
<p><img src="/../images/image-20240826142543763.png" alt="image-20240826142543763"></p>
<p>RIP是当前执行的代码的地址</p>
<p>MMX，XMM，YMM都是用于储存浮点数的寄存器</p>
<p>把局部变量放入寄存器，读写就更快了</p>
<p>rsp代表堆栈：      -4（%rsp）其中-代表是堆栈上的某一个地址</p>
<p><img src="/../images/image-20240826143356174.png" alt="image-20240826143356174"></p>
<p><img src="/../images/image-20240826145632245.png" alt="image-20240826145632245"></p>
<p><img src="/../images/image-20240826145948278.png" alt="image-20240826145948278"></p>
<p>eax与rax的低32位是共用的</p>
<p>ax与eax的低16位是通用的</p>
<p><img src="/../images/image-20240826162116558.png" alt="image-20240826162116558"></p>
<p><img src="/../images/image-20240826162507877.png" alt="image-20240826162507877">%eax ：返回值</p>
<p><img src="/../images/image-20240826163129510.png" alt="image-20240826163129510"></p>
<p><img src="/../images/image-20240826163353133.png" alt="image-20240826163353133"></p>
<p><img src="/../images/image-20240826163854896.png" alt="image-20240826163854896"></p>
<p>l代表32位，q代表64位</p>
<p><img src="/../images/image-20240826164111288.png" alt="image-20240826164111288"></p>
<p><img src="/../images/image-20240826165156571.png" alt="image-20240826165156571"></p>
<p><img src="/../images/image-20240826165630808.png" alt="image-20240826165630808"></p>
<p>在 C++ 中，<code>ThreadPool threadPool &#123;&#125;;</code> 和 <code>ThreadPool threadPool ;</code> 是两种不同的初始化方式，它们对 <code>ThreadPool</code> 对象的初始化有所不同。</p>
<h3 id="1-ThreadPool-threadPool"><a href="#1-ThreadPool-threadPool" class="headerlink" title="1. ThreadPool threadPool {};"></a>1. <code>ThreadPool threadPool &#123;&#125;;</code></h3><p>这是 <strong>直接初始化（Direct Initialization）</strong> 的一种方式，使用了 <strong>统一初始化语法</strong>（Uniform Initialization Syntax）。具体来说，这种写法会调用 <code>ThreadPool</code> 的默认构造函数，并且初始化所有成员变量为默认值：</p>
<ul>
<li><strong>如果 <code>ThreadPool</code> 有默认构造函数</strong>，它将被调用来创建对象。</li>
<li><strong>如果 <code>ThreadPool</code> 的构造函数</strong>没有显式初始化某些成员变量，它们会被自动初始化为其类型的默认值。对于基本数据类型（如 <code>int</code>），这意味着它们会被初始化为 <code>0</code>。对于指针类型，它们会被初始化为 <code>nullptr</code>。</li>
</ul>
<h3 id="2-ThreadPool-threadPool"><a href="#2-ThreadPool-threadPool" class="headerlink" title="2. ThreadPool threadPool ;"></a>2. <code>ThreadPool threadPool ;</code></h3><p>这是 <strong>默认初始化（Default Initialization）</strong> 的一种方式。在这种情况下，<code>ThreadPool</code> 对象的初始化行为依赖于以下几种情况：</p>
<ul>
<li><strong>如果 <code>ThreadPool</code> 有默认构造函数</strong>，它将被调用来创建对象。</li>
<li><strong>如果 <code>ThreadPool</code> 的构造函数没有显式初始化某些成员变量</strong>，那么这些成员变量的初始化方式依赖于它们的类型和是否有默认构造函数。基本数据类型（如 <code>int</code>）不会被初始化到任何特定值（它们会是未定义的），指针类型也不会自动初始化（它们的值是不确定的）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>ThreadPool threadPool &#123;&#125;;</code>**：使用统一初始化语法，所有成员变量被初始化为其类型的默认值，较为安全。</li>
<li><strong><code>ThreadPool threadPool ;</code><strong>：默认初始化，成员变量的初始值依赖于其类型和构造函数，</strong>可能会导致未定义行为（对于基本数据类型）</strong>。</li>
</ul>
<p>在实践中，推荐使用 <code>ThreadPool threadPool &#123;&#125;;</code> 以确保对象的成员变量被正确地初始化，避免潜在的未定义行为。</p>
<p>在对象构造时，<code>std::lock_guard</code> 会自动锁定传入的互斥锁，而在对象析构时，它会自动释放锁</p>
<p><strong><code>std::lock_guard&lt;std::mutex&gt; guard(lock);</code></strong></p>
<p>当执行 <code>std::lock_guard&lt;std::mutex&gt; guard(lock);</code> 时：</p>
<ul>
<li><strong>锁定</strong>: <code>guard</code> 对象在创建时会自动调用 <code>lock()</code> 方法来锁定传入的互斥锁（<code>lock</code>）。</li>
<li><strong>作用域结束</strong>: 当 <code>guard</code> 对象的作用域结束（例如，离开当前的代码块或函数）时，它的析构函数会自动调用 <code>unlock()</code> 方法来解锁互斥锁</li>
</ul>
<p>要理解 <code>subset</code> 中的这行数据，我们可以将其拆解成几部分来分析：</p>
<pre><code class="plaintext">[[ 0.          1.          2.          3.          4.          5.
   6.          7.          8.         -1.         -1.          9.
  -1.         -1.         10.         11.         12.         -1.
  21.50975911 13.        ]]
</code></pre>
<h3 id="1-关键点索引"><a href="#1-关键点索引" class="headerlink" title="1. 关键点索引"></a>1. 关键点索引</h3><ul>
<li>前 18 个值 <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, -1, -1, 9, -1, -1, 10, 11, 12, -1]</code> 代表了关键点的索引。<ul>
<li>正整数表示该位置有一个有效的关键点索引。</li>
<li><code>-1</code> 表示该位置没有对应的关键点。</li>
</ul>
</li>
</ul>
<h3 id="2-总评分"><a href="#2-总评分" class="headerlink" title="2. 总评分"></a>2. 总评分</h3><ul>
<li><code>21.50975911</code> 是这个组合的总评分。这个评分是所有有效关键点的评分之和或某种加权评分的结果。</li>
</ul>
<h3 id="3-关键点数量"><a href="#3-关键点数量" class="headerlink" title="3. 关键点数量"></a>3. 关键点数量</h3><ul>
<li><code>13</code> 是这个组合中的有效关键点数量。这里 <code>13</code> 表示在该组合中共有 13 个有效的关键点索引。</li>
</ul>
<h3 id="结合信息"><a href="#结合信息" class="headerlink" title="结合信息"></a>结合信息</h3><p>这个 <code>subset</code> 行数据表示一个关键点组合，其中包含 13 个有效的关键点，所有这些关键点的索引被列出。组合的总评分为 <code>21.50975911</code>。通过这些信息，你可以了解该组合的结构以及它在某种评分机制下的表现。</p>
<h4 id="详细解读："><a href="#详细解读：" class="headerlink" title="详细解读："></a>详细解读：</h4><ul>
<li>有效关键点索引为 <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</code>，总共 13 个。</li>
<li>索引为 <code>-1</code> 的位置表示这些位置没有有效的关键点。</li>
<li>总评分 <code>21.50975911</code> 可能是根据这些有效关键点的某些特性（如评分、置信度等）计算出来的。</li>
</ul>
<p>这样的 <code>subset</code> 数据通常用于在处理关键点检测任务中，选择或评估最佳的关键点组合。</p>
<p>这个是candidate： [[2.19000000e+02 1.18000000e+02 9.45192695e-01 0.00000000e+00] [1.96000000e+02 2.63000000e+02 9.28416848e-01 1.00000000e+00] [8.70000000e+01 2.89000000e+02 8.54923248e-01 2.00000000e+00] [6.60000000e+01 4.49000000e+02 8.24636817e-01 3.00000000e+00] [1.20000000e+02 5.07000000e+02 7.98071980e-01 4.00000000e+00] [3.07000000e+02 2.38000000e+02 8.55016530e-01 5.00000000e+00] [3.64000000e+02 3.76000000e+02 7.69826353e-01 6.00000000e+00] [2.81000000e+02 4.45000000e+02 8.87847126e-01 7.00000000e+00] [1.68000000e+02 5.42000000e+02 4.70188409e-01 8.00000000e+00] [2.98000000e+02 5.27000000e+02 4.78751719e-01 9.00000000e+00] [1.94000000e+02 1.03000000e+02 9.33498561e-01 1.00000000e+01] [2.30000000e+02 1.02000000e+02 9.27351594e-01 1.10000000e+01] [1.35000000e+02 1.22000000e+02 8.83832693e-01 1.20000000e+01]] 这个是subset: [[ 0.          1.          2.          3.          4.          5.   6.          7.          8.         -1.         -1.          9.  -1.         -1.         10.         11.         12.         -1.  21.50975911 13.        ]]</p>
<p>“Stack underflow”和“stack overflow”都是与栈（stack）数据结构相关的错误，但它们的含义和发生的情况不同：</p>
<h3 id="Stack-Overflow（栈溢出）"><a href="#Stack-Overflow（栈溢出）" class="headerlink" title="Stack Overflow（栈溢出）"></a>Stack Overflow（栈溢出）</h3><ul>
<li><strong>定义</strong>：栈溢出发生在栈的大小超过其最大容量时。通常是由于过深的递归调用或在栈上分配了过多的局部变量导致的。</li>
<li><strong>后果</strong>：栈溢出通常会导致程序崩溃或异常终止，因为系统无法继续在栈上分配内存。</li>
</ul>
<h3 id="Stack-Underflow（栈下溢出）"><a href="#Stack-Underflow（栈下溢出）" class="headerlink" title="Stack Underflow（栈下溢出）"></a>Stack Underflow（栈下溢出）</h3><ul>
<li><strong>定义</strong>：栈下溢出发生在试图从空栈中弹出元素时。例如，尝试执行“pop”操作但栈为空。</li>
<li><strong>后果</strong>：栈下溢出可能导致访问未定义的内存，程序可能会抛出异常或返回错误。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>溢出（overflow）</strong>：栈容量超出限制。</li>
<li><strong>下溢（underflow）</strong>：试图从空栈中移除元素。</li>
</ul>
<p><code>NULL</code> 是一个预处理宏，通常被定义为 <code>0</code> 或 <code>((void*)0)</code>。它在类型上是一个整数，因此可能导致类型不安全的情况。</p>
<ul>
<li><p><code>nullptr</code> 是 C++11 引入的一个关键字，表示空指针。它是一个特定的类型 <code>std::nullptr_t</code>，能更好地支持类型安全。</p>
</li>
<li><p><strong>OpenGL 上下文</strong>：OpenGL 上下文是一个包含了所有 OpenGL 状态的信息的环境。每个窗口通常会有一个自己的上下文。</p>
</li>
</ul>
<p>gcc -E main.cpp | tail -n 15 是什么意思</p>
<p><code>gcc -E main.cpp | tail -n 15</code> 是一个命令行指令，具体含义如下：</p>
<ul>
<li><code>gcc</code>：GNU 编译器集合，用于编译 C 和 C++ 程序。</li>
<li><code>-E</code>：该选项告诉 <code>gcc</code> 只进行预处理，即处理源代码中的宏和包含文件，但不进行编译。</li>
<li><code>main.cpp</code>：要处理的源文件。</li>
<li><code>|</code>：管道符，用于将前一个命令的输出传递给后一个命令。</li>
<li><code>tail -n 15</code>：该命令输出前一个命令的最后 15 行。</li>
</ul>
<p>因此，整个命令的作用是预处理 <code>main.cpp</code> 文件，并显示预处理后的结果的最后 15 行。这通常用于调试宏和包含的头文件。</p>
<p>constexpr</p>
<p>编译时常量</p>
<p><em>在编译时计算</em></p>
<p>结合 <code>if constexpr</code> 根据条件选择性编译代码</p>
<p><code>__attribute__((inline))</code> 是 GCC 和 Clang 编译器中的一个扩展，用于建议编译器将某个函数内联。内联函数的目的是减少函数调用的开销，通过将函数代码直接插入到调用处来提高性能。</p>
<ol>
<li><strong>性能优化</strong>：可以减少函数调用的开销，尤其是在小型函数中。</li>
<li><strong>不强制</strong>：即使使用了 <code>inline</code> 属性，编译器仍然可以选择不内联，具体取决于优化策略和函数的复杂性。</li>
<li><strong>适用场景</strong>：通常用于小的、频繁调用的函数。</li>
</ol>
<p>把std::string opengl_errno_name(int err)改成static const char *opengl_errno_name(int err)的好处</p>
<p>将 <code>std::string opengl_errno_name(int err)</code> 改为 <code>static const char *opengl_errno_name(int err)</code> 的好处包括：</p>
<ol>
<li><strong>性能提升</strong>：使用 <code>const char*</code> 可以减少内存分配和拷贝操作，提高性能，尤其在频繁调用的情况下。</li>
<li><strong>内存管理</strong>：<code>const char*</code> 不需要动态分配内存，避免了内存泄漏的风险，使用起来更加安全。</li>
<li><strong>简单性</strong>：直接返回字符串字面量或静态数组，使代码更简洁，减少不必要的复杂性。</li>
<li><strong>更好地适应 C 风格 API</strong>：在与 C 语言库交互时，使用 <code>const char*</code> 更加兼容。</li>
</ol>
<p><code>#include &lt;GL/gl.h&gt;</code> 和 <code>#include &lt;GL/glu.h&gt;</code> 是 OpenGL 的头文件，它们用于图形编程。具体来说：</p>
<ol>
<li>**<code>&lt;GL/gl.h&gt;</code>**：<ul>
<li>包含了 OpenGL 的核心函数和常量，提供了绘制图形所需的基本接口，比如渲染点、线、三角形等几何图形，以及设置视图、光照、纹理等功能。</li>
</ul>
</li>
<li>**<code>&lt;GL/glu.h&gt;</code>**：<ul>
<li>提供了一些辅助功能和工具，简化了 OpenGL 的使用。例如，它包含了用于生成和操作网格、处理矩阵变换、创建透视和正交投影等的函数。</li>
</ul>
</li>
</ol>
<p><code>#include &lt;GLFW/glfw3.h&gt;</code> 是用于包含 GLFW 库的头文件，GLFW 是一个开源的跨平台库，主要用于创建窗口、处理用户输入以及管理 OpenGL 上下文。具体功能包括：</p>
<ol>
<li><strong>创建和管理窗口</strong>：可以创建多种类型的窗口，并设置其属性。</li>
<li><strong>处理输入</strong>：支持键盘、鼠标和游戏手柄输入，方便处理用户交互。</li>
<li><strong>上下文管理</strong>：简化 OpenGL 上下文的创建和管理，使得在窗口中进行图形渲染更为高效。、</li>
</ol>
<p><code>#include &lt;glm/glm.hpp&gt;</code> 和 <code>#include &lt;glm/ext.hpp&gt;</code> 是用于包含 GLM（OpenGL Mathematics）库的头文件。具体功能如下：</p>
<ol>
<li>**<code>&lt;glm/glm.hpp&gt;</code>**：<ul>
<li>提供基础数学类型和操作，例如向量、矩阵、四元数等，支持高效的数学运算，适用于图形编程和物理计算。</li>
</ul>
</li>
<li>**<code>&lt;glm/ext.hpp&gt;</code>**：<ul>
<li>包含一些扩展功能，比如矩阵变换、投影、视图等常用数学函数，方便进行更复杂的数学运算。</li>
</ul>
</li>
</ol>
<p>GLM 常用于 OpenGL 应用程序中，以简化数学计算和数据管理。</p>
<p>❥ 基本<br>jk &#x2F; kj &#x2F; <Esc> 回到普通模式<br>q &#x2F; :wq &#x2F; ZZ 保存并退出<br>Q 记录宏<br>gl &#x2F; $ 移动到行末尾<br>gh &#x2F; ^ 移动到行开头（不包括空格）<br>3gl &#x2F; $2l 移动到行末尾倒数第 3 个字符<br>3gh &#x2F; ^2h 移动到行开头倒数第 3 个字符<br>❥ 跳转<br>gd 跳转到定义<br>gD 跳转到声明<br>gy 跳转到变量类型的定义<br>gY 跳转到虚函数实现<br>go 头文件和源文件来回跳转<br>gr 寻找符号引用<br>gz 罗列所有相关信息（定义、引用等）<br>gf 打开光标下的文件名<br>gF 打开光标下的文件名并跳到右侧指定的行号<br>gx 打开光标下的网页链接<br><C-o> 跳转回来<br>❥ 重构<br>gcc 注释&#x2F;取消注释当前选中的代码&#x2F;行<br>gn 重命名变量<br>gw 尝试自动修复问题<br>g&#x3D; 自动格式化当前代码<br>❥ 预览<br>K 悬浮窗查看文档<br>gsf 预览函数定义<br>gsc 预览类定义<br>gsd 预览语法错误<br>❥ 开关<br>gso 打开大纲<br>gsg 打开 Git 面板<br>gsp 打开项目文件树<br>gss 查看所有静态语法错误<br>gsl 查看所有编译器报错<br>gsi 开关 Inlay Hint<br><F8> 或 <C-t> 打开&#x2F;关闭终端<br>❥ 标签页<br><F4> 一键保存所有打开的文件<br><F3> 切换到下一个标签页<br><F2> 切换到上一个标签页<br><F1> 将当前标签页固定在最前<br><S-F3> 将当前标签页右移一位<br><S-F2> 将当前标签页左移一位<br><S-F1> 关闭当前标签页<br><C-S-F3> 关闭右侧所有标签页<br><C-S-F2>关闭左侧所有标签页<br><C-S-F1> 关闭除当前标签页外所有<br>g<Space> 选择跳转到一个标签页<br>❥ 文本查找<br>,, 当前文件中模糊查找<br>,k 当前项目中正则表达式查找<br>,l 当前项目中的所有文件<br>,b 当前 Vim 已打开文件<br>,o 最近打开过的历史文件<br>,i 当前所有加入 Git 仓库的文件<br>,p 当前 Git 有未提交修改的文件<br>,c 所有 Git 提交历史<br>,v 所有 Git 分支<br>❥ 选择<br>vac 选中当前类<br>vic 选中当前类体内<br>vaf 选中当前函数<br>vif 选中当前函数体<br>vab 选中当前块<br>vib 选中当前块中内容<br>vai 选中当前函数调用语句<br>vii 选中当前函数调用语句的参数列表<br>vap 选中当前参数（包括逗号）<br>vip 选中当前参数（不包括逗号）<br>vin 选中当前数字<br>vat 选中当前注释块</p>
<ul>
<li>扩大选择</li>
</ul>
<ul>
<li>缩小选择<br>举一反三：dat 删除当前注释块，cip 修改当前参数<br>❥ 移动<br>]c 下一个类开头<br>[c 上一个类开头<br>]C 下一个类结尾<br>[C 上一个类结尾<br>]f 下一个函数开头<br>[f 上一个函数开头<br>]F 下一个函数结尾<br>[F 上一个函数结尾<br>…以此类推，所有英文字母同上“选择”所述…<br><Space> 全屏任意移动<br>❥ 换位<br>mh 左移参数<br>ml 右移参数<br>mj 下移当前语句<br>mk 上移当前语句<br>maf 下移当前函数<br>mif 上移当前函数<br>mac 下移当前类<br>mic 上移当前类<br>❥ 括号<br>可视模式中：<br>s) 给当前选中内容包上 () 括号<br>s} 给当前选中内容包上 {} 括号<br>s] 给当前选中内容包上 [] 括号<br>s&gt; 给当前选中内容包上 &lt;&gt; 尖括号<br>s’ 给当前选中内容包上 ‘’ 单引号<br>s” 给当前选中内容包上 “” 双引号<br>stspan 给当前选中内容包上<span>标签<br>sta href&#x3D;”b.html” 给当前选中内容包上<a href="b.html">标签<br>普通（NORMAL）模式中：<br>ysi<range><brace> 添加括号<br>cs<oldbrace><newbrace> 改变括号<br>ds<brace> 删除括号<br>❥ CMake<br>cmc 或 :CMakeGenerate 配置当前项目<br>cmb 或 :CMakeBuild 构建当前项目<br>cmr 或 :CMakeRun 运行当前项目<br>cms 或 :CMakeStopRunner 杀死当前终端中的正在运行的程序<br>❥ 文件树<br>y 拷贝<br>x 剪切<br>d 删除<br>p 粘贴<br>a 创建</li>
</ul>
<p>ALT+shift+左右箭头   跳转</p>
<pre><code class="yaml">pendulum:
    joint_state_controller:
        publish_rate: 100
        type: joint_state_controller/JointStateController
    x_controller:
        joint: base_to_plat
        type: effort_controllers/JointEffortController
</code></pre>
<p>其中joint_state_controller和x_controller是什么意思 这个文件的作用是什么</p>
<h3 id="1-joint-state-controller"><a href="#1-joint-state-controller" class="headerlink" title="1. joint_state_controller"></a>1. <strong>joint_state_controller</strong></h3><ul>
<li><strong>用途</strong>：这个控制器用于发布机器人的关节状态（例如位置、速度和加速度）到 ROS 主题。它通常是机器人系统中的基础控制器，负责获取各个关节的状态信息并将其传递给其他组件。</li>
<li><strong>类型</strong>：<code>joint_state_controller/JointStateController</code> 是一个标准的控制器类型，用于处理关节状态的更新。</li>
<li><code>joint_state_controller</code> 是用于发布所有关节状态信息的控制器。它会收集机器人的所有关节（如位置、速度和加速度）的状态，并将这些信息发布到 ROS 主题上，通常是 <code>/joint_states</code> 主题。</li>
<li><strong>publish_rate</strong>：表示发布关节状态的频率，这里设置为 100 Hz。</li>
</ul>
<h3 id="2-x-controller"><a href="#2-x-controller" class="headerlink" title="2. x_controller"></a>2. <strong>x_controller</strong></h3><ul>
<li><strong>用途</strong>：这个控制器用于控制名为 <code>base_to_plat</code> 的关节的努力（力或扭矩）。通常用于执行某种运动控制任务，比如驱动一个关节以实现预期的动态行为。</li>
<li><strong>类型</strong>：<code>effort_controllers/JointEffortController</code> 是一个控制器类型，专注于控制关节施加的力或扭矩。</li>
</ul>
<h3 id="文件的作用"><a href="#文件的作用" class="headerlink" title="文件的作用"></a>文件的作用</h3><p>这个文件主要是用于配置 ROS 控制器管理器，定义机器人各个关节的控制方式及其参数。通过这个配置，您可以在启动时自动加载和初始化这些控制器，使得机器人能够实时进行关节状态的监测和控制。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>joint_state_controller</code></strong> 负责关节状态的信息发布。</li>
<li><strong><code>x_controller</code></strong> 则用于具体关节的力量控制。</li>
<li>整个 YAML 文件用于配置和管理这些控制器，使机器人能够有效地执行控制任务。</li>
</ul>
<p>##并发</p>
<p><img src="/../images/image-20240928131042017.png" alt="image-20240928131042017"></p>
<p>###0.时间 time</p>
<p><img src="/../images/image-20241005183555504.png" alt="image-20241005183555504"></p>
<p>###1.线程  thread</p>
<p><img src="/../images/image-20241005183759412.png" alt="image-20241005183759412"></p>
<p>join汇合加入，把子线程加到主线程里，这样主线程只有在子线程结束后才会退出</p>
<p><img src="/../images/image-20241005185354229.png" alt="image-20241005185354229"></p>
<p>当想要对线程进行封装时，会发现线程会随着封装函数执行过去而被销毁（因为thread的析构函数）：</p>
<p><img src="/../images/image-20241005190729501.png" alt="image-20241005190729501"></p>
<p>使用detach（）,还是不行（因为没用join，主线程不会等子线程）：</p>
<p><img src="/../images/image-20241005190842874.png" alt="image-20241005190842874"></p>
<p>全局变量，生命周期会大于封装函数，join，等待子线程：<br><img src="/../images/image-20241005191516568.png" alt="image-20241005191516568"></p>
<p>利用析构函数简化：<br><img src="/../images/image-20241005191923023.png" alt="image-20241005191923023"></p>
<p>再简化，标准函数帮你把析构函数写了：</p>
<p><img src="/../images/image-20241005183933864.png" alt="image-20241005183933864"></p>
<h3 id="2-异步async"><a href="#2-异步async" class="headerlink" title="2.异步async"></a>2.异步async</h3><p>异步相当于thread的帮手函数,专注于任务本身而不是底层的线程管理,不用那么底层了，使用简单了，但是能力也就下降了。</p>
<p><code>std::async</code> 和 <code>std::thread</code> 都是 C++11 引入的用于处理并发和多线程编程的工具，但它们在设计目的、使用方式和抽象级别上存在一些关键的关系与区别。以下是它们之间的详细比较：</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li><strong>都属于 C++ 标准库</strong>：两者都是 C++11 提供的并发支持的一部分，旨在简化多线程编程。</li>
<li><strong>功能互补</strong>：尽管各自的设计有不同侧重点，但它们可以一起使用。例如，可以在 <code>std::async</code> 中使用 <code>std::thread</code>，或者在创建线程时使用 <code>std::async</code> 来管理结果。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>std::thread</code></th>
<th><code>std::async</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>抽象级别</strong></td>
<td>更低级别的线程管理</td>
<td>更高层次的异步任务管理</td>
</tr>
<tr>
<td><strong>线程控制</strong></td>
<td>开发者需要手动管理线程的生命周期（启动、加入、分离）</td>
<td>自动管理线程的生命周期，返回 <code>std::future</code></td>
</tr>
<tr>
<td><strong>执行策略</strong></td>
<td>一般立即启动新线程</td>
<td>可选择立即执行或延迟执行（<code>std::launch::async</code> 或 <code>std::launch::deferred</code>）</td>
</tr>
<tr>
<td><strong>结果处理</strong></td>
<td>返回值需要通过共享数据或其他同步机制来获取</td>
<td>通过 <code>std::future</code> 对象直接获取结果</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>异常不会传播到主线程，需要手动管理</td>
<td>异常会被捕获并在调用 <code>future.get()</code> 时重新抛出</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>需要细致控制线程行为的场景，如实时系统、服务器等</td>
<td>简单的异步任务、并行计算、提高程序响应性</td>
</tr>
</tbody></table>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="使用-std-thread-的示例："><a href="#使用-std-thread-的示例：" class="headerlink" title="使用 std::thread 的示例："></a>使用 <code>std::thread</code> 的示例：</h4><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

void task() &#123;
    std::cout &lt;&lt; &quot;Task is running in a separate thread.\n&quot;;
&#125;

int main() &#123;
    std::thread t(task);
    t.join();  // 等待线程完成
    return 0;
&#125;
</code></pre>
<h4 id="使用-std-async-的示例："><a href="#使用-std-async-的示例：" class="headerlink" title="使用 std::async 的示例："></a>使用 <code>std::async</code> 的示例：</h4><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;future&gt;

int task() &#123;
    return 42;  // 返回结果
&#125;

int main() &#123;
    std::future&lt;int&gt; result = std::async(task);
    std::cout &lt;&lt; &quot;Result from async task: &quot; &lt;&lt; result.get() &lt;&lt; &#39;\n&#39;;  // 获取结果
    return 0;
&#125;
</code></pre>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**选择使用 <code>std::thread</code>**：当你需要更细粒度的线程控制，或者需要实现复杂的线程交互时。</li>
<li>**选择使用 <code>std::async</code>**：当你希望简化异步任务的管理，并专注于任务本身而不是底层的线程管理时。</li>
</ul>
<p>根据具体的需求和场景，开发者可以灵活选择这两者中的一种或结合使用。</p>
<p><img src="/../images/image-20241005185145651.png" alt="image-20241005185145651"></p>
<p><img src="/../images/image-20241005202136786.png" alt="image-20241005202136786"></p>
<p><img src="/../images/image-20241005202235380.png" alt="image-20241005202235380"></p>
<p>std::async相当于在后台开一个线程偷偷执行,如果不想用线程的话，可以用假线程：</p>
<p><img src="/../images/image-20241005203007249.png" alt="image-20241005203007249"></p>
<p>std::async的底层实现：（应该用不到吧）</p>
<p><img src="/../images/image-20241005204852974.png" alt="image-20241005204852974"></p>
<h3 id="3-互斥量"><a href="#3-互斥量" class="headerlink" title="3.互斥量"></a>3.互斥量</h3><p><img src="/../images/image-20241005211544279.png" alt="image-20241005211544279"></p>
<p>std::lock_guard grd(mtx); <em>&#x2F;&#x2F; 创建 lock_guard 对象 grd，锁定 mtx</em></p>
<p>这个有个弊端：不能提前unlock，可以用std::unique_lock:</p>
<p><img src="/../images/image-20241005213525208.png" alt="image-20241005213525208"></p>
<p>如果你即想使用unique_lock的自动解锁，又想手动lock：</p>
<p><img src="/../images/image-20241006100018130.png" alt="image-20241006100018130"></p>
<p>这个是已经上锁了，又想使用自动解锁：<br><img src="/../images/image-20241006100334056.png" alt="image-20241006100334056"></p>
<h3 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h3><p>问题一：</p>
<p><img src="/../images/image-20241005182028304.png" alt="image-20241005182028304"></p>
<p>不要同时锁两个</p>
<p><img src="/../images/image-20241005182958030.png" alt="image-20241005182958030"></p>
<p>保证线程里上锁的顺序一样</p>
<p><img src="/../images/image-20241005183050653.png" alt="image-20241005183050653"></p>
<p>使用标准库里的std::lock</p>
<p><img src="/../images/image-20241005183311794.png" alt="image-20241005183311794"></p>
<p>同样，为了避免忘记解锁，有了一个RALL版本的std::lock<br><img src="/../images/image-20241006100806745.png" alt="image-20241006100806745"></p>
<p>问题二：</p>
<p><img src="/../images/image-20241006101009888.png" alt="image-20241006101009888"></p>
<p>std::recursive_mutex</p>
<p><img src="/../images/image-20241006101432670.png" alt="image-20241006101432670"></p>
<h3 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5.数据结构"></a>5.数据结构</h3><p><img src="/../images/image-20241006101750387.png" alt="image-20241006101750387"></p>
<p>封装一下：</p>
<p><img src="/../images/image-20241006102058522.png" alt="image-20241006102058522"></p>
<p>因为mutex::lock()不是const的 ,那么使用mutable修饰一下：</p>
<p><img src="/../images/image-20241006102636082.png" alt="image-20241006102636082"></p>
<p>####读写锁：</p>
<p><img src="/../images/image-20241006102823718.png" alt="image-20241006102823718"></p>
<p>std::shared_mutex<br><img src="/../images/image-20241006103549484.png" alt="image-20241006103549484"></p>
<p>lock()的RAII是std::unique_lock</p>
<p>lock_shared()的RAII是std::shared_lock</p>
<p><img src="/../images/image-20241006104139107.png" alt="image-20241006104139107"></p>
<p><img src="/../images/image-20241006105913707.png" alt="image-20241006105913707"></p>
<h3 id="6-条件变量"><a href="#6-条件变量" class="headerlink" title="6.条件变量"></a>6.条件变量</h3><p><img src="/../images/image-20241006110451776.png" alt="image-20241006110451776"></p>
<p><img src="/../images/image-20241006110619094.png" alt="image-20241006110619094"></p>
<p><img src="/../images/image-20241006111315559.png" alt="image-20241006111315559"></p>
<p><img src="/../images/image-20241006115747920.png" alt="image-20241006115747920"></p>
<p><img src="/../images/image-20241006120359417.png" alt="image-20241006120359417"></p>
<p><img src="/../images/image-20241006120454654.png" alt="image-20241006120454654"></p>
<p>###7.原子操作（硬件层面）</p>
<p>前面的都是操作系统层面的</p>
<p>硬件解释：</p>
<p><img src="/../images/image-20241006123756588.png" alt="image-20241006123756588"></p>
<p><img src="/../images/image-20241006123820764.png" alt="image-20241006123820764"></p>
<p><img src="/../images/image-20241006124016522.png" alt="image-20241006124016522"></p>
<p>原子变量：</p>
<p><img src="/../images/image-20241006125728044.png" alt="image-20241006125728044"></p>
<p><img src="/../images/image-20241006125817277.png" alt="image-20241006125817277"> </p>
<p><img src="/../images/image-20241006130153788.png" alt="image-20241006130153788"></p>
<p><img src="/../images/image-20241006144356518.png" alt="image-20241006144356518"></p>
<p><img src="/../images/image-20241006144621864.png" alt="image-20241006144621864"></p>
<p><img src="/../images/image-20241006145302292.png" alt="image-20241006145302292"></p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>###——TBB开启的并行编程之旅（Intel TBB并行编程框架）</p>
<p>###0.从并发到并行</p>
<p><img src="/../images/image-20241006150631389.png" alt="image-20241006150631389"></p>
<p><img src="/../images/image-20241006150757093.png" alt="image-20241006150757093"></p>
<p><img src="/../images/image-20241006151002766.png" alt="image-20241006151002766"></p>
<p> 不需要手动创建线程池：</p>
<p><img src="/../images/image-20241006180452099.png" alt="image-20241006180452099"></p>
<p>  std::thread是操作系统意义上的线程，TBB的一个任务不一定代表一个线程，把任务分配到线程上去， TBB可视为一个高效调度器</p>
<p>ubuntu20.04蓝牙耳机连上了，但是声音还是输出在内置扬声器上，使用 <code>pactl load-module module-bluetooth-discover</code> 时遇到“模块初始化失败”的错误.</p>
<ol>
<li><p><strong>检查 Bluetooth 服务</strong>：<br>确保 Bluetooth 服务正在运行。可以使用以下命令启动服务：</p>
<pre><code class="bash">sudo systemctl start bluetooth
</code></pre>
</li>
<li><p><strong>安装必要的包</strong>：<br>确保已安装 PulseAudio 和 Bluetooth 支持。运行以下命令安装相关组件：</p>
<pre><code class="bash">sudo apt install pulseaudio pulseaudio-module-bluetooth pavucontrol
</code></pre>
</li>
<li><p><strong>重启 PulseAudio</strong>：<br>有时重启 PulseAudio 可以解决问题。可以使用以下命令：</p>
<pre><code class="bash">pulseaudio -k
pulseaudio --start
</code></pre>
</li>
</ol>
<p>当然可以。根据你提供的代码，系统的状态空间方程可以表示为以下形式：<br>状态方程：<br>$$[<br>\begin{align*}<br>\dot{x}_1 &amp;&#x3D; x_2 \<br>\dot{x}_2 &amp;&#x3D; \frac{-b \cdot (I + m \cdot l^2)}{P} \cdot x_2 + \frac{m \cdot m \cdot g \cdot l^2}{P} \cdot x_3 \<br>\dot{x}_3 &amp;&#x3D; x_4 \<br>\dot{x}_4 &amp;&#x3D; \frac{-b \cdot m \cdot l}{P} \cdot x_2 + \frac{m \cdot g \cdot l \cdot (M + m)}{P} \cdot x_3 + \frac{1}{P} \cdot u<br>\end{align*}<br>]$$<br>其中，( x_1 ) 和 ( x_2 ) 可能表示倒立摆的位移和速度，而 ( x_3 ) 和 ( x_4 ) 可能表示摆角和角速度。控制输入 ( u ) 是作用在倒立摆上的力。<br>输入方程：<br>$$[<br>u &#x3D; 0 \cdot x_1 + \frac{(I + m \cdot l^2)}{P} \cdot x_2 + 0 \cdot x_3 + \frac{m \cdot l}{P} \cdot x_4<br>]$$<br>但实际上，控制输入 ( u ) 是由控制器决定的，所以输入方程应该表示控制律，而不是状态变量直接映射到控制输入。<br>根据你的代码，状态空间方程的矩阵形式是：<br>$$[<br>\begin{align*}<br>\dot{\mathbf{x}} &amp;&#x3D; \mathbf{A} \mathbf{x} + \mathbf{B} u \<br>y &amp;&#x3D; \mathbf{C} \mathbf{x} + \mathbf{D} u<br>\end{align*}<br>]$$<br>其中，(\mathbf{x}) 是状态向量，(u) 是控制输入，(y) 是系统输出。在你的代码中，并没有明确给出输出矩阵 (\mathbf{C}) 和直接馈通矩阵 (\mathbf{D})，所以我们假设它们是：<br>$$[<br>\mathbf{C} &#x3D; \begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 0 &amp; 0<br>\end{bmatrix}, \quad<br>\mathbf{D} &#x3D; \begin{bmatrix}<br>0 \<br>0<br>\end{bmatrix}<br>]$$<br>这意味着系统的输出是状态向量 (\mathbf{x}) 的前两个元素。<br>因此，状态空间方程的矩阵形式为：<br>$[<br>\mathbf{A} &#x3D; \begin{bmatrix}<br>0 &amp; 1 &amp; 0 &amp; 0 \<br>0 &amp; -\frac{b \cdot (I + m \cdot l^2)}{P} &amp; \frac{m \cdot m \cdot g \cdot l^2}{P} &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>0 &amp; -\frac{b \cdot m \cdot l}{P} &amp; \frac{m \cdot g \cdot l \cdot (M + m)}{P} &amp; 0<br>\end{bmatrix}<br>]$<br>$$[<br>\mathbf{B} &#x3D; \begin{bmatrix}<br>0 \<br>\frac{(I + m \cdot l^2)}{P} \<br>0 \<br>\frac{m \cdot l}{P}<br>\end{bmatrix}<br>]$$<br>请注意，这里的 $(\mathbf{A})$ 和 $(\mathbf{B})$ 矩阵与你代码中定义的矩阵相匹配，但是根据你的系统定义，你可能需要调整 $(\mathbf{C})$ 和 $(\mathbf{D}) $矩阵以反映实际的系统输出。</p>
<p><img src="/../images/image-20241006163519590.png" alt="image-20241006163519590"></p>
<p> <img src="/../images/image-20241006171703693.png" alt="image-20241006171703693"></p>
<p><img src="/../images/image-20241006171811928.png" alt="image-20241006171811928"></p>
<p><img src="/../images/image-20241006181422178.png" alt="image-20241006181422178"></p>
<p><img src="/../images/image-20241006181816664.png" alt="image-20241006181816664"></p>
<h3 id="1-并行循环"><a href="#1-并行循环" class="headerlink" title="1.并行循环"></a>1.并行循环</h3><p>并行的for循环  <img src="/../images/image-20241006194116633.png" alt="image-20241006194116633"></p>
<p><img src="/../images/image-20241006195247291.png" alt="image-20241006195247291"></p>
<p>简单，但是有代价，无法被编译器优化了<img src="/../images/image-20241006195533798.png" alt="image-20241006195533798"></p>
<p>这个是不需要索引的时候可以用</p>
<p><img src="/../images/image-20241006195955333.png" alt="image-20241006195955333"></p>
<p>二维</p>
<p><img src="/../images/image-20241006200235271.png" alt="image-20241006200235271"></p>
<p>三维</p>
<h3 id="2-缩并与扫描"><a href="#2-缩并与扫描" class="headerlink" title="2,缩并与扫描"></a>2,缩并与扫描</h3><p>并行缩并</p>
<p><img src="/../images/image-20241006201321218.png" alt="image-20241006201321218"></p>
<p> <img src="/../images/image-20241006201514955.png" alt="image-20241006201514955"></p>
<p> <img src="/../images/image-20241006202300112.png" alt="image-20241006202300112"></p>
<p>但是，任务是动态分配到线程上，也就是range会变化，精度就会变，为了性能结果会有不同。所以：</p>
<p><img src="/../images/image-20241006202538659.png" alt="image-20241006202538659"></p>
<p>并行缩并的好处，相比于普通的串行缩并：</p>
<p><img src="/../images/image-20241006205437392.png" alt="image-20241006205437392"></p>
<p>串行相加，很大的e指数加上一个很小的float数，误差很大（浮点数不能大加小(等于没加)）</p>
<h3 id="3-并行扫描"><a href="#3-并行扫描" class="headerlink" title="3.并行扫描"></a>3.并行扫描</h3><p><img src="/../images/image-20241006210256789.png" alt="image-20241006210256789"></p>
<p>通常用于生成直方图</p>
<p><img src="/../images/image-20241006211843354.png" alt="image-20241006211843354"></p>
<p><img src="/../images/image-20241006212155394.png" alt="image-20241006212155394"></p>
<p><img src="/../images/image-20241006212546708.png" alt="image-20241006212546708"></p>
<p><img src="/../images/image-20241006214913619.png" alt="image-20241006214913619"></p>
<p>考试比较喜欢的考法是将这三种校正与“<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=4356198&content_type=Article&match_order=1&q=PID%E6%A0%A1%E6%AD%A3&zhida_source=entity">PID校正</a>”校正结合起来，他们喜欢说PID校正，毕竟PD、PI、PID校正分别是超前、滞后、和滞后-超前校正的特殊情况。</p>
<p>$\text{最大超前角}\\varphi_m&#x3D;\gamma^{\prime\prime}-\gamma+5°&#x3D;45°-0°+5°&#x3D;50°\a&#x3D;\frac{1+\mathrm{sin}\varphi_m}{1-\mathrm{sin}\varphi_m}\approx8:,\quad10\mathrm{lg}a\approx9\mathrm{dB}$ </p>
<p><img src="/../images/v2-62e4aec82258978849246f82c939a7fe_720w.webp" alt="img"></p>
<p><img src="/../images/v2-a80d3c8cc88df0c0f3fe1ae310ba5edc_720w.webp" alt="img"></p>
<p>文件扩展名 <code>.tpp</code> 通常表示 <strong>C++ 模板实现文件</strong>。它与 C++ 模板相关，主要用于存放模板类或函数的实现。</p>
<h3 id="具体用途"><a href="#具体用途" class="headerlink" title="具体用途"></a>具体用途</h3><ol>
<li><p><strong>模板定义分离</strong>：在 C++ 中，通常将模板的声明和实现分开。在头文件（<code>.hpp</code> 或 <code>.h</code>）中，你可以声明一个模板，而在 <code>.tpp</code> 文件中实现该模板。这种做法有助于保持代码的组织性和可读性。</p>
</li>
<li><p><strong>包含在头文件中</strong>：为了使用 <code>.tpp</code> 文件中的实现，通常会在相应的头文件中通过 <code>#include</code> 指令将其包含进来。</p>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设你有一个简单的模板类 <code>MyClass</code>，可以这样组织文件：</p>
<p><strong>MyClass.hpp</strong></p>
<pre><code class="cpp">#ifndef MYCLASS_HPP
#define MYCLASS_HPP

template &lt;typename T&gt;
class MyClass &#123;
public:
    MyClass(T value);
    void display();

private:
    T data;
&#125;;

#include &quot;MyClass.tpp&quot; // 包含实现文件

#endif // MYCLASS_HPP
</code></pre>
<p><strong>MyClass.tpp</strong></p>
<pre><code class="cpp">#include &quot;MyClass.hpp&quot;
#include &lt;iostream&gt;

template &lt;typename T&gt;
MyClass&lt;T&gt;::MyClass(T value) : data(value) &#123;&#125;

template &lt;typename T&gt;
void MyClass&lt;T&gt;::display() &#123;
    std::cout &lt;&lt; data &lt;&lt; std::endl;
&#125;
</code></pre>
<p>debug生成的代码没有经过优化</p>
<h3 id="4-TBB的任务域与for循环的嵌套"><a href="#4-TBB的任务域与for循环的嵌套" class="headerlink" title="4.TBB的任务域与for循环的嵌套"></a>4.TBB的任务域与for循环的嵌套</h3><p><img src="/../images/image-20241011101745036.png" alt="image-20241011101745036"></p>
<p>指定任务域里使用的线程</p>
<p>并行嵌套for循环</p>
<p><img src="/../images/image-20241011102146940.png" alt="image-20241011102146940"></p>
<p>但是嵌套for循环会出现死锁问题:</p>
<p><img src="/../images/image-20241011102321351.png" alt="image-20241011102321351"></p>
<p>为啥：(性能优化：线程里的任务做完了，会去其他线程里取任务帮忙)</p>
<p><img src="/../images/image-20241011102603422.png" alt="image-20241011102603422"></p>
<p>解决办法：</p>
<p><img src="/../images/image-20241011103110746.png" alt="image-20241011103110746"></p>
<p><img src="/../images/image-20241011103358416.png" alt="image-20241011103358416"></p>
<p><img src="/../images/image-20241011110039932.png" alt="image-20241011110039932"></p>
<h3 id="5-任务分配"><a href="#5-任务分配" class="headerlink" title="5.任务分配"></a>5.任务分配</h3><p>并行的时候怎样把一个任务均匀的分配到每个线程&#x2F;核心（因为通常几个核心就开几个线程)呢：（线程和任务都不动）</p>
<p><img src="/../images/image-20241011111101669.png" alt="image-20241011111101669"></p>
<p>效果不太好，不能让核心闲着，让核心上一直有线程在运行</p>
<p>解决：让线程数大于核心数（让线程动起来）</p>
<p><img src="/../images/image-20241011112225107.png" alt="image-20241011112225107"></p>
<p>但是操作系统轮换是有开销（overhead）的，而且有可能破坏缓存一致性</p>
<p>解决：线程池（让任务动起来）</p>
<p><img src="/../images/image-20241011114443951.png" alt="image-20241011114443951"></p>
<p>TBB的工作窃取法：</p>
<p><img src="/../images/image-20241011115732981.png" alt="image-20241011115732981"></p>
<p><img src="/../images/image-20241011120205530.png" alt="image-20241011120205530"></p>
<p>tbb::static_partitioner的线程与任务数量一致</p>
<p><img src="/../images/image-20241011120455377.png" alt="image-20241011120455377"></p>
<p><img src="/../images/image-20241011120545985.png" alt="image-20241011120545985"></p>
<p>默认粒度（一个任务里的元素）是1</p>
<p><img src="/../images/image-20241011120835292.png" alt="image-20241011120835292"></p>
<p><img src="/../images/image-20241011135601948.png" alt="image-20241011135601948"><img src="/../images/image-20241011135646042.png" alt="image-20241011135646042"></p>
<h3 id="tbb-static-partitioner"><a href="#tbb-static-partitioner" class="headerlink" title="tbb::static_partitioner"></a><code>tbb::static_partitioner</code></h3><ul>
<li><p><strong>描述</strong>：将任务静态地分配给线程。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>在任务开始时就确定每个线程将处理哪些任务。</li>
<li>适合于任务量相对均匀且已知的情况。</li>
<li>不会在运行时重新平衡负载，因此可能导致某些线程空闲而其他线程忙碌。</li>
</ul>
</li>
</ul>
<h3 id="2-tbb-simple-partitioner"><a href="#2-tbb-simple-partitioner" class="headerlink" title="2. tbb::simple_partitioner"></a>2. <code>tbb::simple_partitioner</code></h3><ul>
<li><p><strong>描述</strong>：提供一个简单的分区策略。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>任务被划分为较小的块，并且每个线程可以从待处理任务中获取一个块。</li>
<li>相对于 <code>static_partitioner</code>，<code>simple_partitioner</code> 允许更好的负载平衡。</li>
<li>适用于任务量不均或动态变化的情况。</li>
</ul>
</li>
</ul>
<h3 id="3-tbb-auto-partitioner"><a href="#3-tbb-auto-partitioner" class="headerlink" title="3. tbb::auto_partitioner"></a>3. <code>tbb::auto_partitioner</code></h3><ul>
<li><p><strong>描述</strong>：动态调整任务分配以优化性能。</p>
</li>
<li><p>特性</p>
<p>：</p>
<ul>
<li>在运行时监控线程的工作负载，并根据需要进行任务重新分配。</li>
<li>可以实现更好的负载均衡，特别是在任务执行时间不均匀的情况下。</li>
<li>适用于复杂的并行任务，能自动适应系统负载。</li>
</ul>
</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>静态分配</strong>（<code>static_partitioner</code>）适用于可预测且均匀的任务；不适合动态负载。</li>
<li><strong>简单分配</strong>（<code>simple_partitioner</code>）在一定程度上改进了负载平衡，但仍然保持简单的结构。</li>
<li><strong>自动分配</strong>（<code>auto_partitioner</code>）最灵活，适合于动态和不均匀的工作负载，通过实时监测和调整提高整体性能。</li>
</ul>
<p>tbb::static_partitioner对循环体不均匀的情况效果不如tbb::simple_partitioner(操作系统调度)</p>
<p>越来越快</p>
<p><img src="/../images/image-20241011140440217.png" alt="image-20241011140440217"></p>
<p><img src="/../images/image-20241011140721127.png" alt="image-20241011140721127"></p>
<p>但是auto_partitioner一定比simple_partitioner快吗</p>
<p><img src="/../images/image-20241011144432532.png" alt="image-20241011144432532"></p>
<p><img src="/../images/image-20241011154029009.png" alt="image-20241011154029009"></p>
<h3 id="6-并发容器"><a href="#6-并发容器" class="headerlink" title="6.并发容器"></a>6.并发容器</h3><p>问题：</p>
<p><img src="/../images/image-20241011155237153.png" alt="image-20241011155237153"></p>
<p>解决：</p>
<p><img src="/../images/image-20241011155440540.png" alt="image-20241011155440540"></p>
<p><img src="/../images/image-20241011160119354.png" alt="image-20241011160119354"></p>
<p>push_back()返回的是一个迭代器</p>
<p>用*获取迭代器指向的元素的引用，再用and（&amp;）获取这个元素的指针</p>
<p><img src="/../images/image-20241011160927535.png" alt="image-20241011160927535"></p>
<p>tbb::concurrent_vector还是一个多线程安全的容器</p>
<p><img src="/../images/image-20241011161401578.png" alt="image-20241011161401578"></p>
<p>访问：随机访问效率不高</p>
<p><img src="/../images/image-20241011162020029.png" alt="image-20241011162020029"></p>
<p>推荐顺序访问：</p>
<p><img src="/../images/image-20241011162546845.png" alt="image-20241011162546845"></p>
<p><img src="/../images/image-20241011164325073.png" alt="image-20241011164325073"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Cplusplus.html" data-id="cm040oe8600005rcxhs4q231b" data-title="Cplusplus" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Qt" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Qt.html" class="article-date">
  <time class="dt-published" datetime="2024-08-21T15:30:34.000Z" itemprop="datePublished">2024-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Qt.html">Qt</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>QWidget</code> 和 <code>QMainWindow</code> 是 Qt 框架中的两个重要类，它们都用于创建图形用户界面（GUI），但有一些关键的区别：</p>
<h3 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a><code>QWidget</code></h3><ul>
<li><strong>基础类</strong>: <code>QWidget</code> 是 Qt 中所有用户界面对象的基类。它提供了一个基础的窗口部件，其他窗口部件（如按钮、文本框）都是从 <code>QWidget</code> 继承而来的。</li>
<li><strong>功能</strong>: <code>QWidget</code> 本身是一个通用的窗口部件，没有特别的窗口管理功能。它可以作为窗口的基础组件，也可以作为其他复杂组件的容器。</li>
<li><strong>布局管理</strong>: <code>QWidget</code> 提供了布局管理功能，可以使用布局管理器来控制其子部件的位置和大小。</li>
<li><strong>使用场景</strong>: 你可以将 <code>QWidget</code> 用作对话框、工具条、或是任何其他需要的窗口部件。如果你只需要一个简单的窗口，<code>QWidget</code> 是一个合适的选择。</li>
</ul>
<h3 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a><code>QMainWindow</code></h3><ul>
<li><strong>派生类</strong>: <code>QMainWindow</code> 是 <code>QWidget</code> 的子类，提供了更丰富的窗口功能和特性。</li>
<li><strong>功能</strong>: <code>QMainWindow</code> 是设计用于主窗口的类，它提供了菜单栏、工具栏、状态栏和中央窗口区域的支持。这使得它特别适合用于主应用窗口的设计。</li>
<li><strong>布局管理</strong>: <code>QMainWindow</code> 提供了特定的布局区域，如菜单栏、工具栏、状态栏和中央部件区域。你可以使用这些功能来创建更复杂的应用程序界面。</li>
<li><strong>使用场景</strong>: 当你需要一个具有菜单栏、工具栏和状态栏的主窗口时，<code>QMainWindow</code> 是一个理想的选择。它适合用于具有复杂界面的桌面应用程序。</li>
</ul>
<h3 id="主要区别总结"><a href="#主要区别总结" class="headerlink" title="主要区别总结"></a>主要区别总结</h3><ol>
<li><strong>功能扩展</strong>:<ul>
<li><code>QWidget</code>: 基础窗口部件，功能较少，适合用于创建简单的窗口或部件。</li>
<li><code>QMainWindow</code>: 提供额外的功能，如菜单栏、工具栏和状态栏，适合用于主应用窗口。</li>
</ul>
</li>
<li><strong>使用场景</strong>:<ul>
<li><code>QWidget</code>: 适合用作对话框、工具条、或简单的窗口部件。</li>
<li><code>QMainWindow</code>: 适合用于需要复杂用户界面的主窗口。</li>
</ul>
</li>
<li><strong>布局支持</strong>:<ul>
<li><code>QWidget</code>: 你需要手动设置布局。</li>
<li><code>QMainWindow</code>: 提供了内置的菜单栏、工具栏、状态栏和中央部件区域，可以直接使用这些功能来设计主窗口界面。</li>
</ul>
</li>
</ol>
<p>connect(menu, &amp;QMenu::triggered, this, &amp;Widget::onMenuTriggered); 为什么QMenu* menu;时不报错 当QMenu  menu;时报错:No matching member function for call to ‘connect’</p>
<p>在 Qt 中，<code>connect</code> 函数的作用是将一个信号与一个槽函数连接起来。它依赖于信号发射的对象和槽函数的对象都是有效的，并且能够正确识别和匹配。</p>
<h3 id="使用-QMenu-menu"><a href="#使用-QMenu-menu" class="headerlink" title="使用 QMenu* menu"></a>使用 <code>QMenu* menu</code></h3><div class="language-cpp"><button title="Copy code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">QMenu</span><span style="color: #89DDFF">*</span><span style="color: #BABED8"> menu </span><span style="color: #89DDFF">=</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">new</span><span style="color: #BABED8"> </span><span style="color: #82AAFF">QMenu</span><span style="color: #89DDFF">();</span></span>
<span class="line"><span style="color: #82AAFF">connect</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">menu</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">QMenu</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">triggered</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">this,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">Widget</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">onMenuTriggered</span><span style="color: #89DDFF">);</span></span></code></pre></div><ul>
<li>这里，<code>menu</code> 是一个指向 <code>QMenu</code> 对象的指针。</li>
<li><code>connect</code> 函数可以使用 <code>menu</code> 指针来连接信号和槽，因为 <code>QMenu</code> 对象在堆上分配，并且其生命周期由指针管理。</li>
<li><code>QMenu</code> 的实例通过指针能够正确地传递给 <code>connect</code>，并且 <code>QMenu</code> 的成员函数和信号可以被正确识别。</li>
</ul>
<h3 id="使用-QMenu-menu-1"><a href="#使用-QMenu-menu-1" class="headerlink" title="使用 QMenu menu"></a>使用 <code>QMenu menu</code></h3><div class="language-cpp"><button title="Copy code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">QMenu menu</span><span style="color: #89DDFF">;</span></span>
<span class="line"><span style="color: #82AAFF">connect</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">menu</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">QMenu</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">triggered</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">this,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">Widget</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">onMenuTriggered</span><span style="color: #89DDFF">);</span></span></code></pre></div><ul>
<li>这里，<code>menu</code> 是一个栈上的 <code>QMenu</code> 对象。</li>
<li>栈上的对象在 <code>connect</code> 时会导致问题，因为 <code>connect</code> 期望信号发射对象在其生命周期内有效。栈上的对象会在超出作用域时被销毁。</li>
<li>在这个情况下，<code>menu</code> 可能在连接信号和槽时已经过早销毁，导致 <code>connect</code> 函数找不到有效的信号源。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>QMenu* menu</code>：指针允许动态管理对象的生命周期，<code>connect</code> 可以正常工作。</li>
<li><code>QMenu menu</code>：栈上的对象在超出作用域时可能被销毁，导致 <code>connect</code> 函数不能正确地处理信号和槽。</li>
</ul>
<p>因此，使用指针确保 <code>QMenu</code> 对象在 <code>connect</code> 调用期间有效。</p>
<p><img src="/../images/image-20240823104744847.png" alt="image-20240823104744847"></p>
<p><img src="/../images/image-20240823104804653.png" alt="image-20240823104804653"></p>
<p>定义对象的指针，让widght来管理对象的生命周期，要是直接定义对象，可能不知道什么时候对象就被销毁了，有些用到这些对象的函数就可能报错，因为在栈上找不到他了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Qt.html" data-id="cm040gf6300012ucx6mgg6k5d" data-title="Qt" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-risc-v" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/risc-v.html" class="article-date">
  <time class="dt-published" datetime="2024-06-18T04:31:10.000Z" itemprop="datePublished">2024-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/risc-v.html">risc_v</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240618123232143.png" alt="image-20240618123232143"></p>
<p>在RISC-V架构中，IF_ID和ID_EX是两个流水线寄存器，用于在指令执行过程中传递数据。</p>
<ol>
<li>IF_ID（Instruction Fetch to Instruction Decode）：IF_ID流水线寄存器用于在指令提取阶段（Instruction Fetch）和指令解码阶段（Instruction Decode）之间传递数据。它保存了从指令缓存中提取的指令，并将其传递给下一个阶段进行解码。</li>
<li>ID_EX（Instruction Decode to Execute）：ID_EX流水线寄存器用于在指令解码阶段（Instruction Decode）和指令执行阶段（Execute）之间传递数据。它保存了从IF_ID寄存器中解码得到的指令信息，包括操作码、寄存器地址等，并将这些信息传递给下一个阶段进行执行。</li>
</ol>
<p>通过使用这些流水线寄存器，RISC-V架构可以实现指令流水线的并行执行，提高指令的执行效率。</p>
<ol>
<li><strong>IF (Instruction Fetch) 取指</strong>：<ul>
<li>这一阶段的主要任务是从内存中的指令缓存或主存中取回当前要执行的指令。</li>
<li>在这个阶段，程序计数器（PC，Program Counter）会指向当前要取的指令地址。</li>
<li>CPU将该地址发给指令缓存，读取该地址处的指令，并将其存储到流水线寄存器（如IF&#x2F;ID寄存器）中，以便在下一阶段使用。</li>
</ul>
</li>
<li><strong>ID (Instruction Decode) 译码</strong>：<ul>
<li>这一阶段的主要任务是对取回的指令进行解码，即解析指令的操作码和操作数。</li>
<li>具体来说，CPU会读取并识别指令的操作码（Opcode），确定这条指令的类型和需要执行的操作。</li>
<li>同时，CPU还会确定指令所涉及的源操作数和目标寄存器。如果需要从寄存器文件中读取操作数，这一阶段也会执行这些操作。</li>
<li>解码后的信息会存储在流水线寄存器（如ID&#x2F;EX寄存器）中，以便在后续的执行阶段使用。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/risc-v.html" data-id="cm03k1yqc0001gycx8zxxb5cx" data-title="risc_v" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-raytracing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/raytracing.html" class="article-date">
  <time class="dt-published" datetime="2024-06-12T08:08:14.000Z" itemprop="datePublished">2024-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/raytracing.html">raytracing</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 C++ 中，冒号（<code>:</code>）用于初始化类的成员变量或调用父类的构造函数。这种语法称为成员初始化列表（member initialization list），它允许在构造函数体执行之前对成员变量进行初始化。</p>
<p>在这里，<code>vec3() : e&#123;0,0,0&#125; &#123;&#125;</code> 中的冒号后面就是成员初始化列表。<code>: e&#123;0,0,0&#125;</code> 表示对类的成员变量 <code>e</code> 进行初始化，其中 <code>&#123;0,0,0&#125;</code> 是对数组 <code>e</code> 的初始化值。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">double&amp; operator[](int i) &#123; return e[i]; &#125;</span></span></code></pre></div><p><strong><code>double&amp;</code></strong>:</p>
<ul>
<li>返回类型是 <code>double&amp;</code>，即返回一个 <code>double</code> 类型的左值引用。</li>
<li>左值引用允许函数返回一个可修改的元素，这样调用者可以直接修改这个元素。</li>
</ul>
<h3 id="左值和右值的定义"><a href="#左值和右值的定义" class="headerlink" title="左值和右值的定义"></a>左值和右值的定义</h3><ul>
<li><strong>左值（lvalue）</strong>: 可以取地址的值，通常表示内存中的一个位置。例如，变量、数组元素、对象成员等都是左值。</li>
<li><strong>右值（rvalue）</strong>: 不存在明确地址的临时值，通常是表达式的结果或者字面量。例如，字面量、临时对象、运算结果等。</li>
</ul>
<p>引用和原变量本质上是同一个东西，对引用的修改就是对原变量的修改</p>
<p><code>double&amp;</code> 表示引用</p>
<p><code>inline</code> 关键字在C++中用于建议编译器将某个函数的代码在每次调用时直接插入到调用处，而不是进行常规的函数调用。从而可以减少函数调用的开销，尤其是当函数体非常小、调用频繁时，这种优化可能会带来性能提升。</p>
<p><code>using color = vec3;</code> 这行代码是一个类型别名（type alias）的定义，将 <code>vec3</code> 类型重命名为 <code>color</code> 类型。也就是说，使用 <code>color</code> 关键字可以代替 <code>vec3</code> 类型的使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/raytracing.html" data-id="clxbjvuxs000j61cxdrun7t8l" data-title="raytracing" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-FOC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/FOC.html" class="article-date">
  <time class="dt-published" datetime="2024-05-28T23:30:54.000Z" itemprop="datePublished">2024-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/FOC.html">FOC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>可以看出，我们只需要像步进电机那样不断的重复这六部换向就可以让BLDC转动起来，甚至会产生一种错觉，是不是我们换向越快电机转的越快呢？答案是:否，这里我们一定要认识到，是当转子处于特定位置时才去触发换向操作，换向是被动换向，想要提高转速一定是要提高电流，让定子产生的磁场更强，让转子更快的达到目标点然后触发换向</p>
<p>如何获得转子角度？<br>我们已经知道了要先检测角度再去换向，那么如何检测当前角度呢？，有以下三种方式。<br>1.通过安装编码器来计算出当前角度。<br>2.通过安装霍尔元件计算当前角度。<br>3.通过检测电流来计算当前角度</p>
<p>编码器方式获取电机当前角度<br>编码器方式分为两种，增量式编码器和绝对式编码器。<br>增量式编码器：<br>每次启动之气都需要做一次校准，而且为了防止单片机性能问题导致脉冲丢失，还需要对编码器每圈校准一次。因此经常使用ABZ三轴编码器，AB输出正交信号，Z轴输出中断。<br>绝对式编码器：<br>只需要在出厂之前做一次校准，之后如果没有拆机便不需要校准，通讯方式一般是SPI和IIC,需要考虑通讯时间对系统的影响。<br>为什么要对编码器进行校准？<br>因为我们无法保证在安装的时候让编码器的0°（机械角度）刚好对应电机绕组的0°（电气角度）</p>
<p><img src="/../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTQ3MzI5,size_16,color_FFFFFF,t_70#pic_center.png" alt="img"></p>
<p>伸开左手，使拇指与其他四指垂直且在一个平面内，让磁感线从手心流入，四指指向电流方向，大拇指指向的就是安培力方向（即导体受力方向）</p>
<p><img src="/../images/resize,m_lfit,limit_1,w_536.jpeg" alt="img"></p>
<p>右手平展，使大拇指与其余四指垂直，并且都跟手掌在一个平面内。把右手放入磁场中，让<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=526702&ss_c=ssc.citiao.link">磁感线</a>从掌心进入（当磁感线为直线时，相当于手心面向N极），大拇指指向导线运动方向，则四指所指方向为导线中感应电流（动生电动势）的方向。</p>
<p><img src="/../images/image-20240529094507089.png" alt="image-20240529094507089"></p>
<p>根据想得到的电流矢量到u1,u2,u3上投影的正负，来判断在哪个扇区里，u1,u2,u3可由u_alpha,u_beta表示出</p>
<p><img src="/../images/image-20240529130329149.png" alt="image-20240529130329149"></p>
<p><img src="/../images/image-20240529130513189.png" alt="image-20240529130513189"></p>
<p><img src="/../images/image-20240529144317410.png" alt="image-20240529144317410"></p>
<p><img src="/../images/image-20240529144120858.png" alt="image-20240529144120858"></p>
<p><img src="/../images/image-20240529144220989.png" alt="image-20240529144220989"></p>
<p><img src="/../images/image-20240530115230681.png" alt="image-20240530115230681"></p>
<p>从定子来计算</p>
<p><img src="/../images/image-20240530115639643.png" alt="image-20240530115639643">可以计算出反电动势，进而计算转子的速度和位置（无感)</p>
<p>当变压器的初级绕组通电后，线圈所产生的磁通在铁心流动，因为铁心本身也是导体（由硅钢片制成），在垂直于磁力线的平面上就会感应电势，这个电势在铁心的断面上形成闭合回路并产生电流，好象一个旋涡所以称为“涡流”。这个“涡流”使变压器的损耗增加，并且使变压器的铁心发热变压器的温升增加。由“涡流”所产生的损耗我们称为“铁损”。<br>另外要绕制变压器需要用大量的铜线，这些铜导线存在着电阻，电流流过时这电阻会消耗一定的功率，这部分损耗往往变成热量而消耗，我们称这种损耗为“铜损”。<br>铁损等于铜损时，变压器效率最高。大概就是变压器额定负荷的0.65倍左右。</p>
<p>从绕组来计算（d,q,轴的电压方程）</p>
<p><img src="/../images/image-20240530130008389.png" alt="image-20240530130008389"></p>
<p>由于定子自感的属性，电流会滞后电压90度</p>
<p><img src="/../images/image-20240530180512850.png" alt="image-20240530180512850"></p>
<p><img src="/../images/image-20240530180534254.png" alt="image-20240530180534254"></p>
<p>要等幅变换，所以要乘（2&#x2F;3）</p>
<p>如果遇到乘(根号下2&#x2F;3),是等功率变换</p>
<p><img src="/../images/image-20240530181152049.png" alt="image-20240530181152049"></p>
<p><img src="/../images/image-20240530193807755.png" alt="image-20240530193807755"></p>
<p><img src="/../images/image-20240530193832651.png" alt="image-20240530193832651"></p>
<p>反帕克变换就是对帕克变换旋转矩阵求逆</p>
<p>MOS管是电压驱动型，三极管是电流驱动型</p>
<p><img src="/../images/image-20240531080240566.png" alt="image-20240531080240566"></p>
<p><img src="/../images/image-20240531102816686.png" alt="image-20240531102816686"></p>
<p>电角度&#x3D;极对数（或者<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%A7%E6%95%B0&spm=1001.2101.3001.7020">级数</a>&#x2F;2）*机械角度</p>
<p><img src="/../images/image-20240531110753146.png" alt="image-20240531110753146"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/FOC.html" data-id="clxbjvuxp000761cx4xv48vr8" data-title="FOC" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/esp32/" rel="tag">esp32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robot-kinematics/" rel="tag">robot_kinematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yolo/" rel="tag">yolo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Embedded/" style="font-size: 10px;">Embedded</a> <a href="/tags/esp32/" style="font-size: 10px;">esp32</a> <a href="/tags/robot-kinematics/" style="font-size: 10px;">robot_kinematics</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/kinematics.html">kinematics</a>
          </li>
        
          <li>
            <a href="/post/Webots.html">Webots</a>
          </li>
        
          <li>
            <a href="/post/ubuntu-nvidia.html">ubuntu-nvidia</a>
          </li>
        
          <li>
            <a href="/post/ROS.html">ROS</a>
          </li>
        
          <li>
            <a href="/post/ODriver.html">ODriver</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>