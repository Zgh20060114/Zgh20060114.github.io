<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Zgh&#39;s</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Zgh的个人站">
<meta property="og:type" content="website">
<meta property="og:title" content="Zgh&#39;s">
<meta property="og:url" content="http://zgh20060114.github.io/index.html">
<meta property="og:site_name" content="Zgh&#39;s">
<meta property="og:description" content="Zgh的个人站">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Zgh's" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zgh&#39;s</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Zgh20060114.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ubuntu-nvidia" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/ubuntu-nvidia.html" class="article-date">
  <time class="dt-published" datetime="2024-10-02T16:44:34.000Z" itemprop="datePublished">2024-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/ubuntu-nvidia.html">ubuntu-nvidia</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>写于2024-10-3-00:46</p>
<p>记录一次把ubnutu20.04de nvidia 驱动搞坏又修复，加上对ubuntu显卡驱动和独显&#x2F;混显，lightdm&#x2F;gdm3桌面管理器的理解。</p>
<p>由于webots仿真卡死崩溃，就找到一篇博客说：</p>
<pre><code>glxinfo | grep OpenGL
</code></pre>
<p>确实opengl输出的是intel集显，使用</p>
<pre><code>sudo prime-select nvidia
</code></pre>
<p>再次查看输出：</p>
<pre><code>zgh@zgh-Legion-Y7000P-IAH7:~$ glxinfo | grep OpenGL
OpenGL vendor string: Mesa/X.org
OpenGL renderer string: llvmpipe (LLVM 12.0.0, 256 bits)
</code></pre>
<p>虽然不是nvidia，但好歹不是intel了，而且仿真不会卡死崩溃了</p>
<pre><code>sudo systemctl restart gdm3

/etc/X11/xorg.conf

xrandr

glxinfo | grep OpenGL

nvidia-settings
</code></pre>
<p>####sudo nvidia-xconfig 不要用这个命令，它会生成什么Xorg的配置文件，把你之前能用的显示配置覆盖掉</p>
<p><code>/etc/X11/xorg.conf</code>内容：</p>
<pre><code> # nvidia-xconfig: X configuration file generated by nvidia-xconfig
# nvidia-xconfig:  version 535.154.05


Section &quot;ServerLayout&quot;
    Identifier     &quot;Layout0&quot;
    Screen      0  &quot;Screen0&quot; 0 0
    InputDevice    &quot;Keyboard0&quot; &quot;CoreKeyboard&quot;
    InputDevice    &quot;Mouse0&quot; &quot;CorePointer&quot;
EndSection

Section &quot;Files&quot;
EndSection

Section &quot;InputDevice&quot;

    # generated from default
    Identifier     &quot;Mouse0&quot;
    Driver         &quot;mouse&quot;
    Option         &quot;Protocol&quot; &quot;auto&quot;
    Option         &quot;Device&quot; &quot;/dev/psaux&quot;
    Option         &quot;Emulate3Buttons&quot; &quot;no&quot;
    Option         &quot;ZAxisMapping&quot; &quot;4 5&quot;
EndSection

Section &quot;InputDevice&quot;

    # generated from default
    Identifier     &quot;Keyboard0&quot;
    Driver         &quot;kbd&quot;
EndSection

Section &quot;Monitor&quot;
    Identifier     &quot;Monitor0&quot;
    VendorName     &quot;Unknown&quot;
    ModelName      &quot;Unknown&quot;
    Option         &quot;DPMS&quot;
EndSection

Section &quot;Device&quot;
    Identifier     &quot;Device0&quot;
    Driver         &quot;nvidia&quot;
    VendorName     &quot;NVIDIA Corporation&quot;
    BusID          &quot;PCI:1:0:0&quot;
EndSection

Section &quot;Screen&quot;
    Identifier     &quot;Screen0&quot;
    Device         &quot;Device0&quot;  #就是要用独立显卡启动
    Monitor        &quot;Monitor0&quot;
    DefaultDepth    24
    SubSection     &quot;Display&quot;
        Depth       24
    EndSubSection
EndSection
</code></pre>
<p>如果这样写：</p>
<pre><code>Section &quot;Device&quot;
    Identifier     &quot;Device0&quot;
    Driver         &quot;nvidia&quot;
    VendorName     &quot;NVIDIA Corporation&quot;
    BusID          &quot;PCI:1:0:0&quot;
EndSection

Section &quot;Screen&quot;
    Identifier     &quot;Screen0&quot;
    Device         &quot;Device1&quot;
    Monitor        &quot;Monitor0&quot;
    DefaultDepth    24
    SubSection     &quot;Display&quot;
        Depth       24
    EndSubSection
EndSection

Section &quot;Device&quot;
        Identifier  &quot;Device1&quot;
        Driver      &quot;intel&quot;
        VendorName  &quot;Intel Corporation&quot;
        Option      &quot;TripleBuffer&quot; &quot;true&quot;
        Option      &quot;TearFree&quot;     &quot;true&quot;
        Option      &quot;DRI&quot;          &quot;false&quot;   #这三条都是为了防止集显显示桌面的时候画面割裂
        BusID       &quot;PCI:0:2:0&quot;
EndSection
</code></pre>
<p>是以Intel集显启动，确实有用</p>
<p>但是此时bios里设置的混合显示，只会使用集显,nvidia-settings内容错误，只能显示笔记本屏幕，无法连接外接显示器。</p>
<p>然后又换lightdm试一试，发现还是只能显示一个，甚至只能显示外接屏幕，拔去外接屏幕，笔记本屏幕也不会亮。</p>
<p>最后又换回了dgm3</p>
<p>##总结：</p>
<h1 id="只有bios独立显卡-etc-X11-xorg-conf使用独立显卡-dgm3才能正常使用。"><a href="#只有bios独立显卡-etc-X11-xorg-conf使用独立显卡-dgm3才能正常使用。" class="headerlink" title="#只有bios独立显卡 +  &#x2F; etc&#x2F;X11&#x2F;xorg.conf使用独立显卡 +dgm3才能正常使用。"></a>#只有bios独立显卡 +  &#x2F; etc&#x2F;X11&#x2F;xorg.conf使用独立显卡 +dgm3才能正常使用。</h1><p>2024-10-3-14:44</p>
<p>这样确实可以用，但是独显功耗太大，而且不知道为什么webots非常卡，看来还是不对</p>
<p>bios混显模式+删除xorg.conf</p>
<p>先修改xorg.conf，把GPU，Intel标清，然后用Intel显示，进入桌面，看到nvidia-settings能选择这三种模式了（这是还不是很对，左面只有一个PRIME Profiles）</p>
<p>重启</p>
<p>在tty里把xorg.conf文件rm掉，</p>
<p>直接reboot</p>
<p>就一切正常了，看一下:</p>
<p><img src="/../images/image-20241003145229468.png" alt="image-20241003145229468"></p>
<p><img src="/../images/image-20241003144809104.png" alt="image-20241003144809104"></p>
<p>nvidia-smi也正常了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/ubuntu-nvidia.html" data-id="cm1s3lpib0000fkcxgc9d188z" data-title="ubuntu-nvidia" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ROS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/ROS.html" class="article-date">
  <time class="dt-published" datetime="2024-09-20T23:57:14.000Z" itemprop="datePublished">2024-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/ROS.html">ROS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240921180747237.png" alt="image-20240921180747237"></p>
<p><img src="/../images/image-20240922084731413.png" alt="image-20240922084731413"></p>
<p><em><strong>legged_control</strong></em></p>
<p>基于OCS2和ros-controls的非线性<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MPC&spm=1001.2101.3001.7020">MPC 1</a>与WBC框架</p>
<ul>
<li><strong>docs</strong> - 包含项目文档和说明。</li>
<li><strong>legged_common</strong> - 共享的数据结构和函数库。</li>
<li><strong>legged_control</strong> - 主控制堆栈的源码，实现了NMPC和WBC的核心算法。</li>
<li><strong>legged_controllers</strong> - 控制器的具体实现，如腿部运动模式控制器。</li>
<li><strong>legged_estimation</strong> - 估计相关的组件，可能涉及状态估计或传感器数据处理。</li>
<li><strong>legged_examples</strong> - 示例代码，可能含有特定机器人的示例配置或仿真设置。</li>
<li><strong>legged_gazebo</strong> - Gazebo仿真相关文件，用于虚拟环境中测试机器人。</li>
<li><strong>legged_hw</strong> - 硬件交互层，用于实际机器人的控制。</li>
<li><strong>legged_interface</strong> - 提供与机器人交互的API。</li>
<li><strong>legged_wbc</strong> - Whole Body Control的相关代码。</li>
<li><strong>qpoases_catkin</strong> - 可能是作为依赖项的QPOASES求解器的ROS集成。</li>
</ul>
<p>Ubuntu 20.04    </p>
<p>ROS noetic </p>
<p>catkin</p>
<p><em><strong>OCS2 是一个针对切换系统优化控制的 C++ 工具箱，适用于机器人任务，包括路径约束处理和 URDF 模型支持。它提供了高效算法如 SLQ、iLQR 和 SQP，并具有 ROS 接口。工具箱包含自动微分工具，确保在有限计算能力的机器人应用中实现数值稳定和高效控制。</strong></em></p>
<p>OCS2是一个大型单库项目；请<strong>不要</strong>尝试编译整个仓库。</p>
<p>URDF文件和YAML文件通常在 ROS 启动文件中被调用。具体步骤如下：</p>
<ol>
<li><p><strong>URDF 文件</strong>：</p>
<ul>
<li>在启动文件（<code>.launch</code>）中使用 <code>&lt;param&gt;</code> 标签将 URDF 文件加载到参数服务器：<pre><code class="xml">&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro $(find your_package)/urdf/your_robot.urdf.xacro&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>YAML 文件</strong>：</p>
<ul>
<li>也可以在启动文件中使用 <code>&lt;rosparam&gt;</code> 标签加载 YAML 文件：<pre><code class="xml">&lt;rosparam file=&quot;$(find your_package)/config/your_config.yaml&quot; command=&quot;load&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>节点中访问</strong>：</p>
<ul>
<li>在你的 ROS 节点代码中，可以通过 <code>ros::param::get()</code> 或 <code>ros::NodeHandle</code> 来访问这些参数。</li>
</ul>
</li>
</ol>
<p>这样，URDF 和 YAML 文件就能在你的 ROS 项目中被有效地调用和使用。</p>
<pre><code>&lt;geometry&gt;  &lt;!--几何形状--&gt;
</code></pre>
<pre><code>&lt;inertial&gt;      &lt;!--惯性属性--&gt;
</code></pre>
<pre><code>&lt;joint name=&quot;world_to_slideBar&quot; type=&quot;fixed&quot;&gt;  &lt;!--这个关节用于将 slideBar 固定在世界坐标系中的特定位置，使得它在仿真中保持稳定，提供支撑作用。--&gt;
    &lt;parent link=&quot;world&quot;/&gt;
    &lt;child link=&quot;slideBar&quot;/&gt;
    &lt;origin xyz=&quot;0.0 0.0 2.0&quot;/&gt;
&lt;/joint&gt;
</code></pre>
<pre><code>&lt;gazebo reference=&quot;slideBar&quot;&gt;
</code></pre>
<ul>
<li><strong>Gazebo特定属性</strong>: 用于指定该链接在 Gazebo 中的特性。</li>
</ul>
<p>​     <code>&lt;mass value=&quot;0.1&quot;/&gt;</code></p>
<ul>
<li><strong>质量</strong>: 指定了链接的质量为 0.1 千克</li>
</ul>
<h4 id="位置"><a href="#位置" class="headerlink" title="&lt;origin&gt;  位置"></a><code>&lt;origin&gt;</code>  位置</h4><p><img src="/../images/image-20240924221522926.png" alt="image-20240924221522926"></p>
<p>自由度通俗的讲就是为了唯一确定一个机构的运动状态所必须的独立变量的个数</p>
<p><img src="/../images/image-20240925083033316.png" alt="image-20240925083033316"></p>
<p><img src="/../images/image-20240925085251799.png" alt="image-20240925085251799"></p>
<p>c12&#x3D;cos(seta1+seta2 )</p>
<p><img src="/../images/image-20240925085203224.png" alt="image-20240925085203224"></p>
<p><img src="/../images/image-20240925090201537.png" alt="image-20240925090201537"></p>
<p><img src="/../images/image-20240925091223929.png" alt="image-20240925091223929"></p>
<p><img src="/../images/image-20240925123003125.png" alt="image-20240925123003125"></p>
<pre><code>&lt;joint name=&quot;base_to_plat&quot; type=&quot;prismatic&quot;&gt;
    &lt;axis xyz=&quot;1 0 0&quot;/&gt;
    &lt;origin xyz=&quot;0.0 0.0 0.0&quot;/&gt;
    &lt;parent link=&quot;slideBar&quot;/&gt;
    &lt;child link=&quot;cart&quot;/&gt;
    &lt;limit effort=&quot;100000.0&quot; lower=&quot;-15&quot; upper=&quot;15&quot; velocity=&quot;100&quot;/&gt;
    &lt;dynamics damping=&quot;0.0&quot; friction=&quot;0.0&quot;/&gt;
&lt;/joint&gt;
</code></pre>
<p>是什么意思</p>
<p>这段代码定义了一个名为 <code>base_to_plat</code> 的滑动关节（prismatic joint），其主要功能是让 <code>cart</code> 在 <code>slideBar</code> 上进行线性滑动。以下是对每个部分的详细解释：</p>
<h3 id="1"><a href="#1" class="headerlink" title="1. &lt;joint name=&quot;base_to_plat&quot; type=&quot;prismatic&quot;&gt;"></a>1. <code>&lt;joint name=&quot;base_to_plat&quot; type=&quot;prismatic&quot;&gt;</code></h3><ul>
<li><strong>名称和类型</strong>:<ul>
<li><code>name=&quot;base_to_plat&quot;</code>: 该关节的名称是 <code>base_to_plat</code>。</li>
<li><code>type=&quot;prismatic&quot;</code>: 关节类型为滑动关节，允许连接的部分沿一个轴线性移动。</li>
</ul>
</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2. &lt;axis xyz=&quot;1 0 0&quot;/&gt;"></a>2. <code>&lt;axis xyz=&quot;1 0 0&quot;/&gt;</code></h3><ul>
<li><strong>运动轴</strong>:<ul>
<li><code>xyz=&quot;1 0 0&quot;</code>: 表示滑动关节的运动轴为 X 轴。<code>1</code> 表示在 X 方向上有运动，而 Y 和 Z 方向上没有运动。</li>
</ul>
</li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3. &lt;origin xyz=&quot;0.0 0.0 0.0&quot;/&gt;"></a>3. <code>&lt;origin xyz=&quot;0.0 0.0 0.0&quot;/&gt;</code></h3><ul>
<li><strong>原点位置</strong>:<ul>
<li><code>xyz=&quot;0.0 0.0 0.0&quot;</code>: 该关节的原点位置设置在 (0, 0, 0)，通常是关节的中心点。</li>
</ul>
</li>
</ul>
<h3 id="4"><a href="#4" class="headerlink" title="4. &lt;parent link=&quot;slideBar&quot;/&gt;"></a>4. <code>&lt;parent link=&quot;slideBar&quot;/&gt;</code></h3><ul>
<li><strong>父链接</strong>:<ul>
<li><code>link=&quot;slideBar&quot;</code>: 指定 <code>slideBar</code> 是该关节的父链接。也就是说，<code>cart</code> 相对于 <code>slideBar</code> 移动。</li>
</ul>
</li>
</ul>
<h3 id="5"><a href="#5" class="headerlink" title="5. &lt;child link=&quot;cart&quot;/&gt;"></a>5. <code>&lt;child link=&quot;cart&quot;/&gt;</code></h3><ul>
<li><strong>子链接</strong>:<ul>
<li><code>link=&quot;cart&quot;</code>: 指定 <code>cart</code> 是该关节的子链接。表示 <code>cart</code> 将通过该关节的运动影响到。</li>
</ul>
</li>
</ul>
<h3 id="6"><a href="#6" class="headerlink" title="6. &lt;limit effort=&quot;100000.0&quot; lower=&quot;-15&quot; upper=&quot;15&quot; velocity=&quot;100&quot;/&gt;"></a>6. <code>&lt;limit effort=&quot;100000.0&quot; lower=&quot;-15&quot; upper=&quot;15&quot; velocity=&quot;100&quot;/&gt;</code></h3><ul>
<li><strong>运动限制</strong>:<ul>
<li><code>effort=&quot;100000.0&quot;</code>: 该关节能够承受的最大力为 100,000（单位通常为牛顿）。</li>
<li><code>lower=&quot;-15&quot;</code>: 关节的最小位置限制为 -15（单位通常为米），表示 <code>cart</code> 可以向后滑动的最大距离。</li>
<li><code>upper=&quot;15&quot;</code>: 关节的最大位置限制为 15（单位通常为米），表示 <code>cart</code> 可以向前滑动的最大距离。</li>
<li><code>velocity=&quot;100&quot;</code>: 关节的最大速度为 100（单位通常为米&#x2F;秒），表示 <code>cart</code> 的移动速度限制。</li>
</ul>
</li>
</ul>
<h3 id="7"><a href="#7" class="headerlink" title="7. &lt;dynamics damping=&quot;0.0&quot; friction=&quot;0.0&quot;/&gt;"></a>7. <code>&lt;dynamics damping=&quot;0.0&quot; friction=&quot;0.0&quot;/&gt;</code></h3><ul>
<li><strong>动力学属性</strong>:<ul>
<li><code>damping=&quot;0.0&quot;</code>: 阻尼系数为 0，表示没有额外的阻力影响滑动。</li>
<li><code>friction=&quot;0.0&quot;</code>: 摩擦系数为 0，表示在滑动过程中没有摩擦力。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段代码的主要目的是定义一个滑动关节，使得 <code>cart</code> 可以在 X 轴上滑动，受到的限制和动力学特性被明确设定。这在机器人和机械模拟中是非常重要的，可以精确控制其运动行为。</p>
<pre><code>&lt;transmission name=&quot;tran2&quot;&gt;
    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
    &lt;joint name=&quot;base_to_plat&quot;&gt;
        &lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;
    &lt;/joint&gt;
    &lt;actuator name=&quot;planar_motor_2&quot;&gt;
        &lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;
        &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;
    &lt;/actuator&gt;
&lt;/transmission&gt;
</code></pre>
<p>是什么意思</p>
<p>这段代码定义了一个名为 <code>tran2</code> 的传动系统，主要用于连接一个滑动关节和一个执行器。以下是各部分的解释：</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1. &lt;transmission name=&quot;tran2&quot;&gt;"></a>1. <code>&lt;transmission name=&quot;tran2&quot;&gt;</code></h3><ul>
<li><strong>传动系统名称</strong>: 这个传动系统被命名为 <code>tran2</code>。</li>
</ul>
<h3 id="2-transmission-interface-SimpleTransmission"><a href="#2-transmission-interface-SimpleTransmission" class="headerlink" title="2. &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;"></a>2. <code>&lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;</code></h3><ul>
<li><strong>传动类型</strong>: 使用简单传动接口，表明传动的实现相对直接。</li>
</ul>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3. &lt;joint name=&quot;base_to_plat&quot;&gt;"></a>3. <code>&lt;joint name=&quot;base_to_plat&quot;&gt;</code></h3><ul>
<li><strong>关节连接</strong>: 连接到先前定义的滑动关节 <code>base_to_plat</code>。</li>
</ul>
<h3 id="4-hardware-interface-EffortJointInterface"><a href="#4-hardware-interface-EffortJointInterface" class="headerlink" title="4. &lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;"></a>4. <code>&lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;</code></h3><ul>
<li><strong>硬件接口</strong>: 该关节使用的是努力关节接口，意味着通过施加力来控制关节运动。</li>
</ul>
<h3 id="5-1"><a href="#5-1" class="headerlink" title="5. &lt;actuator name=&quot;planar_motor_2&quot;&gt;"></a>5. <code>&lt;actuator name=&quot;planar_motor_2&quot;&gt;</code></h3><ul>
<li><strong>执行器名称</strong>: 该传动系统连接的执行器名为 <code>planar_motor_2</code>。</li>
</ul>
<h3 id="6-1"><a href="#6-1" class="headerlink" title="6. &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;"></a>6. <code>&lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;</code></h3><ul>
<li><strong>机械减速比</strong>: 设置为 1，表示执行器的输出与输入之间没有减速，直接传递力。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>整体上，这段代码用于定义一个简单的传动系统，将滑动关节和电机连接起来，以便通过施加力来控制滑动运动。</p>
<h5 id="JointState-消息内容"><a href="#JointState-消息内容" class="headerlink" title="JointState 消息内容"></a><code>JointState</code> 消息内容</h5><p><code>JointState</code> 消息通常包含以下字段：</p>
<ul>
<li><strong><code>name</code></strong>: 存储关节名称的字符串数组。</li>
<li><strong><code>position</code></strong>: 存储每个关节当前角度或位置的浮点数数组。</li>
<li><strong><code>velocity</code></strong>: 存储每个关节当前速度的浮点数数组。</li>
<li><strong><code>effort</code></strong>: 存储每个关节当前力矩或用力程度的浮点数数组。</li>
</ul>
<p><img src="/../images/image-20240927144924380.png" alt="image-20240927144924380"></p>
<p>LQR（线性二次调节器，Linear Quadratic Regulator）是一种用于控制系统的优化方法。它旨在通过最小化某个代价函数来设计控制器，通常用于线性动态系统。</p>
<h3 id="LQR-的基本公式"><a href="#LQR-的基本公式" class="headerlink" title="LQR 的基本公式"></a>LQR 的基本公式</h3><p>假设有一个线性系统描述为：<br>$ \dot{x} &#x3D; Ax + Bu $<br>其中：</p>
<ul>
<li>( x ) 是状态向量</li>
<li>( u ) 是控制输入</li>
<li>( A ) 和 ( B ) 是系统矩阵</li>
</ul>
<p>LQR 通过最小化以下代价函数来设计控制器：<br>$ J &#x3D; \int_0^{\infty} (x^T Q x + u^T R u) , dt $<br>其中：</p>
<ul>
<li>( Q ) 是状态权重矩阵，通常是半正定的$(Q \geq 0 )$</li>
<li>( R ) 是控制输入权重矩阵，通常是正定的（$ R &gt; 0 $）</li>
</ul>
<h3 id="最优控制律"><a href="#最优控制律" class="headerlink" title="最优控制律"></a>最优控制律</h3><p>通过求解代价函数的最小值，可以得到最优控制律：<br>$ u &#x3D; -Kx $<br>其中 $K $是增益矩阵，通过以下公式计算：<br>$K &#x3D; R^{-1} B^T P $<br>而$  P $ 是 Riccati 方程的解：<br>$A^T P + PA - PBR^{-1}B^T P + Q &#x3D; 0 $ </p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>LQR 方法通过设计一个控制器，最小化系统状态和控制输入的加权平方和，从而实现对线性系统的有效控制。它广泛应用于工程、自动控制、机器人等领域。</p>
<h3 id="代码实现过程"><a href="#代码实现过程" class="headerlink" title="代码实现过程"></a>代码实现过程</h3><p>在你提供的代码中，LQR控制器的设计过程主要包含以下几个步骤：</p>
<ol>
<li><p><strong>逆矩阵计算</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;double, 1, 1&gt; R_inv = R_.inverse();
</code></pre>
<p>这里计算了控制输入权重矩阵 (R) 的逆。</p>
</li>
<li><p><strong>计算 BRB 项</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;double, 4, 4&gt; BRB = B_ * R_inv(0, 0) * B_.transpose();
</code></pre>
<p>这一步计算了 $BR^{-1}B^T$项，用于构建哈密尔顿矩阵。</p>
</li>
<li><p><strong>构造哈密尔顿矩阵</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;do	uble, 8, 8&gt; H;
H.topLeftCorner(4, 4) = A_;
H.topRightCorner(4, 4) = -BRB;
H.bottomLeftCorner(4, 4) = -Q_;
H.bottomRightCorner(4, 4) = -A_.transpose();
</code></pre>
<p>哈密尔顿矩阵 (H) 是 LQR 解的核心部分，它结合了系统的动态矩阵 (A)、控制输入矩阵 (B) 和权重矩阵 (Q) 和 (R)。</p>
</li>
<li><p><strong>特征值和特征向量计算</strong>：</p>
<pre><code class="cpp">Eigen::ComplexEigenSolver&lt;Eigen::Matrix&lt;double, 8, 8&gt;&gt; ces;
ces.compute(H);
</code></pre>
<p>通过计算哈密尔顿矩阵的特征值和特征向量来获取系统的稳定性信息。</p>
</li>
<li><p><strong>选择稳定特征向量</strong>：</p>
<pre><code class="cpp">for (int i = 0; i &lt; 8; ++i)
&#123;
    if (eigenvalues(i).real() &lt; 0 &amp;&amp; index &lt; 4)
    &#123;
        Vs.col(index) = eigenvectors.col(i);
        ++index;
    &#125;
&#125;
</code></pre>
<p>选择具有负实部的特征值对应的特征向量，以确保系统的稳定性。</p>
</li>
<li><p><strong>解Ricatti方程</strong>：</p>
<pre><code class="cpp">Eigen::MatrixXcd P_c = Vs2 * Vs1.inverse();
Eigen::Matrix4d P = P_c.real(); // Take the real part
</code></pre>
<p>通过特征向量计算 Riccati 方程的解 (P)，这是 LQR 控制中的关键步骤。</p>
</li>
<li><p><strong>计算 LQR 增益矩阵</strong>：</p>
<pre><code class="cpp">Eigen::Matrix&lt;double, 1, 4&gt; K_temp = R_inv(0, 0) * B_.transpose() * P;
return K_temp.transpose();
</code></pre>
<p>最后计算控制增益矩阵 (K)，该矩阵用于生成控制输入。</p>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>LQR 控制器的实现通过构造哈密尔顿矩阵，计算其特征值和特征向量，求解 Riccati 方程，最终得到一个最优控制增益 (K)。通过这种方式，LQR 能够有效地平衡系统的性能和控制输入，以保证系统的稳定性和响应速度。</p>
<p><code>Eigen::MatrixXd</code> 和 <code>Eigen::Matrix4d</code> 是 Eigen 库中用于表示矩阵的两种不同类型。它们的主要区别如下：</p>
<h3 id="1-尺寸"><a href="#1-尺寸" class="headerlink" title="1. 尺寸"></a>1. 尺寸</h3><ul>
<li><strong><code>Eigen::MatrixXd</code></strong>:<ul>
<li>这是一个动态大小的矩阵，表示一个任意大小的矩阵。</li>
<li>在运行时可以根据需要动态调整其行数和列数。</li>
</ul>
</li>
<li><strong><code>Eigen::Matrix4d</code></strong>:<ul>
<li>这是一个固定大小的矩阵，专门表示一个 <strong>4x4</strong> 的矩阵。</li>
<li>行数和列数在编译时就已经确定，不能被更改。</li>
</ul>
</li>
</ul>
<h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><ul>
<li><strong><code>Eigen::MatrixXd</code></strong>:<ul>
<li>由于是动态大小，内存分配通常是在堆上进行管理，可能会有额外的开销。</li>
</ul>
</li>
<li><strong><code>Eigen::Matrix4d</code></strong>:<ul>
<li>由于大小固定，内存分配是静态的，通常在栈上分配，性能更高，尤其在小矩阵操作时。</li>
</ul>
</li>
</ul>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul>
<li><strong><code>Eigen::MatrixXd</code></strong>:<ul>
<li>适合处理不确定大小的矩阵，特别是在算法中需要处理各种尺寸的情况时。</li>
</ul>
</li>
<li><strong><code>Eigen::Matrix4d</code></strong>:<ul>
<li>适合处理明确为 <strong>4x4</strong> 矩阵的场景，如图形变换、旋转矩阵等。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/ROS.html" data-id="cm1bdrnch0001vzcxgetpe45n" data-title="ROS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ODriver" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/ODriver.html" class="article-date">
  <time class="dt-published" datetime="2024-09-06T02:16:53.000Z" itemprop="datePublished">2024-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/ODriver.html">ODriver</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>共有PWM模块、ADC电流采集、定时器编码器配置、SVPWM模块、FOC核心、PID模块、电压限幅模块，其实有了PWM与SVPWM以及一些必要的数学变换，我们就可以开环使电机转起来了，加入电角度与电流采集作为反馈后，我们就能做到电流闭环，再加入速度PID就可以做到速度闭环，其他的模块只是这些目的的辅助手段罢了</p>
<p> 一、编码器的分类</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">按工作原理的不同可分为增量型和绝对值型。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">(1) 增量型 （增量式可以理解为信号即位移的增加，需要参考量）</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8"> 增量式编码器的原理是将位移转换成周期性的电信号，再把这个电信号转变成计数脉冲，用脉冲的个数表示位移的大小。增量式编码器转轴旋转时，有相应的脉冲输出，其旋转方向的判别和脉冲数量的增减借助后部的判向电路和计数器来实现。其计数起点任意设定，可实现多圈无限累加和测量。还可以把每转发出一个脉冲的Z信号，作为参考机械零位。编码器轴转一圈会输出固定的脉冲，脉冲数由编码器光栅的线数决定。需要提高分辨率时，可利用 90 度相位差的 A、B两路信号对原脉冲数进行倍频，或者更换高分辨率编码器。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8"> 简单来说，增量型编码器总共有三种相线输出，A相、B相、Z相。其中电机每转过一定的角度，A相和B相就输出一个脉冲，且A相和B相相互延迟1/4周期，电机的正反转就是根据A相和B相的延迟关系判断的。Z相为单圈脉冲，即每转一圈输出一个脉冲，可以作为参考机械零位。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">(2) 绝对型（直接输出数字量的传感器，不需要参考量）</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">绝对编码器光码盘上有许多道光通道刻线，每道刻线依次以2线、4线、8线、16线编排，这样，在编码器的每一个位置，通过读取每道刻线的通、暗，获得一组从2的零次方到2的n-1次方的唯一的2进制编码（格雷码），这就称为n位绝对编码器。这样的编码器是由光电码盘进行记忆的。</span></span>
<span class="line"><span style="color: #babed8"></span></span>
<span class="line"><span style="color: #babed8">简单来说，就是对应一圈，电机的每个角度都有一个与该角度对应二进制的数值，且这个数值不会改变，所以称为绝对型编码器。</span></span></code></pre></div><p>二、不同编码器的优缺点及其对应应用范围</p>
<p>   增量型：</p>
<p>增量式编码器十分合适测速度，可无限累加丈量<br>是存在零点累计差错，抗干扰较差，接纳设备的停机需断电回忆<br>增量式编码器的一般应用测速，测转动方向，测移动角度、距离(相对)。</p>
<p>   绝对型：</p>
<p>发生电源故障也不丢失轴位置<br>绝对式编码器十分适合测量位置，可直接输出<br>绝对编码器一般能够以 8 到 12位输出 360 °更精确，但也更昂贵</p>
<h2 id="0、系统配置"><a href="#0、系统配置" class="headerlink" title="0、系统配置"></a>0、系统配置</h2><h2 id="1、电机有力了！（PWM模块）"><a href="#1、电机有力了！（PWM模块）" class="headerlink" title="1、电机有力了！（PWM模块）"></a>1、电机有力了！（PWM模块）</h2><p>高级定时器主要用于产生6路互补的PWM来驱动MOS管，加入死区防止电源导通，本文未使用刹车引脚。高级定时器1通道1、2、3用于产生PWM，通道4用于触发ADC电流采样，根据扇区的位置，灵活设置PWM占空比，进而选择合理的触发点，避免在噪声点采样。引脚配置与PWM极性请根据自己的硬件合理配置，如IR2101是高电平有效，而IR2103则是低端低有效，高端高有效。</p>
<p>定时器从0开始向上计数 当0-t1段,定时器计数器TIMx_CNT值小于CCRx值,输出低电平 t1-t2段,定时器计数器TIMx_CNT值大于CCRx值,输出高电平 当TIMx_CNT值达到ARR时,定时器溢出,重新向上计数…循环此过程 至此一个PWM周期完成</p>
<p>TIMx_ARR寄存器确定PWM频率，<br>TIMx_CCRx寄存器确定占空比</p>
<p><img src="/../images/image-20240907102129162.png" alt="image-20240907102129162"></p>
<p>LED等推挽输出</p>
<p><img src="/../images/image-20240909104907079.png" alt="image-20240909104907079"></p>
<p><img src="/../images/image-20240909105404369.png" alt="image-20240909105404369"></p>
<p><img src="/../images/image-20240909105448227.png" alt="image-20240909105448227"></p>
<p><img src="/../images/image-20240909105833521.png" alt="image-20240909105833521"></p>
<p><img src="/../images/image-20240910132838967.png" alt="image-20240910132838967"></p>
<p><img src="/../images/image-20240910132746715.png" alt="image-20240910132746715"></p>
<p><img src="/../images/image-20240910132952045.png" alt="image-20240910132952045"></p>
<p><img src="/../images/v2-49051363300bd5ea2f30d5391c784ece_720w.webp" alt="img"></p>
<p><img src="/../images/image-20240915213051309.png" alt="image-20240915213051309"></p>
<p><img src="/../images/image-20240915213823875.png" alt="image-20240915213823875"></p>
<p><img src="/../images/image-20240915214652354.png" alt="image-20240915214652354"></p>
<p><img src="/../images/image-20240916160612586.png" alt="image-20240916160612586"></p>
<p><img src="/../images/image-20240916161725535.png" alt="image-20240916161725535"></p>
<p>使用opencv进行颜色识别时受光照影响很大怎么办?<br>1.白平衡算法</p>
<p>2.对于图像数据受到光照度不足或者曝光引起的对比度太小的情况，在图像处理中一般是图像直方图均衡化的方法来处理。直方图均衡化是通过拉伸像素强度分布范围来增强图像对比度的一种方法。例如，更亮的图像将所有像素限制在高值。但是一个好的图像会有来自图像所有区域的像素。因此，我们需要将这个直方图扩展到两端，而这就是直方图均衡化所做的事情(用简单的话来说)。这通常会改善图像的对比度。<br><strong>全局直方图均衡化</strong>,<strong>自适应局部直方图均衡化</strong></p>
<h6 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值?"></a>自适应阈值?</h6><p>- </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/ODriver.html" data-id="cm1bdrncg0000vzcx2kspdeqb" data-title="ODriver" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Cplusplus" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Cplusplus.html" class="article-date">
  <time class="dt-published" datetime="2024-08-21T15:35:17.000Z" itemprop="datePublished">2024-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Cplusplus.html">Cplusplus</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="模版元编程与函数式"><a href="#模版元编程与函数式" class="headerlink" title="模版元编程与函数式"></a>模版元编程与函数式</h3><p><img src="/../images/image-20240808230648900.png" alt="image-20240808230648900"></p>
<p><img src="/../images/image-20240820160811024.png" alt="image-20240820160811024"></p>
<p>template <typename T></p>
<p><img src="/../images/image-20240820162244999.png" alt="image-20240820162244999"></p>
<p><img src="/../images/image-20240820162358151.png" alt="image-20240820162358151"></p>
<p><code>std::enable_if</code> 是 C++ 标准库中的一个模板工具，通常用于实现 SFINAE（Substitution Failure Is Not An Error）技术。它位于 <code>&lt;type_traits&gt;</code> 头文件中，用于在模板编程中根据条件启用或禁用模板的实例化。</p>
<ul>
<li><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>std::enable_if</code> 的基本结构如下：</p>
<pre><code class="cpp">template &lt;bool B, typename T = void&gt;
struct enable_if &#123;
  using type = T;
&#125;;

template &lt;typename T&gt;
struct enable_if&lt;false, T&gt; &#123;
  // 这个结构体是未定义的
&#125;;
</code></pre>
</li>
<li><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3></li>
<li><p><strong><code>std::enable_if</code> 主要有两个模板参数</strong>：</p>
<ul>
<li><code>B</code>：一个布尔值（通常是编译时常量表达式），用于决定 <code>type</code> 成员是否有效。</li>
<li><code>T</code>：一个默认类型（默认为 <code>void</code>），当 <code>B</code> 为真时，<code>type</code> 成员将定义为 <code>T</code>。</li>
</ul>
</li>
<li><p><strong>当 <code>B</code> 为真时</strong>，<code>std::enable_if</code> 的 <code>type</code> 成员被定义为 <code>T</code>。这意味着我们可以使用 <code>std::enable_if</code> 的 <code>type</code> 来在模板中进行条件判断。</p>
</li>
<li><p><strong>当 <code>B</code> 为假时</strong>，<code>std::enable_if</code> 的 <code>type</code> 成员没有定义。尝试使用这种情况下的 <code>type</code> 成员会导致编译错误，从而使得该模板实例化失败。这样可以用来控制模板的选择和重载。</p>
</li>
<li><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个使用 <code>std::enable_if</code> 的示例，演示如何根据类型的特性来启用或禁用函数模板：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

// 用于启用整数类型的模板函数
template&lt;typename T&gt;
typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type
printType() &#123;
  std::cout &lt;&lt; &quot;Integral type\n&quot;;
&#125;

// 用于启用非整数类型的模板函数
template&lt;typename T&gt;
typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value, void&gt;::type
printType() &#123;
  std::cout &lt;&lt; &quot;Non-integral type\n&quot;;
&#125;

int main() &#123;
  printType&lt;int&gt;();    // 输出: Integral type
  printType&lt;double&gt;(); // 输出: Non-integral type
  return 0;
&#125;
</code></pre>
<p>在这个示例中：</p>
</li>
<li><p><code>printType&lt;int&gt;()</code> 会选择第一个模板版本，因为 <code>int</code> 是整数类型。</p>
</li>
<li><p><code>printType&lt;double&gt;()</code> 会选择第二个模板版本，因为 <code>double</code> 不是整数类型。</p>
</li>
<li><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3></li>
<li><p><strong>编译时替换</strong>：<code>std::enable_if</code> 根据布尔表达式 <code>B</code> 的值来决定是否定义 <code>type</code> 成员。</p>
</li>
<li><p><strong>条件启用</strong>：在模板参数中使用 <code>std::enable_if</code> 可以有效地启用或禁用某些模板实例化。</p>
</li>
<li><p><strong>SFINAE</strong>：如果 <code>B</code> 为假，<code>type</code> 成员未定义，尝试实例化使用 <code>type</code> 的模板将导致编译错误，从而引发 SFINAE 机制。</p>
<p>通过这种方式，<code>std::enable_if</code> 可以帮助实现条件模板选择，使得模板编程更加灵活和强大。</p>
<p><img src="/../images/image-20240820163258259.png" alt="image-20240820163258259"></p>
<p>模板的参数可以作为编译器常量，可以自动优化</p>
<p><img src="/../images/image-20240820163542636.png" alt="image-20240820163542636"></p>
<p><img src="/../images/image-20240820163702315.png" alt="image-20240820163702315"></p>
<p><img src="/../images/image-20240820163833807.png" alt="image-20240820163833807"></p>
<p>N变一次，编译器就会重新实例化一遍模版函数，编译就变慢</p>
<p>模版函数必须定义在同一个文件里才能使用（必须是内联的或者在头文件里的），所以模板函数的定义和实现无法分离，因此除非特殊手段，模板函数的定义和实现必须放到头文件里。</p>
<p>模板函数太多会导致头文件非常大。</p>
<p>模板函数内联要加static</p>
<p><img src="/../images/image-20240821074758660.png" alt="image-20240821074758660">{:height 34, :width 232}</p>
<p><img src="/../images/image-20240821075058309.png" alt="image-20240821075058309"></p>
<p><img src="/../images/image-20240821080547610.png" alt="image-20240821080547610"></p>
<p><img src="/../images/image-20240821080851591.png" alt="image-20240821080851591"></p>
<p><code>if constexpr</code> 是 C++17 中引入的一种编译时条件语句。它允许在编译时根据条件选择代码路径，从而避免在运行时进行条件判断。与传统的 <code>if</code> 语句不同，<code>if constexpr</code> 在编译时会根据条件是否为 <code>true</code> 来决定是否编译相应的代码块。</p>
<p>举个例子：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

template &lt;typename T&gt;
void print_type() &#123;
  if constexpr (std::is_integral&lt;T&gt;::value) &#123;
      std::cout &lt;&lt; &quot;Integral type&quot; &lt;&lt; std::endl;
  &#125; else &#123;
      std::cout &lt;&lt; &quot;Non-integral type&quot; &lt;&lt; std::endl;
  &#125;
&#125;

int main() &#123;
  print_type&lt;int&gt;();    // 输出 &quot;Integral type&quot;
  print_type&lt;double&gt;(); // 输出 &quot;Non-integral type&quot;
&#125;
</code></pre>
<p>在这个例子中，<code>if constexpr</code> 会在编译时检查 <code>std::is_integral&lt;T&gt;::value</code> 是否为 <code>true</code>，然后编译对应的代码块。这使得 <code>print_type</code> 函数的行为在编译时就被确定下来，从而避免了在运行时的类型检查。</p>
<p><img src="/../images/image-20240821081339456.png" alt="image-20240821081339456"></p>
<p><img src="/../images/image-20240821082517892.png" alt="image-20240821082517892"></p>
<p><img src="/../images/image-20240821082721689.png" alt="image-20240821082721689"></p>
<p><img src="/../images/image-20240821090104734.png" alt="image-20240821090104734"></p>
<p><img src="/../images/image-20240821090237051.png" alt="image-20240821090237051"></p>
<p><img src="/../images/image-20240821090714458.png" alt="image-20240821090714458">但是这样要把模板实例化的，每一种	情况都声明</p>
<p>所以，尽量不要把模板分离</p>
<p><img src="/../images/image-20240821091734245.png" alt="image-20240821091734245">延迟编译：当一个函数定义在头文件里，可能用不到，可以在前面加 template  <class T = void>这个假模板，只有被调用的时候才会被编译</p>
<p><img src="/../images/image-20240821093416355.png" alt="image-20240821093416355"></p>
<p>可以把函数的信息打印出来</p>
<p><img src="/../images/image-20240821094441153.png" alt="image-20240821094441153"></p>
<p><img src="/../images/image-20240821094522021.png" alt="image-20240821094522021"></p>
<p><img src="/../images/image-20240821094700080.png" alt="image-20240821094700080"></p>
<p><img src="/../images/image-20240821095549768.png" alt="image-20240821095549768"></p>
<p>c++里的引用（int &amp;）相当于C里面的指针（int*）</p>
<p><img src="/../images/image-20240821145117646.png" alt="image-20240821145117646">引用没有空，指针可以空</p>
<p>auto &amp;  auto const &amp; 也可</p>
<p><img src="/../images/image-20240821150609535.png" alt="image-20240821150609535"></p>
<p>懒汉单例模式（Lazy Singleton）是一种设计模式，用于确保一个类只有一个实例，并提供一个全局访问点。与饿汉单例模式不同，懒汉单例模式会在需要实例时才进行初始化，因此被称为“懒汉”模式。</p>
</li>
<li><h3 id="懒汉单例模式的特点"><a href="#懒汉单例模式的特点" class="headerlink" title="懒汉单例模式的特点"></a>懒汉单例模式的特点</h3><ol>
<li><strong>延迟初始化</strong>：单例对象只有在第一次被使用时才会创建。</li>
<li><strong>线程安全问题</strong>：在多线程环境下，需要处理线程安全问题，以确保只有一个实例被创建。</li>
</ol>
</li>
<li><h3 id="懒汉单例模式的实现方式"><a href="#懒汉单例模式的实现方式" class="headerlink" title="懒汉单例模式的实现方式"></a>懒汉单例模式的实现方式</h3><p>下面是一个基本的懒汉单例模式的实现示例（不考虑线程安全）：</p>
<pre><code class="cpp">class Singleton &#123;
public:
  // 获取单例实例的静态方法
  static Singleton* getInstance() &#123;
      if (instance == nullptr) &#123;
          instance = new Singleton();
      &#125;
      return instance;
  &#125;

  // 禁止拷贝构造函数和赋值操作符
  Singleton(const Singleton&amp;) = delete;
  Singleton&amp; operator=(const Singleton&amp;) = delete;

private:
  // 私有构造函数
  Singleton() &#123;&#125;

  // 静态成员变量，用于存储唯一的实例
  static Singleton* instance;
&#125;;

// 静态成员变量的初始化
Singleton* Singleton::instance = nullptr;
</code></pre>
</li>
<li><h3 id="线程安全的实现"><a href="#线程安全的实现" class="headerlink" title="线程安全的实现"></a>线程安全的实现</h3><p>在多线程环境下，上述实现可能会导致线程安全问题，因此需要对其进行改进。可以使用互斥锁（<code>mutex</code>）来确保线程安全：</p>
<pre><code class="cpp">#include &lt;mutex&gt;

class Singleton &#123;
public:
  // 获取单例实例的静态方法
  static Singleton* getInstance() &#123;
      if (instance == nullptr) &#123;
          std::lock_guard&lt;std::mutex&gt; lock(mutex);
          if (instance == nullptr) &#123;
              instance = new Singleton();
          &#125;
      &#125;
      return instance;
  &#125;

  // 禁止拷贝构造函数和赋值操作符
  Singleton(const Singleton&amp;) = delete;
  Singleton&amp; operator=(const Singleton&amp;) = delete;

private:
  // 私有构造函数
  Singleton() &#123;&#125;

  // 静态成员变量，用于存储唯一的实例
  static Singleton* instance;
  // 互斥锁，用于保证线程安全
  static std::mutex mutex;
&#125;;

// 静态成员变量的初始化
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex;
</code></pre>
</li>
<li><h3 id="C-11-及以后的标准"><a href="#C-11-及以后的标准" class="headerlink" title="C++11 及以后的标准"></a>C++11 及以后的标准</h3><p>在C++11及以后的标准中，可以使用<code>std::call_once</code>来确保实例的唯一性，并提高线程安全性：</p>
<pre><code class="cpp">#include &lt;mutex&gt;

class Singleton &#123;
public:
  // 获取单例实例的静态方法
  static Singleton* getInstance() &#123;
      std::call_once(flag, []() &#123;
          instance.reset(new Singleton());
      &#125;);
      return instance.get();
  &#125;

  // 禁止拷贝构造函数和赋值操作符
  Singleton(const Singleton&amp;) = delete;
  Singleton&amp; operator=(const Singleton&amp;) = delete;

private:
  // 私有构造函数
  Singleton() &#123;&#125;

  // 静态成员变量，用于存储唯一的实例
  static std::unique_ptr&lt;Singleton&gt; instance;
  // 静态变量，用于确保单例实例只创建一次
  static std::once_flag flag;
&#125;;

// 静态成员变量的初始化
std::unique_ptr&lt;Singleton&gt; Singleton::instance;
std::once_flag Singleton::flag;
</code></pre>
<p>在这个实现中，<code>std::call_once</code> 和 <code>std::once_flag</code> 确保了即使在多线程环境中，单例对象也只会被创建一次。<code>std::unique_ptr</code> 自动管理内存，避免了手动释放内存的麻烦。</p>
<p>使用互斥锁（mutex）来确保线程安全时为什么只有锁：std::lock_guard<a href="std::mutex">std::mutex</a> lock(mutex); 没有解锁?</p>
<p>在使用 <code>std::lock_guard&lt;std::mutex&gt;</code> 时，解锁是由 <code>std::lock_guard</code> 自动处理的，而不需要显式地调用解锁操作。这是因为 <code>std::lock_guard</code> 是一个RAII（Resource Acquisition Is Initialization）风格的类，它的设计目的是简化互斥锁的管理并自动释放资源。</p>
</li>
<li><h3 id="RAII-和-std-lock-guard"><a href="#RAII-和-std-lock-guard" class="headerlink" title="RAII 和 std::lock_guard"></a>RAII 和 <code>std::lock_guard</code></h3><p>RAII 是一种编程习惯，确保资源（如内存、文件句柄、互斥锁等）的生命周期由对象的生命周期来管理。<code>std::lock_guard</code> 利用 RAII 原则来管理互斥锁的锁定和解锁：</p>
<ol>
<li><strong>构造函数</strong>：当 <code>std::lock_guard</code> 对象被创建时，它会在构造函数中自动锁定传递给它的 <code>std::mutex</code> 对象。</li>
<li><strong>析构函数</strong>：当 <code>std::lock_guard</code> 对象被销毁（即其作用域结束时），它的析构函数会自动释放（解锁）互斥锁。</li>
</ol>
<p>这种设计使得你不需要显式地编写解锁代码，降低了因为遗漏解锁操作而导致的潜在错误。</p>
</li>
<li><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3></li>
<li><p><code>std::lock_guard&lt;std::mutex&gt; lock(mutex);</code></p>
<p>：</p>
<ul>
<li>当执行到这行代码时，<code>lock</code> 对象会在构造函数中自动锁定 <code>mutex</code>。</li>
<li>当 <code>lock</code> 对象超出作用域（例如，<code>getInstance</code> 方法的执行结束时），<code>lock</code> 的析构函数会被调用，从而自动解锁 <code>mutex</code>。</li>
</ul>
</li>
<li><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li>
<li><p><strong>自动解锁</strong>：减少了因为忘记解锁导致的死锁问题。</p>
</li>
<li><p><strong>简化代码</strong>：不需要显式地管理锁的释放，使代码更加简洁和易于维护。</p>
</li>
<li><p><strong>异常安全</strong>：即使在 <code>getInstance</code> 方法中发生异常，<code>std::lock_guard</code> 也会确保互斥锁在 <code>lock</code> 对象被销毁时正确解锁，从而避免死锁。</p>
<p>通过 <code>std::lock_guard</code> 或其他类似的 RAII 风格的工具，C++ 提供了一种简洁而安全的方式来管理互斥锁，帮助程序员编写更健壮的多线程代码。</p>
<p><img src="/../images/image-20240821154750452.png" alt="image-20240821154750452"></p>
<p><img src="/../images/image-20240821155047037.png" alt="image-20240821155047037"></p>
</li>
</ul>
<p><img src="/../images/image-20240822093944038.png" alt="image-20240822093944038"></p>
<p>decltype(auto)和auto的区别</p>
<p><code>decltype(auto)</code> 和 <code>auto</code> 都用于类型推导，但它们有不同的行为：</p>
<ol>
<li><p><strong><code>auto</code></strong>:</p>
<ul>
<li>用于自动推导变量的类型。<code>auto</code> 根据表达式的值推导类型，不会保留表达式的引用性（即 <code>auto</code> 不会推导出引用类型，除非显式指定）。</li>
<li>例如，<code>auto x = 5;</code> 中，<code>x</code> 的类型是 <code>int</code>。</li>
</ul>
</li>
<li><p><strong><code>decltype(auto)</code></strong>:</p>
<ul>
<li>结合 <code>decltype</code> 和 <code>auto</code> 的特性。它推导出表达式的类型，包括引用（<code>decltype</code> 会保留表达式的原始类型）。</li>
<li>例如，<code>decltype(auto) y = (5);</code> 中，<code>y</code> 的类型是 <code>int&amp;</code>，因为 <code>(5)</code> 是一个左值引用。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>:</p>
<ul>
<li>使用 <code>auto</code> 时，结果类型是值类型。</li>
<li>使用 <code>decltype(auto)</code> 时，结果类型保持原表达式的类型，包括引用。</li>
</ul>
<p><img src="/../images/image-20240822094955233.png" alt="image-20240822094955233"></p>
<p><img src="/../images/image-20240822095110135.png" alt="image-20240822095110135"></p>
<p><img src="/../images/image-20240822095353349.png" alt="image-20240822095353349">T1{}创建一个T1的对象</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p><img src="/../images/image-20240822100310129.png" alt="image-20240822100310129"></p>
<p>函数作为参数传入另一个函数，实际传的是这个函数的起始地址</p>
<p><img src="/../images/image-20240822100649562.png" alt="image-20240822100649562"></p>
<p>确实相当于函数指针</p>
<p><img src="/../images/image-20240822100903926.png" alt="image-20240822100903926"></p>
<p><img src="/../images/image-20240822102642020.png" alt="image-20240822102642020"></p>
<p><img src="/../images/image-20240822102841702.png" alt="image-20240822102841702"></p>
<p><img src="/../images/image-20240822103024352.png" alt="image-20240822103024352"></p>
<p><img src="/../images/image-20240822103222797.png" alt="image-20240822103222797"></p>
<p><img src="/../images/image-20240822103620126.png" alt="image-20240822103620126"></p>
<p><img src="/../images/image-20240822103849124.png" alt="image-20240822103849124"></p>
<p><img src="/../images/image-20240822104300564.png" alt="image-20240822104300564"></p>
<p><img src="/../images/image-20240822142510370.png" alt="image-20240822142510370"></p>
<p><img src="/../images/image-20240822142730386.png" alt="image-20240822142730386"></p>
<p>###避免使用模板参数</p>
<p><img src="/../images/image-20240822143331265.png" alt="image-20240822143331265"></p>
<p>类型擦除技术：std::function容器</p>
<p><img src="/../images/image-20240822143825237.png" alt="image-20240822143825237"></p>
<p><img src="/../images/image-20240822145011740.png" alt="image-20240822145011740">但是没办法做部分特例化</p>
<p><img src="/../images/image-20240822145901194.png" alt="image-20240822145901194"></p>
<p><strong>立即调用 Lambda</strong>：在 lambda 表达式的定义后面加上 <code>()</code>，立即调用这个匿名函数。 lambda 表达式的返回值可以用于初始化变量或进行其他操作。</p>
<p><img src="/../images/image-20240822150515258.png" alt="image-20240822150515258"></p>
<p>可以利用return自带的break效果既实现break又赋值的效果</p>
<p><img src="/../images/image-20240822151844264.png" alt="image-20240822151844264"></p>
<p><img src="/../images/image-20240822152541777.png" alt="image-20240822152541777"></p>
<p><img src="/../images/image-20240822152759758.png" alt="image-20240822152759758"></p>
<p><img src="/../images/image-20240822153156878.png" alt="image-20240822153156878"></p>
<p><img src="/../images/image-20240822161836536.png" alt="image-20240822161836536"></p>
<p><img src="/../images/image-20240822162204007.png" alt="image-20240822162204007"></p>
<p>左值持久，右值短暂，左值有持久的状态，而右值要么是字面常量，要么是在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC&spm=1001.2101.3001.7020">表达式求值</a>过程中创建的临时对象(将要被销毁的对象)。</p>
<p>右值引用的好处是减少右值作为参数传递时的复制开销</p>
<p>使用std::move可以获得绑定到一个左值的右值引用</p>
<pre><code class="cpp">int intValue = 10;
int &amp;&amp;intValue3 = std::move(intValue);
</code></pre>
<p><code>decltype(auto)</code> 是 C++11 引入的一种类型推断工具，它结合了 <code>decltype</code> 和 <code>auto</code> 的特性，用于在声明变量时推断其类型。与 <code>auto</code> 不同，<code>decltype(auto)</code> 更精确地推断变量的类型，包括引用性。</p>
<ul>
<li><p><strong>用法</strong>：<code>decltype(auto)</code> 在声明变量时，会推断出表达式的确切类型，包括是否是引用类型。</p>
<pre><code class="cpp">int x = 10;
int&amp; ref = x;
decltype(auto) y = ref; // y 是 int&amp;，与 ref 类型相同
</code></pre>
</li>
<li><p><strong>区别</strong>：<code>auto</code> 只推断值类型，而 <code>decltype(auto)</code> 会保持原有的引用类型或常量性。</p>
<pre><code class="cpp">auto a = x;          // a 是 int
decltype(auto) b = x; // b 是 int，b 不是引用
decltype(auto) c = ref; // c 是 int&amp;，与 ref 类型相同
</code></pre>
</li>
</ul>
<p><strong>总结</strong>：<code>decltype(auto)</code> 在需要精确类型推断，包括引用时非常有用。</p>
<p>但是tuple容器的万能推导由于历史原因，不是decltype(auto),而是auto &amp;&amp;</p>
<p><img src="/../images/image-20240825111507625.png" alt="image-20240825111507625"></p>
<p><img src="/../images/image-20240825111624413.png" alt="image-20240825111624413"></p>
<p>结构化绑定的基本语法如下：</p>
<p>auto [var1, var2, var3] &#x3D; expression;</p>
<p><img src="/../images/image-20240825112136528.png" alt="image-20240825112136528"></p>
<p><img src="/../images/image-20240825154641671.png" alt="image-20240825154641671"></p>
<p><img src="/../images/image-20240825155359129.png" alt="image-20240825155359129"></p>
<p><img src="/../images/image-20240825155541735.png" alt="image-20240825155541735"></p>
<p><img src="/../images/image-20240826130922114.png" alt="image-20240826130922114">optional就像一个更安全的指针</p>
<p>在 C++ 中，<code>union</code> 是一种数据结构，它允许在同一内存位置存储不同的数据类型。<code>union</code> 的所有成员共享同一块内存区域，这意味着在任何给定时刻，<code>union</code> 只能存储一个成员的数据。使用 <code>union</code> 可以节省内存，特别是在需要存储多种不同类型但从不同时存储这些类型时。</p>
<h3 id="union-的基本语法"><a href="#union-的基本语法" class="headerlink" title="union 的基本语法"></a><code>union</code> 的基本语法</h3><pre><code class="cpp">union UnionName &#123;
    type1 member1;
    type2 member2;
    type3 member3;
    // more members
&#125;;
</code></pre>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><p><strong>内存共享</strong>：</p>
<ul>
<li><code>union</code> 中的所有成员共享同一块内存。因此，<code>union</code> 的大小由其最大成员的大小决定。</li>
</ul>
</li>
<li><p><strong>只能存储一个成员</strong>：</p>
<ul>
<li>虽然 <code>union</code> 可以定义多个成员，但在任何时刻只能存储一个成员的数据。写入一个成员会覆盖掉之前写入的成员的数据。</li>
</ul>
</li>
<li><p><strong>节省内存</strong>：</p>
<ul>
<li>因为所有成员共用一块内存，所以 <code>union</code> 可以节省内存，尤其是在只需要存储其中一个成员的数据时。</li>
</ul>
</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code class="cpp">#include &lt;iostream&gt;

union Data &#123;
    int intValue;
    float floatValue;
    char charValue;
&#125;;

int main() &#123;
    Data data;

    data.intValue = 5;
    std::cout &lt;&lt; &quot;intValue: &quot; &lt;&lt; data.intValue &lt;&lt; std::endl;

    data.floatValue = 3.14;
    std::cout &lt;&lt; &quot;floatValue: &quot; &lt;&lt; data.floatValue &lt;&lt; std::endl;

    data.charValue = &#39;A&#39;;
    std::cout &lt;&lt; &quot;charValue: &quot; &lt;&lt; data.charValue &lt;&lt; std::endl;

    // 访问数据会输出不确定的结果，因为各个成员共享同一内存
    std::cout &lt;&lt; &quot;intValue (after modifying to charValue): &quot; &lt;&lt; data.intValue &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p>在上面的示例中，<code>union</code> <code>Data</code> 可以存储 <code>int</code>, <code>float</code>, 和 <code>char</code> 三种数据类型，但它们共享同一块内存。当写入 <code>floatValue</code> 后，之前存储的 <code>intValue</code> 的数据会被覆盖，读取 <code>intValue</code> 会得到不可预测的结果。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p><strong>类型安全</strong>：</p>
<ul>
<li>使用 <code>union</code> 时要注意类型安全。读取当前未写入的成员数据可能会导致未定义的行为。</li>
</ul>
</li>
<li><p><strong>构造和析构</strong>：</p>
<ul>
<li><code>union</code> 允许只有一个成员的构造和析构。C++11 之后，<code>union</code> 可以包含具有非平凡构造函数、析构函数或拷贝&#x2F;移动操作符的成员，但这些操作必须在使用 <code>union</code> 的情况下正确处理。</li>
</ul>
</li>
<li><p><strong><code>std::variant</code> 替代</strong>：</p>
<ul>
<li>C++17 引入了 <code>std::variant</code>，这是一个更安全的替代 <code>union</code>，提供了类型安全的联合体和更丰富的功能。</li>
</ul>
</li>
</ul>
<p>总的来说，<code>union</code> 是一个低级数据结构，用于内存优化和处理不同类型的数据，但在实际编程中需谨慎使用。</p>
<p><img src="/../images/image-20240826131405785.png" alt="image-20240826131405785"></p>
<p><img src="/../images/image-20240826133023527.png" alt="image-20240826133023527"></p>
<p><img src="/../images/image-20240826133352602.png" alt="image-20240826133352602"></p>
<p><img src="/../images/image-20240826134549406.png" alt="image-20240826134549406"></p>
<p><img src="/../images/image-20240826135522792.png" alt="image-20240826135522792"></p>
<ul>
<li>使用 <code>auto</code> 作为参数类型实际上利用了 C++ 的模板机制，因为 <code>auto</code> 类型推断相当于模板类型参数的自动推导。虽然 lambda 本身不是一个模板，但它的参数使用 <code>auto</code> 实际上是利用了模板的类型推断机制。</li>
<li><code>[&amp;] (auto const &amp;t)&#123;&#125;</code> 使用了模板特性中的类型推断机制，通过 <code>auto</code> 使得 lambda 表达式能够处理多种不同类型的参数。这个功能在 C++11 及其后续版本中成为了更灵活、强大的工具，使得代码更加简洁和通用。</li>
</ul>
<p><img src="/../images/image-20240826140520404.png" alt="image-20240826140520404"></p>
<p><img src="/../images/image-20240826140928719.png" alt="image-20240826140928719"></p>
<h1 id="从汇编角度看编译器优化"><a href="#从汇编角度看编译器优化" class="headerlink" title="从汇编角度看编译器优化"></a>从汇编角度看编译器优化</h1><p>编译器是从源代码生成汇编语言</p>
<p><img src="/../images/image-20240826142543763.png" alt="image-20240826142543763"></p>
<p>RIP是当前执行的代码的地址</p>
<p>MMX，XMM，YMM都是用于储存浮点数的寄存器</p>
<p>把局部变量放入寄存器，读写就更快了</p>
<p>rsp代表堆栈：      -4（%rsp）其中-代表是堆栈上的某一个地址</p>
<p><img src="/../images/image-20240826143356174.png" alt="image-20240826143356174"></p>
<p><img src="/../images/image-20240826145632245.png" alt="image-20240826145632245"></p>
<p><img src="/../images/image-20240826145948278.png" alt="image-20240826145948278"></p>
<p>eax与rax的低32位是共用的</p>
<p>ax与eax的低16位是通用的</p>
<p><img src="/../images/image-20240826162116558.png" alt="image-20240826162116558"></p>
<p><img src="/../images/image-20240826162507877.png" alt="image-20240826162507877">%eax ：返回值</p>
<p><img src="/../images/image-20240826163129510.png" alt="image-20240826163129510"></p>
<p><img src="/../images/image-20240826163353133.png" alt="image-20240826163353133"></p>
<p><img src="/../images/image-20240826163854896.png" alt="image-20240826163854896"></p>
<p>l代表32位，q代表64位</p>
<p><img src="/../images/image-20240826164111288.png" alt="image-20240826164111288"></p>
<p><img src="/../images/image-20240826165156571.png" alt="image-20240826165156571"></p>
<p><img src="/../images/image-20240826165630808.png" alt="image-20240826165630808"></p>
<p>在 C++ 中，<code>ThreadPool threadPool &#123;&#125;;</code> 和 <code>ThreadPool threadPool ;</code> 是两种不同的初始化方式，它们对 <code>ThreadPool</code> 对象的初始化有所不同。</p>
<h3 id="1-ThreadPool-threadPool"><a href="#1-ThreadPool-threadPool" class="headerlink" title="1. ThreadPool threadPool {};"></a>1. <code>ThreadPool threadPool &#123;&#125;;</code></h3><p>这是 <strong>直接初始化（Direct Initialization）</strong> 的一种方式，使用了 <strong>统一初始化语法</strong>（Uniform Initialization Syntax）。具体来说，这种写法会调用 <code>ThreadPool</code> 的默认构造函数，并且初始化所有成员变量为默认值：</p>
<ul>
<li><strong>如果 <code>ThreadPool</code> 有默认构造函数</strong>，它将被调用来创建对象。</li>
<li><strong>如果 <code>ThreadPool</code> 的构造函数</strong>没有显式初始化某些成员变量，它们会被自动初始化为其类型的默认值。对于基本数据类型（如 <code>int</code>），这意味着它们会被初始化为 <code>0</code>。对于指针类型，它们会被初始化为 <code>nullptr</code>。</li>
</ul>
<h3 id="2-ThreadPool-threadPool"><a href="#2-ThreadPool-threadPool" class="headerlink" title="2. ThreadPool threadPool ;"></a>2. <code>ThreadPool threadPool ;</code></h3><p>这是 <strong>默认初始化（Default Initialization）</strong> 的一种方式。在这种情况下，<code>ThreadPool</code> 对象的初始化行为依赖于以下几种情况：</p>
<ul>
<li><strong>如果 <code>ThreadPool</code> 有默认构造函数</strong>，它将被调用来创建对象。</li>
<li><strong>如果 <code>ThreadPool</code> 的构造函数没有显式初始化某些成员变量</strong>，那么这些成员变量的初始化方式依赖于它们的类型和是否有默认构造函数。基本数据类型（如 <code>int</code>）不会被初始化到任何特定值（它们会是未定义的），指针类型也不会自动初始化（它们的值是不确定的）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>ThreadPool threadPool &#123;&#125;;</code>**：使用统一初始化语法，所有成员变量被初始化为其类型的默认值，较为安全。</li>
<li><strong><code>ThreadPool threadPool ;</code><strong>：默认初始化，成员变量的初始值依赖于其类型和构造函数，</strong>可能会导致未定义行为（对于基本数据类型）</strong>。</li>
</ul>
<p>在实践中，推荐使用 <code>ThreadPool threadPool &#123;&#125;;</code> 以确保对象的成员变量被正确地初始化，避免潜在的未定义行为。</p>
<p>在对象构造时，<code>std::lock_guard</code> 会自动锁定传入的互斥锁，而在对象析构时，它会自动释放锁</p>
<p><strong><code>std::lock_guard&lt;std::mutex&gt; guard(lock);</code></strong></p>
<p>当执行 <code>std::lock_guard&lt;std::mutex&gt; guard(lock);</code> 时：</p>
<ul>
<li><strong>锁定</strong>: <code>guard</code> 对象在创建时会自动调用 <code>lock()</code> 方法来锁定传入的互斥锁（<code>lock</code>）。</li>
<li><strong>作用域结束</strong>: 当 <code>guard</code> 对象的作用域结束（例如，离开当前的代码块或函数）时，它的析构函数会自动调用 <code>unlock()</code> 方法来解锁互斥锁</li>
</ul>
<p>要理解 <code>subset</code> 中的这行数据，我们可以将其拆解成几部分来分析：</p>
<pre><code class="plaintext">[[ 0.          1.          2.          3.          4.          5.
   6.          7.          8.         -1.         -1.          9.
  -1.         -1.         10.         11.         12.         -1.
  21.50975911 13.        ]]
</code></pre>
<h3 id="1-关键点索引"><a href="#1-关键点索引" class="headerlink" title="1. 关键点索引"></a>1. 关键点索引</h3><ul>
<li>前 18 个值 <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, -1, -1, 9, -1, -1, 10, 11, 12, -1]</code> 代表了关键点的索引。<ul>
<li>正整数表示该位置有一个有效的关键点索引。</li>
<li><code>-1</code> 表示该位置没有对应的关键点。</li>
</ul>
</li>
</ul>
<h3 id="2-总评分"><a href="#2-总评分" class="headerlink" title="2. 总评分"></a>2. 总评分</h3><ul>
<li><code>21.50975911</code> 是这个组合的总评分。这个评分是所有有效关键点的评分之和或某种加权评分的结果。</li>
</ul>
<h3 id="3-关键点数量"><a href="#3-关键点数量" class="headerlink" title="3. 关键点数量"></a>3. 关键点数量</h3><ul>
<li><code>13</code> 是这个组合中的有效关键点数量。这里 <code>13</code> 表示在该组合中共有 13 个有效的关键点索引。</li>
</ul>
<h3 id="结合信息"><a href="#结合信息" class="headerlink" title="结合信息"></a>结合信息</h3><p>这个 <code>subset</code> 行数据表示一个关键点组合，其中包含 13 个有效的关键点，所有这些关键点的索引被列出。组合的总评分为 <code>21.50975911</code>。通过这些信息，你可以了解该组合的结构以及它在某种评分机制下的表现。</p>
<h4 id="详细解读："><a href="#详细解读：" class="headerlink" title="详细解读："></a>详细解读：</h4><ul>
<li>有效关键点索引为 <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</code>，总共 13 个。</li>
<li>索引为 <code>-1</code> 的位置表示这些位置没有有效的关键点。</li>
<li>总评分 <code>21.50975911</code> 可能是根据这些有效关键点的某些特性（如评分、置信度等）计算出来的。</li>
</ul>
<p>这样的 <code>subset</code> 数据通常用于在处理关键点检测任务中，选择或评估最佳的关键点组合。</p>
<p>这个是candidate： [[2.19000000e+02 1.18000000e+02 9.45192695e-01 0.00000000e+00] [1.96000000e+02 2.63000000e+02 9.28416848e-01 1.00000000e+00] [8.70000000e+01 2.89000000e+02 8.54923248e-01 2.00000000e+00] [6.60000000e+01 4.49000000e+02 8.24636817e-01 3.00000000e+00] [1.20000000e+02 5.07000000e+02 7.98071980e-01 4.00000000e+00] [3.07000000e+02 2.38000000e+02 8.55016530e-01 5.00000000e+00] [3.64000000e+02 3.76000000e+02 7.69826353e-01 6.00000000e+00] [2.81000000e+02 4.45000000e+02 8.87847126e-01 7.00000000e+00] [1.68000000e+02 5.42000000e+02 4.70188409e-01 8.00000000e+00] [2.98000000e+02 5.27000000e+02 4.78751719e-01 9.00000000e+00] [1.94000000e+02 1.03000000e+02 9.33498561e-01 1.00000000e+01] [2.30000000e+02 1.02000000e+02 9.27351594e-01 1.10000000e+01] [1.35000000e+02 1.22000000e+02 8.83832693e-01 1.20000000e+01]] 这个是subset: [[ 0.          1.          2.          3.          4.          5.   6.          7.          8.         -1.         -1.          9.  -1.         -1.         10.         11.         12.         -1.  21.50975911 13.        ]]</p>
<p>“Stack underflow”和“stack overflow”都是与栈（stack）数据结构相关的错误，但它们的含义和发生的情况不同：</p>
<h3 id="Stack-Overflow（栈溢出）"><a href="#Stack-Overflow（栈溢出）" class="headerlink" title="Stack Overflow（栈溢出）"></a>Stack Overflow（栈溢出）</h3><ul>
<li><strong>定义</strong>：栈溢出发生在栈的大小超过其最大容量时。通常是由于过深的递归调用或在栈上分配了过多的局部变量导致的。</li>
<li><strong>后果</strong>：栈溢出通常会导致程序崩溃或异常终止，因为系统无法继续在栈上分配内存。</li>
</ul>
<h3 id="Stack-Underflow（栈下溢出）"><a href="#Stack-Underflow（栈下溢出）" class="headerlink" title="Stack Underflow（栈下溢出）"></a>Stack Underflow（栈下溢出）</h3><ul>
<li><strong>定义</strong>：栈下溢出发生在试图从空栈中弹出元素时。例如，尝试执行“pop”操作但栈为空。</li>
<li><strong>后果</strong>：栈下溢出可能导致访问未定义的内存，程序可能会抛出异常或返回错误。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>溢出（overflow）</strong>：栈容量超出限制。</li>
<li><strong>下溢（underflow）</strong>：试图从空栈中移除元素。</li>
</ul>
<p><code>NULL</code> 是一个预处理宏，通常被定义为 <code>0</code> 或 <code>((void*)0)</code>。它在类型上是一个整数，因此可能导致类型不安全的情况。</p>
<ul>
<li><p><code>nullptr</code> 是 C++11 引入的一个关键字，表示空指针。它是一个特定的类型 <code>std::nullptr_t</code>，能更好地支持类型安全。</p>
</li>
<li><p><strong>OpenGL 上下文</strong>：OpenGL 上下文是一个包含了所有 OpenGL 状态的信息的环境。每个窗口通常会有一个自己的上下文。</p>
</li>
</ul>
<p>gcc -E main.cpp | tail -n 15 是什么意思</p>
<p><code>gcc -E main.cpp | tail -n 15</code> 是一个命令行指令，具体含义如下：</p>
<ul>
<li><code>gcc</code>：GNU 编译器集合，用于编译 C 和 C++ 程序。</li>
<li><code>-E</code>：该选项告诉 <code>gcc</code> 只进行预处理，即处理源代码中的宏和包含文件，但不进行编译。</li>
<li><code>main.cpp</code>：要处理的源文件。</li>
<li><code>|</code>：管道符，用于将前一个命令的输出传递给后一个命令。</li>
<li><code>tail -n 15</code>：该命令输出前一个命令的最后 15 行。</li>
</ul>
<p>因此，整个命令的作用是预处理 <code>main.cpp</code> 文件，并显示预处理后的结果的最后 15 行。这通常用于调试宏和包含的头文件。</p>
<p>constexpr</p>
<p>编译时常量</p>
<p><em>在编译时计算</em></p>
<p>结合 <code>if constexpr</code> 根据条件选择性编译代码</p>
<p><code>__attribute__((inline))</code> 是 GCC 和 Clang 编译器中的一个扩展，用于建议编译器将某个函数内联。内联函数的目的是减少函数调用的开销，通过将函数代码直接插入到调用处来提高性能。</p>
<ol>
<li><strong>性能优化</strong>：可以减少函数调用的开销，尤其是在小型函数中。</li>
<li><strong>不强制</strong>：即使使用了 <code>inline</code> 属性，编译器仍然可以选择不内联，具体取决于优化策略和函数的复杂性。</li>
<li><strong>适用场景</strong>：通常用于小的、频繁调用的函数。</li>
</ol>
<p>把std::string opengl_errno_name(int err)改成static const char *opengl_errno_name(int err)的好处</p>
<p>将 <code>std::string opengl_errno_name(int err)</code> 改为 <code>static const char *opengl_errno_name(int err)</code> 的好处包括：</p>
<ol>
<li><strong>性能提升</strong>：使用 <code>const char*</code> 可以减少内存分配和拷贝操作，提高性能，尤其在频繁调用的情况下。</li>
<li><strong>内存管理</strong>：<code>const char*</code> 不需要动态分配内存，避免了内存泄漏的风险，使用起来更加安全。</li>
<li><strong>简单性</strong>：直接返回字符串字面量或静态数组，使代码更简洁，减少不必要的复杂性。</li>
<li><strong>更好地适应 C 风格 API</strong>：在与 C 语言库交互时，使用 <code>const char*</code> 更加兼容。</li>
</ol>
<p><code>#include &lt;GL/gl.h&gt;</code> 和 <code>#include &lt;GL/glu.h&gt;</code> 是 OpenGL 的头文件，它们用于图形编程。具体来说：</p>
<ol>
<li>**<code>&lt;GL/gl.h&gt;</code>**：<ul>
<li>包含了 OpenGL 的核心函数和常量，提供了绘制图形所需的基本接口，比如渲染点、线、三角形等几何图形，以及设置视图、光照、纹理等功能。</li>
</ul>
</li>
<li>**<code>&lt;GL/glu.h&gt;</code>**：<ul>
<li>提供了一些辅助功能和工具，简化了 OpenGL 的使用。例如，它包含了用于生成和操作网格、处理矩阵变换、创建透视和正交投影等的函数。</li>
</ul>
</li>
</ol>
<p><code>#include &lt;GLFW/glfw3.h&gt;</code> 是用于包含 GLFW 库的头文件，GLFW 是一个开源的跨平台库，主要用于创建窗口、处理用户输入以及管理 OpenGL 上下文。具体功能包括：</p>
<ol>
<li><strong>创建和管理窗口</strong>：可以创建多种类型的窗口，并设置其属性。</li>
<li><strong>处理输入</strong>：支持键盘、鼠标和游戏手柄输入，方便处理用户交互。</li>
<li><strong>上下文管理</strong>：简化 OpenGL 上下文的创建和管理，使得在窗口中进行图形渲染更为高效。、</li>
</ol>
<p><code>#include &lt;glm/glm.hpp&gt;</code> 和 <code>#include &lt;glm/ext.hpp&gt;</code> 是用于包含 GLM（OpenGL Mathematics）库的头文件。具体功能如下：</p>
<ol>
<li>**<code>&lt;glm/glm.hpp&gt;</code>**：<ul>
<li>提供基础数学类型和操作，例如向量、矩阵、四元数等，支持高效的数学运算，适用于图形编程和物理计算。</li>
</ul>
</li>
<li>**<code>&lt;glm/ext.hpp&gt;</code>**：<ul>
<li>包含一些扩展功能，比如矩阵变换、投影、视图等常用数学函数，方便进行更复杂的数学运算。</li>
</ul>
</li>
</ol>
<p>GLM 常用于 OpenGL 应用程序中，以简化数学计算和数据管理。</p>
<p>❥ 基本<br>jk &#x2F; kj &#x2F; <Esc> 回到普通模式<br>q &#x2F; :wq &#x2F; ZZ 保存并退出<br>Q 记录宏<br>gl &#x2F; $ 移动到行末尾<br>gh &#x2F; ^ 移动到行开头（不包括空格）<br>3gl &#x2F; $2l 移动到行末尾倒数第 3 个字符<br>3gh &#x2F; ^2h 移动到行开头倒数第 3 个字符<br>❥ 跳转<br>gd 跳转到定义<br>gD 跳转到声明<br>gy 跳转到变量类型的定义<br>gY 跳转到虚函数实现<br>go 头文件和源文件来回跳转<br>gr 寻找符号引用<br>gz 罗列所有相关信息（定义、引用等）<br>gf 打开光标下的文件名<br>gF 打开光标下的文件名并跳到右侧指定的行号<br>gx 打开光标下的网页链接<br><C-o> 跳转回来<br>❥ 重构<br>gcc 注释&#x2F;取消注释当前选中的代码&#x2F;行<br>gn 重命名变量<br>gw 尝试自动修复问题<br>g&#x3D; 自动格式化当前代码<br>❥ 预览<br>K 悬浮窗查看文档<br>gsf 预览函数定义<br>gsc 预览类定义<br>gsd 预览语法错误<br>❥ 开关<br>gso 打开大纲<br>gsg 打开 Git 面板<br>gsp 打开项目文件树<br>gss 查看所有静态语法错误<br>gsl 查看所有编译器报错<br>gsi 开关 Inlay Hint<br><F8> 或 <C-t> 打开&#x2F;关闭终端<br>❥ 标签页<br><F4> 一键保存所有打开的文件<br><F3> 切换到下一个标签页<br><F2> 切换到上一个标签页<br><F1> 将当前标签页固定在最前<br><S-F3> 将当前标签页右移一位<br><S-F2> 将当前标签页左移一位<br><S-F1> 关闭当前标签页<br><C-S-F3> 关闭右侧所有标签页<br><C-S-F2>关闭左侧所有标签页<br><C-S-F1> 关闭除当前标签页外所有<br>g<Space> 选择跳转到一个标签页<br>❥ 文本查找<br>,, 当前文件中模糊查找<br>,k 当前项目中正则表达式查找<br>,l 当前项目中的所有文件<br>,b 当前 Vim 已打开文件<br>,o 最近打开过的历史文件<br>,i 当前所有加入 Git 仓库的文件<br>,p 当前 Git 有未提交修改的文件<br>,c 所有 Git 提交历史<br>,v 所有 Git 分支<br>❥ 选择<br>vac 选中当前类<br>vic 选中当前类体内<br>vaf 选中当前函数<br>vif 选中当前函数体<br>vab 选中当前块<br>vib 选中当前块中内容<br>vai 选中当前函数调用语句<br>vii 选中当前函数调用语句的参数列表<br>vap 选中当前参数（包括逗号）<br>vip 选中当前参数（不包括逗号）<br>vin 选中当前数字<br>vat 选中当前注释块</p>
<ul>
<li>扩大选择</li>
</ul>
<ul>
<li>缩小选择<br>举一反三：dat 删除当前注释块，cip 修改当前参数<br>❥ 移动<br>]c 下一个类开头<br>[c 上一个类开头<br>]C 下一个类结尾<br>[C 上一个类结尾<br>]f 下一个函数开头<br>[f 上一个函数开头<br>]F 下一个函数结尾<br>[F 上一个函数结尾<br>…以此类推，所有英文字母同上“选择”所述…<br><Space> 全屏任意移动<br>❥ 换位<br>mh 左移参数<br>ml 右移参数<br>mj 下移当前语句<br>mk 上移当前语句<br>maf 下移当前函数<br>mif 上移当前函数<br>mac 下移当前类<br>mic 上移当前类<br>❥ 括号<br>可视模式中：<br>s) 给当前选中内容包上 () 括号<br>s} 给当前选中内容包上 {} 括号<br>s] 给当前选中内容包上 [] 括号<br>s&gt; 给当前选中内容包上 &lt;&gt; 尖括号<br>s’ 给当前选中内容包上 ‘’ 单引号<br>s” 给当前选中内容包上 “” 双引号<br>stspan 给当前选中内容包上<span>标签<br>sta href&#x3D;”b.html” 给当前选中内容包上<a href="b.html">标签<br>普通（NORMAL）模式中：<br>ysi<range><brace> 添加括号<br>cs<oldbrace><newbrace> 改变括号<br>ds<brace> 删除括号<br>❥ CMake<br>cmc 或 :CMakeGenerate 配置当前项目<br>cmb 或 :CMakeBuild 构建当前项目<br>cmr 或 :CMakeRun 运行当前项目<br>cms 或 :CMakeStopRunner 杀死当前终端中的正在运行的程序<br>❥ 文件树<br>y 拷贝<br>x 剪切<br>d 删除<br>p 粘贴<br>a 创建</li>
</ul>
<p><img src="/../images/image-20240928131042017.png" alt="image-20240928131042017"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Cplusplus.html" data-id="cm040oe8600005rcxhs4q231b" data-title="Cplusplus" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Qt" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Qt.html" class="article-date">
  <time class="dt-published" datetime="2024-08-21T15:30:34.000Z" itemprop="datePublished">2024-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Qt.html">Qt</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>QWidget</code> 和 <code>QMainWindow</code> 是 Qt 框架中的两个重要类，它们都用于创建图形用户界面（GUI），但有一些关键的区别：</p>
<h3 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a><code>QWidget</code></h3><ul>
<li><strong>基础类</strong>: <code>QWidget</code> 是 Qt 中所有用户界面对象的基类。它提供了一个基础的窗口部件，其他窗口部件（如按钮、文本框）都是从 <code>QWidget</code> 继承而来的。</li>
<li><strong>功能</strong>: <code>QWidget</code> 本身是一个通用的窗口部件，没有特别的窗口管理功能。它可以作为窗口的基础组件，也可以作为其他复杂组件的容器。</li>
<li><strong>布局管理</strong>: <code>QWidget</code> 提供了布局管理功能，可以使用布局管理器来控制其子部件的位置和大小。</li>
<li><strong>使用场景</strong>: 你可以将 <code>QWidget</code> 用作对话框、工具条、或是任何其他需要的窗口部件。如果你只需要一个简单的窗口，<code>QWidget</code> 是一个合适的选择。</li>
</ul>
<h3 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a><code>QMainWindow</code></h3><ul>
<li><strong>派生类</strong>: <code>QMainWindow</code> 是 <code>QWidget</code> 的子类，提供了更丰富的窗口功能和特性。</li>
<li><strong>功能</strong>: <code>QMainWindow</code> 是设计用于主窗口的类，它提供了菜单栏、工具栏、状态栏和中央窗口区域的支持。这使得它特别适合用于主应用窗口的设计。</li>
<li><strong>布局管理</strong>: <code>QMainWindow</code> 提供了特定的布局区域，如菜单栏、工具栏、状态栏和中央部件区域。你可以使用这些功能来创建更复杂的应用程序界面。</li>
<li><strong>使用场景</strong>: 当你需要一个具有菜单栏、工具栏和状态栏的主窗口时，<code>QMainWindow</code> 是一个理想的选择。它适合用于具有复杂界面的桌面应用程序。</li>
</ul>
<h3 id="主要区别总结"><a href="#主要区别总结" class="headerlink" title="主要区别总结"></a>主要区别总结</h3><ol>
<li><strong>功能扩展</strong>:<ul>
<li><code>QWidget</code>: 基础窗口部件，功能较少，适合用于创建简单的窗口或部件。</li>
<li><code>QMainWindow</code>: 提供额外的功能，如菜单栏、工具栏和状态栏，适合用于主应用窗口。</li>
</ul>
</li>
<li><strong>使用场景</strong>:<ul>
<li><code>QWidget</code>: 适合用作对话框、工具条、或简单的窗口部件。</li>
<li><code>QMainWindow</code>: 适合用于需要复杂用户界面的主窗口。</li>
</ul>
</li>
<li><strong>布局支持</strong>:<ul>
<li><code>QWidget</code>: 你需要手动设置布局。</li>
<li><code>QMainWindow</code>: 提供了内置的菜单栏、工具栏、状态栏和中央部件区域，可以直接使用这些功能来设计主窗口界面。</li>
</ul>
</li>
</ol>
<p>connect(menu, &amp;QMenu::triggered, this, &amp;Widget::onMenuTriggered); 为什么QMenu* menu;时不报错 当QMenu  menu;时报错:No matching member function for call to ‘connect’</p>
<p>在 Qt 中，<code>connect</code> 函数的作用是将一个信号与一个槽函数连接起来。它依赖于信号发射的对象和槽函数的对象都是有效的，并且能够正确识别和匹配。</p>
<h3 id="使用-QMenu-menu"><a href="#使用-QMenu-menu" class="headerlink" title="使用 QMenu* menu"></a>使用 <code>QMenu* menu</code></h3><div class="language-cpp"><button title="Copy code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">QMenu</span><span style="color: #89DDFF">*</span><span style="color: #BABED8"> menu </span><span style="color: #89DDFF">=</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">new</span><span style="color: #BABED8"> </span><span style="color: #82AAFF">QMenu</span><span style="color: #89DDFF">();</span></span>
<span class="line"><span style="color: #82AAFF">connect</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">menu</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">QMenu</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">triggered</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">this,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">Widget</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">onMenuTriggered</span><span style="color: #89DDFF">);</span></span></code></pre></div><ul>
<li>这里，<code>menu</code> 是一个指向 <code>QMenu</code> 对象的指针。</li>
<li><code>connect</code> 函数可以使用 <code>menu</code> 指针来连接信号和槽，因为 <code>QMenu</code> 对象在堆上分配，并且其生命周期由指针管理。</li>
<li><code>QMenu</code> 的实例通过指针能够正确地传递给 <code>connect</code>，并且 <code>QMenu</code> 的成员函数和信号可以被正确识别。</li>
</ul>
<h3 id="使用-QMenu-menu-1"><a href="#使用-QMenu-menu-1" class="headerlink" title="使用 QMenu menu"></a>使用 <code>QMenu menu</code></h3><div class="language-cpp"><button title="Copy code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #BABED8">QMenu menu</span><span style="color: #89DDFF">;</span></span>
<span class="line"><span style="color: #82AAFF">connect</span><span style="color: #89DDFF">(</span><span style="color: #BABED8">menu</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">QMenu</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">triggered</span><span style="color: #89DDFF">,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">this,</span><span style="color: #BABED8"> </span><span style="color: #89DDFF">&amp;</span><span style="color: #FFCB6B">Widget</span><span style="color: #89DDFF">::</span><span style="color: #BABED8">onMenuTriggered</span><span style="color: #89DDFF">);</span></span></code></pre></div><ul>
<li>这里，<code>menu</code> 是一个栈上的 <code>QMenu</code> 对象。</li>
<li>栈上的对象在 <code>connect</code> 时会导致问题，因为 <code>connect</code> 期望信号发射对象在其生命周期内有效。栈上的对象会在超出作用域时被销毁。</li>
<li>在这个情况下，<code>menu</code> 可能在连接信号和槽时已经过早销毁，导致 <code>connect</code> 函数找不到有效的信号源。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>QMenu* menu</code>：指针允许动态管理对象的生命周期，<code>connect</code> 可以正常工作。</li>
<li><code>QMenu menu</code>：栈上的对象在超出作用域时可能被销毁，导致 <code>connect</code> 函数不能正确地处理信号和槽。</li>
</ul>
<p>因此，使用指针确保 <code>QMenu</code> 对象在 <code>connect</code> 调用期间有效。</p>
<p><img src="/../images/image-20240823104744847.png" alt="image-20240823104744847"></p>
<p><img src="/../images/image-20240823104804653.png" alt="image-20240823104804653"></p>
<p>定义对象的指针，让widght来管理对象的生命周期，要是直接定义对象，可能不知道什么时候对象就被销毁了，有些用到这些对象的函数就可能报错，因为在栈上找不到他了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Qt.html" data-id="cm040gf6300012ucx6mgg6k5d" data-title="Qt" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-risc-v" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/risc-v.html" class="article-date">
  <time class="dt-published" datetime="2024-06-18T04:31:10.000Z" itemprop="datePublished">2024-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/risc-v.html">risc_v</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240618123232143.png" alt="image-20240618123232143"></p>
<p>在RISC-V架构中，IF_ID和ID_EX是两个流水线寄存器，用于在指令执行过程中传递数据。</p>
<ol>
<li>IF_ID（Instruction Fetch to Instruction Decode）：IF_ID流水线寄存器用于在指令提取阶段（Instruction Fetch）和指令解码阶段（Instruction Decode）之间传递数据。它保存了从指令缓存中提取的指令，并将其传递给下一个阶段进行解码。</li>
<li>ID_EX（Instruction Decode to Execute）：ID_EX流水线寄存器用于在指令解码阶段（Instruction Decode）和指令执行阶段（Execute）之间传递数据。它保存了从IF_ID寄存器中解码得到的指令信息，包括操作码、寄存器地址等，并将这些信息传递给下一个阶段进行执行。</li>
</ol>
<p>通过使用这些流水线寄存器，RISC-V架构可以实现指令流水线的并行执行，提高指令的执行效率。</p>
<ol>
<li><strong>IF (Instruction Fetch) 取指</strong>：<ul>
<li>这一阶段的主要任务是从内存中的指令缓存或主存中取回当前要执行的指令。</li>
<li>在这个阶段，程序计数器（PC，Program Counter）会指向当前要取的指令地址。</li>
<li>CPU将该地址发给指令缓存，读取该地址处的指令，并将其存储到流水线寄存器（如IF&#x2F;ID寄存器）中，以便在下一阶段使用。</li>
</ul>
</li>
<li><strong>ID (Instruction Decode) 译码</strong>：<ul>
<li>这一阶段的主要任务是对取回的指令进行解码，即解析指令的操作码和操作数。</li>
<li>具体来说，CPU会读取并识别指令的操作码（Opcode），确定这条指令的类型和需要执行的操作。</li>
<li>同时，CPU还会确定指令所涉及的源操作数和目标寄存器。如果需要从寄存器文件中读取操作数，这一阶段也会执行这些操作。</li>
<li>解码后的信息会存储在流水线寄存器（如ID&#x2F;EX寄存器）中，以便在后续的执行阶段使用。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/risc-v.html" data-id="cm03k1yqc0001gycx8zxxb5cx" data-title="risc_v" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-raytracing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/raytracing.html" class="article-date">
  <time class="dt-published" datetime="2024-06-12T08:08:14.000Z" itemprop="datePublished">2024-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/raytracing.html">raytracing</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 C++ 中，冒号（<code>:</code>）用于初始化类的成员变量或调用父类的构造函数。这种语法称为成员初始化列表（member initialization list），它允许在构造函数体执行之前对成员变量进行初始化。</p>
<p>在这里，<code>vec3() : e&#123;0,0,0&#125; &#123;&#125;</code> 中的冒号后面就是成员初始化列表。<code>: e&#123;0,0,0&#125;</code> 表示对类的成员变量 <code>e</code> 进行初始化，其中 <code>&#123;0,0,0&#125;</code> 是对数组 <code>e</code> 的初始化值。</p>
<div class="language-txt"><button title="Copy code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #babed8">double&amp; operator[](int i) &#123; return e[i]; &#125;</span></span></code></pre></div><p><strong><code>double&amp;</code></strong>:</p>
<ul>
<li>返回类型是 <code>double&amp;</code>，即返回一个 <code>double</code> 类型的左值引用。</li>
<li>左值引用允许函数返回一个可修改的元素，这样调用者可以直接修改这个元素。</li>
</ul>
<h3 id="左值和右值的定义"><a href="#左值和右值的定义" class="headerlink" title="左值和右值的定义"></a>左值和右值的定义</h3><ul>
<li><strong>左值（lvalue）</strong>: 可以取地址的值，通常表示内存中的一个位置。例如，变量、数组元素、对象成员等都是左值。</li>
<li><strong>右值（rvalue）</strong>: 不存在明确地址的临时值，通常是表达式的结果或者字面量。例如，字面量、临时对象、运算结果等。</li>
</ul>
<p>引用和原变量本质上是同一个东西，对引用的修改就是对原变量的修改</p>
<p><code>double&amp;</code> 表示引用</p>
<p><code>inline</code> 关键字在C++中用于建议编译器将某个函数的代码在每次调用时直接插入到调用处，而不是进行常规的函数调用。从而可以减少函数调用的开销，尤其是当函数体非常小、调用频繁时，这种优化可能会带来性能提升。</p>
<p><code>using color = vec3;</code> 这行代码是一个类型别名（type alias）的定义，将 <code>vec3</code> 类型重命名为 <code>color</code> 类型。也就是说，使用 <code>color</code> 关键字可以代替 <code>vec3</code> 类型的使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/raytracing.html" data-id="clxbjvuxs000j61cxdrun7t8l" data-title="raytracing" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-FOC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/FOC.html" class="article-date">
  <time class="dt-published" datetime="2024-05-28T23:30:54.000Z" itemprop="datePublished">2024-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/FOC.html">FOC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>可以看出，我们只需要像步进电机那样不断的重复这六部换向就可以让BLDC转动起来，甚至会产生一种错觉，是不是我们换向越快电机转的越快呢？答案是:否，这里我们一定要认识到，是当转子处于特定位置时才去触发换向操作，换向是被动换向，想要提高转速一定是要提高电流，让定子产生的磁场更强，让转子更快的达到目标点然后触发换向</p>
<p>如何获得转子角度？<br>我们已经知道了要先检测角度再去换向，那么如何检测当前角度呢？，有以下三种方式。<br>1.通过安装编码器来计算出当前角度。<br>2.通过安装霍尔元件计算当前角度。<br>3.通过检测电流来计算当前角度</p>
<p>编码器方式获取电机当前角度<br>编码器方式分为两种，增量式编码器和绝对式编码器。<br>增量式编码器：<br>每次启动之气都需要做一次校准，而且为了防止单片机性能问题导致脉冲丢失，还需要对编码器每圈校准一次。因此经常使用ABZ三轴编码器，AB输出正交信号，Z轴输出中断。<br>绝对式编码器：<br>只需要在出厂之前做一次校准，之后如果没有拆机便不需要校准，通讯方式一般是SPI和IIC,需要考虑通讯时间对系统的影响。<br>为什么要对编码器进行校准？<br>因为我们无法保证在安装的时候让编码器的0°（机械角度）刚好对应电机绕组的0°（电气角度）</p>
<p><img src="/../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTQ3MzI5,size_16,color_FFFFFF,t_70#pic_center.png" alt="img"></p>
<p>伸开左手，使拇指与其他四指垂直且在一个平面内，让磁感线从手心流入，四指指向电流方向，大拇指指向的就是安培力方向（即导体受力方向）</p>
<p><img src="/../images/resize,m_lfit,limit_1,w_536.jpeg" alt="img"></p>
<p>右手平展，使大拇指与其余四指垂直，并且都跟手掌在一个平面内。把右手放入磁场中，让<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=526702&ss_c=ssc.citiao.link">磁感线</a>从掌心进入（当磁感线为直线时，相当于手心面向N极），大拇指指向导线运动方向，则四指所指方向为导线中感应电流（动生电动势）的方向。</p>
<p><img src="/../images/image-20240529094507089.png" alt="image-20240529094507089"></p>
<p>根据想得到的电流矢量到u1,u2,u3上投影的正负，来判断在哪个扇区里，u1,u2,u3可由u_alpha,u_beta表示出</p>
<p><img src="/../images/image-20240529130329149.png" alt="image-20240529130329149"></p>
<p><img src="/../images/image-20240529130513189.png" alt="image-20240529130513189"></p>
<p><img src="/../images/image-20240529144317410.png" alt="image-20240529144317410"></p>
<p><img src="/../images/image-20240529144120858.png" alt="image-20240529144120858"></p>
<p><img src="/../images/image-20240529144220989.png" alt="image-20240529144220989"></p>
<p><img src="/../images/image-20240530115230681.png" alt="image-20240530115230681"></p>
<p>从定子来计算</p>
<p><img src="/../images/image-20240530115639643.png" alt="image-20240530115639643">可以计算出反电动势，进而计算转子的速度和位置（无感)</p>
<p>当变压器的初级绕组通电后，线圈所产生的磁通在铁心流动，因为铁心本身也是导体（由硅钢片制成），在垂直于磁力线的平面上就会感应电势，这个电势在铁心的断面上形成闭合回路并产生电流，好象一个旋涡所以称为“涡流”。这个“涡流”使变压器的损耗增加，并且使变压器的铁心发热变压器的温升增加。由“涡流”所产生的损耗我们称为“铁损”。<br>另外要绕制变压器需要用大量的铜线，这些铜导线存在着电阻，电流流过时这电阻会消耗一定的功率，这部分损耗往往变成热量而消耗，我们称这种损耗为“铜损”。<br>铁损等于铜损时，变压器效率最高。大概就是变压器额定负荷的0.65倍左右。</p>
<p>从绕组来计算（d,q,轴的电压方程）</p>
<p><img src="/../images/image-20240530130008389.png" alt="image-20240530130008389"></p>
<p>由于定子自感的属性，电流会滞后电压90度</p>
<p><img src="/../images/image-20240530180512850.png" alt="image-20240530180512850"></p>
<p><img src="/../images/image-20240530180534254.png" alt="image-20240530180534254"></p>
<p>要等幅变换，所以要乘（2&#x2F;3）</p>
<p>如果遇到乘(根号下2&#x2F;3),是等功率变换</p>
<p><img src="/../images/image-20240530181152049.png" alt="image-20240530181152049"></p>
<p><img src="/../images/image-20240530193807755.png" alt="image-20240530193807755"></p>
<p><img src="/../images/image-20240530193832651.png" alt="image-20240530193832651"></p>
<p>反帕克变换就是对帕克变换旋转矩阵求逆</p>
<p>MOS管是电压驱动型，三极管是电流驱动型</p>
<p><img src="/../images/image-20240531080240566.png" alt="image-20240531080240566"></p>
<p><img src="/../images/image-20240531102816686.png" alt="image-20240531102816686"></p>
<p>电角度&#x3D;极对数（或者<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%A7%E6%95%B0&spm=1001.2101.3001.7020">级数</a>&#x2F;2）*机械角度</p>
<p><img src="/../images/image-20240531110753146.png" alt="image-20240531110753146"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/FOC.html" data-id="clxbjvuxp000761cx4xv48vr8" data-title="FOC" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-openmv" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/openmv.html" class="article-date">
  <time class="dt-published" datetime="2024-05-20T06:46:47.000Z" itemprop="datePublished">2024-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/openmv.html">openmv</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240520144720306.png" alt="image-20240520144720306"></p>
<p><img src="/../images/image-20240520144755468.png" alt="image-20240520144755468"></p>
<p>安装库<strong>libxcb-cursor.so.0，</strong></p>
<div class="language-bash"><button title="Copy code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight" style="background-color: #1a1a1a" tabindex="0"><code><span class="line"><span style="color: #FFCB6B">sudo</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">apt</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">install</span><span style="color: #BABED8"> </span><span style="color: #C3E88D">libxcb-cursor0</span></span></code></pre></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/openmv.html" data-id="clxbjvuxr000h61cxfy7lffir" data-title="openmv" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OpenGL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/OpenGL.html" class="article-date">
  <time class="dt-published" datetime="2024-05-17T08:51:10.000Z" itemprop="datePublished">2024-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/OpenGL.html">OpenGL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20240517165248939.png" alt="image-20240517165248939"></p>
<p><img src="/../images/image-20240517165400128.png" alt="image-20240517165400128"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiujiubashiyi/p/16429717.html">https://www.cnblogs.com/jiujiubashiyi/p/16429717.html</a></p>
<p>GLFW,GLAD,opengl是什么，有什么联系</p>
<p>GLFW、GLAD和OpenGL是计算机图形学中常用的三个库，它们之间存在着紧密的联系：</p>
<ol>
<li><strong>OpenGL</strong>：是一个跨语言、跨平台的编程接口，用于渲染2D、3D向量图形。它是由硅谷图形公司（Silicon Graphics,  SGI）在1992年开发的。OpenGL是图形硬件制造商的标准，也是创作高质量计算机图形的基本工具。OpenGL提供了一个非常灵活的编程接口，让开发者能够利用它来渲染图形。</li>
<li><strong>GLFW</strong>：是一个跨平台的OpenGL应用程序接口（API）的多线程窗口和输入管理器。简单来说，GLFW用来创建窗口、处理输入事件（如键盘、鼠标点击等），并管理OpenGL上下文。它使得开发者可以比较容易地创建一个OpenGL环境，因为它简化了OpenGL程序中许多繁琐的设置步骤。</li>
<li><strong>GLAD</strong>：是一个自动生成OpenGL函数指针的库。在OpenGL中，许多操作需要通过指针来调用函数，而在不同的操作系统和硬件平台上，这些函数指针的位置可能会有所不同。GLAD就是用来处理这些函数指针的，它会根据当前的平台和OpenGL的版本自动生成对应的函数指针。这为开发者减少了处理这些底层细节的麻烦。</li>
</ol>
<p><strong>它们之间的联系</strong>：</p>
<ul>
<li>使用OpenGL之前，需要创建一个OpenGL环境，这个环境包括一个窗口以及一个上下文，这是通过GLFW来完成的。</li>
<li>GLAD用来确保所有的OpenGL函数调用都能够正确地指向相应的函数，这样开发者就不需要手动查找和设置这些函数指针了。</li>
<li>通常，一个OpenGL程序的设置流程是这样的：首先初始化GLFW，然后使用GLFW创建一个窗口和OpenGL上下文，接着使用GLAD自动加载OpenGL函数，最后就可以开始使用OpenGL进行绘图了。</li>
</ul>
<p>综上，GLFW和GLAD都是帮助开发者更简单、更有效地使用OpenGL的辅助工具。通过它们，开发者可以专注于图形内容的创作，而不必担心底层的细节问题。</p>
<p>glfwMakeContextCurrent(window);是什么意思</p>
<p><code>glfwMakeContextCurrent(window);</code> 是一行来自 GLFW（OpenGL Framework）库的代码。GLFW 是一个跨平台的库，用于窗口和输入处理，它使得创建 OpenGL 应用程序变得更加容易。</p>
<p>这句代码的作用是将 OpenGL 渲染上下文关联到由 <code>window</code> 参数指定的窗口。在 OpenGL 中，渲染上下文是用来进行图形绘制的环境，它定义了一系列可以用来配置和控制渲染行为的设置。</p>
<p>在创建窗口之后，必须调用 <code>glfwMakeContextCurrent</code> 函数来指定哪个窗口的上下文将被当前的线程使用。只有当前上下文中的 OpenGL 调用才会对指定的窗口产生影响。如果没有激活任何上下文，任何 OpenGL 调用都会导致错误。</p>
<p>简单来说，当你想要在特定的窗口上绘制图形时，你需要确保该窗口的 OpenGL 上下文被设置为当前上下文。这就是 <code>glfwMakeContextCurrent(window);</code> 这行代码的目的。</p>
<p>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress) 是什么意思</p>
<p><code>gladLoadGLLoader</code> 是一个函数，通常在 C 或 C++ 程序中使用，用于初始化 OpenGL 函数指针。OpenGL 是一个用于渲染2D和3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。<code>gladLoadGLLoader</code> 函数是 GLAD 库的一部分，GLAD 是一个小型且易于使用的库，它负责在每次调用 OpenGL 函数之前，动态地加载和绑定正确的 OpenGL 函数指针。</p>
<p><code>glfwGetProcAddress</code> 是另一个函数，属于 GLFW 库（一个用于创建窗口、输入处理等的前端库，常与OpenGL一起使用）。<code>glfwGetProcAddress</code> 的作用是获取指向特定OpenGL函数的指针，该函数在OpenGL核心或者扩展中定义。</p>
<pre><code>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)
</code></pre>
<p>这表示在初始化GLAD库时，它将使用GLFW库提供的函数指针来加载OpenGL函数。这允许应用程序使用OpenGL函数，而不需要关心底层的具体实现细节。</p>
<p>这种机制的好处是，应用程序只需要链接到一个库（比如GLFW），而GLFW会负责查找和加载正确的OpenGL函数。这样做可以简化应用程序的编写和维护工作，同时也确保了应用程序可以轻松地与不同平台的OpenGL版本兼容。</p>
<p><strong>双缓冲(Double Buffer)</strong></p>
<p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p>
<ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li>
</ul>
<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素.3D坐标转为2D坐标的处理过程是由OpenGL的<strong>图形渲染管线</strong>（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。(图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出)</p>
<p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做<strong>着色器</strong>(Shader)。</p>
<p><strong>OpenGL着色器</strong>是用OpenGL着色器语言(OpenGL Shading Language, <strong>GLSL</strong>)写成的</p>
<p><img src="/../images/pipeline.png" alt="img"></p>
<p>为了让OpenGL知道我们的<strong>坐标和颜色值</strong>构成的到底是什么，OpenGL需要你去指定这些数据所表示的<strong>渲染类型</strong>。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做**图元(Primitive)**，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</p>
<p><strong>图形渲染管线的第一个部分</strong>—-<strong>顶点着色器</strong></p>
<p>把3D坐标转为另一种3D坐标</p>
<p><strong>几何着色器</strong></p>
<p>一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状</p>
<p><strong>图元装配</strong></p>
<p>将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状</p>
<p><strong>光栅化阶段</strong></p>
<p>把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的**片段(Fragment)**。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<p>OpenGL中的一个<strong>片段</strong>是OpenGL渲染一个像素所需的所有数据</p>
<p><strong>片段着色器</strong></p>
<p>片段着色器的主要目的是计算一个像素的最终颜色</p>
<p><strong>Alpha测试和混合(Blending)阶段</strong></p>
<p>这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同</p>
<p><code>GL_ARRAY_BUFFER</code>目标用于表示顶点属性数据的缓冲区对象</p>
<p>在OpenGL中，VAO（Vertex Array Object）和VBO（Vertex Buffer Object）是用于管理顶点数据的重要概念，并且它们之间存在一定的关系。</p>
<ol>
<li>VAO（Vertex Array Object）：<ul>
<li>VAO是OpenGL中用于存储顶点属性状态的对象。它包含了多个指向VBO的指针，用于指定顶点属性数据的格式、排列方式等。</li>
<li>VAO可以看作是对VBO的管理器，它记录了OpenGL如何解释顶点数据，包括顶点的位置、颜色、法线等信息。通过绑定VAO，可以轻松地切换顶点属性的设置，从而简化渲染流程。</li>
</ul>
</li>
<li>VBO（Vertex Buffer Object）：<ul>
<li>VBO是用于存储顶点数据的缓冲区对象。它可以存储顶点的位置、颜色、纹理坐标等信息。</li>
<li>通过将顶点数据存储在VBO中，可以有效地管理和传输大量的顶点数据，而不必反复传输到GPU。</li>
</ul>
</li>
</ol>
<p>关系：</p>
<ul>
<li>VBO存储了实际的顶点数据，例如顶点的位置、颜色、纹理坐标等。</li>
<li>VAO描述了顶点数据的格式和布局，它指明了如何从VBO中读取顶点数据以供渲染使用。</li>
<li>通常情况下，我们先创建和绑定VAO，然后配置相应的VBO，并将VBO与VAO关联。这样，在渲染时只需绑定相应的VAO即可，OpenGL就会根据VAO中的配置自动获取正确的顶点数据进行渲染。</li>
</ul>
<p>总结来说，VAO用于管理顶点属性状态，而VBO用于存储实际的顶点数据。它们共同协作，使得在OpenGL中管理和使用顶点数据变得更加灵活和高效。</p>
<p>我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）</p>
<p>着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p>
<p>Uniform是另一种从我们的应用程序在 CPU 上传递数据到 GPU 上的着色器的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>
<p>在OpenGL中，VBO（Vertex Buffer Object）和VAO（Vertex Array Object）都是用于管理顶点数据的对象。它们之间的联系和区别如下：</p>
<p>联系：</p>
<ul>
<li>VBO和VAO都是用于管理顶点属性数据的对象。</li>
<li>它们都可以通过OpenGL API进行创建、绑定、更新和删除等操作。</li>
<li>VAO可以保存多个VBO的绑定状态，使得我们在绘制时只需绑定VAO即可同时启用多个顶点属性数组。</li>
</ul>
<p>区别：</p>
<ul>
<li>VBO是用于存储和管理顶点数据的缓冲对象，包括顶点位置、法线、颜色、纹理坐标等属性数据。它能够提高渲染效率，因为可以将这些数据上传到显卡内存中，而不需要每次绘制时都从系统内存中获取。</li>
<li>VAO是用于管理VBO的绑定状态的对象，它记录了VBO的绑定状态以及每个属性在VBO中的偏移量、类型等信息。VAO可以看作是一组VBO的绑定描述符，它规定了如何从VBO中获取顶点属性数据。</li>
</ul>
<p>总体来说，VBO和VAO在OpenGL中都扮演着非常重要的角色，它们都可以提高渲染效率，使得开发者可以更加方便地管理和操作顶点属性数据。其中，VBO主要用于存储和管理顶点数据，而VAO则是用于在绘制时快速激活和绑定多个顶点属性数组。</p>
<p>把两个角度都发送</p>
<p>试一下发后两个数据，看看是不是数据的问题</p>
<p>试试发5个</p>
<p><img src="/../images/image-20240603155209855.png" alt="image-20240603155209855">2024.6.3.15.52Matlab报错，遂改，无用！！！！</p>
<p>艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节.这样就可以让物体非常精细而不用指定额外的顶点</p>
<p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p>
<p>使用 Xlib 来获取窗口大小需要一些底层的操作，但可以通过以下步骤来实现：</p>
<p>首先，你需要安装 <code>python-xlib</code> 库。你可以使用以下命令在 Ubuntu 上安装：</p>
<pre><code class="bash">sudo apt-get install python-xlib
</code></pre>
<p>然后，你可以使用下面的代码来获取当前活动窗口的大小：</p>
<pre><code class="python">from Xlib import display

def get_screen_size():
    disp = display.Display()
    screen = disp.screen()
    root_win = screen.root
    windowID = root_win.get_full_property(disp.intern_atom(&#39;_NET_ACTIVE_WINDOW&#39;), 0).value[0]
    window = disp.create_resource_object(&#39;window&#39;, windowID)
    geometry = window.get_geometry()
    return geometry.width, geometry.height

width, height = get_screen_size()
print(&quot;Window size: &#123;&#125; x &#123;&#125;&quot;.format(width, height))
</code></pre>
<p>这段代码中，我们首先创建了一个 <code>Display</code> 对象，然后获取了当前活动窗口的 ID。接着，我们使用这个窗口 ID 创建了一个 <code>window</code> 对象，并通过这个对象的 <code>get_geometry</code> 方法获取了窗口的宽度和高度。</p>
<p>请注意，使用 Xlib 需要对 X 窗口系统有一定的了解，因为它是一个底层的库，直接和 X 服务器进行交互。希望这个示例能够帮助你开始使用 Xlib 来获取窗口大小。</p>
<ul>
<li><code>layout(location=0)</code>: 这是一个着色器布局限定符（layout qualifier），用于指定顶点属性在输入阶段的位置。在这里，<code>location=0</code> 表示顶点属性的位置索引为 0。这个位置索引将与顶点数组对象（VAO）中的对应属性绑定，以确保正确地将顶点数据传递给顶点着色器。</li>
<li><code>in</code>: 这是一个输入变量修饰符，用于指示这个变量是从外部传递给顶点着色器的。</li>
<li><code>vec3</code>: 这是指定变量类型的关键字，表示这个变量是一个三维向量。</li>
<li><code>in_position</code>: 这是变量的名称，用于在顶点着色器中引用这个输入变量。在这里，<code>in_position</code> 可能表示顶点的位置信息。</li>
</ul>
<p>在OpenGL中，<code>gl_Position</code>是一个内置的变量，用于表示顶点着色器（Vertex Shader）输出的顶点位置。它是一个四维向量（<code>vec4</code>），表示顶点的齐次坐标（Homogeneous Coordinates），通常用于表示三维空间中的点。齐次坐标是四维的，其中前三个分量表示点的位置，而第四个分量通常被用于表示点的类型或者进行透视除法（Perspective Division）。在顶点着色器中，对 <code>gl_Position</code> 的设置将影响后续的图元装配（Primitive Assembly）和光栅化（Rasterization）阶段，最终确定绘制的像素位置。因此，正确设置 <code>gl_Position</code> 是绘制正确图形的关键。</p>
<p>[[ 0.5  0.5  0.   0.   1.   0. ]<br> [-0.5  0.5  0.   1.   0.   0. ]<br> [-0.5 -0.5  0.   0.   0.   1. ]<br> [ 0.5  0.5  0.   0.   1.   0. ]<br> [-0.5 -0.5  0.   0.   0.   1. ]<br> [ 0.5 -0.5  0.   1.   0.   0. ]]</p>
<pre><code>layout(location=0) in vec3 in_position;
layout(location=1) in vec3 in_color;
</code></pre>
<pre><code>self.vbo_format = &#39;3f 3f&#39;
self.attrs = (&#39;in_position&#39;, &#39;in_color&#39;)
</code></pre>
<pre><code>vertex_data = np.hstack([vertices_array, colors_array])
</code></pre>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p><img src="/../images/image-20240608192337289.png" alt="image-20240608192337289"></p>
<h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p><img src="/../images/image-20240608192358635.png" alt="image-20240608192358635"></p>
<p>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p>
<ul>
<li>弧度转角度：<code>角度 = 弧度 * (180.0f / PI)</code></li>
<li>角度转弧度：<code>弧度 = 角度 * (PI / 180.0f)</code></li>
</ul>
<p><img src="/../images/image-20240608192525938.png" alt="image-20240608192525938"></p>
<p>我这一辈子，抠抠搜搜的花了很多钱，精精明明的上了很多当。骂骂咧咧的干了很多活，小心翼翼的闯了很多祸。精打细算的欠了一屁股帐。认认真真的范了很多错。掏心掏肺的结了很多仇。不明不白的吃了很多亏。窝窝囊囊的活了几十年。</p>
<ol>
<li><code>glm::mat4 trans;</code>：首先声明了一个4x4的矩阵trans，用于表示变换矩阵。</li>
<li><code>trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));</code>：这一行代码对trans进行了旋转变换。使用了glm库中的rotate函数，将trans矩阵绕Z轴旋转90度（使用radians函数将角度转换为弧度），并将结果赋值给trans本身。</li>
<li><code>trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));</code>：接着对trans进行了缩放变换。使用了glm库中的scale函数，将trans矩阵沿着X、Y、Z三个轴分别缩放0.5倍，并将结果再次赋值给trans本身。</li>
</ol>
<ul>
<li>局部空间(Local Space，或者称为物体空间(Object Space))</li>
<li>世界空间(World Space)</li>
<li>观察空间(View Space，或者称为视觉空间(Eye Space))</li>
<li>裁剪空间(Clip Space)</li>
<li>屏幕空间(Screen Space)</li>
</ul>
<p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕</p>
<p>坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p>
<p><img src="/../images/coordinate_systems.png" alt="coordinate_systems"></p>
<ol>
<li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li>
<li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li>
<li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>
<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li>
<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li>
</ol>
<p>你可能已经大致了解了每个坐标空间的作用。我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。</p>
<h2 id="局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间-摄像机空间-———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间"><a href="#局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间-摄像机空间-———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间" class="headerlink" title="局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间"></a>局部空间——–模型矩阵——–世界空间———观察矩阵———-观察空间(摄像机空间)———–投影矩阵————–裁剪空间————–视口变换————-屏幕空间</h2><p><img src="/../images/image-20240609164419389.png" alt="image-20240609164419389"></p>
<p><img src="/../images/image-20240609164929887.png" alt="image-20240609164929887"></p>
<p><img src="/../images/image-20240609165058873.png" alt="image-20240609165058873"></p>
<p><img src="/../images/image-20240609211854570.png" alt="image-20240609211854570"></p>
<p><img src="/../images/image-20240609212927721.png" alt="image-20240609212927721"></p>
<p><img src="/../images/image-20240609213514370.png" alt="image-20240609213514370"></p>
<p>glm::LookAt函数需要一个位置、目标和上向量。它会创建一个观察矩阵。</p>
<p>为了改变摄像机方向</p>
<p><img src="/../images/image-20240609221012736.png" alt="image-20240609221012736"></p>
<p><code>self.m_projection=glm.perspective(V_FOV,ASPECT_RATIO,NEARPLANE,FARPLANE)</code></p>
<p>使用 GLM 库中的 <code>glm::perspective()</code> 函数创建了一个投影矩阵（projection matrix）.会根据给定的参数创建一个透视投影矩阵，并返回这个矩阵。这个投影矩阵描述了从摄像机位置观察场景时的投影效果，将三维场景转换为二维屏幕空间</p>
<p><img src="/../images/image-20240610000155256.png" alt="image-20240610000155256"></p>
<p>对连续时间正弦信号考虑下面表示式：<br>x ( t ) &#x3D; s i n ( 2 π f 0 t + φ )<br>可以按抽样频率 fs&#x3D;1&#x2F;Ts对 x(t)抽样来获得离散时间信号<br>x [ n ] &#x3D; x ( t )|t &#x3D;nTs       &#x3D;  x ( t ) |t&#x3D;n &#x2F; fs &#x3D; s i n ( 2 πf0 &#x2F;fsn + φ ),<br>f0 &#x3D;500Hz， fs 取 100Hz， 绘出 x[n]及其 DTFT</p>
<p><img src="/../images/image-20240611133720092.png" alt="image-20240611133720092"></p>
<p><img src="/../images/image-20240611133805550.png" alt="image-20240611133805550"></p>
<p><img src="/../images/image-20240611133838091.png" alt="image-20240611133838091"></p>
<p><img src="/../images/image-20240611140046801.png" alt="image-20240611140046801"></p>
<p>以 5000HZ 和 1000HZ 分别对其采样得到 x1(n)， x2(n)；画出它们的 DTFT 并比较</p>
<p><img src="/../images/image-20240611140651535.png" alt="image-20240611140651535"></p>
<p><img src="/../images/image-20240611141635271.png" alt="image-20240611141635271"></p>
<p>我们可以从第一个方程中直接得到 A 和 φ 的关系：</p>
<p><img src="/../images/image-20240611141659727.png" alt="image-20240611141659727"></p>
<p>φ ！&#x3D;π&#x2F;2+kπ</p>
<p>x(t)&#x3D;2cos(π&#x2F;3 *t)</p>
<p><img src="/../images/image-20240611143342649.png" alt="image-20240611143342649"></p>
<p><img src="/../images/image-20240611143614094.png" alt="image-20240611143614094"></p>
<p><img src="/../images/image-20240611144943071.png" alt="image-20240611144943071"></p>
<p><img src="/../images/image-20240611145404898.png" alt="image-20240611145404898"></p>
<p>现实中无法实现理想低通滤波器。然而，可以按下面的方法计算由理想低通滤波器产生的<br>波形：理想低通运算相当于信号频谱与频域的矩形函数相乘，这对应于信号与通过傅里叶逆变<br>换得到的时域 sinc 函数的卷积。当其应用于点样本时，卷积和为 sinc 函数内插：</p>
<p>xa(t)&#x3D;sum_{n&#x3D;-无穷}^{正无穷} [xa(nt) sin(π(t-nTs)&#x2F;Ts)&#x2F;(π(t-nTs)&#x2F;Ts)]</p>
<p>(3.18)<br>其中，样本 xa(nt)取自 t&#x3D; nTs处。<br>a. 假设只有有限数量的信号样本是非零值，且只需在有限时间区间上进行信号重建，写出<br>基于(3.18)式的 sinc 内插表示式。</p>
<p><code>syms t n Ts xa;</code></p>
<p><code>xa_t = symsum(xa * sin(pi*(t-n*Ts)/Ts)/(pi*(t-n*Ts)/Ts), n, -inf, inf);</code></p>
<p><img src="/../images/image-20240611153315884.png" alt="image-20240611153315884"></p>
<p>C：<br><img src="/../images/image-20240611155005492.png" alt="image-20240611155005492"></p>
<p>根据奈奎斯特采样定理，要求 fs≥2fbfs≥2fb 以避免混叠现象。因此，fb&lt;fs2fb&lt;2fs 是满足采样定理的条件。</p>
<p><img src="/../images/image-20240613162635475.png" alt="image-20240613162635475"></p>
<p>45HZ，基本周期 T是 1&#x2F;45</p>
<p><img src="/../images/image-20240613160828062.png" alt="image-20240613160828062"></p>
<h3 id="结果分析与总结"><a href="#结果分析与总结" class="headerlink" title="结果分析与总结"></a>结果分析与总结</h3><ol>
<li><strong>分析长度 ( 0.5T_p &#x3D; 0.1 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率较低，频率成分不清晰，可能会导致频率混淆。</li>
<li>由于分析长度小于一个周期，频谱分析结果可能包含较多的谐波失真和旁瓣效应。</li>
</ul>
</li>
<li><strong>分析长度 ( 1.5T_p &#x3D; 0.3 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率有所提高，主要频率成分变得更加明显。</li>
<li>由于分析长度超过一个周期，频谱分析结果更加准确，频率成分容易识别。</li>
</ul>
</li>
<li><strong>分析长度 ( 2T_p &#x3D; 0.4 ) 秒</strong>:<ul>
<li>频谱图中的频率分辨率进一步提高，主要频率成分非常清晰。</li>
<li>更长的分析长度提供了更好的频率分辨率，但同时也增加了计算时间和资源需求。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>选择合适的分析长度</strong>：分析长度可以通过基本周期 ( T_p ) 的整数倍来选择。一般来说，分析长度至少应等于或大于一个周期 ( T_p )，这样可以确保频谱分析结果的准确性。</li>
<li><strong>平衡分辨率和计算复杂度</strong>：较长的分析长度提供更好的频率分辨率，但也会增加计算时间和资源。在实际应用中，需要在频率分辨率和计算复杂度之间取得平衡。</li>
<li><strong>避免过短的分析长度</strong>：过短的分析长度（例如小于一个周期）可能导致频谱结果混乱，难以准确识别主要频率成分</li>
</ul>
<p><img src="/../images/image-20240613161203147.png" alt="image-20240613161203147"></p>
<p>你可以看到，白色的阳光实际上是所有可见颜色的集合，物体吸收了其中的大部分颜色。它仅反射了代表物体颜色的部分，被反射颜色的组合就是我们所感知到的颜色（此例中为珊瑚红）。</p>
<p>这些颜色反射的定律被直接地运用在图形领域。当我们在OpenGL中创建一个光源时，我们希望给光源一个颜色。在上一段中我们有一个白色的太阳，所以我们也将光源设置为白色。当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色（也就是我们所感知到的颜色）。让我们再次审视我们的玩具（这一次它还是珊瑚红），看看如何在图形学中计算出它的反射颜色。我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量了：</p>
<pre><code class="c++">glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
glm::vec3 toyColor(1.0f, 0.5f, 0.31f);
glm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f);
</code></pre>
<p>我们可以看到玩具的颜色<strong>吸收</strong>了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，我们可以定义物体的颜色为&#x3D;&#x3D;<strong>物体从一个光源反射各个颜色分量的大小</strong>。&#x3D;&#x3D;</p>
<p>**现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为冯氏光照模型(Phong Lighting Model)。冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。下面这张图展示了这些光照分量看起来的样子：</p>
<p><img src="/../images/basic_lighting_phong.png" alt="img"></p>
<ul>
<li>环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li>
<li>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。</li>
<li>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>
</ul>
<p>在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体进行任何缩放操作，所以我们并不真的需要使用一个法线矩阵，而是仅以模型矩阵乘以法线就可以。但是如果你会进行不等比缩放，使用法线矩阵去乘以法向量就是必须的了。</p>
<p><img src="/../images/image-20240618134143162.png" alt="image-20240618134143162"></p>
<p><img src="/../images/image-20240618134913056.png" alt="image-20240618134913056"></p>
<p><img src="/../images/image-20240618135228887.png" alt="image-20240618135228887"></p>
<p><img src="/../images/image-20240618135413787.png" alt="image-20240618135413787"></p>
<p>已知周期信号 <em>x</em>(<em>t</em>) &#x3D; 0.75 + 3.4 cos 2πft + 2.7 cos 4<em>π</em> <em>ft</em> +1.5sin 3.5<em>π</em> <em>ft</em> + 2.5sin 7<em>π</em> <em>ft</em>  ，其<br>中 25&#x2F;16Hz,若截断时间长度分别为信号周期的 0.9 和 1.1 倍，试分别绘制这八种窗函数<br>提取的 x(t)的频谱。</p>
<p><img src="/../images/image-20240618141855717.png" alt="image-20240618141855717"></p>
<p>根据下列指标采用窗函数法设计低通数字滤波器， 通带截止频率wp&#x3D; 0.2π ，阻带截止频率</p>
<p>ws &#x3D; 0.3π，通带最大衰减 0.25dB，阻带最小衰减 50dB。</p>
<p>（1） 分别利用汉明窗、布莱克曼窗和凯泽窗设计该滤波器，且滤波器具有线性相位。绘出脉冲响应 h(n)及滤波器的频率响应；</p>
<p>（2） 增加 N，观察过渡带和最大肩峰值的变化。</p>
<p>利用汉明窗设计数字微分器</p>
<p>Hd(e^jw)&#x3D;</p>
<p>jw,0&lt;w&lt;π;</p>
<p>-jw,-π&lt;w&lt;0.</p>
<p>要求 <em>N</em> &#x3D; 21，且滤波器具有线性相位。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/OpenGL.html" data-id="clxbjvuxq000c61cx46uggxj5" data-title="OpenGL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/esp32/" rel="tag">esp32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yolo/" rel="tag">yolo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Embedded/" style="font-size: 10px;">Embedded</a> <a href="/tags/esp32/" style="font-size: 10px;">esp32</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/ubuntu-nvidia.html">ubuntu-nvidia</a>
          </li>
        
          <li>
            <a href="/post/ROS.html">ROS</a>
          </li>
        
          <li>
            <a href="/post/ODriver.html">ODriver</a>
          </li>
        
          <li>
            <a href="/post/Cplusplus.html">Cplusplus</a>
          </li>
        
          <li>
            <a href="/post/Qt.html">Qt</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>