<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Zgh&#39;s</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Zgh的个人站">
<meta property="og:type" content="website">
<meta property="og:title" content="Zgh&#39;s">
<meta property="og:url" content="http://zgh20060114.github.io/index.html">
<meta property="og:site_name" content="Zgh&#39;s">
<meta property="og:description" content="Zgh的个人站">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Zgh's" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zgh&#39;s</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Zgh20060114.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-guitar" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/guitar.html" class="article-date">
  <time class="dt-published" datetime="2025-01-09T07:28:23.000Z" itemprop="datePublished">2025-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/guitar.html">guitar</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/guitar.html" data-id="cm5p0bfvd00007ccx3tx6fkmy" data-title="guitar" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-最优控制与强化学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0.html" class="article-date">
  <time class="dt-published" datetime="2024-12-10T04:12:09.000Z" itemprop="datePublished">2024-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0.html">最优控制与强化学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0.html" data-id="cm4hy3jhr0000dzcx2n1pbzdf" data-title="最优控制与强化学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ncnn-yolov8-seg" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/ncnn-yolov8-seg.html" class="article-date">
  <time class="dt-published" datetime="2024-12-03T11:01:02.000Z" itemprop="datePublished">2024-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/ncnn-yolov8-seg.html">ncnn-yolov8-seg</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="yoloV8-segment模型安卓端部署"><a href="#yoloV8-segment模型安卓端部署" class="headerlink" title="yoloV8-segment模型安卓端部署"></a><strong>yoloV8-segment模型安卓端部署</strong></h2><p>注：开发环境为ubuntu20.04;</p>
<p>ncnn为2022.11.28版本;<br>    opencv-mobile为4.6.0版本;</p>
<p>使用yoloV8n,m,l-seg;</p>
<p><strong>介绍</strong>：ncnn是一款非常高效易用的深度学习推理框架，支持各种神经网络模型，如pytorch、tensorflow、onnx等，以及多种硬件后端，如x86、arm、riscv、mips、vulkan等。ncnn 是一个为手机端极致优化的高性能神经网络前向计算框架。 ncnn 从设计之初深刻考虑手机端的部署和使用。 无第三方依赖，跨平台，手机端 cpu 的速度快于目前所有已知的开源框架。 基于 ncnn，开发者能够将深度学习算法轻松移植到手机端高效执行， 开发出人工智能 APP，将 AI 带到你的指尖。 ncnn 目前已在腾讯多款应用中使用，如：QQ，Qzone，微信，天天 P 图等。</p>
<h2 id="一-模型转换：best-pt——-yolov8n-seg-bin和yolov8n-seg-param"><a href="#一-模型转换：best-pt——-yolov8n-seg-bin和yolov8n-seg-param" class="headerlink" title="一.模型转换：best.pt——&gt;yolov8n-seg.bin和yolov8n-seg.param"></a>一.模型转换：best.pt——&gt;yolov8n-seg.bin和yolov8n-seg.param</h2><p><strong>(以yolov8n为例)</strong></p>
<p>起初，直接使用ultralytics官方转换，但是转换后的模型导致APP闪退，查看yolov8n-seg.param:<br><img src="file:////tmp/wps-zgh/ksohtml/wpshuz3eL.jpg" alt="img"><br>得知：里面有很多的MemoryData，不够干净。<br>于是模型转换step by step:</p>
<h3 id="1-build-ncnn"><a href="#1-build-ncnn" class="headerlink" title="1. build ncnn"></a>1. build ncnn</h3><pre><code class="bash">1. sudo apt install cmake protobuf-compiler libprotobuf-dev libopencv-dev
2, gitclone https://github.com/Tencent/ncnn/releases
3, 编译 NCNN
cd ncnn-master
mkdir build
cd build
cmake ..
make
make install
得到了onnx2ncnn转换工具
</code></pre>
<h3 id="2-convert-yolov8-pt-ONNX"><a href="#2-convert-yolov8-pt-ONNX" class="headerlink" title="2. convert yolov8 pt -&gt;ONNX"></a>2. convert yolov8 pt -&gt;ONNX</h3><pre><code class="python">from ultralytics import YOLO

# load yolov8 segment model
model = YOLO(&quot;your_path&quot;)
# concert the model
success = model.export(format=&quot;onnx&quot;, opset=12, simplify=True)
</code></pre>
<h3 id="3-onnx2ncnn"><a href="#3-onnx2ncnn" class="headerlink" title="3. onnx2ncnn"></a>3. onnx2ncnn</h3><h5 id="ONNX介绍"><a href="#ONNX介绍" class="headerlink" title="ONNX介绍"></a>ONNX介绍</h5><p>ONNX是一种针对机器学习所设计的开放式的文件格式，用于存储训练好的模型。它使得不同的<a target="_blank" rel="noopener" href="https://edu.csdn.net/cloud/sd_summit?utm_source=glcblog&spm=1001.2101.3001.7020">深度学习</a>框架（如<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Pytorch&spm=1001.2101.3001.7020">Pytorch</a>, MXNet）可以采用相同格式存储模型数据。是一种便于在各个主流深度学习框架中迁移模型的中间表达格式。</p>
<pre><code class="bash">onnx2ncnn xxx.onnx xxx.param xxx.bin
</code></pre>
<p>在这里xxx.param 存储了模型的参数信息，它记录了计算图的结构。而xxx.bin 则存放了模型的所有具体参数。就可以使用 ncnn 框架来加载和运行这个模型了。</p>
<h3 id="4-但是也会闪退！！！"><a href="#4-但是也会闪退！！！" class="headerlink" title="4. 但是也会闪退！！！"></a>4. 但是也会闪退！！！</h3><p>分析一下yolov8n-seg.param文件，问题一样，也是存在<strong>MemoryData问题</strong>和模型缺少<strong>permute层</strong>的问题,都会导致ncnn框架无法正确解析param模型</p>
<p>坑：需修改ultralytics源码modules文件夹里的block.py和head.py两个文件,修改3个forward函数,改变前向传播的方式：</p>
<ol>
<li>class C2f(nn.Module):</li>
</ol>
<pre><code class="python">  def forward(self, x):

​    x = self.cv1(x)

​    x = [x, x[:, self.c:, ...]]    

​    x.extend(m(x[-1]) for m in self.m)

​    x.pop(1)

​    return self.cv2(torch.cat(x, 1))
</code></pre>
<ol start="2">
<li>class Detect(nn.Module):</li>
</ol>
<pre><code class="python">  def forward(self, x):

​    shape = x[0].shape

​    for i in range(self.nl):

​      x[i] = torch.cat((self.cv2[i](x[i]), self.cv3[i](x[i])), 1)

​    if self.training:

​      return x

​    elif self.dynamic or self.shape != shape:

​      self.anchors, self.strides = (x.transpose(0, 1) for x in make_anchors(x, self.stride, 0.5))

​      self.shape = shape

​    pred = torch.cat([xi.view(shape[0], self.no, -1) for xi in x], 2)

​    return pred
</code></pre>
<ol start="3">
<li>class Segment(Detect):</li>
</ol>
<pre><code class="python">  def forward(self, x):

​    p = self.proto(x[0])  # mask protos

​    bs = p.shape[0]  # batch size

 

​    mc = torch.cat([self.cv4[i](x[i]).view(bs, self.nm, -1) for i in range(self.nl)], 2)  

​    x = self.detect(self, x)

​    if self.training:

​      return x, mc, p

​    return (torch.cat([x, mc], 1).permute(0, 2, 1), p.view(bs, self.nm, -1)) if self.export else (torch.cat([x[0], mc], 1), (x[1], mc, p)) 
</code></pre>
<h3 id="5-重新执行3，4步操作"><a href="#5-重新执行3，4步操作" class="headerlink" title="5. 重新执行3，4步操作"></a>5. 重新执行3，4步操作</h3><h2 id="二-模型转换完毕，下面开始使用Android-studio构建安卓工程"><a href="#二-模型转换完毕，下面开始使用Android-studio构建安卓工程" class="headerlink" title="二. 模型转换完毕，下面开始使用Android studio构建安卓工程"></a>二. 模型转换完毕，下面开始使用Android studio构建安卓工程</h2><h3 id="1-Configure-ncnn"><a href="#1-Configure-ncnn" class="headerlink" title="1. Configure ncnn"></a>1. Configure ncnn</h3><p><strong>Download [ncnn-YYYYMMDD-android-vulkan].（预编译库）（来自腾讯优图实验室的nihui大神的开源力作）</strong></p>
<p><img src="file:////tmp/wps-zgh/ksohtml/wps5D3BtL.jpg" alt="img"> </p>
<p><strong>Extract ncnn-YYYYMMDD-android-vulkan.zip into app&#x2F;src&#x2F;main&#x2F;jni folder and change the ncnn_DIR path to yours in app&#x2F;src&#x2F;main&#x2F;jni&#x2F;CMakeLists.txt.</strong></p>
<h3 id="2-Configure-OpenCV"><a href="#2-Configure-OpenCV" class="headerlink" title="2. Configure OpenCV"></a>2. Configure OpenCV</h3><p><strong>Download opencv-mobile-XYZ-android (安卓opencv库)(这个也是nihui大神的又一开源力作,适合在安卓移动端使用的轻量级opencv版本)</strong></p>
<p><strong>step 1. download opencv-mobile source</strong></p>
<pre><code class="bash">wget -q https://github.com/nihui/opencv-mobile/releases/latest/download/opencv-mobile-4.10.0.zip
unzip -q opencv-mobile-4.10.0.zip
cd opencv-mobile-4.10.0
</code></pre>
<p><strong>step 2. apply your opencv option changes to options.txt</strong></p>
<pre><code class="bash">vim options.txt
</code></pre>
<p><strong>step 3. build your opencv package with cmake</strong></p>
<pre><code class="bash">mkdir -p build
cd build
cmake -DCMAKE_INSTALL_PREFIX=install \
  -DCMAKE_BUILD_TYPE=Release \
  `cat ../options.txt` \
  -DBUILD_opencv_world=OFF ..
make -j4
make install
</code></pre>
<p><strong>Extract opencv-mobile-XYZ-android.zip into app&#x2F;src&#x2F;main&#x2F;jni and change the OpenCV_DIR path to yours in app&#x2F;src&#x2F;main&#x2F;jni&#x2F;CMakeLists.txt.</strong></p>
<h3 id="3-Android-studio构建"><a href="#3-Android-studio构建" class="headerlink" title="3. Android studio构建"></a>3. Android studio构建</h3><p><img src="file:////tmp/wps-zgh/ksohtml/wpsOhuvnK.jpg" alt="img"> </p>
<p>使用NDK26.1，java</p>
<p>项目目录构成：<br><img src="../images/image-20241203194942398.png" alt="image-20241203194942398" style="zoom: 80%;" /></p>
<p><img src="/../images/image-20241203195136554.png" alt="image-20241203195136554"></p>
<h2 id="三、构建，烧录"><a href="#三、构建，烧录" class="headerlink" title="三、构建，烧录"></a>三、构建，烧录</h2><p>打开安卓设备（本人使用小米,CPU为骁龙8Gen1）开发者选项，USB调试，安装选项，烧录：</p>
<p>效果：</p>
<p><strong>n:</strong></p>
 <img src="../images/1733227046742-173322733477910.jpg" alt="1733227046742" style="zoom:33%;" />



<p><strong>m:</strong></p>
<img src="../images/1733227046737-17332272923528.jpg" alt="1733227046737" style="zoom:33%;" />

<p><strong>l:</strong></p>
<img src="../images/1733227046740-17332272316817.jpg" alt="1733227046740" style="zoom:33%;" />



<p>可切换前后摄像头，可切换CPU&#x2F;GPU</p>
<h4 id="结果分析："><a href="#结果分析：" class="headerlink" title="结果分析："></a>结果分析：</h4><p><strong>n:帧率在30帧左右，有时会检测不准确，无法将两个挨得较近的识别目标分开</strong></p>
<p><strong>m:帧率在12帧左右，准确性进一步提高</strong></p>
<p><strong>l: 帧率在10帧左右，较为准确，可将挨得较近的识别目标分开</strong></p>
<h2 id="四、模型量化"><a href="#四、模型量化" class="headerlink" title="四、模型量化"></a>四、模型量化</h2><p>我们常说的模型量化就是将浮点存储（运算）转换为整型存储（运算）的一种模型压缩技术。比如：<strong>原来表示一个权重或偏置需要使用FP32表示，使用了INT8量化后只需要使用一个INT8来表示就可以了</strong>。</p>
<ol>
<li>合并bn层</li>
</ol>
<pre><code class="bash">./ncnnoptimize xxx.param xxx.bin xxx_opt.param xxx_opt.bin 0
</code></pre>
<ol start="2">
<li>生成量化图像集</li>
</ol>
<pre><code class="bash">1.下载校准数据集
git clone https://github.com/nihui/imagenet-sample-images

2.生成量化图像集
find images/ -type f &gt; imagelist.txt  

3.生成量化表
./ncnn2table xxx-opt.param xxx-opt.bin imagelist.txt yolov8-seg.table mean=[104,117,123] norm=[0.017,0.017,0.017] shape=[256,256,3] pixel=BGR thread=8 method=kl
</code></pre>
<ol start="3">
<li>int8 量化</li>
</ol>
<pre><code class="bash">./ncnn2int8 xxx.param xxx.bin xxx_int8.param xxx_int8.bin yolov8-seg.table
</code></pre>
<p>把生成的量化后的bin和param替换掉之前的模型，</p>
<p>重新执行第三步即可</p>
<p>效果：</p>
<p><strong>n:</strong></p>
<img src="../images/1733229812376.jpg" alt="1733229812376" style="zoom:33%;" />



<p><strong>m:</strong></p>
<img src="../images/1733229812378.jpg" alt="1733229812378" style="zoom:33%;" />



<p><strong>l:</strong></p>
<img src="../images/1733229812381.jpg" alt="1733229812381" style="zoom:33%;" />



<h4 id="结果分析：-1"><a href="#结果分析：-1" class="headerlink" title="结果分析："></a>结果分析：</h4><p><strong>n:帧率提升到34帧左右，检测不太准确，会漏检</strong></p>
<p><strong>m:帧率提升到14帧左右，准确性有些下降，</strong></p>
<p><strong>l: 帧率提升到12帧左右，且准确度下降但不多</strong></p>
<h2 id="完毕！！"><a href="#完毕！！" class="headerlink" title="完毕！！"></a>完毕！！</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/ncnn-yolov8-seg.html" data-id="cm48cmcbi000082cx1mfy3yf5" data-title="ncnn-yolov8-seg" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-流体力学" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html" class="article-date">
  <time class="dt-published" datetime="2024-12-03T07:57:28.000Z" itemprop="datePublished">2024-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html">流体力学</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <img src="../images/image-20241203161937539.png" alt="image-20241203161937539" style="zoom:33%;" />





<p><img src="/../images/image-20241205142257927.png" alt="image-20241205142257927"></p>
<p><img src="/../images/image-20241205141814374.png" alt="image-20241205141814374"></p>
<p>质点导数</p>
<p><img src="/../images/image-20241203155836204.png" alt="image-20241203155836204"></p>
<p><img src="/../images/image-20241203160152242.png" alt="image-20241203160152242"></p>
<p><img src="/../images/image-20241203165342550.png" alt="image-20241203165342550"></p>
<p><img src="/../images/image-20241203170039102.png" alt="image-20241203170039102"></p>
<p><img src="/../images/image-20241204140012884.png" alt="image-20241204140012884"></p>
<p><img src="/../images/image-20241205192254250.png" alt="image-20241205192254250"></p>
<p><img src="/../images/image-20241204145649809.png" alt="image-20241204145649809"></p>
<p><img src="/../images/image-20241204150756664.png" alt="image-20241204150756664"></p>
<p><img src="/../images/image-20241204150825461.png" alt="image-20241204150825461"></p>
<p>能量方程</p>
<p><img src="/../images/image-20241204151640080.png" alt="image-20241204151640080"></p>
<p><img src="/../images/image-20241204152728778.png" alt="image-20241204152728778"></p>
<p><img src="/../images/image-20241204165848297.png" alt="image-20241204165848297"></p>
<p><img src="/../images/image-20241204165908740.png" alt="image-20241204165908740"></p>
<p><img src="/../images/image-20241204170042303.png" alt="image-20241204170042303"></p>
<p><img src="/../images/image-20241204175325109.png" alt="image-20241204175325109"></p>
<p>第二粘性系数</p>
<p><img src="/../images/image-20241204183346417.png" alt="image-20241204183346417"></p>
<p><img src="/../images/image-20241204185257818.png" alt="image-20241204185257818"></p>
<p><img src="/../images/image-20241204185940237.png" alt="image-20241204185940237"></p>
<p>将三大守恒控制方程列在一起组成N-S方程</p>
<p><img src="/../images/image-20241204195630503.png" alt="image-20241204195630503"></p>
<p><img src="/../images/image-20241204200110205.png" alt="image-20241204200110205"></p>
<p>伯努利方程</p>
<p><img src="/../images/image-20241204204726803.png" alt="image-20241204204726803"></p>
<p><img src="/../images/image-20241204215054163.png" alt="image-20241204215054163"></p>
<p><img src="/../images/image-20241204221129006.png" alt="image-20241204221129006"></p>
<p><img src="/../images/image-20241204222825601.png" alt="image-20241204222825601"></p>
<p><img src="/../images/image-20241204225516688.png" alt="image-20241204225516688"></p>
<p><img src="/../images/image-20241205081006808.png" alt="image-20241205081006808"></p>
<p><img src="/../images/image-20241205081409258.png" alt="image-20241205081409258"></p>
<p><img src="/../images/image-20241205081503907.png" alt="image-20241205081503907"></p>
<p><img src="/../images/image-20241205081525941.png" alt="image-20241205081525941"></p>
<p>雷诺平均方程</p>
<p><img src="/../images/image-20241205102722264.png" alt="image-20241205102722264"></p>
<p>雷诺应力</p>
<p><img src="/../images/image-20241205112051236.png" alt="image-20241205112051236"></p>
<p>雷诺平均方程</p>
<p><img src="/../images/image-20241205113052414.png" alt="image-20241205113052414"></p>
<p>脉动方程:</p>
<p><img src="/../images/image-20241205140300437.png" alt="image-20241205140300437"></p>
<p><img src="/../images/image-20241205150258344.png" alt="image-20241205150258344"></p>
<p>边界层的基本概念中的名义厚度，排挤厚度和动量损失厚度是什么</p>
<p><img src="/../images/image-20241205154954431.png" alt="image-20241205154954431"></p>
<p><img src="/../images/image-20241205155019195.png" alt="image-20241205155019195"></p>
<p>在流体力学中，<strong>边界层</strong>是指流体流动中，紧邻固体表面的一层流体区域。该区域内，由于黏性作用，流体的速度从零（在固体表面）逐渐过渡到自由流速度。边界层是流体动力学中的重要概念，它在流体流动、热交换、摩擦力以及流体与固体表面相互作用等方面起着关键作用。</p>
<p>边界层的基本特征主要涉及以下方面：</p>
<ol>
<li><strong>速度分布</strong>：流体速度从零逐渐增大至自由流速度。</li>
<li><strong>边界层厚度</strong>：随着流动距离增加，边界层厚度逐渐增大。</li>
<li><strong>流动类型</strong>：可以是层流边界层，也可以是湍流边界层。</li>
<li><strong>动量和热量传输</strong>：边界层内通过粘性效应和湍流传递动量和热量。</li>
<li><strong>摩擦力</strong>：边界层内的黏性摩擦力决定了流体与固体表面之间的摩擦阻力。</li>
<li><strong>边界层分离</strong>：在某些条件下，边界层可能会分离，导致流体与表面的失去附着。</li>
</ol>
<p><img src="/../images/image-20241205160045329.png" alt="image-20241205160045329"></p>
<p><img src="/../images/image-20241205160109661.png" alt="image-20241205160109661"></p>
<h2 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h2><p><img src="/../images/image-20241206082658849.png" alt="image-20241206082658849"></p>
<p><img src="/../images/image-20241206082738341.png" alt="image-20241206082738341"></p>
<p>脉动方程</p>
<p><img src="/../images/image-20241206083422766.png" alt="image-20241206083422766"></p>
<p>雷诺应力输运方程</p>
<p><img src="/../images/image-20241206083931047.png" alt="image-20241206083931047"></p>
<p><img src="/../images/image-20241205162738204.png" alt="image-20241205162738204"></p>
<p><img src="/../images/image-20241205162840664.png" alt="image-20241205162840664"></p>
<p>层流边界层方程</p>
<p><img src="/../images/image-20241205163612445.png" alt="image-20241205163612445"></p>
<p>湍流边界层方程</p>
<p><img src="/../images/image-20241205164101364.png" alt="image-20241205164101364"></p>
<p>层流边界层的Blasius解</p>
<p><img src="/../images/image-20241205171141467.png" alt="image-20241205171141467"></p>
<p>层流边界层的Blasius解</p>
<p><img src="/../images/image-20241206080006514.png" alt="image-20241206080006514"></p>
<p><img src="/../images/image-20241205190517447.png" alt="image-20241205190517447"></p>
<h2 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h2><p>雷诺数：</p>
<p><img src="/../images/image-20241206075214815.png" alt="image-20241206075214815"></p>
<p>壁面率</p>
<p><img src="/../images/image-20241206090507824.png" alt="image-20241206090507824"></p>
<p>对数率</p>
<p><img src="/../images/image-20241206090757982.png" alt="image-20241206090757982"></p>
<p>速度亏损率</p>
<p><img src="/../images/image-20241206091214961.png" alt="image-20241206091214961"></p>
<p>推导平板混合边界层的摩擦阻力计算公式</p>
<p><img src="/../images/image-20241206093425944.png" alt="image-20241206093425944"></p>
<p><img src="/../images/image-20241206105307904.png" alt="image-20241206105307904"></p>
<p><img src="/../images/image-20241206110250939.png" alt="image-20241206110250939"></p>
<p><img src="/../images/image-20241206110304725.png" alt="image-20241206110304725"></p>
<h2 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h2><p>粘性流体涡量输运方程</p>
<p><img src="/../images/image-20241206111225363.png" alt="image-20241206111225363"></p>
<p>涡旋运动基本定理中的开尔文定理,拉格朗日涡保持性定理,亥姆霍兹涡线和涡管保持性定理是什么</p>
<p><img src="/../images/image-20241206112112198.png" alt="image-20241206112112198"></p>
<p><img src="/../images/image-20241206112153916.png" alt="image-20241206112153916"></p>
<p>题</p>
<p><img src="/../images/image-20241206133900908.png" alt="image-20241206133900908"></p>
<p><img src="/../images/image-20241206134926843.png" alt="image-20241206134926843"></p>
<p><img src="/../images/image-20241206140206356.png" alt="image-20241206140206356"></p>
<h2 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h2><p><img src="/../images/image-20241206151132183.png" alt="image-20241206151132183"></p>
<p><img src="/../images/image-20241206151157524.png" alt="image-20241206151157524"></p>
<p><img src="/../images/image-20241206151251564.png" alt="image-20241206151251564"></p>
<p><img src="/../images/image-20241206151521224.png" alt="image-20241206151521224"></p>
<p><img src="/../images/image-20241206161012747.png" alt="image-20241206161012747"></p>
<p><img src="/../images/image-20241206181344118.png" alt="image-20241206181344118"></p>
<p>给出空间点源的速度场表达式</p>
<p><img src="/../images/image-20241206183742874.png" alt="image-20241206183742874"></p>
<p>给出空间偶极的速度场表达式</p>
<p><img src="/../images/image-20241206183904950.png" alt="image-20241206183904950"></p>
<p>5.3定常绕流与环量作用</p>
<p><img src="/../images/image-20241206202242372.png" alt="image-20241206202242372"></p>
<h2 id="5-4"><a href="#5-4" class="headerlink" title="5.4"></a>5.4</h2><p>库塔条件</p>
<p><img src="/../images/image-20241206203910509.png" alt="image-20241206203910509"></p>
<p>库塔条件求升力</p>
<p><img src="/../images/image-20241206212901832.png" alt="image-20241206212901832"></p>
<h2 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h2><p><img src="/../images/image-20241207080343085.png" alt="image-20241207080343085"></p>
<p><img src="/../images/image-20241207081603372.png" alt="image-20241207081603372"></p>
<p><img src="/../images/image-20241207083116645.png" alt="image-20241207083116645"></p>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p><img src="/../images/image-20241207092305624.png" alt="image-20241207092305624"></p>
<p>色散波</p>
<p><img src="/../images/image-20241207092512242.png" alt="image-20241207092512242"></p>
<p>流体质点运动、压力分布</p>
<p><img src="/../images/image-20241207093720436.png" alt="image-20241207093720436"></p>
<p>根据有限水深色散关系式，推导群速度的表达式</p>
<p><img src="/../images/image-20241207094607968.png" alt="image-20241207094607968"></p>
<p>根据无限水深色散关系式，推导群速度的表达式</p>
<p><img src="/../images/image-20241207095002105.png" alt="image-20241207095002105"></p>
<p>深水波的波能</p>
<p><img src="/../images/image-20241207101127905.png" alt="image-20241207101127905"></p>
<p>写出流体力学N-S方程的无量纲形式</p>
<p><img src="/../images/image-20241207101547355.png" alt="image-20241207101547355"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html" data-id="cm4862po20002lbcxhkdm881c" data-title="流体力学" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-四足" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/%E5%9B%9B%E8%B6%B3.html" class="article-date">
  <time class="dt-published" datetime="2024-11-13T00:30:10.000Z" itemprop="datePublished">2024-11-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/%E5%9B%9B%E8%B6%B3.html">四足</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基于模型预测控制与全身控制的控制器"><a href="#基于模型预测控制与全身控制的控制器" class="headerlink" title="基于模型预测控制与全身控制的控制器"></a>基于模型预测控制与全身控制的控制器</h2><ul>
<li><h4 id="虚拟模型控制（VMC-Virtual-Model-Control）"><a href="#虚拟模型控制（VMC-Virtual-Model-Control）" class="headerlink" title="虚拟模型控制（VMC: Virtual Model Control）"></a>虚拟模型控制（VMC: Virtual Model Control）</h4></li>
</ul>
<p>通过模拟虚拟组件来产生所需的关节力矩,这些关节力矩产生的效果与虚拟组件产生的效果相同，因此实现了模拟组件与真实机器 人连接的控制效果</p>
<ul>
<li><h4 id="全身控制（WBC）"><a href="#全身控制（WBC）" class="headerlink" title="全身控制（WBC）"></a>全身控制（WBC）</h4></li>
</ul>
<p>为实现一组任务，所有驱动关节 都能得到控制信号的控制系统都可以称作全身控制</p>
<ul>
<li><h4 id="WBC-使用了浮动基逆动力学"><a href="#WBC-使用了浮动基逆动力学" class="headerlink" title="WBC 使用了浮动基逆动力学"></a>WBC 使用了浮动基逆动力学</h4></li>
</ul>
<p>模型预测控制（MPC）试图在未来的一个滚动时域内，使用优化算法来跟踪给定的期望 轨迹</p>
<p>设计一个基于模型预测控制与全身控制的控制器。在 模型预测控制中，将整个机器人简化为一个单刚体模型并分析其动力学，建立状态方程、 预测方程，将控制问题转化为一个优化问题，最终求出足底反力。在全身控制中，采用了多刚体动力学。四足机器人全身控制将整体的任务按照重要程度分为四个子任务，利 用雅可比矩阵的零空间特性，保证低优先级的任务无法影响高优先级任务的控制。</p>
<p>legged_controller是入口</p>
<h3 id="激光雷达"><a href="#激光雷达" class="headerlink" title="激光雷达"></a>激光雷达</h3><p><a target="_blank" rel="noopener" href="https://www.researching.cn/ArticlePdf/m00002/2022/59/18/1815006.pdf">https://www.researching.cn/ArticlePdf/m00002/2022/59/18/1815006.pdf</a></p>
<p><strong>武汉理工大学的初秀民、柳晨光等</strong>科研人员在<strong>《机械工程学报》2022年第4期</strong>发表了<strong>《无人水面艇三维激光雷达目标实时识别系统》</strong></p>
<h3 id="Virtual-RobotX-VRX"><a href="#Virtual-RobotX-VRX" class="headerlink" title="Virtual RobotX (VRX)"></a>Virtual RobotX (VRX)</h3><p>Virtual RobotX (VRX) 是一个开源的模拟环境，专门设计用于模拟<strong>无人水面车辆</strong>（USVs）在海洋环境中的操作</p>
<p>多功能 VRX 仿真环境作为一个可扩展的框架，致力于促进无人水面舰艇 （USV） 自主性的设计、开发和评估。VRX 仿真环境已被海事机器人研发社区所接受，不断发展以适应感知、学习和控制的进步，同时探索 USV 功能的新应用。</p>
<p><img src="/../images/image-20241113101048510.png" alt="image-20241113101048510"></p>
<p><img src="/../images/image-20241113101258443.png" alt="image-20241113101258443"></p>
<p><img src="/../images/image-20241113102818405.png" alt="image-20241113102818405"></p>
<p><img src="/../images/44672eed82d6e40e19cb84927e3bfdd4.png#pic_center" alt="在这里插入图片描述"></p>
<p>可以在世界中添加障碍等元素</p>
<p>可以创建自定义WAM-V推进器和传感器</p>
<p>不知道水下能不能仿真</p>
<h3 id="Webots水下机器人仿真"><a href="#Webots水下机器人仿真" class="headerlink" title="Webots水下机器人仿真"></a>Webots水下机器人仿真</h3><h3 id="uuv-simulator水下机器人仿真"><a href="#uuv-simulator水下机器人仿真" class="headerlink" title="uuv_simulator水下机器人仿真"></a>uuv_simulator水下机器人仿真</h3><p><a target="_blank" rel="noopener" href="https://github.com/uuvsimulator/uuv_simulator">https://github.com/uuvsimulator/uuv_simulator</a></p>
<p>矩阵就是坐标变换</p>
<p>矩阵的行列式就是是三维空间中立方体的体积的缩放比例</p>
<p>旋转矩阵式正交矩阵（三个列向量是一组标准正交基（单位向量+正交））</p>
<p>旋转矩阵的行列式恒为1（旋转矩阵不会缩放）</p>
<p>旋转矩阵逆等于转置</p>
<h3 id="旋转矩阵，欧拉角，四元数，旋转向量和齐次变换矩阵"><a href="#旋转矩阵，欧拉角，四元数，旋转向量和齐次变换矩阵" class="headerlink" title="[旋转矩阵，欧拉角，四元数，旋转向量和齐次变换矩阵]"></a>[旋转矩阵，欧拉角，四元数，旋转向量和齐次变换矩阵]</h3><p><strong>这几个名词都是用来描述一个物体的位置和姿态的</strong></p>
<p>。<strong>旋转矩阵的初衷</strong>就是人们希望给定一个向量x，然后我对它旋转，能直接通过矩阵乘法的形式得到旋转后的向量坐标。也就是说y&#x3D;Ax。<strong>这个方便计算机计算，因此旋转矩阵常用于编程</strong>。旋转矩阵是一个正交矩阵(AT&#x3D;A−1AT&#x3D;A−1)而且行列式是1。既然<strong>有了旋转矩阵那么为何还要欧拉角呢</strong>？这是因为我给你一个旋转矩阵，人看不懂它到底转了多少角度啊。计算机很容易算出来，但是对人来说非常困难。比如飞机驾驶员你让他以旋转矩阵的形式给飞机下指令，那人家不得疯了。而欧拉角那就非常直观，欧拉角就是我飞机头抬头多少(俯仰角pitch)，向左拐还是向右拐(偏航角yaw)，以及滚筒动作的角度(滚转角roll)。<strong>因此欧拉角一般是方便用户操作，或者程序员检查运算结果是否正确</strong>。然后<strong>有了欧拉角为何还要四元数呢</strong>？因为欧拉角有问题，即万向锁问题。欧拉角的意思是说旋转可以分解为绕机身，机翼，垂直机身三个轴旋转。注意了是依次旋转，每次旋转后的旋转轴姿态已经变化。看下图，比如你先绕机翼那个轴转90度，然后你会发现原先(第一幅图)的滚转角(即绕原先的机身转)与现在的偏航角(绕垂直机身的那个轴)重合了。也<strong>就是说滚转这个方向等与偏航了，两个自由度合并成一个了</strong>。这样一个麻烦就是如果一个给定旋转矩阵可能会计算出多个欧拉角。于是乎，数学家就用四元数来代替欧拉角。</p>
<p><strong>旋转向量其实和欧拉角类似也会存在万向锁的，任何只用三个变量来描述姿态的方法都会产生万向锁</strong>。旋转向量就是方向与旋转轴相同，模为旋转角度的一个向量。<strong>之所以会用旋转向量是因为旋转矩阵用9个元素来描述三维的旋转，太浪费了</strong>。所以想用三个元素的向量来描述三维运动，这个向量就是旋转向量。<strong>齐次变换矩阵就是既包含旋转又包含平移的变换矩阵（它是4x4），旋转矩阵只包含旋转（它是3x3），齐次变换矩阵的左上角是旋转矩阵，右侧那列是平移量</strong>。</p>
<pre><code class="c++">printf(&quot;%d\n&quot;,2.0);
输出：
2123684520
</code></pre>
<pre><code class="c++">printf(&quot;%0.1f\n&quot;,2);
输出:
0.0
</code></pre>
<pre><code class="C++">int n,m=0；
可以这样
</code></pre>
<p>不需要鼠标选取</p>
<p>直接光标所在行</p>
<p>Ctrl + &#x2F; 　　　　　　　　　 注释(取消注释)选择的行</p>
<p>Shift + Enter 　　　　　　 开始新行</p>
<p>Ctrl + Y 　　　　　　　　  删除当前插入符所在的行</p>
<p>Ctrl + D 　　　　　　　　  复制当前行、或者选择的块</p>
<p>Ctrl + Delete 　　　　　　  删除到字符结尾</p>
<p>Ctrl + Backspace 　　　　  删除到字符的开始</p>
<p>Ctrl + Shift + NumPad+ 　　展开所有的代码块</p>
<p> Ctrl + Shift + NumPad- 　　 收缩所有的代码块</p>
<p>ALT+ ←&#x2F;→                              切换文件</p>
<p>SHIFT + ALT ←&#x2F;→ 				  返回上次编辑的位置</p>
<p>CTRL+ALT+:                           emjo</p>
<pre><code class="bash">/opt/glibc-2.34/lib/ld-linux-x86-64.so.2 --library-path /opt/glibc-2.34/lib:/lib/x86_64-linux-gnu ./yazi
q退出
</code></pre>
<pre><code>char *rev
和
char review[]是一样的

char *rev[]
是数组里还是数组
</code></pre>
<pre><code class="C++">    while (number &gt; 0) &#123;
        int digit = number % 10;  // 获取最低位
        printf(&quot;%d &quot;, digit);      // 打印每一位
        number /= 10;              // 去掉最低位
    &#125;
</code></pre>
<ul>
<li><strong>空格问题</strong>：<code>scanf</code> 使用 <code>%s</code> 读取字符串时，遇到空格、制表符或者换行符就会停止读取。因此，如果输入的字符串中有空格，<code>scanf</code> 只能获取到第一个单词。例如，输入 <code>Hello World</code> 时，<code>scanf</code> 只会读取 <code>Hello</code>，而 <code>World</code> 会被留在输入缓冲区。</li>
</ul>
<pre><code>int a = 10;
int &amp;ref = a;  // 通过引用初始化 a
</code></pre>
<p>在编译时，编译器可能会将其转化为：</p>
<pre><code>int a = 10;
int *ref = &amp;a;  // ref 是指向 a 的指针，类似引用
</code></pre>
<p>&amp;是赋值还是被赋值，等号左边还是右边</p>
<p>“~”符号的输出：<strong>Shift + Fn + Esc</strong>。 “&#96;”符号的输出：Fn + Esc。</p>
<p>小脑（运动控制），以及大脑（具身智能）</p>
<pre><code>Welcome to Rust!

This will download and install the official compiler for the Rust
programming language, and its package manager, Cargo.

Rustup metadata and toolchains will be installed into the Rustup
home directory, located at:

  /home/zgh/.rustup

This can be modified with the RUSTUP_HOME environment variable.

The Cargo home directory is located at:

  /home/zgh/.cargo

This can be modified with the CARGO_HOME environment variable.

The cargo, rustc, rustup and other commands will be added to
Cargo&#39;s bin directory, located at:

  /home/zgh/.cargo/bin

This path will then be added to your PATH environment variable by
modifying the profile files located at:

  /home/zgh/.profile
  /home/zgh/.bashrc

You can uninstall at any time with rustup self uninstall and
these changes will be reverted.

Current installation options:


   default host triple: x86_64-unknown-linux-gnu
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes
</code></pre>
<pre><code class="cmake">set(CMAKE_PREFIX_PATH &quot;/opt/Qt/6.7.2/gcc_64&quot;)
</code></pre>
<p><img src="/../images/image-20241224212847057.png" alt="image-20241224212847057"></p>
<h3 id="name-urdf-spawner"><a href="#name-urdf-spawner" class="headerlink" title="name=&quot;urdf_spawner&quot;"></a><code>name=&quot;urdf_spawner&quot;</code></h3><ul>
<li><p><strong>作用</strong>：指定该节点的名字。</p>
</li>
<li><p><strong>意义</strong>：在 ROS 中，节点名称是全局唯一的标识，用于区分不同的节点。</p>
</li>
<li><p>例子</p>
<p>：</p>
<ul>
<li><code>urdf_spawner</code> 是该节点的名字，表示它的功能是用来生成（spawn）一个 URDF 模型到 Gazebo 中。</li>
</ul>
</li>
</ul>
<h3 id="respawn-false"><a href="#respawn-false" class="headerlink" title="respawn=&quot;false&quot;"></a><code>respawn=&quot;false&quot;</code></h3><ul>
<li><p><strong>作用</strong>：指定节点是否在退出后自动重启。</p>
</li>
<li><p>选项</p>
<p>：</p>
<ul>
<li><code>false</code>（默认值）：节点在退出后不会自动重启。</li>
<li><code>true</code>：如果节点因任何原因退出（例如崩溃），ROS 会自动尝试重新启动该节点。</li>
</ul>
</li>
<li><p>意义</p>
<p>：</p>
<ul>
<li>如果该节点负责关键功能（如控制器或监控器），可以设置为 <code>true</code> 确保系统稳定性。</li>
<li>在本例中，设置为 <code>false</code>，表明 <code>urdf_spawner</code> 节点在完成模型生成任务后不需要持续运行或重启。</li>
</ul>
</li>
</ul>
<h3 id="output-screen"><a href="#output-screen" class="headerlink" title="output=&quot;screen&quot;"></a><code>output=&quot;screen&quot;</code></h3><ul>
<li><p><strong>作用</strong>：定义节点的日志输出方式。</p>
</li>
<li><p>选项</p>
<p>：</p>
<ul>
<li><code>screen</code>：节点的日志输出会直接显示在终端中。</li>
<li><code>log</code>：节点的日志输出会写入 ROS 的日志文件（通常在 <code>~/.ros/log</code> 文件夹中）。</li>
</ul>
</li>
<li><p>意义</p>
<p>：</p>
<ul>
<li>设置为 <code>screen</code> 有助于实时查看节点的运行信息（如错误信息或调试日志），适合在开发和调试阶段使用。</li>
<li>如果希望保存日志供后续分析，可以设置为 <code>log</code>。</li>
</ul>
</li>
</ul>
<p><strong><code>controller_manager</code> 是控制器的管理层</strong>：</p>
<ul>
<li>负责加载和运行具体的控制器，包括 <code>joint_state_controller</code>。</li>
</ul>
<p><strong><code>joint_state_controller</code> 是具体的状态发布控制器</strong>：</p>
<ul>
<li>从硬件接口读取关节状态数据，并发布到 <code>/joint_states</code> 话题。</li>
</ul>
<p><strong><code>robot_state_publisher</code> 是基于状态的姿态计算工具</strong>：</p>
<ul>
<li>读取 <code>/joint_states</code> 中的关节数据，结合机器人模型生成 TF 坐标变换，用于可视化和坐标计算。</li>
</ul>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设我们有一个机械臂机器人，以下是如何使用这些组件：</p>
<ol>
<li><strong>控制器管理</strong>：<ul>
<li>使用 <code>controller_manager</code> 动态加载和启动控制器，例如 <code>joint_state_controller</code> 和关节位置控制器。</li>
</ul>
</li>
<li><strong>状态发布</strong>：<ul>
<li>启动 <code>joint_state_controller</code>，从硬件中获取关节状态并发布到 <code>/joint_states</code>。</li>
</ul>
</li>
<li><strong>姿态计算</strong>：<ul>
<li>启动 <code>robot_state_publisher</code>，读取 <code>/joint_states</code>，根据 URDF 生成动态的 TF 坐标变换。</li>
</ul>
</li>
<li><strong>可视化</strong>：<ul>
<li>在 RViz 中加载机器人模型，使用 TF 数据实时显示机器人在仿真或实际环境中的姿态变化。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/%E5%9B%9B%E8%B6%B3.html" data-id="cm3f5a1ib0000czcx489zdgnv" data-title="四足" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%8E%89%E8%B6%B3/" rel="tag">玉足</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-图形学" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6.html" class="article-date">
  <time class="dt-published" datetime="2024-11-02T08:34:15.000Z" itemprop="datePublished">2024-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6.html">图形学</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20241102163615219.png" alt="image-20241102163615219"></p>
<p><img src="/../images/image-20241102170537184.png" alt="image-20241102170537184"></p>
<p><img src="/../images/image-20241102170633713.png" alt="image-20241102170633713"></p>
<p>光线与球体的相交测试：</p>
<p><img src="/../images/image-20241102170834824.png" alt="image-20241102170834824"></p>
<p>可以通过判断这个一元二次方程的delta判别式判断光线是否击中了球体</p>
<p><strong>结构体</strong>：默认的成员访问权限是 <code>public</code>。</p>
<p><strong>类</strong>：默认的成员访问权限是 <code>private</code>。</p>
<h3 id="视口裁剪（Viewport-Clipping）"><a href="#视口裁剪（Viewport-Clipping）" class="headerlink" title="视口裁剪（Viewport Clipping）"></a>视口裁剪（Viewport Clipping）</h3><p>视口裁剪是指在渲染过程中，图形系统根据当前的视口（viewport）大小和位置，裁剪出只在视口内的部分。这通常发生在将三维场景转换为二维图像时。</p>
<ul>
<li><strong>视口定义</strong>：视口是指在窗口或屏幕上的一个矩形区域，图形渲染的结果只显示在这个区域内。</li>
<li><strong>用途</strong>：视口裁剪确保只绘制视口范围内的图形，避免无效的计算和渲染，提高效率。</li>
</ul>
<h3 id="透视裁剪（Perspective-Clipping）"><a href="#透视裁剪（Perspective-Clipping）" class="headerlink" title="透视裁剪（Perspective Clipping）"></a>透视裁剪（Perspective Clipping）</h3><p>透视裁剪是指在透视投影过程中，决定哪些对象在视锥体内并且可见，从而只渲染可见部分。透视投影会产生一个视锥体，位于观察者与场景之间。</p>
<ul>
<li><strong>视锥体</strong>：在透视投影中，视锥体是一个从观察点（摄像机位置）向外扩展的锥形区域。只有位于这个区域内的对象才会被渲染。</li>
<li><strong>裁剪</strong>：透视裁剪会去除视锥体外的对象，避免不必要的计算和渲染，并处理对象的深度关系。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>视口裁剪</strong>：关注的是最终图像在屏幕上的显示区域，只显示视口内的内容。</li>
<li><strong>透视裁剪</strong>：关注的是三维场景中哪些对象在视锥体内，以决定哪些对象是可见的。</li>
</ul>
<p>屏幕空间和 NDC（Normalized Device Coordinates）空间之间的关系:</p>
<h3 id="坐标变换流程"><a href="#坐标变换流程" class="headerlink" title="坐标变换流程"></a>坐标变换流程</h3><p>在图形渲染过程中，顶点坐标经历多个变换，从世界空间到最终的屏幕空间，这个过程大致包括：</p>
<ol>
<li><strong>模型变换</strong>：将顶点从局部模型坐标转换到世界坐标。</li>
<li><strong>视图变换</strong>：将世界坐标转换到相机坐标（视图空间）。</li>
<li><strong>投影变换</strong>：将相机坐标转换到裁剪空间。</li>
<li><strong>裁剪</strong>：将不在视野范围内的顶点剔除。</li>
<li><strong>透视除法</strong>：将裁剪空间的坐标转换到 NDC 空间。这个步骤涉及将每个坐标的 x、y 和 z 分别除以 w（齐次坐标），使得坐标范围归一化到 [-1, 1]。</li>
</ol>
<h3 id="NDC-到屏幕空间的转换"><a href="#NDC-到屏幕空间的转换" class="headerlink" title="NDC 到屏幕空间的转换"></a>NDC 到屏幕空间的转换</h3><p>一旦顶点处于 NDC 空间，它们需要被转换到屏幕空间：</p>
<ol>
<li><strong>视口变换</strong>：将 NDC 坐标映射到实际的屏幕像素坐标。视口变换使用屏幕的分辨率来进行坐标的线性变换。具体步骤是：<ul>
<li>将 NDC 的 x 和 y 坐标从 [-1, 1] 范围映射到屏幕像素的范围。例如，对于一个宽度为 W，高度为 H 的屏幕：<ul>
<li><code>screenX = (ndcX + 1) * 0.5 * (W - 1)</code></li>
<li><code>screenY = (1 - (ndcY + 1) * 0.5) * (H - 1)</code>（Y 轴可能需要翻转，具体取决于坐标系统的定义）</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>NDC 空间</strong> 是一个归一化的坐标系统，主要用于在渲染管线中的处理，使得顶点坐标能够统一处理，不论目标显示设备的分辨率如何。</li>
<li><strong>屏幕空间</strong> 是实际显示的坐标系统，与屏幕的物理尺寸和分辨率相关。</li>
<li><strong>转换</strong>：通过视口变换，NDC 空间的坐标被转换为屏幕空间的像素坐标，从而最终呈现在用户的屏幕上。</li>
</ul>
<p>NDC 空间可以看作是从三维世界到二维屏幕的中间步骤，而屏幕空间则是最终的输出结果。</p>
<p><img src="/../images/image-20241103175728042.png" alt="image-20241103175728042"></p>
<p><img src="/../images/image-20241103181614993.png" alt="image-20241103181614993"></p>
<h3 id="虚函数（Virtual-Function）"><a href="#虚函数（Virtual-Function）" class="headerlink" title="虚函数（Virtual Function）"></a>虚函数（Virtual Function）</h3><ol>
<li><strong>定义</strong>：虚函数是在基类中声明为<code>virtual</code>的成员函数，可以在派生类中重写（override）。</li>
<li><strong>实现</strong>：虚函数可以有具体的实现。基类中的虚函数可以提供默认的实现，派生类可以选择重写它。</li>
<li><strong>对象创建</strong>：可以创建基类的对象，也可以创建派生类的对象。</li>
</ol>
<h3 id="纯虚函数（Pure-Virtual-Function）"><a href="#纯虚函数（Pure-Virtual-Function）" class="headerlink" title="纯虚函数（Pure Virtual Function）"></a>纯虚函数（Pure Virtual Function）</h3><ol>
<li><strong>定义</strong>：纯虚函数是在基类中声明为<code>virtual</code>并且等于0的函数。语法是<code>virtual void functionName() = 0;</code>。</li>
<li><strong>实现</strong>：纯虚函数没有实现，基类通常不可以实例化。</li>
<li><strong>对象创建</strong>：不能直接创建类的对象（即抽象类），只能创建派生类的对象。</li>
<li><strong>用途</strong>：用于定义接口，强制派生类实现特定的函数</li>
</ol>
<p>输入流操作符 (<code>&gt;&gt;</code>) 在处理流时，会自动跳过空格和其他空白字符（如换行符和制表符），直到遇到下一个有意义的值为止。因此，空格在这一过程中并不会被显式处理。</p>
<h3 id="line-compare-0-2-v-的含义："><a href="#line-compare-0-2-v-的含义：" class="headerlink" title="line.compare(0, 2, &quot;v &quot;) 的含义："></a><code>line.compare(0, 2, &quot;v &quot;)</code> 的含义：</h3><ol>
<li>**<code>0</code>**：表示从 <code>line</code> 字符串的第一个字符开始进行比较。</li>
<li>**<code>2</code>**：表示比较的长度为 2，也就是说，只比较 <code>line</code> 字符串的前两个字符。</li>
<li>**<code>&quot;v &quot;</code>**：表示要将 <code>line</code> 字符串的前两个字符与字符串 <code>&quot;v &quot;</code> 进行比较。</li>
<li>如果 <code>line</code> 的前两个字符与 <code>&quot;v &quot;</code> 完全匹配，<code>compare</code> 方法返回 0。</li>
<li>如果不匹配，返回一个非 0 的值（具体的值取决于比较的结果：如果 <code>line</code> 字符串小于 <code>&quot;v &quot;</code>，返回一个负数；如果 <code>line</code> 字符串大于 <code>&quot;v &quot;</code>，返回一个正数）。</li>
</ol>
<h3 id="平面和场景"><a href="#平面和场景" class="headerlink" title="平面和场景"></a>平面和场景</h3><p>场景：管理世界空间下所有的形状（Shape）</p>
<p>平面的数学定义：</p>
<p><img src="/../images/image-20241105220133619.png" alt="image-20241105220133619"></p>
<p><img src="/../images/image-20241105220823204.png" alt="image-20241105220823204"></p>
<p>修改是为了改进多线程环境中的 <strong>线程安全性</strong> 和 <strong>竞态条件</strong> 的问题。我们来详细分析一下原始代码和修改后的代码之间的差异，以及为什么要这样修改。</p>
<h3 id="原始代码："><a href="#原始代码：" class="headerlink" title="原始代码："></a>原始代码：</h3><pre><code class="cpp">count++; 
if (count % film.getWidth() == 0) &#123;
    std::cout &lt;&lt; static_cast&lt;float&gt;(count) / (film.getWidth() * film.getHeight()) &lt;&lt; std::endl;
&#125;
</code></pre>
<h3 id="修改后的代码："><a href="#修改后的代码：" class="headerlink" title="修改后的代码："></a>修改后的代码：</h3><pre><code class="cpp">int n = ++count;
if (n % film.getWidth() == 0) &#123;
    std::cout &lt;&lt; static_cast&lt;float&gt;(n) / (film.getWidth() * film.getHeight()) &lt;&lt; std::endl;
&#125;
</code></pre>
<h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><h4 id="1-count-是非原子操作"><a href="#1-count-是非原子操作" class="headerlink" title="1. count++ 是非原子操作"></a>1. <strong><code>count++</code> 是非原子操作</strong></h4><ul>
<li><code>count++</code> 实际上是由 <strong>两个操作</strong> 组成的：<strong>读取 <code>count</code> 的值</strong>，然后 **增加 <code>count</code>**。在多线程环境中，如果多个线程同时执行 <code>count++</code>，就会发生 <strong>竞态条件</strong>（race condition），可能导致 <code>count</code> 的值增加不正确或者丢失。</li>
<li>例如，如果线程 A 和线程 B 同时读取到相同的 <code>count</code> 值，然后都加 1 写回，这样就会丢失一个递增的结果，导致 <code>count</code> 的值不准确。</li>
</ul>
<h4 id="2-count-是原子操作"><a href="#2-count-是原子操作" class="headerlink" title="2. ++count 是原子操作"></a>2. <strong><code>++count</code> 是原子操作</strong></h4><ul>
<li><code>++count</code> 是 <strong>自增并返回自增后的值</strong>，它在执行过程中是原子的，不会有并发冲突（前提是 <code>count</code> 本身是原子变量或操作）。这是因为它在自增的时候直接对 <code>count</code> 的值进行更新并返回，而不需要先读取再写入，避免了多个线程同时读取和写入的情况。</li>
</ul>
<h4 id="3-存储递增结果到-n"><a href="#3-存储递增结果到-n" class="headerlink" title="3. 存储递增结果到 n"></a>3. <strong>存储递增结果到 <code>n</code></strong></h4><ul>
<li>修改后的代码 <code>int n = ++count;</code> 将自增后的结果保存在 <code>n</code> 中。这样做的好处是：<ol>
<li><strong>保证了 <code>count</code> 更新后的值在后续代码中是确定的</strong>。如果我们直接在 <code>if (count % film.getWidth() == 0)</code> 中访问 <code>count</code>，其他线程可能会在我们检查 <code>count</code> 时修改它，导致判断条件不稳定。而 <code>n</code> 是在更新后的值保存时就固定了，因此后续的判断和输出使用 <code>n</code> 可以确保一致性。</li>
<li><strong>避免了 <code>count</code> 被其他线程修改时的影响</strong>。虽然 <code>count</code> 本身是全局共享的，但通过把递增结果保存在 <code>n</code> 中，我们保证了 <code>n</code> 的值不会在后续代码执行时被其他线程改动，确保了输出的正确性。</li>
</ol>
</li>
</ul>
<h3 id="线程安全与性能考虑："><a href="#线程安全与性能考虑：" class="headerlink" title="线程安全与性能考虑："></a>线程安全与性能考虑：</h3><ul>
<li>使用 <code>int n = ++count;</code> 的修改，确保了 <strong>每个线程对 <code>count</code> 的更新是安全的</strong>。同时，虽然 <code>++count</code> 在某些情况下可能是原子操作，但若 <code>count</code> 是一个普通变量，并且没有显式的线程同步机制，那么可能仍然存在隐性的问题。将更新后的 <code>count</code> 值保存到 <code>n</code> 可以减少这种不确定性。</li>
<li>在多线程环境下，避免直接在条件判断中使用共享变量（如 <code>count</code>）是一个常见的做法，尤其是当这个变量在多个线程中共享且没有其他同步机制时。通过中间变量 <code>n</code> 来持有更新后的值，避免了在 <code>count</code> 被其他线程修改时产生的竞态条件。</li>
</ul>
<pre><code class="cpp">        glm::translate(glm::mat4(1.f), pos) *
        glm::rotate(glm::mat4(1.f), glm::radians(rotate.z), &#123; 0, 0, 1 &#125;) *
        glm::rotate(glm::mat4(1.f), glm::radians(rotate.y), &#123; 0, 1, 0 &#125;) *
        glm::rotate(glm::mat4(1.f), glm::radians(rotate.x), &#123; 1, 0, 0 &#125;) *
        glm::scale(glm::mat4(1.f), scale)
</code></pre>
<ul>
<li><code>glm::mat4(1.f)</code>：创建一个单位矩阵，表示没有任何变换。</li>
<li><code>glm::translate(..., pos)</code>：将矩阵平移到 <code>pos</code> 指定的位置，<code>pos</code> 是一个 <code>glm::vec3</code> 向量,表示物体在3D空间中的平移偏移量（<code>x</code>, <code>y</code>, <code>z</code>）。</li>
<li><code>glm::radians(rotate.z)</code>：将角度 <code>rotate.z</code> 转换为弧度，因为GLM的 <code>rotate</code> 函数期望的旋转角度单位是弧度。</li>
<li><code>&#123; 0, 0, 1 &#125;</code>：指定旋转轴为Z轴。</li>
<li><code>glm::scale(glm::mat4(1.f), scale)</code>：执行一个缩放变换，其中 <code>scale</code> 是一个 <code>glm::vec3</code> 向量，表示沿着X、Y和Z轴的缩放比例。例如，<code>scale = &#123; 2.f, 3.f, 1.f &#125;</code> 表示在X轴上放大2倍，在Y轴上放大3倍，而Z轴保持不变。</li>
</ul>
<p>在GLM中，矩阵的乘法是从 <strong>右到左</strong> 进行的</p>
<p><img src="/../images/image-20241109162036809.png" alt="image-20241109162036809"></p>
<p><img src="/../images/image-20241109213953208.png" alt="image-20241109213953208"></p>
<p><img src="/../images/image-20241110094231486.png" alt="image-20241110094231486"></p>
<p><img src="/../images/image-20241110095142061.png" alt="image-20241110095142061"></p>
<p><img src="/../images/image-20241110095414276.png" alt="image-20241110095414276"></p>
<p><img src="/../images/image-20241110095522416.png" alt="image-20241110095522416"></p>
<p><img src="/../images/image-20241110144226840.png" alt="image-20241110144226840"></p>
<p>frame坐标系不用储存坐标系的原点，只用存储坐标轴的方向</p>
<p><img src="/../images/image-20241112092245780.png" alt="image-20241112092245780"></p>
<p>镜面反射：x,z取反</p>
<p>漫反射：采样</p>
<p><img src="/../images/image-20241112092430966.png" alt="image-20241112092430966"></p>
<pre><code class="cpp">for (size_t i = 0; i &lt; shapeInstances.size(); i++) &#123;
    auto shapeInstance = shapeInstances[i];
    auto ray_object = ray.rayObjectFromWorld(shapeInstance.object_from_world);
    hitInfo = shapeInstance.shape.intersect(ray_object, t_min, t_max); // 需要把世界空间下的光线转换成对象空间里相交测试
    if (hitInfo.has_value()) &#123;
        t_max = hitInfo-&gt;distance;
        closest_hitInfo = hitInfo;
        closest_instance = &amp;shapeInstance;
    &#125;
&#125;
</code></pre>
<p>与：</p>
<pre><code class="cpp">    for (size_t i = 0; i &lt; shapeInstances.size(); i++) &#123;
        auto ray_object = ray.rayObjectFromWorld(shapeInstances[i].object_from_world);
        hitInfo = shapeInstances[i].shape.intersect(ray_object, t_min, t_max); //需要把世界空间下的光线转换成对象空间里相交测试
        if (hitInfo.has_value()) &#123;
            t_max = hitInfo-&gt;distance;
            closest_hitInfo = hitInfo;
            closest_instance = &amp;shapeInstances[i];
        &#125;
    &#125;
</code></pre>
<p>看似一样，实则不一样</p>
<p>第一个是拷贝，</p>
<p><code>shapeInstance</code> 就是一个独立的对象，它与原始 <code>shapeInstances[i]</code> 没有直接关系</p>
<p>减小光追的噪点：</p>
<p><img src="/../images/image-20241112200209893.png" alt="image-20241112200209893"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6.html" data-id="cm2zwq9rd0000h9cxga7gdlb6" data-title="图形学" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-motion-planning" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/motion-planning.html" class="article-date">
  <time class="dt-published" datetime="2024-10-27T11:56:49.000Z" itemprop="datePublished">2024-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/motion-planning.html">motion_planning</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20241027200509747.png" alt="image-20241027200509747"></p>
<p><img src="/../images/image-20241027200356742.png" alt="image-20241027200356742"></p>
<p><img src="/../images/image-20241027200333906.png" alt="image-20241027200333906"></p>
<p><img src="/../images/image-20241027200800232.png" alt="image-20241027200800232"></p>
<p><img src="/../images/image-20241027205352801.png" alt="image-20241027205352801"></p>
<p><img src="/../images/image-20241028081500141.png" alt="image-20241028081500141"></p>
<p><img src="/../images/image-20241028082324091.png" alt="image-20241028082324091"></p>
<p>地图处理：</p>
<p><img src="/../images/image-20241027205539229.png" alt="image-20241027205539229"></p>
<p>Octree Map存储效率高，占用内存小，适合三维空间</p>
<p>缺点：构建和查询比较复杂，需要递归操作</p>
<p><img src="/../images/image-20241027210518464.png" alt="image-20241027210518464"></p>
<p>对于平面，可以使用四叉树地图</p>
<p>拓扑地图</p>
<p><img src="/../images/image-20241027210407252.png" alt="image-20241027210407252"></p>
<p>不能生成具体的路径</p>
<p>欧式距离场地图</p>
<p><img src="/../images/image-20241027210719429.png" alt="image-20241027210719429"></p>
<p>每一个像素点的值是到目标点的距离</p>
<p>高精地图+激光雷达：</p>
<p><img src="/../images/image-20241027211413340.png" alt="image-20241027211413340"></p>
<p><img src="/../images/image-20241027211825655.png" alt="image-20241027211825655"></p>
<p><img src="/../images/image-20241027212906123.png" alt="image-20241027212906123"></p>
<p><img src="/../images/image-20241028075246319.png" alt="image-20241028075246319"></p>
<p><img src="/../images/image-20241028075418437.png" alt="image-20241028075418437"></p>
<p><img src="/../images/image-20241028080419520.png" alt="image-20241028080419520"></p>
<p><img src="/../images/image-20241028080601730.png" alt="image-20241028080601730"></p>
<p>基于结构化地图（已经使用数据结构&#x2F;储存方式存储好了环境信息）的搜索：</p>
<p><img src="/../images/image-20241028083144863.png" alt="image-20241028083144863"></p>
<p>基于采样的路径搜索算法（不太适用于移动机器人）</p>
<p>没有地图的算法：概率路图</p>
<p><img src="/../images/image-20241028083334678.png" alt="image-20241028083334678"></p>
<p><img src="/../images/image-20241028084401881.png" alt="image-20241028084401881"></p>
<p>没有地图，先构造地图：<br><img src="/../images/image-20241028085903682.png" alt="image-20241028085903682"></p>
<p>建完图后路径规划：</p>
<p><img src="/../images/image-20241028090435029.png" alt="image-20241028090435029"></p>
<p><img src="/../images/image-20241028090508977.png" alt="image-20241028090508977"></p>
<p><img src="/../images/image-20241028090709696.png" alt="image-20241028090709696"><img src="/../images/image-20241028090740717.png" alt="image-20241028090740717"></p>
<p><img src="/../images/image-20241028091720342.png" alt="image-20241028091720342"></p>
<p><img src="/../images/image-20241028093035763.png" alt="image-20241028093035763"></p>
<p>PRM的升级：RRT（快速搜索随机数）</p>
<p>（一边构建地图，一边搜索路径）</p>
<p><img src="/../images/image-20241028204215612.png" alt="image-20241028204215612"></p>
<p><img src="/../images/image-20241028204322405.png" alt="image-20241028204322405"></p>
<p><img src="/../images/image-20241028204556756.png" alt="image-20241028204556756"></p>
<p><img src="/../images/image-20241028205030612.png" alt="image-20241028205030612"></p>
<p><img src="/../images/image-20241028205207024.png" alt="image-20241028205207024"></p>
<p><img src="/../images/image-20241028205744700.png" alt="image-20241028205744700"></p>
<p><img src="/../images/image-20241028210026292.png" alt="image-20241028210026292"></p>
<p><img src="/../images/image-20241028210759396.png" alt="image-20241028210759396"></p>
<p><img src="/../images/image-20241028211121913.png" alt="image-20241028211121913"></p>
<p>基于图搜索的路径搜索算法</p>
<p>1.朴素的搜索思想——BFS，DFS</p>
<p><img src="/../images/image-20241028212530583.png" alt="image-20241028212530583"></p>
<p>栅格地图可以很容易的转换成graph，欧式距离场可以很容易的转换成栅格地图，拓扑地图本身就是graph</p>
<p><img src="/../images/image-20241028213223056.png" alt="image-20241028213223056"></p>
<p>图搜索的核心问题：</p>
<p><img src="/../images/image-20241028213700790.png" alt="image-20241028213700790"></p>
<p><img src="/../images/image-20241028213931204.png" alt="image-20241028213931204"></p>
<p><img src="/../images/image-20241029075416595.png" alt="image-20241029075416595"></p>
<p><img src="/../images/image-20241029145851838.png" alt="image-20241029145851838"></p>
<p><code>std::reverse</code> 是 C++ 标准库中的一个算法，用于反转给定范围内的元素顺序。它定义在 <code>&lt;algorithm&gt;</code> 头文件中。</p>
<p><code>std::reverse</code> 接受两个迭代器作为参数，表示要反转的范围。其基本语法如下：</p>
<pre><code class="cpp">#include &lt;algorithm&gt; // 需要包含这个头文件
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() &#123;
    std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;

    // 反转 vec 中的元素
    std::reverse(vec.begin(), vec.end());

    // 输出反转后的结果
    for (int v : vec) &#123;
        std::cout &lt;&lt; v &lt;&lt; &quot; &quot;; // 输出: 5 4 3 2 1
    &#125;

    return 0;
&#125;
</code></pre>
<p>2.（DFS，BFS）搜索算法的进化————Dijkstra,A*</p>
<p><img src="/../images/image-20241029160810942.png" alt="image-20241029160810942"></p>
<p>Dijkstra(使用八联通图，可以走斜线)</p>
<p><img src="/../images/image-20241029165736780.png" alt="image-20241029165736780"></p>
<p>为什么: 如果distance._current大于distance[current]: 继续下一次循环</p>
<ol>
<li><ul>
<li><p>优先队列会按照节点的最小距离进行排序。可能在多个阶段，一个节点被加入队列，但这些加入可能是基于旧的距离值。</p>
</li>
<li><p>当我们从队列中弹出一个节点时，这个节点的距离可能并不是它的最短距离（因为它可能已经被更短的路径更新过）。</p>
</li>
<li><p>如果当前弹出的节点的距离大于我们在 <code>distance</code> 数组中记录的最短距离，这意味着我们已经找到了一条更短的路径到达这个节点，因此可以跳过对这个节点的处理。</p>
</li>
</ul>
</li>
</ol>
<p>A*（优化搜索速度）</p>
<p>A*的核心思想：不但考虑七点到当前节点的代价值，还要考虑当前节点到目标点的代价值</p>
<p><img src="/../images/image-20241029212450000.png" alt="image-20241029212450000"><img src="/../images/image-20241029212535602.png" alt="image-20241029212535602"></p>
<p>这里的估算函数叫启发式函数</p>
<p>常用的启发式函数</p>
<p><img src="/../images/image-20241029213145988.png" alt="image-20241029213145988"></p>
<p>注意：曼哈顿距离&gt;真实距离（有可能无法保证路径最优）,但就因为它比较大，所以有时候它的效果最好</p>
<p><img src="/../images/image-20241029213403921.png" alt="image-20241029213403921"></p>
<p><img src="/../images/image-20241029215149569.png" alt="image-20241029215149569"></p>
<p>A*算法的最优性保证：</p>
<p>只有满足条件，A*所得的路径才是最短路径</p>
<p><img src="/../images/image-20241029220508538.png" alt="image-20241029220508538"></p>
<p><img src="/../images/image-20241029220721469.png" alt="image-20241029220721469"></p>
<p><img src="/../images/image-20241030000750748.png" alt="image-20241030000750748"></p>
<p><img src="/../images/image-20241029234519659.png" alt="image-20241029234519659"></p>
<p>启发函数的选择：</p>
<p><img src="/../images/image-20241029234454890.png" alt="image-20241029234454890"></p>
<p>A*的平衡性问题：</p>
<p>虽然A* 算法的结果和理想结果的路径都是最短的，但是理想结果的转折更少，更适合使用，而且A* 算法搜索的节点还是有点多</p>
<p><img src="/../images/image-20241030000139507.png" alt="image-20241030000139507"></p>
<p>怎么解决呢？</p>
<p>从Dijkstra到A *增加了一个指标，效果大大提升，那再加一个指标</p>
<p><img src="/../images/image-20241030000250579.png" alt="image-20241030000250579"></p>
<p>在实际工程上，DFS会用递归方法实现</p>
<p><img src="/../images/image-20241030001223316.png" alt="image-20241030001223316"></p>
<h4 id="一种有趣的搜索思路：JPS"><a href="#一种有趣的搜索思路：JPS" class="headerlink" title="一种有趣的搜索思路：JPS"></a>一种有趣的搜索思路：JPS</h4><p><img src="/../images/image-20241030081738023.png" alt="image-20241030081738023"></p>
<p>JPS是一种跳跃式搜索算法：关注障碍物边缘的关键性节点（最短路径是起点+障碍物边缘节点+终点）</p>
<p>解决A *算法的平衡性问题</p>
<p>强迫邻居是必须要探索的点（强迫邻居有可能就是绕过障碍物的关键节点）</p>
<p>跳点和强迫邻居都需要继续拓展，所以都要加到openlist里面</p>
<p>这就是向前看规则：</p>
<p><img src="/../images/image-20241030090946938.png" alt="image-20241030090946938"></p>
<p>跳跃规则： </p>
<p>起点的八个邻居都需要加入到openlist里，都需要拓展</p>
<p><img src="/../images/image-20241030091816758.png" alt="image-20241030091816758"></p>
<p>八邻域探索方向可分为正向和对角线方向</p>
<p><img src="/../images/image-20241030092325008.png" alt="image-20241030092325008"></p>
<p>A*会八个方向一圈一圈的探索，JPS是只沿一个方向探索：</p>
<p><img src="/../images/image-20241030092925681.png" alt="image-20241030092925681"></p>
<p><img src="/../images/image-20241030102440054.png" alt="image-20241030102440054"></p>
<p><img src="/../images/image-20241030102733661.png" alt="image-20241030102733661"></p>
<p><img src="/../images/image-20241030103012358.png" alt="image-20241030103012358"></p>
<p><img src="/../images/image-20241030111828675.png" alt="image-20241030111828675"></p>
<p>对比：</p>
<p><img src="/../images/image-20241030113042835.png" alt="image-20241030113042835"></p>
<p>蓝色是被拓展过并添加到openlist里的，绿色是没有拓展过但是添加到openlist里的，右图里灰色是访问过的点</p>
<p>A*的openlist里的节点更多</p>
<p><img src="/../images/image-20241030124811683.png" alt="image-20241030124811683"></p>
<h4 id="从容应对动态障碍物–D-（动态A星算法）"><a href="#从容应对动态障碍物–D-（动态A星算法）" class="headerlink" title="从容应对动态障碍物–D*（动态A星算法）"></a>从容应对动态障碍物–D*（动态A星算法）</h4><p>D* 又称Dynamic A* </p>
<p>初始生成一条最优路径，在跟踪过程中，根据障碍物的变化，实时调整受影响的局部局部路径</p>
<p>算法流程：</p>
<p><img src="/../images/image-20241030130705029.png" alt="image-20241030130705029"></p>
<p>1.方向构建：</p>
<p><img src="/../images/image-20241030135745527.png" alt="image-20241030135745527"></p>
<p>h(X)：用来存储路径代价，指从X到达终点G的路径（{X,……G}，简记为{X}）代价，不一定是全局最优，第一次搜索到起点时时，所有点的h会被更新，计算方式同Dijkstra算法，是用相邻两点的代价+上一个点的代价累加得到</p>
<p>k(X)：用来记录自X节点被加入到OPEN_LIST中后的最小h(X)值（具体计算方式由Insert函数决定）,也是优先队列OPEN_LIST的排序依据，k将会保持到最小，它表示了本点在全图环境中到G点的最小代价(k(x)没有受到障碍物增加的影响)</p>
<p>3，代价修改：</p>
<p><img src="/../images/image-20241030140245818.png" alt="image-20241030140245818"></p>
<p>4，状态处理</p>
<p><img src="/../images/image-20241030141730446.png" alt="image-20241030141730446"></p>
<p><img src="/../images/image-20241030142134552.png" alt="image-20241030142134552"></p>
<p><strong><img src="/../images/image-20241031163648792.png" alt="image-20241031163648792"></strong> </p>
<p>考虑动力学和运动学的路径搜索</p>
<p><img src="/../images/image-20241031164340672.png" alt="image-20241031164340672"></p>
<p>优化了节点的扩展方式，节点不一定是栅格的中心(弧形路径)</p>
<p><img src="/../images/image-20241031164749998.png" alt="image-20241031164749998"></p>
<p>优化了启发式函数</p>
<p><img src="/../images/image-20241031170710478.png" alt="image-20241031170710478"></p>
<p><img src="/../images/image-20241031171111390.png" alt="image-20241031171111390"></p>
<p>搜索到的路径还要进行轨迹优化</p>
<p><img src="/../images/image-20241031171824387.png" alt="image-20241031171824387"></p>
<p>轨迹优化——Min-Jerk(jerk是加加速度)</p>
<p><img src="/../images/image-20241031173115830.png" alt="image-20241031173115830"></p>
<ol>
<li></li>
</ol>
<p><img src="/../images/image-20241031173311282.png" alt="image-20241031173311282"></p>
<p><img src="/../images/image-20241031173953976.png" alt="image-20241031173953976"></p>
<p>贝塞尔曲线把对连续曲线的规划，转变为对控制点的规划</p>
<p>贝塞尔曲线还有一个巨大的优点：导数还是贝塞尔曲线，仍然有控制点</p>
<p>缺点：贝塞尔曲线的形状完全依赖于控制点的数量和位置</p>
<p>移动一个控制点可能会对曲线的整体形状产生意想不到的影响，这使得局部控制变得困难</p>
<p>B样条曲线解决这两个问题</p>
<p><img src="/../images/image-20241031185043102.png" alt="image-20241031185043102"></p>
<p>2.<img src="/../images/image-20241031190211093.png" alt="image-20241031190211093"></p>
<ol start="3">
<li></li>
</ol>
<p><img src="/../images/image-20241031190753360.png" alt="image-20241031190753360"></p>
<ol start="4">
<li></li>
</ol>
<p><img src="/../images/image-20241031191654657.png" alt="image-20241031191654657">Min-Jerk是舒适性，Min-Snap是节省燃料</p>
<h3 id="lattice-planner"><a href="#lattice-planner" class="headerlink" title="lattice planner"></a>lattice planner</h3><p><img src="/../images/image-20241031192442070.png" alt="image-20241031192442070"></p>
<ol>
<li></li>
</ol>
<p><img src="/../images/image-20241031192808923.png" alt="image-20241031192808923"></p>
<p><img src="/../images/image-20241031193006723.png" alt="image-20241031193006723"></p>
<ol start="2">
<li></li>
</ol>
<p><img src="/../images/image-20241031195516780.png" alt="image-20241031195516780"></p>
<h3 id="轨迹跟踪"><a href="#轨迹跟踪" class="headerlink" title="轨迹跟踪"></a>轨迹跟踪</h3><p><img src="/../images/image-20241031195747013.png" alt="image-20241031195747013"></p>
<p><img src="/../images/image-20241031201328125.png" alt="image-20241031201328125"></p>
<p><img src="/../images/image-20241031201528244.png" alt="image-20241031201528244"></p>
<p><img src="/../images/image-20241031202702436.png" alt="image-20241031202702436"></p>
<p>Navigation2组成模块</p>
<p><img src="/../images/image-20241101083306228.png" alt="image-20241101083306228"></p>
<p>运行流程：</p>
<p><img src="/../images/image-20241101090545162.png" alt="image-20241101090545162"></p>
<p>功能包：</p>
<p><img src="/../images/image-20241101102148537.png" alt="image-20241101102148537"></p>
<h3 id="Nav2中的地图"><a href="#Nav2中的地图" class="headerlink" title="Nav2中的地图"></a>Nav2中的地图</h3><p>代价地图</p>
<p><img src="/../images/image-20241101103945972.png" alt="image-20241101103945972"></p>
<p><img src="/../images/image-20241101104611414.png" alt="image-20241101104611414"></p>
<p>分层代价地图：(直更新有变化的区域)</p>
<p>论文里的分层：</p>
<p><img src="/../images/image-20241101110059183.png" alt="image-20241101110059183"></p>
<p>Nav2分层：</p>
<p><img src="/../images/image-20241101110624721.png" alt="image-20241101110624721"></p>
<p>（速度过滤器：限速区）</p>
<p>重启蓝牙服务：</p>
<pre><code class="bash">sudo systemctl restart bluetooth
</code></pre>
<p>代价地图局部更新的过程：</p>
<p><img src="/../images/image-20241101143628088.png" alt="image-20241101143628088"></p>
<p>更新边界，更新值</p>
<p>Nav2的核心特点是使用插件机制，插件机制的实现过程是每个层去继承一个基类</p>
<p><img src="/../images/image-20241101144958061.png" alt="image-20241101144958061"></p>
<p><img src="/../images/image-20241101145411730.png" alt="image-20241101145411730"> </p>
<p>膨胀层具体实现：</p>
<p><img src="/../images/image-20241101164120062.png" alt="image-20241101164120062"></p>
<p><img src="/../images/image-20241101164142361.png" alt="image-20241101164142361"></p>
<p><img src="/../images/image-20241101164200699.png" alt="image-20241101164200699"></p>
<p>限速区具体实现：</p>
<p><img src="/../images/image-20241101164645369.png" alt="image-20241101164645369"></p>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>机器人坐标系：</p>
<p><img src="/../images/image-20241101175725933.png" alt="image-20241101175725933"></p>
<p>(TF树里只能有一个parent)</p>
<p>代价地图有两张：</p>
<p>全局路径搜索（静态），局部轨迹优化（动态）</p>
<p><img src="/../images/image-20241101180415555.png" alt="image-20241101180415555"></p>
<p>全局代价地图参数：</p>
<p><img src="/../images/image-20241101182125726.png" alt="image-20241101182125726"></p>
<p>局部代价地图参数：</p>
<p><img src="/../images/image-20241101183829578.png" alt="image-20241101183829578"></p>
<p><code>footprint</code> 是机器人在环境中占据的空间的几何形状。这个形状通常用一组坐标点来表示，形成一个多边形。</p>
<p><code>resolution=0.05</code> 表示地图的分辨率。指每个栅格（grid cell）的大小，以米为单位</p>
<h2 id="全局路径规划服务器"><a href="#全局路径规划服务器" class="headerlink" title="全局路径规划服务器"></a>全局路径规划服务器</h2><p>Planner_Server的功能</p>
<p><img src="/../images/image-20241101190731449.png" alt="image-20241101190731449"></p>
<p>1.对行为树接口：</p>
<p><img src="/../images/image-20241101191646808.png" alt="image-20241101191646808"></p>
<p>(navigation2里面使用了大量的action通信机制)</p>
<p><img src="/../images/image-20241101193625811.png" alt="image-20241101193625811"></p>
<p>2，开启全局代价地图</p>
<p><img src="/../images/image-20241101193934386.png" alt="image-20241101193934386"></p>
<p>3.加载规划算法</p>
<p><img src="/../images/image-20241101203600662.png" alt="image-20241101203600662"></p>
<p>插件机制：</p>
<p><img src="/../images/image-20241101203800248.png" alt="image-20241101203800248"></p>
<p><img src="/../images/image-20241101205003460.png" alt="image-20241101205003460"></p>
<p>planning_server的源码实现：</p>
<p><img src="/../images/image-20241101210227207.png" alt="image-20241101210227207"></p>
<p><img src="/../images/image-20241101211444648.png" alt="image-20241101211444648"></p>
<p><img src="/../images/image-20241101211549670.png" alt="image-20241101211549670"></p>
<p><img src="/../images/image-20241101223410617.png" alt="image-20241101223410617"></p>
<h3 id="planner-server参数配置"><a href="#planner-server参数配置" class="headerlink" title="planner_server参数配置"></a>planner_server参数配置</h3><p><img src="/../images/image-20241101224154321.png" alt="image-20241101224154321"></p>
<p> <img src="/../images/image-20241101225936142.png" alt="image-20241101225936142"></p>
<h2 id="Controller-Server"><a href="#Controller-Server" class="headerlink" title="Controller_Server"></a>Controller_Server</h2><p><img src="/../images/image-20241103224438065.png" alt="image-20241103224438065"></p>
<p>1.接口回调函数（给行为树调用）</p>
<p><img src="/../images/image-20241103225206814.png" alt="image-20241103225206814"></p>
<p><img src="/../images/image-20241103225751593.png" alt="image-20241103225751593"></p>
<p><img src="/../images/image-20241103230254653.png" alt="image-20241103230254653"></p>
<p>2.控制器插件</p>
<p><img src="/../images/image-20241103230812738.png" alt="image-20241103230812738"></p>
<p>重要插件–进度检查器</p>
<p><img src="/../images/image-20241103231323752.png" alt="image-20241103231323752"></p>
<p>重要插件–目标检查器</p>
<p><img src="/../images/image-20241103231740311.png" alt="image-20241103231740311"></p>
<p>控制流程：</p>
<p><img src="/../images/image-20241104000032308.png" alt="image-20241104000032308"></p>
<p>3.开启局部代价地图</p>
<p>和Planner_Server类似</p>
<h3 id="DWB算法详解"><a href="#DWB算法详解" class="headerlink" title="DWB算法详解"></a>DWB算法详解</h3><p><img src="/../images/image-20241104000312567.png" alt="image-20241104000312567"></p>
<p><img src="/../images/image-20241104001209166.png" alt="image-20241104001209166"></p>
<p><img src="/../images/image-20241104001344505.png" alt="image-20241104001344505">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/motion-planning.html" data-id="cm2rjbwlo0000kycxa1c9h8rg" data-title="motion_planning" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PNC/" rel="tag">PNC</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Realsense" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/Realsense.html" class="article-date">
  <time class="dt-published" datetime="2024-10-12T06:30:23.000Z" itemprop="datePublished">2024-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/Realsense.html">Realsense</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="pyrealsense-core-module"><a href="#pyrealsense-core-module" class="headerlink" title="pyrealsense.core     module"></a>pyrealsense.core     module</h2><p>pyrealsense.core.Device(service, device_id&#x3D;0, streams&#x3D;None, depth_control_preset&#x3D;None, ivcam_preset&#x3D;None)</p>
<p>class  pyrealsense.core.DeviceBase(dev, device_id, name, serial, version, streams)</p>
<p>class  pyrealsense.core.Service</p>
<h2 id="pyrealsense-stream-module"><a href="#pyrealsense-stream-module" class="headerlink" title="pyrealsense.stream     module"></a>pyrealsense.stream     module</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/Realsense.html" data-id="cm25s218300030ncxbcsj7w6f" data-title="Realsense" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C-STL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/C-STL.html" class="article-date">
  <time class="dt-published" datetime="2024-10-11T13:13:31.000Z" itemprop="datePublished">2024-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/C-STL.html">C++STL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>STL 即<strong>标准模板库</strong>（Standard Template Library），是 C++ 标准库的一部分，里面包含了一些模板化的通用的数据结构和算法。由于其模板化的特点，它能够兼容自定义的数据类型，避免大量的造轮子工作。NOI 和 ICPC 赛事都支持 STL 库的使用，因此合理利用 STL 可以避免编写无用算法，并且充分利用编译器对模板库优化提高效率。</p>
<p><a target="_blank" rel="noopener" href="https://www.boost.org/">Boost</a> 是除了标准库外，另一个久副盛名的开源 C++ 工具库，其代码具有可移植、高质量、高性能、高可靠性等特点。Boost 中的模块数量非常之大，功能全面，并且拥有完备的跨平台支持，因此被看作 C++ 的准标准库。C++ 标准中的不少特性也都来自于 Boost，如智能指针、元编程、日期和时间等。尽管在 OI 中无法使用 Boost，但是 Boost 中有不少轮子可以用来验证算法或者对拍，如 Boost.Geometry 有 R 树的实现，Boost.Graph 有图的相关算法，Boost.Intrusive 则提供了一套与 STL 容器用法相似的侵入式容器。</p>
<h2 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h2><p><img src="/../images/container1.png" alt="img"></p>
<h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><h4 id="1-序列式-容器"><a href="#1-序列式-容器" class="headerlink" title="1. &#x3D;&#x3D;序列式&#x3D;&#x3D;容器"></a>1. &#x3D;&#x3D;序列式&#x3D;&#x3D;容器</h4><ul>
<li>vector(向量)后端可高效增加元素的顺序表.</li>
<li>array(数组)，定长的顺序表。</li>
<li>deque（双端队列）双端可高效增加元素的顺序表。</li>
<li>list（列表）可以沿双向遍历的链表。</li>
<li>forward_list（单向列表）只能沿一个方向遍历的链表。</li>
</ul>
<h4 id="2，-关联式-容器"><a href="#2，-关联式-容器" class="headerlink" title="2，&#x3D;&#x3D;关联式&#x3D;&#x3D;容器"></a>2，&#x3D;&#x3D;关联式&#x3D;&#x3D;容器</h4><ul>
<li>set（集合）有序储存互异元素的容器<ul>
<li>不允许重复元素。存储唯一的元素，且自动按升序排序。</li>
<li>元素的插入、删除和查找操作的时间复杂度为O(log n)。</li>
</ul>
</li>
<li>multiset(多重集合)允许存储重复的元素，且也会自动按升序排序<ul>
<li>允许重复元素。</li>
<li>与<code>set</code>类似，插入、删除和查找操作的时间复杂度同样为O(log n)。</li>
</ul>
</li>
<li>map（映射）由{建，值}对组成的集合（也是集合）<ul>
<li><strong>唯一性</strong>：每个键只能出现一次；如果插入一个已存在的键，则会更新其对应的值。</li>
<li><strong>有序性</strong>：<code>map</code>中的元素会根据键自动排序，默认情况下是升序排列。</li>
<li><strong>时间复杂度</strong>：插入、删除和查找操作的平均时间复杂度为O(log n)。</li>
</ul>
</li>
</ul>
<h4 id="3，无序-并联式-容器"><a href="#3，无序-并联式-容器" class="headerlink" title="3，无序(并联式)容器"></a>3，无序(并联式)容器</h4><ul>
<li><strong>无序（多重）集合</strong>(<code>unordered_set</code>&#x2F;<code>unordered_multiset</code>)<strong>C++11</strong>，与 <code>set</code>&#x2F;<code>multiset</code> 的区别在于元素无序，只关心「元素是否存在」，使用哈希实现。<ul>
<li><strong>唯一性</strong>：<code>unordered_set</code> 中的每个元素都是唯一的，不能重复。</li>
<li><strong>无序性</strong>：元素的排列是基于哈希值的，不按照任何特定顺序存储。</li>
<li><strong>性能</strong>：插入、查找和删除操作的平均时间复杂度为 O(1)，但在最坏情况下可能会退化为 O(n)</li>
</ul>
</li>
<li><strong>无序（多重）映射</strong>(<code>unordered_map</code>&#x2F;<code>unordered_multimap</code>)<strong>C++11</strong>，与 <code>map</code>&#x2F;<code>multimap</code> 的区别在于键 (key) 无序，只关心 “键与值的对应关系”，使用哈希实现。</li>
</ul>
<h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>容器适配器其实并不是容器。它们不具有容器的某些特点（如：有迭代器、有 <code>clear()</code> 函数……）。</p>
<p>​	「适配器是使一种事物的行为类似于另外一种事物行为的一种机制」，适配器对容		器进行包装，使其表现出另外一种行为。</p>
<ul>
<li><strong>栈</strong>(<code>stack</code>) 后进先出 (LIFO) 的容器，默认是对双端队列（<code>deque</code>）的包装。</li>
<li><strong>队列</strong>(<code>queue</code>) 先进先出 (FIFO) 的容器，默认是对双端队列（<code>deque</code>）的包装。</li>
<li><strong>优先队列</strong>(<code>priority_queue</code>) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列，默认是对向量（<code>vector</code>）的包装。</li>
</ul>
<h4 id="容器声明"><a href="#容器声明" class="headerlink" title="容器声明"></a>容器声明</h4><p>都是 <code>containerName&lt;typeName,...&gt; name</code> 的形式，但模板参数（<code>&lt;&gt;</code> 内的参数）的个数、形式会根据具体容器而变。</p>
<p>本质原因：STL 就是「标准模板库」，所以容器都是模板类。</p>
<h4 id="容器共有函数"><a href="#容器共有函数" class="headerlink" title="容器共有函数"></a>容器共有函数</h4><p>&#x3D; ：赋值运算符，赋值构造函数</p>
<p>begain() :返回指向开头元素的迭代器</p>
<p>end（）：返回指向末尾的下一个元素的迭代器。<code>end()</code> 不指向某个元素.end() 迭代器指向的是一个“哨兵”位置，表示容器的结束。可以用来判断迭代是否完成。</p>
<p>size():返回容器内的元素个数</p>
<p><code>max_size()</code>：返回容器 理论上 能存储的最大元素个数。依容器类型和所存储变量的类型而变。</p>
<p><code>empty()</code>：返回容器是否为空。</p>
<p><code>swap()</code>：交换两个容器。</p>
<p><code>clear()</code>：清空容器。</p>
<p><code>==</code>&#x2F;<code>!=</code>&#x2F;<code>&lt;</code>&#x2F;<code>&gt;</code>&#x2F;<code>&lt;=</code>&#x2F;<code>&gt;=</code>：按 <strong>字典序</strong> 比较两个容器的大小.无序容器不支持 <code>&lt;</code>&#x2F;<code>&gt;</code>&#x2F;<code>&lt;=</code>&#x2F;<code>&gt;=</code>。</p>
<p><img src="/../images/image-20241210081117939.png" alt="image-20241210081117939"></p>
<h3 id="priority-queue-解析"><a href="#priority-queue-解析" class="headerlink" title="priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; 解析"></a><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code> 解析</h3><ol>
<li><strong><code>priority_queue&lt;int&gt;</code></strong>:<ul>
<li><code>priority_queue</code> 是 C++ STL（标准模板库）中的一个容器适配器，用于实现优先队列。</li>
<li>优先队列是一个特殊的队列，元素总是按优先级顺序被访问，优先级高的元素总是先被取出。</li>
<li>默认情况下，<code>priority_queue</code> 使用 <strong>最大堆</strong>（即，优先队列中最优先的元素是当前堆中的最大元素）。</li>
</ul>
</li>
<li><strong><code>vector&lt;int&gt;</code></strong>:<ul>
<li>这部分指定了 <code>priority_queue</code> 内部使用的底层容器。默认情况下，<code>priority_queue</code> 使用一个 <code>vector</code> 来存储元素。</li>
<li><code>vector&lt;int&gt;</code> 表示优先队列会存储 <code>int</code> 类型的元素，并且底层数据结构是一个动态数组（<code>vector</code>）。</li>
</ul>
</li>
<li><strong><code>greater&lt;int&gt;</code></strong>:<ul>
<li><code>greater&lt;int&gt;</code> 是一个函数对象（比较器），它指定了如何比较队列中的元素。</li>
<li><code>greater&lt;int&gt;</code> 表示一个 <strong>升序比较器</strong>，即它会把 <strong>较小的元素优先</strong> 放到队列前面。</li>
<li>默认情况下，<code>priority_queue</code> 是一个最大堆，它是通过 <code>less&lt;int&gt;</code>（即大于比较）来实现的，而 <code>greater&lt;int&gt;</code> 则实现了一个最小堆（即小于比较）。这使得 <code>pq</code> 中的元素会按照从小到大的顺序排列。</li>
</ul>
</li>
</ol>
<h3 id="为什么-std-sort-必须在-std-unique-之前使用？"><a href="#为什么-std-sort-必须在-std-unique-之前使用？" class="headerlink" title="为什么 std::sort 必须在 std::unique 之前使用？"></a>为什么 <code>std::sort</code> 必须在 <code>std::unique</code> 之前使用？</h3><p><code>std::unique</code> 只能去除<strong>相邻</strong>的重复元素。它不会去除容器中所有不相邻的重复元素。例如，假设容器中有 <code>1, 2, 3, 1, 4, 5, 1</code>，如果在调用 <code>std::unique</code> 之前没有对容器排序，<code>std::unique</code> 将无法去除所有重复元素，因为它只会处理相邻的元素。因此，为了确保所有重复元素都能被去除，必须先对容器进行排序，使得相同的元素排列在一起，然后才能通过 <code>std::unique</code> 去除它们。</p>
<p>a[n]</p>
<p>std::sort(a,a+n);</p>
<p>m &#x3D; std::unique（a,a+n）-n;</p>
<p>std::cin 输入流 （空格分割）</p>
<p>stringstream 字符串流</p>
<p>begain（），end（）</p>
<p>vector&lt;&gt;</p>
<p>clear() , resize() , push_back() , pop_back() , empty() ， 可重复</p>
<p>set&lt;&gt;</p>
<p>自动排序：默认升序</p>
<p>不可重复</p>
<p>不可修改</p>
<p>insert（），find（），count（）， erase（），empty（）</p>
<p>stack&lt;&gt;</p>
<p>priority_queue&lt;&gt;</p>
<p>push()  ,pop() ,top()</p>
<p>queue</p>
<p>push() ,pop() ,front()</p>
<p>ctrl + tab + 上下左右 代替鼠标切换文件</p>
<p>Ctrl + W：一个字符、一个字符串、一行、两行代码逐渐扩选</p>
<p>Alt + Shift + 左键：针对要编辑的部分快速选中多行</p>
<p>std::advance(iter, n);</p>
<p>如果 <code>n</code> 为正数，迭代器会向前移动；如果 <code>n</code> 为负数，迭代器会向后移动。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/C-STL.html" data-id="cm25s217y00000ncxdg95b2ai" data-title="C++STL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-STL/" rel="tag">C++STL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-kinematics" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/kinematics.html" class="article-date">
  <time class="dt-published" datetime="2024-10-07T14:26:21.000Z" itemprop="datePublished">2024-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/kinematics.html">kinematics</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/image-20241009151945396.png" alt="image-20241009151945396"></p>
<p><img src="/../images/image-20241011082114462.png" alt="image-20241011082114462"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgh20060114.github.io/post/kinematics.html" data-id="cm24he2gj0000pzcx40pwa14w" data-title="kinematics" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/robot-kinematics/" rel="tag">robot_kinematics</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/" rel="tag">C++STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PNC/" rel="tag">PNC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/esp32/" rel="tag">esp32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/robot-kinematics/" rel="tag">robot_kinematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yolo/" rel="tag">yolo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%89%E8%B6%B3/" rel="tag">玉足</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-STL/" style="font-size: 10px;">C++STL</a> <a href="/tags/Embedded/" style="font-size: 10px;">Embedded</a> <a href="/tags/PNC/" style="font-size: 10px;">PNC</a> <a href="/tags/esp32/" style="font-size: 10px;">esp32</a> <a href="/tags/robot-kinematics/" style="font-size: 10px;">robot_kinematics</a> <a href="/tags/yolo/" style="font-size: 10px;">yolo</a> <a href="/tags/%E7%8E%89%E8%B6%B3/" style="font-size: 10px;">玉足</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">计算机图形学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/guitar.html">guitar</a>
          </li>
        
          <li>
            <a href="/post/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0.html">最优控制与强化学习</a>
          </li>
        
          <li>
            <a href="/post/ncnn-yolov8-seg.html">ncnn-yolov8-seg</a>
          </li>
        
          <li>
            <a href="/post/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html">流体力学</a>
          </li>
        
          <li>
            <a href="/post/%E5%9B%9B%E8%B6%B3.html">四足</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>